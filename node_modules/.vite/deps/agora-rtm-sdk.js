var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};

// node_modules/agora-rtc-sdk-ng/AgoraRTC_N-production.js
var require_AgoraRTC_N_production = __commonJS({
  "node_modules/agora-rtc-sdk-ng/AgoraRTC_N-production.js"(exports2, module2) {
    !function(e, t) {
      "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).AgoraRTC = t();
    }(exports2, function() {
      "use strict";
      function e(e2, t2) {
        return t2.forEach(function(t3) {
          t3 && "string" != typeof t3 && !Array.isArray(t3) && Object.keys(t3).forEach(function(i3) {
            if ("default" !== i3 && !(i3 in e2)) {
              var n2 = Object.getOwnPropertyDescriptor(t3, i3);
              Object.defineProperty(e2, i3, n2.get ? n2 : { enumerable: true, get: function() {
                return t3[i3];
              } });
            }
          });
        }), Object.freeze(e2);
      }
      var t = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
      function i2(e2) {
        return e2 && e2.__esModule && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
      }
      var n = function(e2) {
        try {
          return !!e2();
        } catch (e3) {
          return true;
        }
      }, r = !n(function() {
        var e2 = (function() {
        }).bind();
        return "function" != typeof e2 || e2.hasOwnProperty("prototype");
      }), o = r, s = Function.prototype, a = s.call, c = o && s.bind.bind(a, a), d = o ? c : function(e2) {
        return function() {
          return a.apply(e2, arguments);
        };
      }, l = d({}.isPrototypeOf), u = function(e2) {
        return e2 && e2.Math == Math && e2;
      }, h = u("object" == typeof globalThis && globalThis) || u("object" == typeof window && window) || u("object" == typeof self && self) || u("object" == typeof t && t) || function() {
        return this;
      }() || t || Function("return this")(), p2 = r, _ = Function.prototype, E = _.apply, f = _.call, m = "object" == typeof Reflect && Reflect.apply || (p2 ? f.bind(E) : function() {
        return f.apply(E, arguments);
      }), T = d, S = T({}.toString), g = T("".slice), R2 = function(e2) {
        return g(S(e2), 8, -1);
      }, C = R2, v = d, I = function(e2) {
        if ("Function" === C(e2))
          return v(e2);
      }, y = "object" == typeof document && document.all, A = { all: y, IS_HTMLDDA: void 0 === y && void 0 !== y }, b = A.all, w = A.IS_HTMLDDA ? function(e2) {
        return "function" == typeof e2 || e2 === b;
      } : function(e2) {
        return "function" == typeof e2;
      }, O = {}, N = !n(function() {
        return 7 != Object.defineProperty({}, 1, { get: function() {
          return 7;
        } })[1];
      }), D = r, P = Function.prototype.call, L = D ? P.bind(P) : function() {
        return P.apply(P, arguments);
      }, k = {}, M = {}.propertyIsEnumerable, U = Object.getOwnPropertyDescriptor, x = U && !M.call({ 1: 2 }, 1);
      k.f = x ? function(e2) {
        var t2 = U(this, e2);
        return !!t2 && t2.enumerable;
      } : M;
      var V, F, B = function(e2, t2) {
        return { enumerable: !(1 & e2), configurable: !(2 & e2), writable: !(4 & e2), value: t2 };
      }, j = n, G = R2, W = Object, H = d("".split), K = j(function() {
        return !W("z").propertyIsEnumerable(0);
      }) ? function(e2) {
        return "String" == G(e2) ? H(e2, "") : W(e2);
      } : W, Y = function(e2) {
        return null == e2;
      }, q = Y, z = TypeError, X = function(e2) {
        if (q(e2))
          throw z("Can't call method on " + e2);
        return e2;
      }, J = K, Q = X, Z = function(e2) {
        return J(Q(e2));
      }, $ = w, ee = A.all, te = A.IS_HTMLDDA ? function(e2) {
        return "object" == typeof e2 ? null !== e2 : $(e2) || e2 === ee;
      } : function(e2) {
        return "object" == typeof e2 ? null !== e2 : $(e2);
      }, ie = {}, ne = ie, re = h, oe = w, se = function(e2) {
        return oe(e2) ? e2 : void 0;
      }, ae = function(e2, t2) {
        return arguments.length < 2 ? se(ne[e2]) || se(re[e2]) : ne[e2] && ne[e2][t2] || re[e2] && re[e2][t2];
      }, ce = "undefined" != typeof navigator && String(navigator.userAgent) || "", de = h, le = ce, ue = de.process, he = de.Deno, pe = ue && ue.versions || he && he.version, _e = pe && pe.v8;
      _e && (F = (V = _e.split("."))[0] > 0 && V[0] < 4 ? 1 : +(V[0] + V[1])), !F && le && (!(V = le.match(/Edge\/(\d+)/)) || V[1] >= 74) && (V = le.match(/Chrome\/(\d+)/)) && (F = +V[1]);
      var Ee = F, fe = Ee, me = n, Te = h.String, Se = !!Object.getOwnPropertySymbols && !me(function() {
        var e2 = Symbol();
        return !Te(e2) || !(Object(e2) instanceof Symbol) || !Symbol.sham && fe && fe < 41;
      }), ge = Se && !Symbol.sham && "symbol" == typeof Symbol.iterator, Re = ae, Ce = w, ve = l, Ie = Object, ye = ge ? function(e2) {
        return "symbol" == typeof e2;
      } : function(e2) {
        var t2 = Re("Symbol");
        return Ce(t2) && ve(t2.prototype, Ie(e2));
      }, Ae = String, be = function(e2) {
        try {
          return Ae(e2);
        } catch (e3) {
          return "Object";
        }
      }, we = w, Oe = be, Ne = TypeError, De = function(e2) {
        if (we(e2))
          return e2;
        throw Ne(Oe(e2) + " is not a function");
      }, Pe = De, Le = Y, ke = function(e2, t2) {
        var i3 = e2[t2];
        return Le(i3) ? void 0 : Pe(i3);
      }, Me = L, Ue = w, xe = te, Ve = TypeError, Fe = { exports: {} }, Be = h, je = Object.defineProperty, Ge = function(e2, t2) {
        try {
          je(Be, e2, { value: t2, configurable: true, writable: true });
        } catch (i3) {
          Be[e2] = t2;
        }
        return t2;
      }, We = "__core-js_shared__", He = h[We] || Ge(We, {}), Ke = He;
      (Fe.exports = function(e2, t2) {
        return Ke[e2] || (Ke[e2] = void 0 !== t2 ? t2 : {});
      })("versions", []).push({ version: "3.31.1", mode: "pure", copyright: "Â© 2014-2023 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.31.1/LICENSE", source: "https://github.com/zloirock/core-js" });
      var Ye = Fe.exports, qe = X, ze = Object, Xe = function(e2) {
        return ze(qe(e2));
      }, Je = Xe, Qe = d({}.hasOwnProperty), Ze = Object.hasOwn || function(e2, t2) {
        return Qe(Je(e2), t2);
      }, $e = d, et = 0, tt = Math.random(), it = $e(1 .toString), nt = function(e2) {
        return "Symbol(" + (void 0 === e2 ? "" : e2) + ")_" + it(++et + tt, 36);
      }, rt = Ye, ot = Ze, st = nt, at = Se, ct = ge, dt = h.Symbol, lt = rt("wks"), ut = ct ? dt.for || dt : dt && dt.withoutSetter || st, ht = function(e2) {
        return ot(lt, e2) || (lt[e2] = at && ot(dt, e2) ? dt[e2] : ut("Symbol." + e2)), lt[e2];
      }, pt = L, _t = te, Et = ye, ft = ke, mt = function(e2, t2) {
        var i3, n2;
        if ("string" === t2 && Ue(i3 = e2.toString) && !xe(n2 = Me(i3, e2)))
          return n2;
        if (Ue(i3 = e2.valueOf) && !xe(n2 = Me(i3, e2)))
          return n2;
        if ("string" !== t2 && Ue(i3 = e2.toString) && !xe(n2 = Me(i3, e2)))
          return n2;
        throw Ve("Can't convert object to primitive value");
      }, Tt = TypeError, St = ht("toPrimitive"), gt = function(e2, t2) {
        if (!_t(e2) || Et(e2))
          return e2;
        var i3, n2 = ft(e2, St);
        if (n2) {
          if (void 0 === t2 && (t2 = "default"), i3 = pt(n2, e2, t2), !_t(i3) || Et(i3))
            return i3;
          throw Tt("Can't convert object to primitive value");
        }
        return void 0 === t2 && (t2 = "number"), mt(e2, t2);
      }, Rt = ye, Ct = function(e2) {
        var t2 = gt(e2, "string");
        return Rt(t2) ? t2 : t2 + "";
      }, vt = te, It = h.document, yt = vt(It) && vt(It.createElement), At = function(e2) {
        return yt ? It.createElement(e2) : {};
      }, bt = At, wt = !N && !n(function() {
        return 7 != Object.defineProperty(bt("div"), "a", { get: function() {
          return 7;
        } }).a;
      }), Ot = N, Nt = L, Dt = k, Pt = B, Lt = Z, kt = Ct, Mt = Ze, Ut = wt, xt = Object.getOwnPropertyDescriptor;
      O.f = Ot ? xt : function(e2, t2) {
        if (e2 = Lt(e2), t2 = kt(t2), Ut)
          try {
            return xt(e2, t2);
          } catch (e3) {
          }
        if (Mt(e2, t2))
          return Pt(!Nt(Dt.f, e2, t2), e2[t2]);
      };
      var Vt = n, Ft = w, Bt = /#|\.prototype\./, jt = function(e2, t2) {
        var i3 = Wt[Gt(e2)];
        return i3 == Kt || i3 != Ht && (Ft(t2) ? Vt(t2) : !!t2);
      }, Gt = jt.normalize = function(e2) {
        return String(e2).replace(Bt, ".").toLowerCase();
      }, Wt = jt.data = {}, Ht = jt.NATIVE = "N", Kt = jt.POLYFILL = "P", Yt = jt, qt = De, zt = r, Xt = I(I.bind), Jt = function(e2, t2) {
        return qt(e2), void 0 === t2 ? e2 : zt ? Xt(e2, t2) : function() {
          return e2.apply(t2, arguments);
        };
      }, Qt = {}, Zt = N && n(function() {
        return 42 != Object.defineProperty(function() {
        }, "prototype", { value: 42, writable: false }).prototype;
      }), $t = te, ei = String, ti = TypeError, ii = function(e2) {
        if ($t(e2))
          return e2;
        throw ti(ei(e2) + " is not an object");
      }, ni = N, ri = wt, oi = Zt, si = ii, ai = Ct, ci = TypeError, di = Object.defineProperty, li = Object.getOwnPropertyDescriptor, ui = "enumerable", hi = "configurable", pi = "writable";
      Qt.f = ni ? oi ? function(e2, t2, i3) {
        if (si(e2), t2 = ai(t2), si(i3), "function" == typeof e2 && "prototype" === t2 && "value" in i3 && pi in i3 && !i3[pi]) {
          var n2 = li(e2, t2);
          n2 && n2[pi] && (e2[t2] = i3.value, i3 = { configurable: hi in i3 ? i3[hi] : n2[hi], enumerable: ui in i3 ? i3[ui] : n2[ui], writable: false });
        }
        return di(e2, t2, i3);
      } : di : function(e2, t2, i3) {
        if (si(e2), t2 = ai(t2), si(i3), ri)
          try {
            return di(e2, t2, i3);
          } catch (e3) {
          }
        if ("get" in i3 || "set" in i3)
          throw ci("Accessors not supported");
        return "value" in i3 && (e2[t2] = i3.value), e2;
      };
      var _i = Qt, Ei = B, fi = N ? function(e2, t2, i3) {
        return _i.f(e2, t2, Ei(1, i3));
      } : function(e2, t2, i3) {
        return e2[t2] = i3, e2;
      }, mi = h, Ti = m, Si = I, gi = w, Ri = O.f, Ci = Yt, vi = ie, Ii = Jt, yi = fi, Ai = Ze, bi = function(e2) {
        var t2 = function(i3, n2, r2) {
          if (this instanceof t2) {
            switch (arguments.length) {
              case 0:
                return new e2();
              case 1:
                return new e2(i3);
              case 2:
                return new e2(i3, n2);
            }
            return new e2(i3, n2, r2);
          }
          return Ti(e2, this, arguments);
        };
        return t2.prototype = e2.prototype, t2;
      }, wi = function(e2, t2) {
        var i3, n2, r2, o2, s2, a2, c2, d2, l2, u2 = e2.target, h2 = e2.global, p3 = e2.stat, _2 = e2.proto, E2 = h2 ? mi : p3 ? mi[u2] : (mi[u2] || {}).prototype, f2 = h2 ? vi : vi[u2] || yi(vi, u2, {})[u2], m2 = f2.prototype;
        for (o2 in t2)
          n2 = !(i3 = Ci(h2 ? o2 : u2 + (p3 ? "." : "#") + o2, e2.forced)) && E2 && Ai(E2, o2), a2 = f2[o2], n2 && (c2 = e2.dontCallGetSet ? (l2 = Ri(E2, o2)) && l2.value : E2[o2]), s2 = n2 && c2 ? c2 : t2[o2], n2 && typeof a2 == typeof s2 || (d2 = e2.bind && n2 ? Ii(s2, mi) : e2.wrap && n2 ? bi(s2) : _2 && gi(s2) ? Si(s2) : s2, (e2.sham || s2 && s2.sham || a2 && a2.sham) && yi(d2, "sham", true), yi(f2, o2, d2), _2 && (Ai(vi, r2 = u2 + "Prototype") || yi(vi, r2, {}), yi(vi[r2], o2, s2), e2.real && m2 && (i3 || !m2[o2]) && yi(m2, o2, s2)));
      }, Oi = Math.ceil, Ni = Math.floor, Di = Math.trunc || function(e2) {
        var t2 = +e2;
        return (t2 > 0 ? Ni : Oi)(t2);
      }, Pi = Di, Li = function(e2) {
        var t2 = +e2;
        return t2 != t2 || 0 === t2 ? 0 : Pi(t2);
      }, ki = Li, Mi = Math.max, Ui = Math.min, xi = function(e2, t2) {
        var i3 = ki(e2);
        return i3 < 0 ? Mi(i3 + t2, 0) : Ui(i3, t2);
      }, Vi = Li, Fi = Math.min, Bi = function(e2) {
        return e2 > 0 ? Fi(Vi(e2), 9007199254740991) : 0;
      }, ji = Bi, Gi = function(e2) {
        return ji(e2.length);
      }, Wi = Z, Hi = xi, Ki = Gi, Yi = function(e2) {
        return function(t2, i3, n2) {
          var r2, o2 = Wi(t2), s2 = Ki(o2), a2 = Hi(n2, s2);
          if (e2 && i3 != i3) {
            for (; s2 > a2; )
              if ((r2 = o2[a2++]) != r2)
                return true;
          } else
            for (; s2 > a2; a2++)
              if ((e2 || a2 in o2) && o2[a2] === i3)
                return e2 || a2 || 0;
          return !e2 && -1;
        };
      }, qi = { includes: Yi(true), indexOf: Yi(false) }, zi = qi.includes;
      wi({ target: "Array", proto: true, forced: n(function() {
        return !Array(1).includes();
      }) }, { includes: function(e2) {
        return zi(this, e2, arguments.length > 1 ? arguments[1] : void 0);
      } });
      var Xi = ie, Ji = function(e2) {
        return Xi[e2 + "Prototype"];
      }, Qi = Ji("Array").includes, Zi = te, $i = R2, en = ht("match"), tn = function(e2) {
        var t2;
        return Zi(e2) && (void 0 !== (t2 = e2[en]) ? !!t2 : "RegExp" == $i(e2));
      }, nn = tn, rn = TypeError, on = {};
      on[ht("toStringTag")] = "z";
      var sn = "[object z]" === String(on), an = sn, cn = w, dn = R2, ln = ht("toStringTag"), un = Object, hn = "Arguments" == dn(function() {
        return arguments;
      }()), pn = an ? dn : function(e2) {
        var t2, i3, n2;
        return void 0 === e2 ? "Undefined" : null === e2 ? "Null" : "string" == typeof (i3 = function(e3, t3) {
          try {
            return e3[t3];
          } catch (e4) {
          }
        }(t2 = un(e2), ln)) ? i3 : hn ? dn(t2) : "Object" == (n2 = dn(t2)) && cn(t2.callee) ? "Arguments" : n2;
      }, _n = pn, En = String, fn = function(e2) {
        if ("Symbol" === _n(e2))
          throw TypeError("Cannot convert a Symbol value to a string");
        return En(e2);
      }, mn = ht("match"), Tn = wi, Sn = function(e2) {
        if (nn(e2))
          throw rn("The method doesn't accept regular expressions");
        return e2;
      }, gn = X, Rn = fn, Cn = function(e2) {
        var t2 = /./;
        try {
          "/./"[e2](t2);
        } catch (i3) {
          try {
            return t2[mn] = false, "/./"[e2](t2);
          } catch (e3) {
          }
        }
        return false;
      }, vn = d("".indexOf);
      Tn({ target: "String", proto: true, forced: !Cn("includes") }, { includes: function(e2) {
        return !!~vn(Rn(gn(this)), Rn(Sn(e2)), arguments.length > 1 ? arguments[1] : void 0);
      } });
      var In = Ji("String").includes, yn = l, An = Qi, bn = In, wn = Array.prototype, On = String.prototype, Nn = function(e2) {
        var t2 = e2.includes;
        return e2 === wn || yn(wn, e2) && t2 === wn.includes ? An : "string" == typeof e2 || e2 === On || yn(On, e2) && t2 === On.includes ? bn : t2;
      }, Dn = i2(Nn), Pn = De, Ln = Xe, kn = K, Mn = Gi, Un = TypeError, xn = function(e2) {
        return function(t2, i3, n2, r2) {
          Pn(i3);
          var o2 = Ln(t2), s2 = kn(o2), a2 = Mn(o2), c2 = e2 ? a2 - 1 : 0, d2 = e2 ? -1 : 1;
          if (n2 < 2)
            for (; ; ) {
              if (c2 in s2) {
                r2 = s2[c2], c2 += d2;
                break;
              }
              if (c2 += d2, e2 ? c2 < 0 : a2 <= c2)
                throw Un("Reduce of empty array with no initial value");
            }
          for (; e2 ? c2 >= 0 : a2 > c2; c2 += d2)
            c2 in s2 && (r2 = i3(r2, s2[c2], c2, o2));
          return r2;
        };
      }, Vn = { left: xn(false), right: xn(true) }, Fn = n, Bn = function(e2, t2) {
        var i3 = [][e2];
        return !!i3 && Fn(function() {
          i3.call(null, t2 || function() {
            return 1;
          }, 1);
        });
      }, jn = "undefined" != typeof process && "process" == R2(process), Gn = Vn.left;
      wi({ target: "Array", proto: true, forced: !jn && Ee > 79 && Ee < 83 || !Bn("reduce") }, { reduce: function(e2) {
        var t2 = arguments.length;
        return Gn(this, e2, t2, t2 > 1 ? arguments[1] : void 0);
      } });
      var Wn = Ji("Array").reduce, Hn = l, Kn = Wn, Yn = Array.prototype, qn = function(e2) {
        var t2 = e2.reduce;
        return e2 === Yn || Hn(Yn, e2) && t2 === Yn.reduce ? Kn : t2;
      }, zn = qn, Xn = i2(zn), Jn = R2, Qn = Array.isArray || function(e2) {
        return "Array" == Jn(e2);
      }, Zn = wi, $n = Qn, er = d([].reverse), tr = [1, 2];
      Zn({ target: "Array", proto: true, forced: String(tr) === String(tr.reverse()) }, { reverse: function() {
        return $n(this) && (this.length = this.length), er(this);
      } });
      var ir = Ji("Array").reverse, nr = l, rr = ir, or = Array.prototype, sr = function(e2) {
        var t2 = e2.reverse;
        return e2 === or || nr(or, e2) && t2 === or.reverse ? rr : t2;
      }, ar = sr, cr = i2(ar), dr = nt, lr = Ye("keys"), ur = function(e2) {
        return lr[e2] || (lr[e2] = dr(e2));
      }, hr = !n(function() {
        function e2() {
        }
        return e2.prototype.constructor = null, Object.getPrototypeOf(new e2()) !== e2.prototype;
      }), pr = Ze, _r = w, Er = Xe, fr = hr, mr = ur("IE_PROTO"), Tr = Object, Sr = Tr.prototype, gr = fr ? Tr.getPrototypeOf : function(e2) {
        var t2 = Er(e2);
        if (pr(t2, mr))
          return t2[mr];
        var i3 = t2.constructor;
        return _r(i3) && t2 instanceof i3 ? i3.prototype : t2 instanceof Tr ? Sr : null;
      }, Rr = d, Cr = De, vr = w, Ir = String, yr = TypeError, Ar = function(e2, t2, i3) {
        try {
          return Rr(Cr(Object.getOwnPropertyDescriptor(e2, t2)[i3]));
        } catch (e3) {
        }
      }, br = ii, wr = function(e2) {
        if ("object" == typeof e2 || vr(e2))
          return e2;
        throw yr("Can't set " + Ir(e2) + " as a prototype");
      }, Or = Object.setPrototypeOf || ("__proto__" in {} ? function() {
        var e2, t2 = false, i3 = {};
        try {
          (e2 = Ar(Object.prototype, "__proto__", "set"))(i3, []), t2 = i3 instanceof Array;
        } catch (e3) {
        }
        return function(i4, n2) {
          return br(i4), wr(n2), t2 ? e2(i4, n2) : i4.__proto__ = n2, i4;
        };
      }() : void 0), Nr = {}, Dr = {}, Pr = Ze, Lr = Z, kr = qi.indexOf, Mr = Dr, Ur = d([].push), xr = function(e2, t2) {
        var i3, n2 = Lr(e2), r2 = 0, o2 = [];
        for (i3 in n2)
          !Pr(Mr, i3) && Pr(n2, i3) && Ur(o2, i3);
        for (; t2.length > r2; )
          Pr(n2, i3 = t2[r2++]) && (~kr(o2, i3) || Ur(o2, i3));
        return o2;
      }, Vr = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], Fr = xr, Br = Vr.concat("length", "prototype");
      Nr.f = Object.getOwnPropertyNames || function(e2) {
        return Fr(e2, Br);
      };
      var jr = {};
      jr.f = Object.getOwnPropertySymbols;
      var Gr = ae, Wr = Nr, Hr = jr, Kr = ii, Yr = d([].concat), qr = Gr("Reflect", "ownKeys") || function(e2) {
        var t2 = Wr.f(Kr(e2)), i3 = Hr.f;
        return i3 ? Yr(t2, i3(e2)) : t2;
      }, zr = Ze, Xr = qr, Jr = O, Qr = Qt, Zr = {}, $r = xr, eo = Vr, to = Object.keys || function(e2) {
        return $r(e2, eo);
      }, io = N, no = Zt, ro = Qt, oo = ii, so = Z, ao = to;
      Zr.f = io && !no ? Object.defineProperties : function(e2, t2) {
        oo(e2);
        for (var i3, n2 = so(t2), r2 = ao(t2), o2 = r2.length, s2 = 0; o2 > s2; )
          ro.f(e2, i3 = r2[s2++], n2[i3]);
        return e2;
      };
      var co, lo = ae("document", "documentElement"), uo = ii, ho = Zr, po = Vr, _o = Dr, Eo = lo, fo = At, mo = "prototype", To = "script", So = ur("IE_PROTO"), go = function() {
      }, Ro = function(e2) {
        return "<" + To + ">" + e2 + "</" + To + ">";
      }, Co = function(e2) {
        e2.write(Ro("")), e2.close();
        var t2 = e2.parentWindow.Object;
        return e2 = null, t2;
      }, vo = function() {
        try {
          co = new ActiveXObject("htmlfile");
        } catch (e3) {
        }
        var e2, t2, i3;
        vo = "undefined" != typeof document ? document.domain && co ? Co(co) : (t2 = fo("iframe"), i3 = "java" + To + ":", t2.style.display = "none", Eo.appendChild(t2), t2.src = String(i3), (e2 = t2.contentWindow.document).open(), e2.write(Ro("document.F=Object")), e2.close(), e2.F) : Co(co);
        for (var n2 = po.length; n2--; )
          delete vo[mo][po[n2]];
        return vo();
      };
      _o[So] = true;
      var Io = Object.create || function(e2, t2) {
        var i3;
        return null !== e2 ? (go[mo] = uo(e2), i3 = new go(), go[mo] = null, i3[So] = e2) : i3 = vo(), void 0 === t2 ? i3 : ho.f(i3, t2);
      }, yo = te, Ao = fi, bo = Error, wo = d("".replace), Oo = String(bo("zxcasd").stack), No = /\n\s*at [^:]*:[^\n]*/, Do = No.test(Oo), Po = B, Lo = !n(function() {
        var e2 = Error("a");
        return !("stack" in e2) || (Object.defineProperty(e2, "stack", Po(1, 7)), 7 !== e2.stack);
      }), ko = fi, Mo = function(e2, t2) {
        if (Do && "string" == typeof e2 && !bo.prepareStackTrace)
          for (; t2--; )
            e2 = wo(e2, No, "");
        return e2;
      }, Uo = Lo, xo = Error.captureStackTrace, Vo = {}, Fo = Vo, Bo = ht("iterator"), jo = Array.prototype, Go = function(e2) {
        return void 0 !== e2 && (Fo.Array === e2 || jo[Bo] === e2);
      }, Wo = pn, Ho = ke, Ko = Y, Yo = Vo, qo = ht("iterator"), zo = function(e2) {
        if (!Ko(e2))
          return Ho(e2, qo) || Ho(e2, "@@iterator") || Yo[Wo(e2)];
      }, Xo = L, Jo = De, Qo = ii, Zo = be, $o = zo, es = TypeError, ts = function(e2, t2) {
        var i3 = arguments.length < 2 ? $o(e2) : t2;
        if (Jo(i3))
          return Qo(Xo(i3, e2));
        throw es(Zo(e2) + " is not iterable");
      }, is = L, ns = ii, rs = ke, os = function(e2, t2, i3) {
        var n2, r2;
        ns(e2);
        try {
          if (!(n2 = rs(e2, "return"))) {
            if ("throw" === t2)
              throw i3;
            return i3;
          }
          n2 = is(n2, e2);
        } catch (e3) {
          r2 = true, n2 = e3;
        }
        if ("throw" === t2)
          throw i3;
        if (r2)
          throw n2;
        return ns(n2), i3;
      }, ss = Jt, as = L, cs = ii, ds = be, ls = Go, us = Gi, hs = l, ps = ts, _s = zo, Es = os, fs = TypeError, ms2 = function(e2, t2) {
        this.stopped = e2, this.result = t2;
      }, Ts = ms2.prototype, Ss = function(e2, t2, i3) {
        var n2, r2, o2, s2, a2, c2, d2, l2 = i3 && i3.that, u2 = !(!i3 || !i3.AS_ENTRIES), h2 = !(!i3 || !i3.IS_RECORD), p3 = !(!i3 || !i3.IS_ITERATOR), _2 = !(!i3 || !i3.INTERRUPTED), E2 = ss(t2, l2), f2 = function(e3) {
          return n2 && Es(n2, "normal", e3), new ms2(true, e3);
        }, m2 = function(e3) {
          return u2 ? (cs(e3), _2 ? E2(e3[0], e3[1], f2) : E2(e3[0], e3[1])) : _2 ? E2(e3, f2) : E2(e3);
        };
        if (h2)
          n2 = e2.iterator;
        else if (p3)
          n2 = e2;
        else {
          if (!(r2 = _s(e2)))
            throw fs(ds(e2) + " is not iterable");
          if (ls(r2)) {
            for (o2 = 0, s2 = us(e2); s2 > o2; o2++)
              if ((a2 = m2(e2[o2])) && hs(Ts, a2))
                return a2;
            return new ms2(false);
          }
          n2 = ps(e2, r2);
        }
        for (c2 = h2 ? e2.next : n2.next; !(d2 = as(c2, n2)).done; ) {
          try {
            a2 = m2(d2.value);
          } catch (e3) {
            Es(n2, "throw", e3);
          }
          if ("object" == typeof a2 && a2 && hs(Ts, a2))
            return a2;
        }
        return new ms2(false);
      }, gs = fn, Rs = wi, Cs = l, vs = gr, Is = Or, ys = function(e2, t2, i3) {
        for (var n2 = Xr(t2), r2 = Qr.f, o2 = Jr.f, s2 = 0; s2 < n2.length; s2++) {
          var a2 = n2[s2];
          zr(e2, a2) || i3 && zr(i3, a2) || r2(e2, a2, o2(t2, a2));
        }
      }, As = Io, bs = fi, ws = B, Os = function(e2, t2) {
        yo(t2) && "cause" in t2 && Ao(e2, "cause", t2.cause);
      }, Ns = function(e2, t2, i3, n2) {
        Uo && (xo ? xo(e2, t2) : ko(e2, "stack", Mo(i3, n2)));
      }, Ds = Ss, Ps = function(e2, t2) {
        return void 0 === e2 ? arguments.length < 2 ? "" : t2 : gs(e2);
      }, Ls = ht("toStringTag"), ks = Error, Ms = [].push, Us = function(e2, t2) {
        var i3, n2 = Cs(xs, this);
        Is ? i3 = Is(ks(), n2 ? vs(this) : xs) : (i3 = n2 ? this : As(xs), bs(i3, Ls, "Error")), void 0 !== t2 && bs(i3, "message", Ps(t2)), Ns(i3, Us, i3.stack, 1), arguments.length > 2 && Os(i3, arguments[2]);
        var r2 = [];
        return Ds(e2, Ms, { that: r2 }), bs(i3, "errors", r2), i3;
      };
      Is ? Is(Us, ks) : ys(Us, ks, { name: true });
      var xs = Us.prototype = As(ks.prototype, { constructor: ws(1, Us), message: ws(1, ""), name: ws(1, "AggregateError") });
      Rs({ global: true, constructor: true, arity: 2 }, { AggregateError: Us });
      var Vs, Fs, Bs, js = w, Gs = h.WeakMap, Ws = js(Gs) && /native code/.test(String(Gs)), Hs = h, Ks = te, Ys = fi, qs = Ze, zs = He, Xs = ur, Js = Dr, Qs = "Object already initialized", Zs = Hs.TypeError, $s = Hs.WeakMap;
      if (Ws || zs.state) {
        var ea = zs.state || (zs.state = new $s());
        ea.get = ea.get, ea.has = ea.has, ea.set = ea.set, Vs = function(e2, t2) {
          if (ea.has(e2))
            throw Zs(Qs);
          return t2.facade = e2, ea.set(e2, t2), t2;
        }, Fs = function(e2) {
          return ea.get(e2) || {};
        }, Bs = function(e2) {
          return ea.has(e2);
        };
      } else {
        var ta = Xs("state");
        Js[ta] = true, Vs = function(e2, t2) {
          if (qs(e2, ta))
            throw Zs(Qs);
          return t2.facade = e2, Ys(e2, ta, t2), t2;
        }, Fs = function(e2) {
          return qs(e2, ta) ? e2[ta] : {};
        }, Bs = function(e2) {
          return qs(e2, ta);
        };
      }
      var ia, na, ra, oa = { set: Vs, get: Fs, has: Bs, enforce: function(e2) {
        return Bs(e2) ? Fs(e2) : Vs(e2, {});
      }, getterFor: function(e2) {
        return function(t2) {
          var i3;
          if (!Ks(t2) || (i3 = Fs(t2)).type !== e2)
            throw Zs("Incompatible receiver, " + e2 + " required");
          return i3;
        };
      } }, sa = N, aa = Ze, ca = Function.prototype, da = sa && Object.getOwnPropertyDescriptor, la = aa(ca, "name"), ua = { EXISTS: la, PROPER: la && "something" === (function() {
      }).name, CONFIGURABLE: la && (!sa || sa && da(ca, "name").configurable) }, ha = fi, pa = function(e2, t2, i3, n2) {
        return n2 && n2.enumerable ? e2[t2] = i3 : ha(e2, t2, i3), e2;
      }, _a = n, Ea = w, fa = te, ma = Io, Ta = gr, Sa = pa, ga = ht("iterator"), Ra = false;
      [].keys && ("next" in (ra = [].keys()) ? (na = Ta(Ta(ra))) !== Object.prototype && (ia = na) : Ra = true);
      var Ca = !fa(ia) || _a(function() {
        var e2 = {};
        return ia[ga].call(e2) !== e2;
      });
      Ea((ia = Ca ? {} : ma(ia))[ga]) || Sa(ia, ga, function() {
        return this;
      });
      var va = { IteratorPrototype: ia, BUGGY_SAFARI_ITERATORS: Ra }, Ia = pn, ya = sn ? {}.toString : function() {
        return "[object " + Ia(this) + "]";
      }, Aa = sn, ba = Qt.f, wa = fi, Oa = Ze, Na = ya, Da = ht("toStringTag"), Pa = function(e2, t2, i3, n2) {
        if (e2) {
          var r2 = i3 ? e2 : e2.prototype;
          Oa(r2, Da) || ba(r2, Da, { configurable: true, value: t2 }), n2 && !Aa && wa(r2, "toString", Na);
        }
      }, La = va.IteratorPrototype, ka = Io, Ma = B, Ua = Pa, xa = Vo, Va = function() {
        return this;
      }, Fa = function(e2, t2, i3, n2) {
        var r2 = t2 + " Iterator";
        return e2.prototype = ka(La, { next: Ma(+!n2, i3) }), Ua(e2, r2, false, true), xa[r2] = Va, e2;
      }, Ba = wi, ja = L, Ga = ua, Wa = Fa, Ha = gr, Ka = Pa, Ya = pa, qa = Vo, za = va, Xa = Ga.PROPER, Ja = za.BUGGY_SAFARI_ITERATORS, Qa = ht("iterator"), Za = "keys", $a = "values", ec = "entries", tc = function() {
        return this;
      }, ic = function(e2, t2, i3, n2, r2, o2, s2) {
        Wa(i3, t2, n2);
        var a2, c2, d2, l2 = function(e3) {
          if (e3 === r2 && E2)
            return E2;
          if (!Ja && e3 in p3)
            return p3[e3];
          switch (e3) {
            case Za:
            case $a:
            case ec:
              return function() {
                return new i3(this, e3);
              };
          }
          return function() {
            return new i3(this);
          };
        }, u2 = t2 + " Iterator", h2 = false, p3 = e2.prototype, _2 = p3[Qa] || p3["@@iterator"] || r2 && p3[r2], E2 = !Ja && _2 || l2(r2), f2 = "Array" == t2 && p3.entries || _2;
        if (f2 && (a2 = Ha(f2.call(new e2()))) !== Object.prototype && a2.next && (Ka(a2, u2, true, true), qa[u2] = tc), Xa && r2 == $a && _2 && _2.name !== $a && (h2 = true, E2 = function() {
          return ja(_2, this);
        }), r2)
          if (c2 = { values: l2($a), keys: o2 ? E2 : l2(Za), entries: l2(ec) }, s2)
            for (d2 in c2)
              (Ja || h2 || !(d2 in p3)) && Ya(p3, d2, c2[d2]);
          else
            Ba({ target: t2, proto: true, forced: Ja || h2 }, c2);
        return s2 && p3[Qa] !== E2 && Ya(p3, Qa, E2, { name: r2 }), qa[t2] = E2, c2;
      }, nc = function(e2, t2) {
        return { value: e2, done: t2 };
      }, rc = Z, oc = Vo, sc = oa;
      Qt.f;
      var ac = ic, cc = nc, dc = "Array Iterator", lc = sc.set, uc = sc.getterFor(dc);
      ac(Array, "Array", function(e2, t2) {
        lc(this, { type: dc, target: rc(e2), index: 0, kind: t2 });
      }, function() {
        var e2 = uc(this), t2 = e2.target, i3 = e2.kind, n2 = e2.index++;
        return !t2 || n2 >= t2.length ? (e2.target = void 0, cc(void 0, true)) : cc("keys" == i3 ? n2 : "values" == i3 ? t2[n2] : [n2, t2[n2]], false);
      }, "values"), oc.Arguments = oc.Array;
      var hc = Qt, pc = function(e2, t2, i3) {
        return hc.f(e2, t2, i3);
      }, _c = ae, Ec = pc, fc = N, mc = ht("species"), Tc = l, Sc = TypeError, gc = function(e2, t2) {
        if (Tc(t2, e2))
          return e2;
        throw Sc("Incorrect invocation");
      }, Rc = w, Cc = He, vc = d(Function.toString);
      Rc(Cc.inspectSource) || (Cc.inspectSource = function(e2) {
        return vc(e2);
      });
      var Ic = Cc.inspectSource, yc = d, Ac = n, bc = w, wc = pn, Oc = Ic, Nc = function() {
      }, Dc = [], Pc = ae("Reflect", "construct"), Lc = /^\s*(?:class|function)\b/, kc = yc(Lc.exec), Mc = !Lc.exec(Nc), Uc = function(e2) {
        if (!bc(e2))
          return false;
        try {
          return Pc(Nc, Dc, e2), true;
        } catch (e3) {
          return false;
        }
      }, xc = function(e2) {
        if (!bc(e2))
          return false;
        switch (wc(e2)) {
          case "AsyncFunction":
          case "GeneratorFunction":
          case "AsyncGeneratorFunction":
            return false;
        }
        try {
          return Mc || !!kc(Lc, Oc(e2));
        } catch (e3) {
          return true;
        }
      };
      xc.sham = true;
      var Vc, Fc, Bc, jc, Gc = !Pc || Ac(function() {
        var e2;
        return Uc(Uc.call) || !Uc(Object) || !Uc(function() {
          e2 = true;
        }) || e2;
      }) ? xc : Uc, Wc = Gc, Hc = be, Kc = TypeError, Yc = ii, qc = function(e2) {
        if (Wc(e2))
          return e2;
        throw Kc(Hc(e2) + " is not a constructor");
      }, zc = Y, Xc = ht("species"), Jc = function(e2, t2) {
        var i3, n2 = Yc(e2).constructor;
        return void 0 === n2 || zc(i3 = Yc(n2)[Xc]) ? t2 : qc(i3);
      }, Qc = d([].slice), Zc = TypeError, $c = function(e2, t2) {
        if (e2 < t2)
          throw Zc("Not enough arguments");
        return e2;
      }, ed = /(?:ipad|iphone|ipod).*applewebkit/i.test(ce), td = h, id = m, nd = Jt, rd = w, od = Ze, sd = n, ad = lo, cd = Qc, dd = At, ld = $c, ud = ed, hd = jn, pd = td.setImmediate, _d = td.clearImmediate, Ed = td.process, fd = td.Dispatch, md = td.Function, Td = td.MessageChannel, Sd = td.String, gd = 0, Rd = {}, Cd = "onreadystatechange";
      sd(function() {
        Vc = td.location;
      });
      var vd = function(e2) {
        if (od(Rd, e2)) {
          var t2 = Rd[e2];
          delete Rd[e2], t2();
        }
      }, Id = function(e2) {
        return function() {
          vd(e2);
        };
      }, yd = function(e2) {
        vd(e2.data);
      }, Ad = function(e2) {
        td.postMessage(Sd(e2), Vc.protocol + "//" + Vc.host);
      };
      pd && _d || (pd = function(e2) {
        ld(arguments.length, 1);
        var t2 = rd(e2) ? e2 : md(e2), i3 = cd(arguments, 1);
        return Rd[++gd] = function() {
          id(t2, void 0, i3);
        }, Fc(gd), gd;
      }, _d = function(e2) {
        delete Rd[e2];
      }, hd ? Fc = function(e2) {
        Ed.nextTick(Id(e2));
      } : fd && fd.now ? Fc = function(e2) {
        fd.now(Id(e2));
      } : Td && !ud ? (jc = (Bc = new Td()).port2, Bc.port1.onmessage = yd, Fc = nd(jc.postMessage, jc)) : td.addEventListener && rd(td.postMessage) && !td.importScripts && Vc && "file:" !== Vc.protocol && !sd(Ad) ? (Fc = Ad, td.addEventListener("message", yd, false)) : Fc = Cd in dd("script") ? function(e2) {
        ad.appendChild(dd("script"))[Cd] = function() {
          ad.removeChild(this), vd(e2);
        };
      } : function(e2) {
        setTimeout(Id(e2), 0);
      });
      var bd = { set: pd, clear: _d }, wd = function() {
        this.head = null, this.tail = null;
      };
      wd.prototype = { add: function(e2) {
        var t2 = { item: e2, next: null }, i3 = this.tail;
        i3 ? i3.next = t2 : this.head = t2, this.tail = t2;
      }, get: function() {
        var e2 = this.head;
        if (e2)
          return null === (this.head = e2.next) && (this.tail = null), e2.item;
      } };
      var Od, Nd, Dd, Pd, Ld, kd = wd, Md = /ipad|iphone|ipod/i.test(ce) && "undefined" != typeof Pebble, Ud = /web0s(?!.*chrome)/i.test(ce), xd = h, Vd = Jt, Fd = O.f, Bd = bd.set, jd = kd, Gd = ed, Wd = Md, Hd = Ud, Kd = jn, Yd = xd.MutationObserver || xd.WebKitMutationObserver, qd = xd.document, zd = xd.process, Xd = xd.Promise, Jd = Fd(xd, "queueMicrotask"), Qd = Jd && Jd.value;
      if (!Qd) {
        var Zd = new jd(), $d = function() {
          var e2, t2;
          for (Kd && (e2 = zd.domain) && e2.exit(); t2 = Zd.get(); )
            try {
              t2();
            } catch (e3) {
              throw Zd.head && Od(), e3;
            }
          e2 && e2.enter();
        };
        Gd || Kd || Hd || !Yd || !qd ? !Wd && Xd && Xd.resolve ? ((Pd = Xd.resolve(void 0)).constructor = Xd, Ld = Vd(Pd.then, Pd), Od = function() {
          Ld($d);
        }) : Kd ? Od = function() {
          zd.nextTick($d);
        } : (Bd = Vd(Bd, xd), Od = function() {
          Bd($d);
        }) : (Nd = true, Dd = qd.createTextNode(""), new Yd($d).observe(Dd, { characterData: true }), Od = function() {
          Dd.data = Nd = !Nd;
        }), Qd = function(e2) {
          Zd.head || Od(), Zd.add(e2);
        };
      }
      var el = Qd, tl = function(e2) {
        try {
          return { error: false, value: e2() };
        } catch (e3) {
          return { error: true, value: e3 };
        }
      }, il = h.Promise, nl = "object" == typeof Deno && Deno && "object" == typeof Deno.version, rl = !nl && !jn && "object" == typeof window && "object" == typeof document, ol = h, sl = il, al = w, cl = Yt, dl = Ic, ll = ht, ul = rl, hl = nl, pl = Ee, _l = sl && sl.prototype, El = ll("species"), fl = false, ml = al(ol.PromiseRejectionEvent), Tl = cl("Promise", function() {
        var e2 = dl(sl), t2 = e2 !== String(sl);
        if (!t2 && 66 === pl)
          return true;
        if (!_l.catch || !_l.finally)
          return true;
        if (!pl || pl < 51 || !/native code/.test(e2)) {
          var i3 = new sl(function(e3) {
            e3(1);
          }), n2 = function(e3) {
            e3(function() {
            }, function() {
            });
          };
          if ((i3.constructor = {})[El] = n2, !(fl = i3.then(function() {
          }) instanceof n2))
            return true;
        }
        return !t2 && (ul || hl) && !ml;
      }), Sl = { CONSTRUCTOR: Tl, REJECTION_EVENT: ml, SUBCLASSING: fl }, gl = {}, Rl = De, Cl = TypeError, vl = function(e2) {
        var t2, i3;
        this.promise = new e2(function(e3, n2) {
          if (void 0 !== t2 || void 0 !== i3)
            throw Cl("Bad Promise constructor");
          t2 = e3, i3 = n2;
        }), this.resolve = Rl(t2), this.reject = Rl(i3);
      };
      gl.f = function(e2) {
        return new vl(e2);
      };
      var Il, yl, Al = wi, bl = jn, wl = h, Ol = L, Nl = pa, Dl = Pa, Pl = function(e2) {
        var t2 = _c(e2);
        fc && t2 && !t2[mc] && Ec(t2, mc, { configurable: true, get: function() {
          return this;
        } });
      }, Ll = De, kl = w, Ml = te, Ul = gc, xl = Jc, Vl = bd.set, Fl = el, Bl = function(e2, t2) {
        try {
          1 == arguments.length ? console.error(e2) : console.error(e2, t2);
        } catch (e3) {
        }
      }, jl = tl, Gl = kd, Wl = oa, Hl = il, Kl = Sl, Yl = gl, ql = "Promise", zl = Kl.CONSTRUCTOR, Xl = Kl.REJECTION_EVENT, Jl = Wl.getterFor(ql), Ql = Wl.set, Zl = Hl && Hl.prototype, $l = Hl, eu = Zl, tu = wl.TypeError, iu = wl.document, nu = wl.process, ru = Yl.f, ou = ru, su = !!(iu && iu.createEvent && wl.dispatchEvent), au = "unhandledrejection", cu = function(e2) {
        var t2;
        return !(!Ml(e2) || !kl(t2 = e2.then)) && t2;
      }, du = function(e2, t2) {
        var i3, n2, r2, o2 = t2.value, s2 = 1 == t2.state, a2 = s2 ? e2.ok : e2.fail, c2 = e2.resolve, d2 = e2.reject, l2 = e2.domain;
        try {
          a2 ? (s2 || (2 === t2.rejection && _u(t2), t2.rejection = 1), true === a2 ? i3 = o2 : (l2 && l2.enter(), i3 = a2(o2), l2 && (l2.exit(), r2 = true)), i3 === e2.promise ? d2(tu("Promise-chain cycle")) : (n2 = cu(i3)) ? Ol(n2, i3, c2, d2) : c2(i3)) : d2(o2);
        } catch (e3) {
          l2 && !r2 && l2.exit(), d2(e3);
        }
      }, lu = function(e2, t2) {
        e2.notified || (e2.notified = true, Fl(function() {
          for (var i3, n2 = e2.reactions; i3 = n2.get(); )
            du(i3, e2);
          e2.notified = false, t2 && !e2.rejection && hu(e2);
        }));
      }, uu = function(e2, t2, i3) {
        var n2, r2;
        su ? ((n2 = iu.createEvent("Event")).promise = t2, n2.reason = i3, n2.initEvent(e2, false, true), wl.dispatchEvent(n2)) : n2 = { promise: t2, reason: i3 }, !Xl && (r2 = wl["on" + e2]) ? r2(n2) : e2 === au && Bl("Unhandled promise rejection", i3);
      }, hu = function(e2) {
        Ol(Vl, wl, function() {
          var t2, i3 = e2.facade, n2 = e2.value;
          if (pu(e2) && (t2 = jl(function() {
            bl ? nu.emit("unhandledRejection", n2, i3) : uu(au, i3, n2);
          }), e2.rejection = bl || pu(e2) ? 2 : 1, t2.error))
            throw t2.value;
        });
      }, pu = function(e2) {
        return 1 !== e2.rejection && !e2.parent;
      }, _u = function(e2) {
        Ol(Vl, wl, function() {
          var t2 = e2.facade;
          bl ? nu.emit("rejectionHandled", t2) : uu("rejectionhandled", t2, e2.value);
        });
      }, Eu = function(e2, t2, i3) {
        return function(n2) {
          e2(t2, n2, i3);
        };
      }, fu = function(e2, t2, i3) {
        e2.done || (e2.done = true, i3 && (e2 = i3), e2.value = t2, e2.state = 2, lu(e2, true));
      }, mu = function(e2, t2, i3) {
        if (!e2.done) {
          e2.done = true, i3 && (e2 = i3);
          try {
            if (e2.facade === t2)
              throw tu("Promise can't be resolved itself");
            var n2 = cu(t2);
            n2 ? Fl(function() {
              var i4 = { done: false };
              try {
                Ol(n2, t2, Eu(mu, i4, e2), Eu(fu, i4, e2));
              } catch (t3) {
                fu(i4, t3, e2);
              }
            }) : (e2.value = t2, e2.state = 1, lu(e2, false));
          } catch (t3) {
            fu({ done: false }, t3, e2);
          }
        }
      };
      zl && (eu = ($l = function(e2) {
        Ul(this, eu), Ll(e2), Ol(Il, this);
        var t2 = Jl(this);
        try {
          e2(Eu(mu, t2), Eu(fu, t2));
        } catch (e3) {
          fu(t2, e3);
        }
      }).prototype, (Il = function(e2) {
        Ql(this, { type: ql, done: false, notified: false, parent: false, reactions: new Gl(), rejection: false, state: 0, value: void 0 });
      }).prototype = Nl(eu, "then", function(e2, t2) {
        var i3 = Jl(this), n2 = ru(xl(this, $l));
        return i3.parent = true, n2.ok = !kl(e2) || e2, n2.fail = kl(t2) && t2, n2.domain = bl ? nu.domain : void 0, 0 == i3.state ? i3.reactions.add(n2) : Fl(function() {
          du(n2, i3);
        }), n2.promise;
      }), yl = function() {
        var e2 = new Il(), t2 = Jl(e2);
        this.promise = e2, this.resolve = Eu(mu, t2), this.reject = Eu(fu, t2);
      }, Yl.f = ru = function(e2) {
        return e2 === $l || void 0 === e2 ? new yl(e2) : ou(e2);
      }), Al({ global: true, constructor: true, wrap: true, forced: zl }, { Promise: $l }), Dl($l, ql, false, true), Pl(ql);
      var Tu = ht("iterator"), Su = false;
      try {
        var gu = 0, Ru = { next: function() {
          return { done: !!gu++ };
        }, return: function() {
          Su = true;
        } };
        Ru[Tu] = function() {
          return this;
        }, Array.from(Ru, function() {
          throw 2;
        });
      } catch (e2) {
      }
      var Cu = il, vu = function(e2, t2) {
        if (!t2 && !Su)
          return false;
        var i3 = false;
        try {
          var n2 = {};
          n2[Tu] = function() {
            return { next: function() {
              return { done: i3 = true };
            } };
          }, e2(n2);
        } catch (e3) {
        }
        return i3;
      }, Iu = Sl.CONSTRUCTOR || !vu(function(e2) {
        Cu.all(e2).then(void 0, function() {
        });
      }), yu = L, Au = De, bu = gl, wu = tl, Ou = Ss;
      wi({ target: "Promise", stat: true, forced: Iu }, { all: function(e2) {
        var t2 = this, i3 = bu.f(t2), n2 = i3.resolve, r2 = i3.reject, o2 = wu(function() {
          var i4 = Au(t2.resolve), o3 = [], s2 = 0, a2 = 1;
          Ou(e2, function(e3) {
            var c2 = s2++, d2 = false;
            a2++, yu(i4, t2, e3).then(function(e4) {
              d2 || (d2 = true, o3[c2] = e4, --a2 || n2(o3));
            }, r2);
          }), --a2 || n2(o3);
        });
        return o2.error && r2(o2.value), i3.promise;
      } });
      var Nu = wi, Du = Sl.CONSTRUCTOR;
      il && il.prototype, Nu({ target: "Promise", proto: true, forced: Du, real: true }, { catch: function(e2) {
        return this.then(void 0, e2);
      } });
      var Pu = L, Lu = De, ku = gl, Mu = tl, Uu = Ss;
      wi({ target: "Promise", stat: true, forced: Iu }, { race: function(e2) {
        var t2 = this, i3 = ku.f(t2), n2 = i3.reject, r2 = Mu(function() {
          var r3 = Lu(t2.resolve);
          Uu(e2, function(e3) {
            Pu(r3, t2, e3).then(i3.resolve, n2);
          });
        });
        return r2.error && n2(r2.value), i3.promise;
      } });
      var xu = L, Vu = gl;
      wi({ target: "Promise", stat: true, forced: Sl.CONSTRUCTOR }, { reject: function(e2) {
        var t2 = Vu.f(this);
        return xu(t2.reject, void 0, e2), t2.promise;
      } });
      var Fu = ii, Bu = te, ju = gl, Gu = function(e2, t2) {
        if (Fu(e2), Bu(t2) && t2.constructor === e2)
          return t2;
        var i3 = ju.f(e2);
        return (0, i3.resolve)(t2), i3.promise;
      }, Wu = wi, Hu = il, Ku = Sl.CONSTRUCTOR, Yu = Gu, qu = ae("Promise"), zu = !Ku;
      Wu({ target: "Promise", stat: true, forced: true }, { resolve: function(e2) {
        return Yu(zu && this === qu ? Hu : this, e2);
      } });
      var Xu = L, Ju = De, Qu = gl, Zu = tl, $u = Ss;
      wi({ target: "Promise", stat: true, forced: Iu }, { allSettled: function(e2) {
        var t2 = this, i3 = Qu.f(t2), n2 = i3.resolve, r2 = i3.reject, o2 = Zu(function() {
          var i4 = Ju(t2.resolve), r3 = [], o3 = 0, s2 = 1;
          $u(e2, function(e3) {
            var a2 = o3++, c2 = false;
            s2++, Xu(i4, t2, e3).then(function(e4) {
              c2 || (c2 = true, r3[a2] = { status: "fulfilled", value: e4 }, --s2 || n2(r3));
            }, function(e4) {
              c2 || (c2 = true, r3[a2] = { status: "rejected", reason: e4 }, --s2 || n2(r3));
            });
          }), --s2 || n2(r3);
        });
        return o2.error && r2(o2.value), i3.promise;
      } });
      var eh = L, th = De, ih = ae, nh = gl, rh = tl, oh = Ss, sh = "No one promise resolved";
      wi({ target: "Promise", stat: true, forced: Iu }, { any: function(e2) {
        var t2 = this, i3 = ih("AggregateError"), n2 = nh.f(t2), r2 = n2.resolve, o2 = n2.reject, s2 = rh(function() {
          var n3 = th(t2.resolve), s3 = [], a2 = 0, c2 = 1, d2 = false;
          oh(e2, function(e3) {
            var l2 = a2++, u2 = false;
            c2++, eh(n3, t2, e3).then(function(e4) {
              u2 || d2 || (d2 = true, r2(e4));
            }, function(e4) {
              u2 || d2 || (u2 = true, s3[l2] = e4, --c2 || o2(new i3(s3, sh)));
            });
          }), --c2 || o2(new i3(s3, sh));
        });
        return s2.error && o2(s2.value), n2.promise;
      } });
      var ah = wi, ch = il, dh = n, lh = ae, uh = w, hh = Jc, ph = Gu, _h = ch && ch.prototype;
      ah({ target: "Promise", proto: true, real: true, forced: !!ch && dh(function() {
        _h.finally.call({ then: function() {
        } }, function() {
        });
      }) }, { finally: function(e2) {
        var t2 = hh(this, lh("Promise")), i3 = uh(e2);
        return this.then(i3 ? function(i4) {
          return ph(t2, e2()).then(function() {
            return i4;
          });
        } : e2, i3 ? function(i4) {
          return ph(t2, e2()).then(function() {
            throw i4;
          });
        } : e2);
      } });
      var Eh = d, fh = Li, mh = fn, Th = X, Sh = Eh("".charAt), gh = Eh("".charCodeAt), Rh = Eh("".slice), Ch = function(e2) {
        return function(t2, i3) {
          var n2, r2, o2 = mh(Th(t2)), s2 = fh(i3), a2 = o2.length;
          return s2 < 0 || s2 >= a2 ? e2 ? "" : void 0 : (n2 = gh(o2, s2)) < 55296 || n2 > 56319 || s2 + 1 === a2 || (r2 = gh(o2, s2 + 1)) < 56320 || r2 > 57343 ? e2 ? Sh(o2, s2) : n2 : e2 ? Rh(o2, s2, s2 + 2) : r2 - 56320 + (n2 - 55296 << 10) + 65536;
        };
      }, vh = { codeAt: Ch(false), charAt: Ch(true) }, Ih = vh.charAt, yh = fn, Ah = oa, bh = ic, wh = nc, Oh = "String Iterator", Nh = Ah.set, Dh = Ah.getterFor(Oh);
      bh(String, "String", function(e2) {
        Nh(this, { type: Oh, string: yh(e2), index: 0 });
      }, function() {
        var e2, t2 = Dh(this), i3 = t2.string, n2 = t2.index;
        return n2 >= i3.length ? wh(void 0, true) : (e2 = Ih(i3, n2), t2.index += e2.length, wh(e2, false));
      });
      var Ph = ie.Promise, Lh = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 }, kh = h, Mh = pn, Uh = fi, xh = Vo, Vh = ht("toStringTag");
      for (var Fh in Lh) {
        var Bh = kh[Fh], jh = Bh && Bh.prototype;
        jh && Mh(jh) !== Vh && Uh(jh, Vh, Fh), xh[Fh] = xh.Array;
      }
      var Gh = Ph, Wh = i2(Gh), Hh = Ji("Array").values, Kh = pn, Yh = Ze, qh = l, zh = Hh, Xh = Array.prototype, Jh = { DOMTokenList: true, NodeList: true }, Qh = function(e2) {
        var t2 = e2.values;
        return e2 === Xh || qh(Xh, e2) && t2 === Xh.values || Yh(Jh, Kh(e2)) ? zh : t2;
      }, Zh = i2(Qh), $h = n, ep = ht("iterator"), tp = !$h(function() {
        var e2 = new URL("b?a=1&b=2&c=3", "http://a"), t2 = e2.searchParams, i3 = new URLSearchParams("a=1&a=2"), n2 = "";
        return e2.pathname = "c%20d", t2.forEach(function(e3, i4) {
          t2.delete("b"), n2 += i4 + e3;
        }), i3.delete("a", 2), !e2.toJSON || !i3.has("a", 1) || i3.has("a", 2) || !t2.size && true || !t2.sort || "http://a/c%20d?a=1&c=3" !== e2.href || "3" !== t2.get("c") || "a=1" !== String(new URLSearchParams("?a=1")) || !t2[ep] || "a" !== new URL("https://a@b").username || "b" !== new URLSearchParams(new URLSearchParams("a=b")).get("a") || "xn--e1aybc" !== new URL("http://ÑÐµÑÑ").host || "#%D0%B1" !== new URL("http://a#Ð±").hash || "a1c3" !== n2 || "x" !== new URL("http://x", void 0).host;
      }), ip = pa, np = Ct, rp = Qt, op = B, sp = function(e2, t2, i3) {
        var n2 = np(t2);
        n2 in e2 ? rp.f(e2, n2, op(0, i3)) : e2[n2] = i3;
      }, ap = xi, cp = Gi, dp = sp, lp = Array, up = Math.max, hp = function(e2, t2, i3) {
        for (var n2 = cp(e2), r2 = ap(t2, n2), o2 = ap(void 0 === i3 ? n2 : i3, n2), s2 = lp(up(o2 - r2, 0)), a2 = 0; r2 < o2; r2++, a2++)
          dp(s2, a2, e2[r2]);
        return s2.length = a2, s2;
      }, pp = hp, _p = Math.floor, Ep = function(e2, t2) {
        var i3 = e2.length, n2 = _p(i3 / 2);
        return i3 < 8 ? fp(e2, t2) : mp(e2, Ep(pp(e2, 0, n2), t2), Ep(pp(e2, n2), t2), t2);
      }, fp = function(e2, t2) {
        for (var i3, n2, r2 = e2.length, o2 = 1; o2 < r2; ) {
          for (n2 = o2, i3 = e2[o2]; n2 && t2(e2[n2 - 1], i3) > 0; )
            e2[n2] = e2[--n2];
          n2 !== o2++ && (e2[n2] = i3);
        }
        return e2;
      }, mp = function(e2, t2, i3, n2) {
        for (var r2 = t2.length, o2 = i3.length, s2 = 0, a2 = 0; s2 < r2 || a2 < o2; )
          e2[s2 + a2] = s2 < r2 && a2 < o2 ? n2(t2[s2], i3[a2]) <= 0 ? t2[s2++] : i3[a2++] : s2 < r2 ? t2[s2++] : i3[a2++];
        return e2;
      }, Tp = Ep, Sp = wi, gp = h, Rp = L, Cp = d, vp = N, Ip = tp, yp = pa, Ap = pc, bp = function(e2, t2, i3) {
        for (var n2 in t2)
          i3 && i3.unsafe && e2[n2] ? e2[n2] = t2[n2] : ip(e2, n2, t2[n2], i3);
        return e2;
      }, wp = Pa, Op2 = Fa, Np = oa, Dp = gc, Pp = w, Lp = Ze, kp = Jt, Mp = pn, Up = ii, xp = te, Vp = fn, Fp = Io, Bp = B, jp = ts, Gp = zo, Wp = $c, Hp = Tp, Kp = ht("iterator"), Yp = "URLSearchParams", qp = Yp + "Iterator", zp = Np.set, Xp = Np.getterFor(Yp), Jp = Np.getterFor(qp), Qp = Object.getOwnPropertyDescriptor, Zp = function(e2) {
        if (!vp)
          return gp[e2];
        var t2 = Qp(gp, e2);
        return t2 && t2.value;
      }, $p = Zp("fetch"), e_ = Zp("Request"), t_ = Zp("Headers"), i_ = e_ && e_.prototype, n_ = t_ && t_.prototype, r_ = gp.RegExp, o_ = gp.TypeError, s_ = gp.decodeURIComponent, a_ = gp.encodeURIComponent, c_ = Cp("".charAt), d_ = Cp([].join), l_ = Cp([].push), u_ = Cp("".replace), h_ = Cp([].shift), p_ = Cp([].splice), __ = Cp("".split), E_ = Cp("".slice), f_ = /\+/g, m_ = Array(4), T_ = function(e2) {
        return m_[e2 - 1] || (m_[e2 - 1] = r_("((?:%[\\da-f]{2}){" + e2 + "})", "gi"));
      }, S_ = function(e2) {
        try {
          return s_(e2);
        } catch (t2) {
          return e2;
        }
      }, g_ = function(e2) {
        var t2 = u_(e2, f_, " "), i3 = 4;
        try {
          return s_(t2);
        } catch (e3) {
          for (; i3; )
            t2 = u_(t2, T_(i3--), S_);
          return t2;
        }
      }, R_ = /[!'()~]|%20/g, C_ = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+" }, v_ = function(e2) {
        return C_[e2];
      }, I_ = function(e2) {
        return u_(a_(e2), R_, v_);
      }, y_ = Op2(function(e2, t2) {
        zp(this, { type: qp, iterator: jp(Xp(e2).entries), kind: t2 });
      }, "Iterator", function() {
        var e2 = Jp(this), t2 = e2.kind, i3 = e2.iterator.next(), n2 = i3.value;
        return i3.done || (i3.value = "keys" === t2 ? n2.key : "values" === t2 ? n2.value : [n2.key, n2.value]), i3;
      }, true), A_ = function(e2) {
        this.entries = [], this.url = null, void 0 !== e2 && (xp(e2) ? this.parseObject(e2) : this.parseQuery("string" == typeof e2 ? "?" === c_(e2, 0) ? E_(e2, 1) : e2 : Vp(e2)));
      };
      A_.prototype = { type: Yp, bindURL: function(e2) {
        this.url = e2, this.update();
      }, parseObject: function(e2) {
        var t2, i3, n2, r2, o2, s2, a2, c2 = Gp(e2);
        if (c2)
          for (i3 = (t2 = jp(e2, c2)).next; !(n2 = Rp(i3, t2)).done; ) {
            if (o2 = (r2 = jp(Up(n2.value))).next, (s2 = Rp(o2, r2)).done || (a2 = Rp(o2, r2)).done || !Rp(o2, r2).done)
              throw o_("Expected sequence with length 2");
            l_(this.entries, { key: Vp(s2.value), value: Vp(a2.value) });
          }
        else
          for (var d2 in e2)
            Lp(e2, d2) && l_(this.entries, { key: d2, value: Vp(e2[d2]) });
      }, parseQuery: function(e2) {
        if (e2)
          for (var t2, i3, n2 = __(e2, "&"), r2 = 0; r2 < n2.length; )
            (t2 = n2[r2++]).length && (i3 = __(t2, "="), l_(this.entries, { key: g_(h_(i3)), value: g_(d_(i3, "=")) }));
      }, serialize: function() {
        for (var e2, t2 = this.entries, i3 = [], n2 = 0; n2 < t2.length; )
          e2 = t2[n2++], l_(i3, I_(e2.key) + "=" + I_(e2.value));
        return d_(i3, "&");
      }, update: function() {
        this.entries.length = 0, this.parseQuery(this.url.query);
      }, updateURL: function() {
        this.url && this.url.update();
      } };
      var b_ = function() {
        Dp(this, w_);
        var e2 = zp(this, new A_(arguments.length > 0 ? arguments[0] : void 0));
        vp || (this.size = e2.entries.length);
      }, w_ = b_.prototype;
      if (bp(w_, { append: function(e2, t2) {
        var i3 = Xp(this);
        Wp(arguments.length, 2), l_(i3.entries, { key: Vp(e2), value: Vp(t2) }), vp || this.length++, i3.updateURL();
      }, delete: function(e2) {
        for (var t2 = Xp(this), i3 = Wp(arguments.length, 1), n2 = t2.entries, r2 = Vp(e2), o2 = i3 < 2 ? void 0 : arguments[1], s2 = void 0 === o2 ? o2 : Vp(o2), a2 = 0; a2 < n2.length; ) {
          var c2 = n2[a2];
          if (c2.key !== r2 || void 0 !== s2 && c2.value !== s2)
            a2++;
          else if (p_(n2, a2, 1), void 0 !== s2)
            break;
        }
        vp || (this.size = n2.length), t2.updateURL();
      }, get: function(e2) {
        var t2 = Xp(this).entries;
        Wp(arguments.length, 1);
        for (var i3 = Vp(e2), n2 = 0; n2 < t2.length; n2++)
          if (t2[n2].key === i3)
            return t2[n2].value;
        return null;
      }, getAll: function(e2) {
        var t2 = Xp(this).entries;
        Wp(arguments.length, 1);
        for (var i3 = Vp(e2), n2 = [], r2 = 0; r2 < t2.length; r2++)
          t2[r2].key === i3 && l_(n2, t2[r2].value);
        return n2;
      }, has: function(e2) {
        for (var t2 = Xp(this).entries, i3 = Wp(arguments.length, 1), n2 = Vp(e2), r2 = i3 < 2 ? void 0 : arguments[1], o2 = void 0 === r2 ? r2 : Vp(r2), s2 = 0; s2 < t2.length; ) {
          var a2 = t2[s2++];
          if (a2.key === n2 && (void 0 === o2 || a2.value === o2))
            return true;
        }
        return false;
      }, set: function(e2, t2) {
        var i3 = Xp(this);
        Wp(arguments.length, 1);
        for (var n2, r2 = i3.entries, o2 = false, s2 = Vp(e2), a2 = Vp(t2), c2 = 0; c2 < r2.length; c2++)
          (n2 = r2[c2]).key === s2 && (o2 ? p_(r2, c2--, 1) : (o2 = true, n2.value = a2));
        o2 || l_(r2, { key: s2, value: a2 }), vp || (this.size = r2.length), i3.updateURL();
      }, sort: function() {
        var e2 = Xp(this);
        Hp(e2.entries, function(e3, t2) {
          return e3.key > t2.key ? 1 : -1;
        }), e2.updateURL();
      }, forEach: function(e2) {
        for (var t2, i3 = Xp(this).entries, n2 = kp(e2, arguments.length > 1 ? arguments[1] : void 0), r2 = 0; r2 < i3.length; )
          n2((t2 = i3[r2++]).value, t2.key, this);
      }, keys: function() {
        return new y_(this, "keys");
      }, values: function() {
        return new y_(this, "values");
      }, entries: function() {
        return new y_(this, "entries");
      } }, { enumerable: true }), yp(w_, Kp, w_.entries, { name: "entries" }), yp(w_, "toString", function() {
        return Xp(this).serialize();
      }, { enumerable: true }), vp && Ap(w_, "size", { get: function() {
        return Xp(this).entries.length;
      }, configurable: true, enumerable: true }), wp(b_, Yp), Sp({ global: true, constructor: true, forced: !Ip }, { URLSearchParams: b_ }), !Ip && Pp(t_)) {
        var O_ = Cp(n_.has), N_ = Cp(n_.set), D_ = function(e2) {
          if (xp(e2)) {
            var t2, i3 = e2.body;
            if (Mp(i3) === Yp)
              return t2 = e2.headers ? new t_(e2.headers) : new t_(), O_(t2, "content-type") || N_(t2, "content-type", "application/x-www-form-urlencoded;charset=UTF-8"), Fp(e2, { body: Bp(0, Vp(i3)), headers: Bp(0, t2) });
          }
          return e2;
        };
        if (Pp($p) && Sp({ global: true, enumerable: true, dontCallGetSet: true, forced: true }, { fetch: function(e2) {
          return $p(e2, arguments.length > 1 ? D_(arguments[1]) : {});
        } }), Pp(e_)) {
          var P_ = function(e2) {
            return Dp(this, i_), new e_(e2, arguments.length > 1 ? D_(arguments[1]) : {});
          };
          i_.constructor = P_, P_.prototype = i_, Sp({ global: true, constructor: true, dontCallGetSet: true, forced: true }, { Request: P_ });
        }
      }
      var L_, k_ = { URLSearchParams: b_, getState: Xp }, M_ = ie.URLSearchParams, U_ = N, x_ = d, V_ = L, F_ = n, B_ = to, j_ = jr, G_ = k, W_ = Xe, H_ = K, K_ = Object.assign, Y_ = Object.defineProperty, q_ = x_([].concat), z_ = !K_ || F_(function() {
        if (U_ && 1 !== K_({ b: 1 }, K_(Y_({}, "a", { enumerable: true, get: function() {
          Y_(this, "b", { value: 3, enumerable: false });
        } }), { b: 2 })).b)
          return true;
        var e2 = {}, t2 = {}, i3 = Symbol(), n2 = "abcdefghijklmnopqrst";
        return e2[i3] = 7, n2.split("").forEach(function(e3) {
          t2[e3] = e3;
        }), 7 != K_({}, e2)[i3] || B_(K_({}, t2)).join("") != n2;
      }) ? function(e2, t2) {
        for (var i3 = W_(e2), n2 = arguments.length, r2 = 1, o2 = j_.f, s2 = G_.f; n2 > r2; )
          for (var a2, c2 = H_(arguments[r2++]), d2 = o2 ? q_(B_(c2), o2(c2)) : B_(c2), l2 = d2.length, u2 = 0; l2 > u2; )
            a2 = d2[u2++], U_ && !V_(s2, c2, a2) || (i3[a2] = c2[a2]);
        return i3;
      } : K_, X_ = ii, J_ = os, Q_ = Jt, Z_ = L, $_ = Xe, eE = function(e2, t2, i3, n2) {
        try {
          return n2 ? t2(X_(i3)[0], i3[1]) : t2(i3);
        } catch (t3) {
          J_(e2, "throw", t3);
        }
      }, tE = Go, iE = Gc, nE = Gi, rE = sp, oE = ts, sE = zo, aE = Array, cE = d, dE = 2147483647, lE = /[^\0-\u007E]/, uE = /[.\u3002\uFF0E\uFF61]/g, hE = "Overflow: input needs wider integers to process", pE = RangeError, _E = cE(uE.exec), EE = Math.floor, fE = String.fromCharCode, mE = cE("".charCodeAt), TE = cE([].join), SE = cE([].push), gE = cE("".replace), RE = cE("".split), CE = cE("".toLowerCase), vE = function(e2) {
        return e2 + 22 + 75 * (e2 < 26);
      }, IE = function(e2, t2, i3) {
        var n2 = 0;
        for (e2 = i3 ? EE(e2 / 700) : e2 >> 1, e2 += EE(e2 / t2); e2 > 455; )
          e2 = EE(e2 / 35), n2 += 36;
        return EE(n2 + 36 * e2 / (e2 + 38));
      }, yE = function(e2) {
        var t2 = [];
        e2 = function(e3) {
          for (var t3 = [], i4 = 0, n3 = e3.length; i4 < n3; ) {
            var r3 = mE(e3, i4++);
            if (r3 >= 55296 && r3 <= 56319 && i4 < n3) {
              var o3 = mE(e3, i4++);
              56320 == (64512 & o3) ? SE(t3, ((1023 & r3) << 10) + (1023 & o3) + 65536) : (SE(t3, r3), i4--);
            } else
              SE(t3, r3);
          }
          return t3;
        }(e2);
        var i3, n2, r2 = e2.length, o2 = 128, s2 = 0, a2 = 72;
        for (i3 = 0; i3 < e2.length; i3++)
          (n2 = e2[i3]) < 128 && SE(t2, fE(n2));
        var c2 = t2.length, d2 = c2;
        for (c2 && SE(t2, "-"); d2 < r2; ) {
          var l2 = dE;
          for (i3 = 0; i3 < e2.length; i3++)
            (n2 = e2[i3]) >= o2 && n2 < l2 && (l2 = n2);
          var u2 = d2 + 1;
          if (l2 - o2 > EE((dE - s2) / u2))
            throw pE(hE);
          for (s2 += (l2 - o2) * u2, o2 = l2, i3 = 0; i3 < e2.length; i3++) {
            if ((n2 = e2[i3]) < o2 && ++s2 > dE)
              throw pE(hE);
            if (n2 == o2) {
              for (var h2 = s2, p3 = 36; ; ) {
                var _2 = p3 <= a2 ? 1 : p3 >= a2 + 26 ? 26 : p3 - a2;
                if (h2 < _2)
                  break;
                var E2 = h2 - _2, f2 = 36 - _2;
                SE(t2, fE(vE(_2 + E2 % f2))), h2 = EE(E2 / f2), p3 += 36;
              }
              SE(t2, fE(vE(h2))), a2 = IE(s2, u2, d2 == c2), s2 = 0, d2++;
            }
          }
          s2++, o2++;
        }
        return TE(t2, "");
      }, AE = wi, bE = N, wE = tp, OE = h, NE = Jt, DE = d, PE = pa, LE = pc, kE = gc, ME = Ze, UE = z_, xE = function(e2) {
        var t2 = $_(e2), i3 = iE(this), n2 = arguments.length, r2 = n2 > 1 ? arguments[1] : void 0, o2 = void 0 !== r2;
        o2 && (r2 = Q_(r2, n2 > 2 ? arguments[2] : void 0));
        var s2, a2, c2, d2, l2, u2, h2 = sE(t2), p3 = 0;
        if (!h2 || this === aE && tE(h2))
          for (s2 = nE(t2), a2 = i3 ? new this(s2) : aE(s2); s2 > p3; p3++)
            u2 = o2 ? r2(t2[p3], p3) : t2[p3], rE(a2, p3, u2);
        else
          for (l2 = (d2 = oE(t2, h2)).next, a2 = i3 ? new this() : []; !(c2 = Z_(l2, d2)).done; p3++)
            u2 = o2 ? eE(d2, r2, [c2.value, p3], true) : c2.value, rE(a2, p3, u2);
        return a2.length = p3, a2;
      }, VE = hp, FE = vh.codeAt, BE = function(e2) {
        var t2, i3, n2 = [], r2 = RE(gE(CE(e2), uE, "."), ".");
        for (t2 = 0; t2 < r2.length; t2++)
          i3 = r2[t2], SE(n2, _E(lE, i3) ? "xn--" + yE(i3) : i3);
        return TE(n2, ".");
      }, jE = fn, GE = Pa, WE = $c, HE = k_, KE = oa, YE = KE.set, qE = KE.getterFor("URL"), zE = HE.URLSearchParams, XE = HE.getState, JE = OE.URL, QE = OE.TypeError, ZE = OE.parseInt, $E = Math.floor, ef = Math.pow, tf = DE("".charAt), nf = DE(/./.exec), rf = DE([].join), of2 = DE(1 .toString), sf = DE([].pop), af = DE([].push), cf = DE("".replace), df = DE([].shift), lf = DE("".split), uf = DE("".slice), hf = DE("".toLowerCase), pf = DE([].unshift), _f = "Invalid scheme", Ef = "Invalid host", ff = "Invalid port", mf = /[a-z]/i, Tf = /[\d+-.a-z]/i, Sf = /\d/, gf = /^0x/i, Rf = /^[0-7]+$/, Cf = /^\d+$/, vf = /^[\da-f]+$/i, If = /[\0\t\n\r #%/:<>?@[\\\]^|]/, yf = /[\0\t\n\r #/:<>?@[\\\]^|]/, Af = /^[\u0000-\u0020]+/, bf = /(^|[^\u0000-\u0020])[\u0000-\u0020]+$/, wf = /[\t\n\r]/g, Of = function(e2) {
        var t2, i3, n2, r2;
        if ("number" == typeof e2) {
          for (t2 = [], i3 = 0; i3 < 4; i3++)
            pf(t2, e2 % 256), e2 = $E(e2 / 256);
          return rf(t2, ".");
        }
        if ("object" == typeof e2) {
          for (t2 = "", n2 = function(e3) {
            for (var t3 = null, i4 = 1, n3 = null, r3 = 0, o2 = 0; o2 < 8; o2++)
              0 !== e3[o2] ? (r3 > i4 && (t3 = n3, i4 = r3), n3 = null, r3 = 0) : (null === n3 && (n3 = o2), ++r3);
            return r3 > i4 && (t3 = n3, i4 = r3), t3;
          }(e2), i3 = 0; i3 < 8; i3++)
            r2 && 0 === e2[i3] || (r2 && (r2 = false), n2 === i3 ? (t2 += i3 ? ":" : "::", r2 = true) : (t2 += of2(e2[i3], 16), i3 < 7 && (t2 += ":")));
          return "[" + t2 + "]";
        }
        return e2;
      }, Nf = {}, Df = UE({}, Nf, { " ": 1, '"': 1, "<": 1, ">": 1, "`": 1 }), Pf = UE({}, Df, { "#": 1, "?": 1, "{": 1, "}": 1 }), Lf = UE({}, Pf, { "/": 1, ":": 1, ";": 1, "=": 1, "@": 1, "[": 1, "\\": 1, "]": 1, "^": 1, "|": 1 }), kf = function(e2, t2) {
        var i3 = FE(e2, 0);
        return i3 > 32 && i3 < 127 && !ME(t2, e2) ? e2 : encodeURIComponent(e2);
      }, Mf = { ftp: 21, file: null, http: 80, https: 443, ws: 80, wss: 443 }, Uf = function(e2, t2) {
        var i3;
        return 2 == e2.length && nf(mf, tf(e2, 0)) && (":" == (i3 = tf(e2, 1)) || !t2 && "|" == i3);
      }, xf = function(e2) {
        var t2;
        return e2.length > 1 && Uf(uf(e2, 0, 2)) && (2 == e2.length || "/" === (t2 = tf(e2, 2)) || "\\" === t2 || "?" === t2 || "#" === t2);
      }, Vf = function(e2) {
        return "." === e2 || "%2e" === hf(e2);
      }, Ff = {}, Bf = {}, jf = {}, Gf = {}, Wf = {}, Hf = {}, Kf = {}, Yf = {}, qf = {}, zf = {}, Xf = {}, Jf = {}, Qf = {}, Zf = {}, $f = {}, em = {}, tm = {}, im = {}, nm = {}, rm = {}, om = {}, sm = function(e2, t2, i3) {
        var n2, r2, o2, s2 = jE(e2);
        if (t2) {
          if (r2 = this.parse(s2))
            throw QE(r2);
          this.searchParams = null;
        } else {
          if (void 0 !== i3 && (n2 = new sm(i3, true)), r2 = this.parse(s2, null, n2))
            throw QE(r2);
          (o2 = XE(new zE())).bindURL(this), this.searchParams = o2;
        }
      };
      sm.prototype = { type: "URL", parse: function(e2, t2, i3) {
        var n2, r2, o2, s2, a2, c2 = this, d2 = t2 || Ff, l2 = 0, u2 = "", h2 = false, p3 = false, _2 = false;
        for (e2 = jE(e2), t2 || (c2.scheme = "", c2.username = "", c2.password = "", c2.host = null, c2.port = null, c2.path = [], c2.query = null, c2.fragment = null, c2.cannotBeABaseURL = false, e2 = cf(e2, Af, ""), e2 = cf(e2, bf, "$1")), e2 = cf(e2, wf, ""), n2 = xE(e2); l2 <= n2.length; ) {
          switch (r2 = n2[l2], d2) {
            case Ff:
              if (!r2 || !nf(mf, r2)) {
                if (t2)
                  return _f;
                d2 = jf;
                continue;
              }
              u2 += hf(r2), d2 = Bf;
              break;
            case Bf:
              if (r2 && (nf(Tf, r2) || "+" == r2 || "-" == r2 || "." == r2))
                u2 += hf(r2);
              else {
                if (":" != r2) {
                  if (t2)
                    return _f;
                  u2 = "", d2 = jf, l2 = 0;
                  continue;
                }
                if (t2 && (c2.isSpecial() != ME(Mf, u2) || "file" == u2 && (c2.includesCredentials() || null !== c2.port) || "file" == c2.scheme && !c2.host))
                  return;
                if (c2.scheme = u2, t2)
                  return void (c2.isSpecial() && Mf[c2.scheme] == c2.port && (c2.port = null));
                u2 = "", "file" == c2.scheme ? d2 = Zf : c2.isSpecial() && i3 && i3.scheme == c2.scheme ? d2 = Gf : c2.isSpecial() ? d2 = Yf : "/" == n2[l2 + 1] ? (d2 = Wf, l2++) : (c2.cannotBeABaseURL = true, af(c2.path, ""), d2 = nm);
              }
              break;
            case jf:
              if (!i3 || i3.cannotBeABaseURL && "#" != r2)
                return _f;
              if (i3.cannotBeABaseURL && "#" == r2) {
                c2.scheme = i3.scheme, c2.path = VE(i3.path), c2.query = i3.query, c2.fragment = "", c2.cannotBeABaseURL = true, d2 = om;
                break;
              }
              d2 = "file" == i3.scheme ? Zf : Hf;
              continue;
            case Gf:
              if ("/" != r2 || "/" != n2[l2 + 1]) {
                d2 = Hf;
                continue;
              }
              d2 = qf, l2++;
              break;
            case Wf:
              if ("/" == r2) {
                d2 = zf;
                break;
              }
              d2 = im;
              continue;
            case Hf:
              if (c2.scheme = i3.scheme, r2 == L_)
                c2.username = i3.username, c2.password = i3.password, c2.host = i3.host, c2.port = i3.port, c2.path = VE(i3.path), c2.query = i3.query;
              else if ("/" == r2 || "\\" == r2 && c2.isSpecial())
                d2 = Kf;
              else if ("?" == r2)
                c2.username = i3.username, c2.password = i3.password, c2.host = i3.host, c2.port = i3.port, c2.path = VE(i3.path), c2.query = "", d2 = rm;
              else {
                if ("#" != r2) {
                  c2.username = i3.username, c2.password = i3.password, c2.host = i3.host, c2.port = i3.port, c2.path = VE(i3.path), c2.path.length--, d2 = im;
                  continue;
                }
                c2.username = i3.username, c2.password = i3.password, c2.host = i3.host, c2.port = i3.port, c2.path = VE(i3.path), c2.query = i3.query, c2.fragment = "", d2 = om;
              }
              break;
            case Kf:
              if (!c2.isSpecial() || "/" != r2 && "\\" != r2) {
                if ("/" != r2) {
                  c2.username = i3.username, c2.password = i3.password, c2.host = i3.host, c2.port = i3.port, d2 = im;
                  continue;
                }
                d2 = zf;
              } else
                d2 = qf;
              break;
            case Yf:
              if (d2 = qf, "/" != r2 || "/" != tf(u2, l2 + 1))
                continue;
              l2++;
              break;
            case qf:
              if ("/" != r2 && "\\" != r2) {
                d2 = zf;
                continue;
              }
              break;
            case zf:
              if ("@" == r2) {
                h2 && (u2 = "%40" + u2), h2 = true, o2 = xE(u2);
                for (var E2 = 0; E2 < o2.length; E2++) {
                  var f2 = o2[E2];
                  if (":" != f2 || _2) {
                    var m2 = kf(f2, Lf);
                    _2 ? c2.password += m2 : c2.username += m2;
                  } else
                    _2 = true;
                }
                u2 = "";
              } else if (r2 == L_ || "/" == r2 || "?" == r2 || "#" == r2 || "\\" == r2 && c2.isSpecial()) {
                if (h2 && "" == u2)
                  return "Invalid authority";
                l2 -= xE(u2).length + 1, u2 = "", d2 = Xf;
              } else
                u2 += r2;
              break;
            case Xf:
            case Jf:
              if (t2 && "file" == c2.scheme) {
                d2 = em;
                continue;
              }
              if (":" != r2 || p3) {
                if (r2 == L_ || "/" == r2 || "?" == r2 || "#" == r2 || "\\" == r2 && c2.isSpecial()) {
                  if (c2.isSpecial() && "" == u2)
                    return Ef;
                  if (t2 && "" == u2 && (c2.includesCredentials() || null !== c2.port))
                    return;
                  if (s2 = c2.parseHost(u2))
                    return s2;
                  if (u2 = "", d2 = tm, t2)
                    return;
                  continue;
                }
                "[" == r2 ? p3 = true : "]" == r2 && (p3 = false), u2 += r2;
              } else {
                if ("" == u2)
                  return Ef;
                if (s2 = c2.parseHost(u2))
                  return s2;
                if (u2 = "", d2 = Qf, t2 == Jf)
                  return;
              }
              break;
            case Qf:
              if (!nf(Sf, r2)) {
                if (r2 == L_ || "/" == r2 || "?" == r2 || "#" == r2 || "\\" == r2 && c2.isSpecial() || t2) {
                  if ("" != u2) {
                    var T2 = ZE(u2, 10);
                    if (T2 > 65535)
                      return ff;
                    c2.port = c2.isSpecial() && T2 === Mf[c2.scheme] ? null : T2, u2 = "";
                  }
                  if (t2)
                    return;
                  d2 = tm;
                  continue;
                }
                return ff;
              }
              u2 += r2;
              break;
            case Zf:
              if (c2.scheme = "file", "/" == r2 || "\\" == r2)
                d2 = $f;
              else {
                if (!i3 || "file" != i3.scheme) {
                  d2 = im;
                  continue;
                }
                if (r2 == L_)
                  c2.host = i3.host, c2.path = VE(i3.path), c2.query = i3.query;
                else if ("?" == r2)
                  c2.host = i3.host, c2.path = VE(i3.path), c2.query = "", d2 = rm;
                else {
                  if ("#" != r2) {
                    xf(rf(VE(n2, l2), "")) || (c2.host = i3.host, c2.path = VE(i3.path), c2.shortenPath()), d2 = im;
                    continue;
                  }
                  c2.host = i3.host, c2.path = VE(i3.path), c2.query = i3.query, c2.fragment = "", d2 = om;
                }
              }
              break;
            case $f:
              if ("/" == r2 || "\\" == r2) {
                d2 = em;
                break;
              }
              i3 && "file" == i3.scheme && !xf(rf(VE(n2, l2), "")) && (Uf(i3.path[0], true) ? af(c2.path, i3.path[0]) : c2.host = i3.host), d2 = im;
              continue;
            case em:
              if (r2 == L_ || "/" == r2 || "\\" == r2 || "?" == r2 || "#" == r2) {
                if (!t2 && Uf(u2))
                  d2 = im;
                else if ("" == u2) {
                  if (c2.host = "", t2)
                    return;
                  d2 = tm;
                } else {
                  if (s2 = c2.parseHost(u2))
                    return s2;
                  if ("localhost" == c2.host && (c2.host = ""), t2)
                    return;
                  u2 = "", d2 = tm;
                }
                continue;
              }
              u2 += r2;
              break;
            case tm:
              if (c2.isSpecial()) {
                if (d2 = im, "/" != r2 && "\\" != r2)
                  continue;
              } else if (t2 || "?" != r2)
                if (t2 || "#" != r2) {
                  if (r2 != L_ && (d2 = im, "/" != r2))
                    continue;
                } else
                  c2.fragment = "", d2 = om;
              else
                c2.query = "", d2 = rm;
              break;
            case im:
              if (r2 == L_ || "/" == r2 || "\\" == r2 && c2.isSpecial() || !t2 && ("?" == r2 || "#" == r2)) {
                if (".." === (a2 = hf(a2 = u2)) || "%2e." === a2 || ".%2e" === a2 || "%2e%2e" === a2 ? (c2.shortenPath(), "/" == r2 || "\\" == r2 && c2.isSpecial() || af(c2.path, "")) : Vf(u2) ? "/" == r2 || "\\" == r2 && c2.isSpecial() || af(c2.path, "") : ("file" == c2.scheme && !c2.path.length && Uf(u2) && (c2.host && (c2.host = ""), u2 = tf(u2, 0) + ":"), af(c2.path, u2)), u2 = "", "file" == c2.scheme && (r2 == L_ || "?" == r2 || "#" == r2))
                  for (; c2.path.length > 1 && "" === c2.path[0]; )
                    df(c2.path);
                "?" == r2 ? (c2.query = "", d2 = rm) : "#" == r2 && (c2.fragment = "", d2 = om);
              } else
                u2 += kf(r2, Pf);
              break;
            case nm:
              "?" == r2 ? (c2.query = "", d2 = rm) : "#" == r2 ? (c2.fragment = "", d2 = om) : r2 != L_ && (c2.path[0] += kf(r2, Nf));
              break;
            case rm:
              t2 || "#" != r2 ? r2 != L_ && ("'" == r2 && c2.isSpecial() ? c2.query += "%27" : c2.query += "#" == r2 ? "%23" : kf(r2, Nf)) : (c2.fragment = "", d2 = om);
              break;
            case om:
              r2 != L_ && (c2.fragment += kf(r2, Df));
          }
          l2++;
        }
      }, parseHost: function(e2) {
        var t2, i3, n2;
        if ("[" == tf(e2, 0)) {
          if ("]" != tf(e2, e2.length - 1))
            return Ef;
          if (t2 = function(e3) {
            var t3, i4, n3, r2, o2, s2, a2, c2 = [0, 0, 0, 0, 0, 0, 0, 0], d2 = 0, l2 = null, u2 = 0, h2 = function() {
              return tf(e3, u2);
            };
            if (":" == h2()) {
              if (":" != tf(e3, 1))
                return;
              u2 += 2, l2 = ++d2;
            }
            for (; h2(); ) {
              if (8 == d2)
                return;
              if (":" != h2()) {
                for (t3 = i4 = 0; i4 < 4 && nf(vf, h2()); )
                  t3 = 16 * t3 + ZE(h2(), 16), u2++, i4++;
                if ("." == h2()) {
                  if (0 == i4)
                    return;
                  if (u2 -= i4, d2 > 6)
                    return;
                  for (n3 = 0; h2(); ) {
                    if (r2 = null, n3 > 0) {
                      if (!("." == h2() && n3 < 4))
                        return;
                      u2++;
                    }
                    if (!nf(Sf, h2()))
                      return;
                    for (; nf(Sf, h2()); ) {
                      if (o2 = ZE(h2(), 10), null === r2)
                        r2 = o2;
                      else {
                        if (0 == r2)
                          return;
                        r2 = 10 * r2 + o2;
                      }
                      if (r2 > 255)
                        return;
                      u2++;
                    }
                    c2[d2] = 256 * c2[d2] + r2, 2 != ++n3 && 4 != n3 || d2++;
                  }
                  if (4 != n3)
                    return;
                  break;
                }
                if (":" == h2()) {
                  if (u2++, !h2())
                    return;
                } else if (h2())
                  return;
                c2[d2++] = t3;
              } else {
                if (null !== l2)
                  return;
                u2++, l2 = ++d2;
              }
            }
            if (null !== l2)
              for (s2 = d2 - l2, d2 = 7; 0 != d2 && s2 > 0; )
                a2 = c2[d2], c2[d2--] = c2[l2 + s2 - 1], c2[l2 + --s2] = a2;
            else if (8 != d2)
              return;
            return c2;
          }(uf(e2, 1, -1)), !t2)
            return Ef;
          this.host = t2;
        } else if (this.isSpecial()) {
          if (e2 = BE(e2), nf(If, e2))
            return Ef;
          if (t2 = function(e3) {
            var t3, i4, n3, r2, o2, s2, a2, c2 = lf(e3, ".");
            if (c2.length && "" == c2[c2.length - 1] && c2.length--, (t3 = c2.length) > 4)
              return e3;
            for (i4 = [], n3 = 0; n3 < t3; n3++) {
              if ("" == (r2 = c2[n3]))
                return e3;
              if (o2 = 10, r2.length > 1 && "0" == tf(r2, 0) && (o2 = nf(gf, r2) ? 16 : 8, r2 = uf(r2, 8 == o2 ? 1 : 2)), "" === r2)
                s2 = 0;
              else {
                if (!nf(10 == o2 ? Cf : 8 == o2 ? Rf : vf, r2))
                  return e3;
                s2 = ZE(r2, o2);
              }
              af(i4, s2);
            }
            for (n3 = 0; n3 < t3; n3++)
              if (s2 = i4[n3], n3 == t3 - 1) {
                if (s2 >= ef(256, 5 - t3))
                  return null;
              } else if (s2 > 255)
                return null;
            for (a2 = sf(i4), n3 = 0; n3 < i4.length; n3++)
              a2 += i4[n3] * ef(256, 3 - n3);
            return a2;
          }(e2), null === t2)
            return Ef;
          this.host = t2;
        } else {
          if (nf(yf, e2))
            return Ef;
          for (t2 = "", i3 = xE(e2), n2 = 0; n2 < i3.length; n2++)
            t2 += kf(i3[n2], Nf);
          this.host = t2;
        }
      }, cannotHaveUsernamePasswordPort: function() {
        return !this.host || this.cannotBeABaseURL || "file" == this.scheme;
      }, includesCredentials: function() {
        return "" != this.username || "" != this.password;
      }, isSpecial: function() {
        return ME(Mf, this.scheme);
      }, shortenPath: function() {
        var e2 = this.path, t2 = e2.length;
        !t2 || "file" == this.scheme && 1 == t2 && Uf(e2[0], true) || e2.length--;
      }, serialize: function() {
        var e2 = this, t2 = e2.scheme, i3 = e2.username, n2 = e2.password, r2 = e2.host, o2 = e2.port, s2 = e2.path, a2 = e2.query, c2 = e2.fragment, d2 = t2 + ":";
        return null !== r2 ? (d2 += "//", e2.includesCredentials() && (d2 += i3 + (n2 ? ":" + n2 : "") + "@"), d2 += Of(r2), null !== o2 && (d2 += ":" + o2)) : "file" == t2 && (d2 += "//"), d2 += e2.cannotBeABaseURL ? s2[0] : s2.length ? "/" + rf(s2, "/") : "", null !== a2 && (d2 += "?" + a2), null !== c2 && (d2 += "#" + c2), d2;
      }, setHref: function(e2) {
        var t2 = this.parse(e2);
        if (t2)
          throw QE(t2);
        this.searchParams.update();
      }, getOrigin: function() {
        var e2 = this.scheme, t2 = this.port;
        if ("blob" == e2)
          try {
            return new am(e2.path[0]).origin;
          } catch (e3) {
            return "null";
          }
        return "file" != e2 && this.isSpecial() ? e2 + "://" + Of(this.host) + (null !== t2 ? ":" + t2 : "") : "null";
      }, getProtocol: function() {
        return this.scheme + ":";
      }, setProtocol: function(e2) {
        this.parse(jE(e2) + ":", Ff);
      }, getUsername: function() {
        return this.username;
      }, setUsername: function(e2) {
        var t2 = xE(jE(e2));
        if (!this.cannotHaveUsernamePasswordPort()) {
          this.username = "";
          for (var i3 = 0; i3 < t2.length; i3++)
            this.username += kf(t2[i3], Lf);
        }
      }, getPassword: function() {
        return this.password;
      }, setPassword: function(e2) {
        var t2 = xE(jE(e2));
        if (!this.cannotHaveUsernamePasswordPort()) {
          this.password = "";
          for (var i3 = 0; i3 < t2.length; i3++)
            this.password += kf(t2[i3], Lf);
        }
      }, getHost: function() {
        var e2 = this.host, t2 = this.port;
        return null === e2 ? "" : null === t2 ? Of(e2) : Of(e2) + ":" + t2;
      }, setHost: function(e2) {
        this.cannotBeABaseURL || this.parse(e2, Xf);
      }, getHostname: function() {
        var e2 = this.host;
        return null === e2 ? "" : Of(e2);
      }, setHostname: function(e2) {
        this.cannotBeABaseURL || this.parse(e2, Jf);
      }, getPort: function() {
        var e2 = this.port;
        return null === e2 ? "" : jE(e2);
      }, setPort: function(e2) {
        this.cannotHaveUsernamePasswordPort() || ("" == (e2 = jE(e2)) ? this.port = null : this.parse(e2, Qf));
      }, getPathname: function() {
        var e2 = this.path;
        return this.cannotBeABaseURL ? e2[0] : e2.length ? "/" + rf(e2, "/") : "";
      }, setPathname: function(e2) {
        this.cannotBeABaseURL || (this.path = [], this.parse(e2, tm));
      }, getSearch: function() {
        var e2 = this.query;
        return e2 ? "?" + e2 : "";
      }, setSearch: function(e2) {
        "" == (e2 = jE(e2)) ? this.query = null : ("?" == tf(e2, 0) && (e2 = uf(e2, 1)), this.query = "", this.parse(e2, rm)), this.searchParams.update();
      }, getSearchParams: function() {
        return this.searchParams.facade;
      }, getHash: function() {
        var e2 = this.fragment;
        return e2 ? "#" + e2 : "";
      }, setHash: function(e2) {
        "" != (e2 = jE(e2)) ? ("#" == tf(e2, 0) && (e2 = uf(e2, 1)), this.fragment = "", this.parse(e2, om)) : this.fragment = null;
      }, update: function() {
        this.query = this.searchParams.serialize() || null;
      } };
      var am = function(e2) {
        var t2 = kE(this, cm), i3 = WE(arguments.length, 1) > 1 ? arguments[1] : void 0, n2 = YE(t2, new sm(e2, false, i3));
        bE || (t2.href = n2.serialize(), t2.origin = n2.getOrigin(), t2.protocol = n2.getProtocol(), t2.username = n2.getUsername(), t2.password = n2.getPassword(), t2.host = n2.getHost(), t2.hostname = n2.getHostname(), t2.port = n2.getPort(), t2.pathname = n2.getPathname(), t2.search = n2.getSearch(), t2.searchParams = n2.getSearchParams(), t2.hash = n2.getHash());
      }, cm = am.prototype, dm = function(e2, t2) {
        return { get: function() {
          return qE(this)[e2]();
        }, set: t2 && function(e3) {
          return qE(this)[t2](e3);
        }, configurable: true, enumerable: true };
      };
      if (bE && (LE(cm, "href", dm("serialize", "setHref")), LE(cm, "origin", dm("getOrigin")), LE(cm, "protocol", dm("getProtocol", "setProtocol")), LE(cm, "username", dm("getUsername", "setUsername")), LE(cm, "password", dm("getPassword", "setPassword")), LE(cm, "host", dm("getHost", "setHost")), LE(cm, "hostname", dm("getHostname", "setHostname")), LE(cm, "port", dm("getPort", "setPort")), LE(cm, "pathname", dm("getPathname", "setPathname")), LE(cm, "search", dm("getSearch", "setSearch")), LE(cm, "searchParams", dm("getSearchParams")), LE(cm, "hash", dm("getHash", "setHash"))), PE(cm, "toJSON", function() {
        return qE(this).serialize();
      }, { enumerable: true }), PE(cm, "toString", function() {
        return qE(this).serialize();
      }, { enumerable: true }), JE) {
        var lm = JE.createObjectURL, um = JE.revokeObjectURL;
        lm && PE(am, "createObjectURL", NE(lm, JE)), um && PE(am, "revokeObjectURL", NE(um, JE));
      }
      GE(am, "URL"), AE({ global: true, constructor: true, forced: !wE, sham: !bE }, { URL: am });
      var hm = wi, pm = n, _m = $c, Em = fn, fm = tp, mm = ae("URL");
      hm({ target: "URL", stat: true, forced: !(fm && pm(function() {
        mm.canParse();
      })) }, { canParse: function(e2) {
        var t2 = _m(arguments.length, 1), i3 = Em(e2), n2 = t2 < 2 || void 0 === arguments[1] ? void 0 : Em(arguments[1]);
        try {
          return !!new mm(i3, n2);
        } catch (e3) {
          return false;
        }
      } });
      var Tm = i2(ie.URL);
      let Sm = true, gm = true;
      function Rm(e2, t2, i3) {
        const n2 = e2.match(t2);
        return n2 && n2.length >= i3 && parseInt(n2[i3], 10);
      }
      function Cm(e2, t2, i3) {
        if (!e2.RTCPeerConnection)
          return;
        const n2 = e2.RTCPeerConnection.prototype, r2 = n2.addEventListener;
        n2.addEventListener = function(e3, n3) {
          if (e3 !== t2)
            return r2.apply(this, arguments);
          const o3 = (e4) => {
            const t3 = i3(e4);
            t3 && (n3.handleEvent ? n3.handleEvent(t3) : n3(t3));
          };
          return this._eventMap = this._eventMap || {}, this._eventMap[t2] || (this._eventMap[t2] = /* @__PURE__ */ new Map()), this._eventMap[t2].set(n3, o3), r2.apply(this, [e3, o3]);
        };
        const o2 = n2.removeEventListener;
        n2.removeEventListener = function(e3, i4) {
          if (e3 !== t2 || !this._eventMap || !this._eventMap[t2])
            return o2.apply(this, arguments);
          if (!this._eventMap[t2].has(i4))
            return o2.apply(this, arguments);
          const n3 = this._eventMap[t2].get(i4);
          return this._eventMap[t2].delete(i4), 0 === this._eventMap[t2].size && delete this._eventMap[t2], 0 === Object.keys(this._eventMap).length && delete this._eventMap, o2.apply(this, [e3, n3]);
        }, Object.defineProperty(n2, "on" + t2, { get() {
          return this["_on" + t2];
        }, set(e3) {
          this["_on" + t2] && (this.removeEventListener(t2, this["_on" + t2]), delete this["_on" + t2]), e3 && this.addEventListener(t2, this["_on" + t2] = e3);
        }, enumerable: true, configurable: true });
      }
      function vm(e2) {
        return "boolean" != typeof e2 ? new Error("Argument type: " + typeof e2 + ". Please use a boolean.") : (Sm = e2, e2 ? "adapter.js logging disabled" : "adapter.js logging enabled");
      }
      function Im(e2) {
        return "boolean" != typeof e2 ? new Error("Argument type: " + typeof e2 + ". Please use a boolean.") : (gm = !e2, "adapter.js deprecation warnings " + (e2 ? "disabled" : "enabled"));
      }
      function ym() {
        if ("object" == typeof window) {
          if (Sm)
            return;
          "undefined" != typeof console && "function" == typeof console.log && console.log.apply(console, arguments);
        }
      }
      function Am(e2, t2) {
        gm && console.warn(e2 + " is deprecated, please use " + t2 + " instead.");
      }
      function bm(e2) {
        return "[object Object]" === Object.prototype.toString.call(e2);
      }
      function wm(e2) {
        var t2;
        return bm(e2) ? Xn(t2 = Object.keys(e2)).call(t2, function(t3, i3) {
          const n2 = bm(e2[i3]), r2 = n2 ? wm(e2[i3]) : e2[i3], o2 = n2 && !Object.keys(r2).length;
          return void 0 === r2 || o2 ? t3 : Object.assign(t3, { [i3]: r2 });
        }, {}) : e2;
      }
      function Om(e2, t2, i3) {
        t2 && !i3.has(t2.id) && (i3.set(t2.id, t2), Object.keys(t2).forEach((n2) => {
          n2.endsWith("Id") ? Om(e2, e2.get(t2[n2]), i3) : n2.endsWith("Ids") && t2[n2].forEach((t3) => {
            Om(e2, e2.get(t3), i3);
          });
        }));
      }
      function Nm(e2, t2, i3) {
        const n2 = i3 ? "outbound-rtp" : "inbound-rtp", r2 = /* @__PURE__ */ new Map();
        if (null === t2)
          return r2;
        const o2 = [];
        return e2.forEach((e3) => {
          "track" === e3.type && e3.trackIdentifier === t2.id && o2.push(e3);
        }), o2.forEach((t3) => {
          e2.forEach((i4) => {
            i4.type === n2 && i4.trackId === t3.id && Om(e2, i4, r2);
          });
        }), r2;
      }
      const Dm = ym;
      function Pm(e2, t2) {
        const i3 = e2 && e2.navigator;
        if (!i3.mediaDevices)
          return;
        const n2 = function(e3) {
          if ("object" != typeof e3 || e3.mandatory || e3.optional)
            return e3;
          const t3 = {};
          return Object.keys(e3).forEach((i4) => {
            if ("require" === i4 || "advanced" === i4 || "mediaSource" === i4)
              return;
            const n3 = "object" == typeof e3[i4] ? e3[i4] : { ideal: e3[i4] };
            void 0 !== n3.exact && "number" == typeof n3.exact && (n3.min = n3.max = n3.exact);
            const r3 = function(e4, t4) {
              return e4 ? e4 + t4.charAt(0).toUpperCase() + t4.slice(1) : "deviceId" === t4 ? "sourceId" : t4;
            };
            if (void 0 !== n3.ideal) {
              t3.optional = t3.optional || [];
              let e4 = {};
              "number" == typeof n3.ideal ? (e4[r3("min", i4)] = n3.ideal, t3.optional.push(e4), e4 = {}, e4[r3("max", i4)] = n3.ideal, t3.optional.push(e4)) : (e4[r3("", i4)] = n3.ideal, t3.optional.push(e4));
            }
            void 0 !== n3.exact && "number" != typeof n3.exact ? (t3.mandatory = t3.mandatory || {}, t3.mandatory[r3("", i4)] = n3.exact) : ["min", "max"].forEach((e4) => {
              void 0 !== n3[e4] && (t3.mandatory = t3.mandatory || {}, t3.mandatory[r3(e4, i4)] = n3[e4]);
            });
          }), e3.advanced && (t3.optional = (t3.optional || []).concat(e3.advanced)), t3;
        }, r2 = function(e3, r3) {
          if (t2.version >= 61)
            return r3(e3);
          if ((e3 = JSON.parse(JSON.stringify(e3))) && "object" == typeof e3.audio) {
            const t3 = function(e4, t4, i4) {
              t4 in e4 && !(i4 in e4) && (e4[i4] = e4[t4], delete e4[t4]);
            };
            t3((e3 = JSON.parse(JSON.stringify(e3))).audio, "autoGainControl", "googAutoGainControl"), t3(e3.audio, "noiseSuppression", "googNoiseSuppression"), e3.audio = n2(e3.audio);
          }
          if (e3 && "object" == typeof e3.video) {
            let o3 = e3.video.facingMode;
            o3 = o3 && ("object" == typeof o3 ? o3 : { ideal: o3 });
            const s2 = t2.version < 66;
            if (o3 && ("user" === o3.exact || "environment" === o3.exact || "user" === o3.ideal || "environment" === o3.ideal) && (!i3.mediaDevices.getSupportedConstraints || !i3.mediaDevices.getSupportedConstraints().facingMode || s2)) {
              let t3;
              if (delete e3.video.facingMode, "environment" === o3.exact || "environment" === o3.ideal ? t3 = ["back", "rear"] : "user" !== o3.exact && "user" !== o3.ideal || (t3 = ["front"]), t3)
                return i3.mediaDevices.enumerateDevices().then((i4) => {
                  let s3 = (i4 = i4.filter((e4) => "videoinput" === e4.kind)).find((e4) => t3.some((t4) => {
                    var i5;
                    return Dn(i5 = e4.label.toLowerCase()).call(i5, t4);
                  }));
                  return !s3 && i4.length && Dn(t3).call(t3, "back") && (s3 = i4[i4.length - 1]), s3 && (e3.video.deviceId = o3.exact ? { exact: s3.deviceId } : { ideal: s3.deviceId }), e3.video = n2(e3.video), Dm("chrome: " + JSON.stringify(e3)), r3(e3);
                });
            }
            e3.video = n2(e3.video);
          }
          return Dm("chrome: " + JSON.stringify(e3)), r3(e3);
        }, o2 = function(e3) {
          return t2.version >= 64 ? e3 : { name: { PermissionDeniedError: "NotAllowedError", PermissionDismissedError: "NotAllowedError", InvalidStateError: "NotAllowedError", DevicesNotFoundError: "NotFoundError", ConstraintNotSatisfiedError: "OverconstrainedError", TrackStartError: "NotReadableError", MediaDeviceFailedDueToShutdown: "NotAllowedError", MediaDeviceKillSwitchOn: "NotAllowedError", TabCaptureError: "AbortError", ScreenCaptureError: "AbortError", DeviceCaptureError: "AbortError" }[e3.name] || e3.name, message: e3.message, constraint: e3.constraint || e3.constraintName, toString() {
            return this.name + (this.message && ": ") + this.message;
          } };
        };
        if (i3.getUserMedia = (function(e3, t3, n3) {
          r2(e3, (e4) => {
            i3.webkitGetUserMedia(e4, t3, (e5) => {
              n3 && n3(o2(e5));
            });
          });
        }).bind(i3), i3.mediaDevices.getUserMedia) {
          const e3 = i3.mediaDevices.getUserMedia.bind(i3.mediaDevices);
          i3.mediaDevices.getUserMedia = function(t3) {
            return r2(t3, (t4) => e3(t4).then((e4) => {
              if (t4.audio && !e4.getAudioTracks().length || t4.video && !e4.getVideoTracks().length)
                throw e4.getTracks().forEach((e5) => {
                  e5.stop();
                }), new DOMException("", "NotFoundError");
              return e4;
            }, (e4) => Wh.reject(o2(e4))));
          };
        }
      }
      function Lm(e2) {
        e2.MediaStream = e2.MediaStream || e2.webkitMediaStream;
      }
      function km(e2) {
        if ("object" == typeof e2 && e2.RTCPeerConnection && !("ontrack" in e2.RTCPeerConnection.prototype)) {
          Object.defineProperty(e2.RTCPeerConnection.prototype, "ontrack", { get() {
            return this._ontrack;
          }, set(e3) {
            this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = e3);
          }, enumerable: true, configurable: true });
          const t2 = e2.RTCPeerConnection.prototype.setRemoteDescription;
          e2.RTCPeerConnection.prototype.setRemoteDescription = function() {
            return this._ontrackpoly || (this._ontrackpoly = (t3) => {
              t3.stream.addEventListener("addtrack", (i3) => {
                let n2;
                n2 = e2.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((e3) => e3.track && e3.track.id === i3.track.id) : { track: i3.track };
                const r2 = new Event("track");
                r2.track = i3.track, r2.receiver = n2, r2.transceiver = { receiver: n2 }, r2.streams = [t3.stream], this.dispatchEvent(r2);
              }), t3.stream.getTracks().forEach((i3) => {
                let n2;
                n2 = e2.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((e3) => e3.track && e3.track.id === i3.id) : { track: i3 };
                const r2 = new Event("track");
                r2.track = i3, r2.receiver = n2, r2.transceiver = { receiver: n2 }, r2.streams = [t3.stream], this.dispatchEvent(r2);
              });
            }, this.addEventListener("addstream", this._ontrackpoly)), t2.apply(this, arguments);
          };
        } else
          Cm(e2, "track", (e3) => (e3.transceiver || Object.defineProperty(e3, "transceiver", { value: { receiver: e3.receiver } }), e3));
      }
      function Mm(e2) {
        if ("object" == typeof e2 && e2.RTCPeerConnection && !("getSenders" in e2.RTCPeerConnection.prototype) && "createDTMFSender" in e2.RTCPeerConnection.prototype) {
          const t2 = function(e3, t3) {
            return { track: t3, get dtmf() {
              return void 0 === this._dtmf && ("audio" === t3.kind ? this._dtmf = e3.createDTMFSender(t3) : this._dtmf = null), this._dtmf;
            }, _pc: e3 };
          };
          if (!e2.RTCPeerConnection.prototype.getSenders) {
            e2.RTCPeerConnection.prototype.getSenders = function() {
              return this._senders = this._senders || [], this._senders.slice();
            };
            const i4 = e2.RTCPeerConnection.prototype.addTrack;
            e2.RTCPeerConnection.prototype.addTrack = function(e3, n4) {
              let r2 = i4.apply(this, arguments);
              return r2 || (r2 = t2(this, e3), this._senders.push(r2)), r2;
            };
            const n3 = e2.RTCPeerConnection.prototype.removeTrack;
            e2.RTCPeerConnection.prototype.removeTrack = function(e3) {
              n3.apply(this, arguments);
              const t3 = this._senders.indexOf(e3);
              -1 !== t3 && this._senders.splice(t3, 1);
            };
          }
          const i3 = e2.RTCPeerConnection.prototype.addStream;
          e2.RTCPeerConnection.prototype.addStream = function(e3) {
            this._senders = this._senders || [], i3.apply(this, [e3]), e3.getTracks().forEach((e4) => {
              this._senders.push(t2(this, e4));
            });
          };
          const n2 = e2.RTCPeerConnection.prototype.removeStream;
          e2.RTCPeerConnection.prototype.removeStream = function(e3) {
            this._senders = this._senders || [], n2.apply(this, [e3]), e3.getTracks().forEach((e4) => {
              const t3 = this._senders.find((t4) => t4.track === e4);
              t3 && this._senders.splice(this._senders.indexOf(t3), 1);
            });
          };
        } else if ("object" == typeof e2 && e2.RTCPeerConnection && "getSenders" in e2.RTCPeerConnection.prototype && "createDTMFSender" in e2.RTCPeerConnection.prototype && e2.RTCRtpSender && !("dtmf" in e2.RTCRtpSender.prototype)) {
          const t2 = e2.RTCPeerConnection.prototype.getSenders;
          e2.RTCPeerConnection.prototype.getSenders = function() {
            const e3 = t2.apply(this, []);
            return e3.forEach((e4) => e4._pc = this), e3;
          }, Object.defineProperty(e2.RTCRtpSender.prototype, "dtmf", { get() {
            return void 0 === this._dtmf && ("audio" === this.track.kind ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf;
          } });
        }
      }
      function Um(e2) {
        if (!e2.RTCPeerConnection)
          return;
        const t2 = e2.RTCPeerConnection.prototype.getStats;
        e2.RTCPeerConnection.prototype.getStats = function() {
          const [e3, i3, n2] = arguments;
          if (arguments.length > 0 && "function" == typeof e3)
            return t2.apply(this, arguments);
          if (0 === t2.length && (0 === arguments.length || "function" != typeof e3))
            return t2.apply(this, []);
          const r2 = function(e4) {
            const t3 = {};
            return e4.result().forEach((e5) => {
              const i4 = { id: e5.id, timestamp: e5.timestamp, type: { localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[e5.type] || e5.type };
              e5.names().forEach((t4) => {
                i4[t4] = e5.stat(t4);
              }), t3[i4.id] = i4;
            }), t3;
          }, o2 = function(e4) {
            return new Map(Object.keys(e4).map((t3) => [t3, e4[t3]]));
          };
          if (arguments.length >= 2) {
            const n3 = function(e4) {
              i3(o2(r2(e4)));
            };
            return t2.apply(this, [n3, e3]);
          }
          return new Wh((e4, i4) => {
            t2.apply(this, [function(t3) {
              e4(o2(r2(t3)));
            }, i4]);
          }).then(i3, n2);
        };
      }
      function xm(e2) {
        if (!("object" == typeof e2 && e2.RTCPeerConnection && e2.RTCRtpSender && e2.RTCRtpReceiver))
          return;
        if (!("getStats" in e2.RTCRtpSender.prototype)) {
          const t3 = e2.RTCPeerConnection.prototype.getSenders;
          t3 && (e2.RTCPeerConnection.prototype.getSenders = function() {
            const e3 = t3.apply(this, []);
            return e3.forEach((e4) => e4._pc = this), e3;
          });
          const i3 = e2.RTCPeerConnection.prototype.addTrack;
          i3 && (e2.RTCPeerConnection.prototype.addTrack = function() {
            const e3 = i3.apply(this, arguments);
            return e3._pc = this, e3;
          }), e2.RTCRtpSender.prototype.getStats = function() {
            const e3 = this;
            return this._pc.getStats().then((t4) => Nm(t4, e3.track, true));
          };
        }
        if (!("getStats" in e2.RTCRtpReceiver.prototype)) {
          const t3 = e2.RTCPeerConnection.prototype.getReceivers;
          t3 && (e2.RTCPeerConnection.prototype.getReceivers = function() {
            const e3 = t3.apply(this, []);
            return e3.forEach((e4) => e4._pc = this), e3;
          }), Cm(e2, "track", (e3) => (e3.receiver._pc = e3.srcElement, e3)), e2.RTCRtpReceiver.prototype.getStats = function() {
            const e3 = this;
            return this._pc.getStats().then((t4) => Nm(t4, e3.track, false));
          };
        }
        if (!("getStats" in e2.RTCRtpSender.prototype) || !("getStats" in e2.RTCRtpReceiver.prototype))
          return;
        const t2 = e2.RTCPeerConnection.prototype.getStats;
        e2.RTCPeerConnection.prototype.getStats = function() {
          if (arguments.length > 0 && arguments[0] instanceof e2.MediaStreamTrack) {
            const e3 = arguments[0];
            let t3, i3, n2;
            return this.getSenders().forEach((i4) => {
              i4.track === e3 && (t3 ? n2 = true : t3 = i4);
            }), this.getReceivers().forEach((t4) => (t4.track === e3 && (i3 ? n2 = true : i3 = t4), t4.track === e3)), n2 || t3 && i3 ? Wh.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : t3 ? t3.getStats() : i3 ? i3.getStats() : Wh.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"));
          }
          return t2.apply(this, arguments);
        };
      }
      function Vm(e2) {
        e2.RTCPeerConnection.prototype.getLocalStreams = function() {
          return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map((e3) => this._shimmedLocalStreams[e3][0]);
        };
        const t2 = e2.RTCPeerConnection.prototype.addTrack;
        e2.RTCPeerConnection.prototype.addTrack = function(e3, i4) {
          if (!i4)
            return t2.apply(this, arguments);
          this._shimmedLocalStreams = this._shimmedLocalStreams || {};
          const n3 = t2.apply(this, arguments);
          return this._shimmedLocalStreams[i4.id] ? -1 === this._shimmedLocalStreams[i4.id].indexOf(n3) && this._shimmedLocalStreams[i4.id].push(n3) : this._shimmedLocalStreams[i4.id] = [i4, n3], n3;
        };
        const i3 = e2.RTCPeerConnection.prototype.addStream;
        e2.RTCPeerConnection.prototype.addStream = function(e3) {
          this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e3.getTracks().forEach((e4) => {
            const t4 = this.getSenders().find((t5) => t5.track === e4);
            if (t4)
              throw new DOMException("Track already exists.", "InvalidAccessError");
          });
          const t3 = this.getSenders();
          i3.apply(this, arguments);
          const n3 = this.getSenders().filter((e4) => -1 === t3.indexOf(e4));
          this._shimmedLocalStreams[e3.id] = [e3].concat(n3);
        };
        const n2 = e2.RTCPeerConnection.prototype.removeStream;
        e2.RTCPeerConnection.prototype.removeStream = function(e3) {
          return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[e3.id], n2.apply(this, arguments);
        };
        const r2 = e2.RTCPeerConnection.prototype.removeTrack;
        e2.RTCPeerConnection.prototype.removeTrack = function(e3) {
          return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e3 && Object.keys(this._shimmedLocalStreams).forEach((t3) => {
            const i4 = this._shimmedLocalStreams[t3].indexOf(e3);
            -1 !== i4 && this._shimmedLocalStreams[t3].splice(i4, 1), 1 === this._shimmedLocalStreams[t3].length && delete this._shimmedLocalStreams[t3];
          }), r2.apply(this, arguments);
        };
      }
      function Fm(e2, t2) {
        if (!e2.RTCPeerConnection)
          return;
        if (e2.RTCPeerConnection.prototype.addTrack && t2.version >= 65)
          return Vm(e2);
        const i3 = e2.RTCPeerConnection.prototype.getLocalStreams;
        e2.RTCPeerConnection.prototype.getLocalStreams = function() {
          const e3 = i3.apply(this);
          return this._reverseStreams = this._reverseStreams || {}, e3.map((e4) => this._reverseStreams[e4.id]);
        };
        const n2 = e2.RTCPeerConnection.prototype.addStream;
        e2.RTCPeerConnection.prototype.addStream = function(t3) {
          if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, t3.getTracks().forEach((e3) => {
            const t4 = this.getSenders().find((t5) => t5.track === e3);
            if (t4)
              throw new DOMException("Track already exists.", "InvalidAccessError");
          }), !this._reverseStreams[t3.id]) {
            const i4 = new e2.MediaStream(t3.getTracks());
            this._streams[t3.id] = i4, this._reverseStreams[i4.id] = t3, t3 = i4;
          }
          n2.apply(this, [t3]);
        };
        const r2 = e2.RTCPeerConnection.prototype.removeStream;
        function o2(e3, t3) {
          let i4 = t3.sdp;
          return Object.keys(e3._reverseStreams || []).forEach((t4) => {
            const n3 = e3._reverseStreams[t4], r3 = e3._streams[n3.id];
            i4 = i4.replace(new RegExp(r3.id, "g"), n3.id);
          }), new RTCSessionDescription({ type: t3.type, sdp: i4 });
        }
        e2.RTCPeerConnection.prototype.removeStream = function(e3) {
          this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, r2.apply(this, [this._streams[e3.id] || e3]), delete this._reverseStreams[this._streams[e3.id] ? this._streams[e3.id].id : e3.id], delete this._streams[e3.id];
        }, e2.RTCPeerConnection.prototype.addTrack = function(t3, i4) {
          if ("closed" === this.signalingState)
            throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
          const n3 = [].slice.call(arguments, 1);
          if (1 !== n3.length || !n3[0].getTracks().find((e3) => e3 === t3))
            throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
          const r3 = this.getSenders().find((e3) => e3.track === t3);
          if (r3)
            throw new DOMException("Track already exists.", "InvalidAccessError");
          this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {};
          const o3 = this._streams[i4.id];
          if (o3)
            o3.addTrack(t3), Wh.resolve().then(() => {
              this.dispatchEvent(new Event("negotiationneeded"));
            });
          else {
            const n4 = new e2.MediaStream([t3]);
            this._streams[i4.id] = n4, this._reverseStreams[n4.id] = i4, this.addStream(n4);
          }
          return this.getSenders().find((e3) => e3.track === t3);
        }, ["createOffer", "createAnswer"].forEach(function(t3) {
          const i4 = e2.RTCPeerConnection.prototype[t3], n3 = { [t3]() {
            const e3 = arguments;
            return arguments.length && "function" == typeof arguments[0] ? i4.apply(this, [(t4) => {
              const i5 = o2(this, t4);
              e3[0].apply(null, [i5]);
            }, (t4) => {
              e3[1] && e3[1].apply(null, t4);
            }, arguments[2]]) : i4.apply(this, arguments).then((e4) => o2(this, e4));
          } };
          e2.RTCPeerConnection.prototype[t3] = n3[t3];
        });
        const s2 = e2.RTCPeerConnection.prototype.setLocalDescription;
        e2.RTCPeerConnection.prototype.setLocalDescription = function() {
          return arguments.length && arguments[0].type ? (arguments[0] = function(e3, t3) {
            let i4 = t3.sdp;
            return Object.keys(e3._reverseStreams || []).forEach((t4) => {
              const n3 = e3._reverseStreams[t4], r3 = e3._streams[n3.id];
              i4 = i4.replace(new RegExp(n3.id, "g"), r3.id);
            }), new RTCSessionDescription({ type: t3.type, sdp: i4 });
          }(this, arguments[0]), s2.apply(this, arguments)) : s2.apply(this, arguments);
        };
        const a2 = Object.getOwnPropertyDescriptor(e2.RTCPeerConnection.prototype, "localDescription");
        Object.defineProperty(e2.RTCPeerConnection.prototype, "localDescription", { get() {
          const e3 = a2.get.apply(this);
          return "" === e3.type ? e3 : o2(this, e3);
        } }), e2.RTCPeerConnection.prototype.removeTrack = function(e3) {
          if ("closed" === this.signalingState)
            throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
          if (!e3._pc)
            throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
          if (!(e3._pc === this))
            throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
          let t3;
          this._streams = this._streams || {}, Object.keys(this._streams).forEach((i4) => {
            this._streams[i4].getTracks().find((t4) => e3.track === t4) && (t3 = this._streams[i4]);
          }), t3 && (1 === t3.getTracks().length ? this.removeStream(this._reverseStreams[t3.id]) : t3.removeTrack(e3.track), this.dispatchEvent(new Event("negotiationneeded")));
        };
      }
      function Bm(e2, t2) {
        !e2.RTCPeerConnection && e2.webkitRTCPeerConnection && (e2.RTCPeerConnection = e2.webkitRTCPeerConnection), e2.RTCPeerConnection && t2.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(t3) {
          const i3 = e2.RTCPeerConnection.prototype[t3], n2 = { [t3]() {
            return arguments[0] = new ("addIceCandidate" === t3 ? e2.RTCIceCandidate : e2.RTCSessionDescription)(arguments[0]), i3.apply(this, arguments);
          } };
          e2.RTCPeerConnection.prototype[t3] = n2[t3];
        });
      }
      function jm(e2, t2) {
        Cm(e2, "negotiationneeded", (e3) => {
          const i3 = e3.target;
          if (!(t2.version < 72 || i3.getConfiguration && "plan-b" === i3.getConfiguration().sdpSemantics) || "stable" === i3.signalingState)
            return e3;
        });
      }
      var Gm = Object.freeze({ __proto__: null, fixNegotiationNeeded: jm, shimAddTrackRemoveTrack: Fm, shimAddTrackRemoveTrackWithNative: Vm, shimGetDisplayMedia: function(e2, t2) {
        e2.navigator.mediaDevices && "getDisplayMedia" in e2.navigator.mediaDevices || e2.navigator.mediaDevices && ("function" == typeof t2 ? e2.navigator.mediaDevices.getDisplayMedia = function(i3) {
          return t2(i3).then((t3) => {
            const n2 = i3.video && i3.video.width, r2 = i3.video && i3.video.height, o2 = i3.video && i3.video.frameRate;
            return i3.video = { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: t3, maxFrameRate: o2 || 3 } }, n2 && (i3.video.mandatory.maxWidth = n2), r2 && (i3.video.mandatory.maxHeight = r2), e2.navigator.mediaDevices.getUserMedia(i3);
          });
        } : console.error("shimGetDisplayMedia: getSourceId argument is not a function"));
      }, shimGetSendersWithDtmf: Mm, shimGetStats: Um, shimGetUserMedia: Pm, shimMediaStream: Lm, shimOnTrack: km, shimPeerConnection: Bm, shimSenderReceiverGetStats: xm });
      function Wm(e2, t2) {
        const i3 = e2 && e2.navigator, n2 = e2 && e2.MediaStreamTrack;
        if (i3.getUserMedia = function(e3, t3, n3) {
          Am("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), i3.mediaDevices.getUserMedia(e3).then(t3, n3);
        }, !(t2.version > 55 && "autoGainControl" in i3.mediaDevices.getSupportedConstraints())) {
          const e3 = function(e4, t4, i4) {
            t4 in e4 && !(i4 in e4) && (e4[i4] = e4[t4], delete e4[t4]);
          }, t3 = i3.mediaDevices.getUserMedia.bind(i3.mediaDevices);
          if (i3.mediaDevices.getUserMedia = function(i4) {
            return "object" == typeof i4 && "object" == typeof i4.audio && (i4 = JSON.parse(JSON.stringify(i4)), e3(i4.audio, "autoGainControl", "mozAutoGainControl"), e3(i4.audio, "noiseSuppression", "mozNoiseSuppression")), t3(i4);
          }, n2 && n2.prototype.getSettings) {
            const t4 = n2.prototype.getSettings;
            n2.prototype.getSettings = function() {
              const i4 = t4.apply(this, arguments);
              return e3(i4, "mozAutoGainControl", "autoGainControl"), e3(i4, "mozNoiseSuppression", "noiseSuppression"), i4;
            };
          }
          if (n2 && n2.prototype.applyConstraints) {
            const t4 = n2.prototype.applyConstraints;
            n2.prototype.applyConstraints = function(i4) {
              return "audio" === this.kind && "object" == typeof i4 && (i4 = JSON.parse(JSON.stringify(i4)), e3(i4, "autoGainControl", "mozAutoGainControl"), e3(i4, "noiseSuppression", "mozNoiseSuppression")), t4.apply(this, [i4]);
            };
          }
        }
      }
      function Hm(e2) {
        "object" == typeof e2 && e2.RTCTrackEvent && "receiver" in e2.RTCTrackEvent.prototype && !("transceiver" in e2.RTCTrackEvent.prototype) && Object.defineProperty(e2.RTCTrackEvent.prototype, "transceiver", { get() {
          return { receiver: this.receiver };
        } });
      }
      function Km(e2, t2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection && !e2.mozRTCPeerConnection)
          return;
        !e2.RTCPeerConnection && e2.mozRTCPeerConnection && (e2.RTCPeerConnection = e2.mozRTCPeerConnection), t2.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(t3) {
          const i4 = e2.RTCPeerConnection.prototype[t3], n3 = { [t3]() {
            return arguments[0] = new ("addIceCandidate" === t3 ? e2.RTCIceCandidate : e2.RTCSessionDescription)(arguments[0]), i4.apply(this, arguments);
          } };
          e2.RTCPeerConnection.prototype[t3] = n3[t3];
        });
        const i3 = { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }, n2 = e2.RTCPeerConnection.prototype.getStats;
        e2.RTCPeerConnection.prototype.getStats = function() {
          const [e3, r2, o2] = arguments;
          return n2.apply(this, [e3 || null]).then((e4) => {
            if (t2.version < 53 && !r2)
              try {
                e4.forEach((e5) => {
                  e5.type = i3[e5.type] || e5.type;
                });
              } catch (t3) {
                if ("TypeError" !== t3.name)
                  throw t3;
                e4.forEach((t4, n3) => {
                  e4.set(n3, Object.assign({}, t4, { type: i3[t4.type] || t4.type }));
                });
              }
            return e4;
          }).then(r2, o2);
        };
      }
      function Ym(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection || !e2.RTCRtpSender)
          return;
        if (e2.RTCRtpSender && "getStats" in e2.RTCRtpSender.prototype)
          return;
        const t2 = e2.RTCPeerConnection.prototype.getSenders;
        t2 && (e2.RTCPeerConnection.prototype.getSenders = function() {
          const e3 = t2.apply(this, []);
          return e3.forEach((e4) => e4._pc = this), e3;
        });
        const i3 = e2.RTCPeerConnection.prototype.addTrack;
        i3 && (e2.RTCPeerConnection.prototype.addTrack = function() {
          const e3 = i3.apply(this, arguments);
          return e3._pc = this, e3;
        }), e2.RTCRtpSender.prototype.getStats = function() {
          return this.track ? this._pc.getStats(this.track) : Wh.resolve(/* @__PURE__ */ new Map());
        };
      }
      function qm(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection || !e2.RTCRtpSender)
          return;
        if (e2.RTCRtpSender && "getStats" in e2.RTCRtpReceiver.prototype)
          return;
        const t2 = e2.RTCPeerConnection.prototype.getReceivers;
        t2 && (e2.RTCPeerConnection.prototype.getReceivers = function() {
          const e3 = t2.apply(this, []);
          return e3.forEach((e4) => e4._pc = this), e3;
        }), Cm(e2, "track", (e3) => (e3.receiver._pc = e3.srcElement, e3)), e2.RTCRtpReceiver.prototype.getStats = function() {
          return this._pc.getStats(this.track);
        };
      }
      function zm(e2) {
        e2.RTCPeerConnection && !("removeStream" in e2.RTCPeerConnection.prototype) && (e2.RTCPeerConnection.prototype.removeStream = function(e3) {
          Am("removeStream", "removeTrack"), this.getSenders().forEach((t2) => {
            var i3;
            t2.track && Dn(i3 = e3.getTracks()).call(i3, t2.track) && this.removeTrack(t2);
          });
        });
      }
      function Xm(e2) {
        e2.DataChannel && !e2.RTCDataChannel && (e2.RTCDataChannel = e2.DataChannel);
      }
      function Jm(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection)
          return;
        const t2 = e2.RTCPeerConnection.prototype.addTransceiver;
        t2 && (e2.RTCPeerConnection.prototype.addTransceiver = function() {
          this.setParametersPromises = [];
          let e3 = arguments[1] && arguments[1].sendEncodings;
          void 0 === e3 && (e3 = []), e3 = [...e3];
          const i3 = e3.length > 0;
          i3 && e3.forEach((e4) => {
            if ("rid" in e4) {
              if (!/^[a-z0-9]{0,16}$/i.test(e4.rid))
                throw new TypeError("Invalid RID value provided.");
            }
            if ("scaleResolutionDownBy" in e4 && !(parseFloat(e4.scaleResolutionDownBy) >= 1))
              throw new RangeError("scale_resolution_down_by must be >= 1.0");
            if ("maxFramerate" in e4 && !(parseFloat(e4.maxFramerate) >= 0))
              throw new RangeError("max_framerate must be >= 0.0");
          });
          const n2 = t2.apply(this, arguments);
          if (i3) {
            const { sender: t3 } = n2, i4 = t3.getParameters();
            (!("encodings" in i4) || 1 === i4.encodings.length && 0 === Object.keys(i4.encodings[0]).length) && (i4.encodings = e3, t3.sendEncodings = e3, this.setParametersPromises.push(t3.setParameters(i4).then(() => {
              delete t3.sendEncodings;
            }).catch(() => {
              delete t3.sendEncodings;
            })));
          }
          return n2;
        });
      }
      function Qm(e2) {
        if ("object" != typeof e2 || !e2.RTCRtpSender)
          return;
        const t2 = e2.RTCRtpSender.prototype.getParameters;
        t2 && (e2.RTCRtpSender.prototype.getParameters = function() {
          const e3 = t2.apply(this, arguments);
          return "encodings" in e3 || (e3.encodings = [].concat(this.sendEncodings || [{}])), e3;
        });
      }
      function Zm(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection)
          return;
        const t2 = e2.RTCPeerConnection.prototype.createOffer;
        e2.RTCPeerConnection.prototype.createOffer = function() {
          return this.setParametersPromises && this.setParametersPromises.length ? Wh.all(this.setParametersPromises).then(() => t2.apply(this, arguments)).finally(() => {
            this.setParametersPromises = [];
          }) : t2.apply(this, arguments);
        };
      }
      function $m(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection)
          return;
        const t2 = e2.RTCPeerConnection.prototype.createAnswer;
        e2.RTCPeerConnection.prototype.createAnswer = function() {
          return this.setParametersPromises && this.setParametersPromises.length ? Wh.all(this.setParametersPromises).then(() => t2.apply(this, arguments)).finally(() => {
            this.setParametersPromises = [];
          }) : t2.apply(this, arguments);
        };
      }
      var eT = Object.freeze({ __proto__: null, shimAddTransceiver: Jm, shimCreateAnswer: $m, shimCreateOffer: Zm, shimGetDisplayMedia: function(e2, t2) {
        e2.navigator.mediaDevices && "getDisplayMedia" in e2.navigator.mediaDevices || e2.navigator.mediaDevices && (e2.navigator.mediaDevices.getDisplayMedia = function(i3) {
          if (!i3 || !i3.video) {
            const e3 = new DOMException("getDisplayMedia without video constraints is undefined");
            return e3.name = "NotFoundError", e3.code = 8, Wh.reject(e3);
          }
          return true === i3.video ? i3.video = { mediaSource: t2 } : i3.video.mediaSource = t2, e2.navigator.mediaDevices.getUserMedia(i3);
        });
      }, shimGetParameters: Qm, shimGetUserMedia: Wm, shimOnTrack: Hm, shimPeerConnection: Km, shimRTCDataChannel: Xm, shimReceiverGetStats: qm, shimRemoveStream: zm, shimSenderGetStats: Ym });
      function tT(e2) {
        if ("object" == typeof e2 && e2.RTCPeerConnection) {
          if ("getLocalStreams" in e2.RTCPeerConnection.prototype || (e2.RTCPeerConnection.prototype.getLocalStreams = function() {
            return this._localStreams || (this._localStreams = []), this._localStreams;
          }), !("addStream" in e2.RTCPeerConnection.prototype)) {
            const t2 = e2.RTCPeerConnection.prototype.addTrack;
            e2.RTCPeerConnection.prototype.addStream = function(e3) {
              var i3;
              this._localStreams || (this._localStreams = []), Dn(i3 = this._localStreams).call(i3, e3) || this._localStreams.push(e3), e3.getAudioTracks().forEach((i4) => t2.call(this, i4, e3)), e3.getVideoTracks().forEach((i4) => t2.call(this, i4, e3));
            }, e2.RTCPeerConnection.prototype.addTrack = function(e3) {
              for (var i3 = arguments.length, n2 = new Array(i3 > 1 ? i3 - 1 : 0), r2 = 1; r2 < i3; r2++)
                n2[r2 - 1] = arguments[r2];
              return n2 && n2.forEach((e4) => {
                var t3;
                this._localStreams ? Dn(t3 = this._localStreams).call(t3, e4) || this._localStreams.push(e4) : this._localStreams = [e4];
              }), t2.apply(this, arguments);
            };
          }
          "removeStream" in e2.RTCPeerConnection.prototype || (e2.RTCPeerConnection.prototype.removeStream = function(e3) {
            this._localStreams || (this._localStreams = []);
            const t2 = this._localStreams.indexOf(e3);
            if (-1 === t2)
              return;
            this._localStreams.splice(t2, 1);
            const i3 = e3.getTracks();
            this.getSenders().forEach((e4) => {
              Dn(i3).call(i3, e4.track) && this.removeTrack(e4);
            });
          });
        }
      }
      function iT(e2) {
        if ("object" == typeof e2 && e2.RTCPeerConnection && ("getRemoteStreams" in e2.RTCPeerConnection.prototype || (e2.RTCPeerConnection.prototype.getRemoteStreams = function() {
          return this._remoteStreams ? this._remoteStreams : [];
        }), !("onaddstream" in e2.RTCPeerConnection.prototype))) {
          Object.defineProperty(e2.RTCPeerConnection.prototype, "onaddstream", { get() {
            return this._onaddstream;
          }, set(e3) {
            this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = e3), this.addEventListener("track", this._onaddstreampoly = (e4) => {
              e4.streams.forEach((e5) => {
                var t3;
                if (this._remoteStreams || (this._remoteStreams = []), Dn(t3 = this._remoteStreams).call(t3, e5))
                  return;
                this._remoteStreams.push(e5);
                const i3 = new Event("addstream");
                i3.stream = e5, this.dispatchEvent(i3);
              });
            });
          } });
          const t2 = e2.RTCPeerConnection.prototype.setRemoteDescription;
          e2.RTCPeerConnection.prototype.setRemoteDescription = function() {
            const e3 = this;
            return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function(t3) {
              t3.streams.forEach((t4) => {
                if (e3._remoteStreams || (e3._remoteStreams = []), e3._remoteStreams.indexOf(t4) >= 0)
                  return;
                e3._remoteStreams.push(t4);
                const i3 = new Event("addstream");
                i3.stream = t4, e3.dispatchEvent(i3);
              });
            }), t2.apply(e3, arguments);
          };
        }
      }
      function nT(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection)
          return;
        const t2 = e2.RTCPeerConnection.prototype, i3 = t2.createOffer, n2 = t2.createAnswer, r2 = t2.setLocalDescription, o2 = t2.setRemoteDescription, s2 = t2.addIceCandidate;
        t2.createOffer = function(e3, t3) {
          const n3 = arguments.length >= 2 ? arguments[2] : arguments[0], r3 = i3.apply(this, [n3]);
          return t3 ? (r3.then(e3, t3), Wh.resolve()) : r3;
        }, t2.createAnswer = function(e3, t3) {
          const i4 = arguments.length >= 2 ? arguments[2] : arguments[0], r3 = n2.apply(this, [i4]);
          return t3 ? (r3.then(e3, t3), Wh.resolve()) : r3;
        };
        let a2 = function(e3, t3, i4) {
          const n3 = r2.apply(this, [e3]);
          return i4 ? (n3.then(t3, i4), Wh.resolve()) : n3;
        };
        t2.setLocalDescription = a2, a2 = function(e3, t3, i4) {
          const n3 = o2.apply(this, [e3]);
          return i4 ? (n3.then(t3, i4), Wh.resolve()) : n3;
        }, t2.setRemoteDescription = a2, a2 = function(e3, t3, i4) {
          const n3 = s2.apply(this, [e3]);
          return i4 ? (n3.then(t3, i4), Wh.resolve()) : n3;
        }, t2.addIceCandidate = a2;
      }
      function rT(e2) {
        const t2 = e2 && e2.navigator;
        if (t2.mediaDevices && t2.mediaDevices.getUserMedia) {
          const e3 = t2.mediaDevices, i3 = e3.getUserMedia.bind(e3);
          t2.mediaDevices.getUserMedia = (e4) => i3(oT(e4));
        }
        !t2.getUserMedia && t2.mediaDevices && t2.mediaDevices.getUserMedia && (t2.getUserMedia = (function(e3, i3, n2) {
          t2.mediaDevices.getUserMedia(e3).then(i3, n2);
        }).bind(t2));
      }
      function oT(e2) {
        return e2 && void 0 !== e2.video ? Object.assign({}, e2, { video: wm(e2.video) }) : e2;
      }
      function sT(e2) {
        if (!e2.RTCPeerConnection)
          return;
        const t2 = e2.RTCPeerConnection;
        e2.RTCPeerConnection = function(e3, i3) {
          if (e3 && e3.iceServers) {
            const t3 = [];
            for (let i4 = 0; i4 < e3.iceServers.length; i4++) {
              let n2 = e3.iceServers[i4];
              !n2.hasOwnProperty("urls") && n2.hasOwnProperty("url") ? (Am("RTCIceServer.url", "RTCIceServer.urls"), n2 = JSON.parse(JSON.stringify(n2)), n2.urls = n2.url, delete n2.url, t3.push(n2)) : t3.push(e3.iceServers[i4]);
            }
            e3.iceServers = t3;
          }
          return new t2(e3, i3);
        }, e2.RTCPeerConnection.prototype = t2.prototype, "generateCertificate" in t2 && Object.defineProperty(e2.RTCPeerConnection, "generateCertificate", { get: () => t2.generateCertificate });
      }
      function aT(e2) {
        "object" == typeof e2 && e2.RTCTrackEvent && "receiver" in e2.RTCTrackEvent.prototype && !("transceiver" in e2.RTCTrackEvent.prototype) && Object.defineProperty(e2.RTCTrackEvent.prototype, "transceiver", { get() {
          return { receiver: this.receiver };
        } });
      }
      function cT(e2) {
        const t2 = e2.RTCPeerConnection.prototype.createOffer;
        e2.RTCPeerConnection.prototype.createOffer = function(e3) {
          if (e3) {
            void 0 !== e3.offerToReceiveAudio && (e3.offerToReceiveAudio = !!e3.offerToReceiveAudio);
            const t3 = this.getTransceivers().find((e4) => "audio" === e4.receiver.track.kind);
            false === e3.offerToReceiveAudio && t3 ? "sendrecv" === t3.direction ? t3.setDirection ? t3.setDirection("sendonly") : t3.direction = "sendonly" : "recvonly" === t3.direction && (t3.setDirection ? t3.setDirection("inactive") : t3.direction = "inactive") : true !== e3.offerToReceiveAudio || t3 || this.addTransceiver("audio", { direction: "recvonly" }), void 0 !== e3.offerToReceiveVideo && (e3.offerToReceiveVideo = !!e3.offerToReceiveVideo);
            const i3 = this.getTransceivers().find((e4) => "video" === e4.receiver.track.kind);
            false === e3.offerToReceiveVideo && i3 ? "sendrecv" === i3.direction ? i3.setDirection ? i3.setDirection("sendonly") : i3.direction = "sendonly" : "recvonly" === i3.direction && (i3.setDirection ? i3.setDirection("inactive") : i3.direction = "inactive") : true !== e3.offerToReceiveVideo || i3 || this.addTransceiver("video", { direction: "recvonly" });
          }
          return t2.apply(this, arguments);
        };
      }
      function dT(e2) {
        "object" != typeof e2 || e2.AudioContext || (e2.AudioContext = e2.webkitAudioContext);
      }
      var lT = Object.freeze({ __proto__: null, shimAudioContext: dT, shimCallbacksAPI: nT, shimConstraints: oT, shimCreateOfferLegacy: cT, shimGetUserMedia: rT, shimLocalStreamsAPI: tT, shimRTCIceServerUrls: sT, shimRemoteStreamsAPI: iT, shimTrackEventTransceiver: aT }), uT = "	\n\v\f\r Â áââââââââââââ¯âã\u2028\u2029\uFEFF", hT = X, pT = fn, _T = uT, ET = d("".replace), fT = RegExp("^[" + _T + "]+"), mT = RegExp("(^|[^" + _T + "])[" + _T + "]+$"), TT = function(e2) {
        return function(t2) {
          var i3 = pT(hT(t2));
          return 1 & e2 && (i3 = ET(i3, fT, "")), 2 & e2 && (i3 = ET(i3, mT, "$1")), i3;
        };
      }, ST = { start: TT(1), end: TT(2), trim: TT(3) }, gT = ua.PROPER, RT = n, CT = uT, vT = ST.trim;
      wi({ target: "String", proto: true, forced: function(e2) {
        return RT(function() {
          return !!CT[e2]() || "âÂá " !== "âÂá "[e2]() || gT && CT[e2].name !== e2;
        });
      }("trim") }, { trim: function() {
        return vT(this);
      } });
      var IT = Ji("String").trim, yT = l, AT = IT, bT = String.prototype, wT = function(e2) {
        var t2 = e2.trim;
        return "string" == typeof e2 || e2 === bT || yT(bT, e2) && t2 === bT.trim ? AT : t2;
      }, OT = i2(wT), NT = { exports: {} };
      !function(e2) {
        const t2 = { generateIdentifier: function() {
          return Math.random().toString(36).substring(2, 12);
        } };
        t2.localCName = t2.generateIdentifier(), t2.splitLines = function(e3) {
          return e3.trim().split("\n").map((e4) => e4.trim());
        }, t2.splitSections = function(e3) {
          return e3.split("\nm=").map((e4, t3) => (t3 > 0 ? "m=" + e4 : e4).trim() + "\r\n");
        }, t2.getDescription = function(e3) {
          const i3 = t2.splitSections(e3);
          return i3 && i3[0];
        }, t2.getMediaSections = function(e3) {
          const i3 = t2.splitSections(e3);
          return i3.shift(), i3;
        }, t2.matchPrefix = function(e3, i3) {
          return t2.splitLines(e3).filter((e4) => 0 === e4.indexOf(i3));
        }, t2.parseCandidate = function(e3) {
          let t3;
          t3 = 0 === e3.indexOf("a=candidate:") ? e3.substring(12).split(" ") : e3.substring(10).split(" ");
          const i3 = { foundation: t3[0], component: { 1: "rtp", 2: "rtcp" }[t3[1]] || t3[1], protocol: t3[2].toLowerCase(), priority: parseInt(t3[3], 10), ip: t3[4], address: t3[4], port: parseInt(t3[5], 10), type: t3[7] };
          for (let e4 = 8; e4 < t3.length; e4 += 2)
            switch (t3[e4]) {
              case "raddr":
                i3.relatedAddress = t3[e4 + 1];
                break;
              case "rport":
                i3.relatedPort = parseInt(t3[e4 + 1], 10);
                break;
              case "tcptype":
                i3.tcpType = t3[e4 + 1];
                break;
              case "ufrag":
                i3.ufrag = t3[e4 + 1], i3.usernameFragment = t3[e4 + 1];
                break;
              default:
                void 0 === i3[t3[e4]] && (i3[t3[e4]] = t3[e4 + 1]);
            }
          return i3;
        }, t2.writeCandidate = function(e3) {
          const t3 = [];
          t3.push(e3.foundation);
          const i3 = e3.component;
          "rtp" === i3 ? t3.push(1) : "rtcp" === i3 ? t3.push(2) : t3.push(i3), t3.push(e3.protocol.toUpperCase()), t3.push(e3.priority), t3.push(e3.address || e3.ip), t3.push(e3.port);
          const n2 = e3.type;
          return t3.push("typ"), t3.push(n2), "host" !== n2 && e3.relatedAddress && e3.relatedPort && (t3.push("raddr"), t3.push(e3.relatedAddress), t3.push("rport"), t3.push(e3.relatedPort)), e3.tcpType && "tcp" === e3.protocol.toLowerCase() && (t3.push("tcptype"), t3.push(e3.tcpType)), (e3.usernameFragment || e3.ufrag) && (t3.push("ufrag"), t3.push(e3.usernameFragment || e3.ufrag)), "candidate:" + t3.join(" ");
        }, t2.parseIceOptions = function(e3) {
          return e3.substring(14).split(" ");
        }, t2.parseRtpMap = function(e3) {
          let t3 = e3.substring(9).split(" ");
          const i3 = { payloadType: parseInt(t3.shift(), 10) };
          return t3 = t3[0].split("/"), i3.name = t3[0], i3.clockRate = parseInt(t3[1], 10), i3.channels = 3 === t3.length ? parseInt(t3[2], 10) : 1, i3.numChannels = i3.channels, i3;
        }, t2.writeRtpMap = function(e3) {
          let t3 = e3.payloadType;
          void 0 !== e3.preferredPayloadType && (t3 = e3.preferredPayloadType);
          const i3 = e3.channels || e3.numChannels || 1;
          return "a=rtpmap:" + t3 + " " + e3.name + "/" + e3.clockRate + (1 !== i3 ? "/" + i3 : "") + "\r\n";
        }, t2.parseExtmap = function(e3) {
          const t3 = e3.substring(9).split(" ");
          return { id: parseInt(t3[0], 10), direction: t3[0].indexOf("/") > 0 ? t3[0].split("/")[1] : "sendrecv", uri: t3[1], attributes: t3.slice(2).join(" ") };
        }, t2.writeExtmap = function(e3) {
          return "a=extmap:" + (e3.id || e3.preferredId) + (e3.direction && "sendrecv" !== e3.direction ? "/" + e3.direction : "") + " " + e3.uri + (e3.attributes ? " " + e3.attributes : "") + "\r\n";
        }, t2.parseFmtp = function(e3) {
          const t3 = {};
          let i3;
          const n2 = e3.substring(e3.indexOf(" ") + 1).split(";");
          for (let e4 = 0; e4 < n2.length; e4++)
            i3 = n2[e4].trim().split("="), t3[i3[0].trim()] = i3[1];
          return t3;
        }, t2.writeFmtp = function(e3) {
          let t3 = "", i3 = e3.payloadType;
          if (void 0 !== e3.preferredPayloadType && (i3 = e3.preferredPayloadType), e3.parameters && Object.keys(e3.parameters).length) {
            const n2 = [];
            Object.keys(e3.parameters).forEach((t4) => {
              void 0 !== e3.parameters[t4] ? n2.push(t4 + "=" + e3.parameters[t4]) : n2.push(t4);
            }), t3 += "a=fmtp:" + i3 + " " + n2.join(";") + "\r\n";
          }
          return t3;
        }, t2.parseRtcpFb = function(e3) {
          const t3 = e3.substring(e3.indexOf(" ") + 1).split(" ");
          return { type: t3.shift(), parameter: t3.join(" ") };
        }, t2.writeRtcpFb = function(e3) {
          let t3 = "", i3 = e3.payloadType;
          return void 0 !== e3.preferredPayloadType && (i3 = e3.preferredPayloadType), e3.rtcpFeedback && e3.rtcpFeedback.length && e3.rtcpFeedback.forEach((e4) => {
            t3 += "a=rtcp-fb:" + i3 + " " + e4.type + (e4.parameter && e4.parameter.length ? " " + e4.parameter : "") + "\r\n";
          }), t3;
        }, t2.parseSsrcMedia = function(e3) {
          const t3 = e3.indexOf(" "), i3 = { ssrc: parseInt(e3.substring(7, t3), 10) }, n2 = e3.indexOf(":", t3);
          return n2 > -1 ? (i3.attribute = e3.substring(t3 + 1, n2), i3.value = e3.substring(n2 + 1)) : i3.attribute = e3.substring(t3 + 1), i3;
        }, t2.parseSsrcGroup = function(e3) {
          const t3 = e3.substring(13).split(" ");
          return { semantics: t3.shift(), ssrcs: t3.map((e4) => parseInt(e4, 10)) };
        }, t2.getMid = function(e3) {
          const i3 = t2.matchPrefix(e3, "a=mid:")[0];
          if (i3)
            return i3.substring(6);
        }, t2.parseFingerprint = function(e3) {
          const t3 = e3.substring(14).split(" ");
          return { algorithm: t3[0].toLowerCase(), value: t3[1].toUpperCase() };
        }, t2.getDtlsParameters = function(e3, i3) {
          return { role: "auto", fingerprints: t2.matchPrefix(e3 + i3, "a=fingerprint:").map(t2.parseFingerprint) };
        }, t2.writeDtlsParameters = function(e3, t3) {
          let i3 = "a=setup:" + t3 + "\r\n";
          return e3.fingerprints.forEach((e4) => {
            i3 += "a=fingerprint:" + e4.algorithm + " " + e4.value + "\r\n";
          }), i3;
        }, t2.parseCryptoLine = function(e3) {
          const t3 = e3.substring(9).split(" ");
          return { tag: parseInt(t3[0], 10), cryptoSuite: t3[1], keyParams: t3[2], sessionParams: t3.slice(3) };
        }, t2.writeCryptoLine = function(e3) {
          return "a=crypto:" + e3.tag + " " + e3.cryptoSuite + " " + ("object" == typeof e3.keyParams ? t2.writeCryptoKeyParams(e3.keyParams) : e3.keyParams) + (e3.sessionParams ? " " + e3.sessionParams.join(" ") : "") + "\r\n";
        }, t2.parseCryptoKeyParams = function(e3) {
          if (0 !== e3.indexOf("inline:"))
            return null;
          const t3 = e3.substring(7).split("|");
          return { keyMethod: "inline", keySalt: t3[0], lifeTime: t3[1], mkiValue: t3[2] ? t3[2].split(":")[0] : void 0, mkiLength: t3[2] ? t3[2].split(":")[1] : void 0 };
        }, t2.writeCryptoKeyParams = function(e3) {
          return e3.keyMethod + ":" + e3.keySalt + (e3.lifeTime ? "|" + e3.lifeTime : "") + (e3.mkiValue && e3.mkiLength ? "|" + e3.mkiValue + ":" + e3.mkiLength : "");
        }, t2.getCryptoParameters = function(e3, i3) {
          return t2.matchPrefix(e3 + i3, "a=crypto:").map(t2.parseCryptoLine);
        }, t2.getIceParameters = function(e3, i3) {
          const n2 = t2.matchPrefix(e3 + i3, "a=ice-ufrag:")[0], r2 = t2.matchPrefix(e3 + i3, "a=ice-pwd:")[0];
          return n2 && r2 ? { usernameFragment: n2.substring(12), password: r2.substring(10) } : null;
        }, t2.writeIceParameters = function(e3) {
          let t3 = "a=ice-ufrag:" + e3.usernameFragment + "\r\na=ice-pwd:" + e3.password + "\r\n";
          return e3.iceLite && (t3 += "a=ice-lite\r\n"), t3;
        }, t2.parseRtpParameters = function(e3) {
          const i3 = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }, n2 = t2.splitLines(e3)[0].split(" ");
          i3.profile = n2[2];
          for (let r3 = 3; r3 < n2.length; r3++) {
            const o2 = n2[r3], s2 = t2.matchPrefix(e3, "a=rtpmap:" + o2 + " ")[0];
            if (s2) {
              const n3 = t2.parseRtpMap(s2), r4 = t2.matchPrefix(e3, "a=fmtp:" + o2 + " ");
              switch (n3.parameters = r4.length ? t2.parseFmtp(r4[0]) : {}, n3.rtcpFeedback = t2.matchPrefix(e3, "a=rtcp-fb:" + o2 + " ").map(t2.parseRtcpFb), i3.codecs.push(n3), n3.name.toUpperCase()) {
                case "RED":
                case "ULPFEC":
                  i3.fecMechanisms.push(n3.name.toUpperCase());
              }
            }
          }
          t2.matchPrefix(e3, "a=extmap:").forEach((e4) => {
            i3.headerExtensions.push(t2.parseExtmap(e4));
          });
          const r2 = t2.matchPrefix(e3, "a=rtcp-fb:* ").map(t2.parseRtcpFb);
          return i3.codecs.forEach((e4) => {
            r2.forEach((t3) => {
              e4.rtcpFeedback.find((e5) => e5.type === t3.type && e5.parameter === t3.parameter) || e4.rtcpFeedback.push(t3);
            });
          }), i3;
        }, t2.writeRtpDescription = function(e3, i3) {
          let n2 = "";
          n2 += "m=" + e3 + " ", n2 += i3.codecs.length > 0 ? "9" : "0", n2 += " " + (i3.profile || "UDP/TLS/RTP/SAVPF") + " ", n2 += i3.codecs.map((e4) => void 0 !== e4.preferredPayloadType ? e4.preferredPayloadType : e4.payloadType).join(" ") + "\r\n", n2 += "c=IN IP4 0.0.0.0\r\n", n2 += "a=rtcp:9 IN IP4 0.0.0.0\r\n", i3.codecs.forEach((e4) => {
            n2 += t2.writeRtpMap(e4), n2 += t2.writeFmtp(e4), n2 += t2.writeRtcpFb(e4);
          });
          let r2 = 0;
          return i3.codecs.forEach((e4) => {
            e4.maxptime > r2 && (r2 = e4.maxptime);
          }), r2 > 0 && (n2 += "a=maxptime:" + r2 + "\r\n"), i3.headerExtensions && i3.headerExtensions.forEach((e4) => {
            n2 += t2.writeExtmap(e4);
          }), n2;
        }, t2.parseRtpEncodingParameters = function(e3) {
          const i3 = [], n2 = t2.parseRtpParameters(e3), r2 = -1 !== n2.fecMechanisms.indexOf("RED"), o2 = -1 !== n2.fecMechanisms.indexOf("ULPFEC"), s2 = t2.matchPrefix(e3, "a=ssrc:").map((e4) => t2.parseSsrcMedia(e4)).filter((e4) => "cname" === e4.attribute), a2 = s2.length > 0 && s2[0].ssrc;
          let c2;
          const d2 = t2.matchPrefix(e3, "a=ssrc-group:FID").map((e4) => e4.substring(17).split(" ").map((e5) => parseInt(e5, 10)));
          d2.length > 0 && d2[0].length > 1 && d2[0][0] === a2 && (c2 = d2[0][1]), n2.codecs.forEach((e4) => {
            if ("RTX" === e4.name.toUpperCase() && e4.parameters.apt) {
              let t3 = { ssrc: a2, codecPayloadType: parseInt(e4.parameters.apt, 10) };
              a2 && c2 && (t3.rtx = { ssrc: c2 }), i3.push(t3), r2 && (t3 = JSON.parse(JSON.stringify(t3)), t3.fec = { ssrc: a2, mechanism: o2 ? "red+ulpfec" : "red" }, i3.push(t3));
            }
          }), 0 === i3.length && a2 && i3.push({ ssrc: a2 });
          let l2 = t2.matchPrefix(e3, "b=");
          return l2.length && (l2 = 0 === l2[0].indexOf("b=TIAS:") ? parseInt(l2[0].substring(7), 10) : 0 === l2[0].indexOf("b=AS:") ? 1e3 * parseInt(l2[0].substring(5), 10) * 0.95 - 16e3 : void 0, i3.forEach((e4) => {
            e4.maxBitrate = l2;
          })), i3;
        }, t2.parseRtcpParameters = function(e3) {
          const i3 = {}, n2 = t2.matchPrefix(e3, "a=ssrc:").map((e4) => t2.parseSsrcMedia(e4)).filter((e4) => "cname" === e4.attribute)[0];
          n2 && (i3.cname = n2.value, i3.ssrc = n2.ssrc);
          const r2 = t2.matchPrefix(e3, "a=rtcp-rsize");
          i3.reducedSize = r2.length > 0, i3.compound = 0 === r2.length;
          const o2 = t2.matchPrefix(e3, "a=rtcp-mux");
          return i3.mux = o2.length > 0, i3;
        }, t2.writeRtcpParameters = function(e3) {
          let t3 = "";
          return e3.reducedSize && (t3 += "a=rtcp-rsize\r\n"), e3.mux && (t3 += "a=rtcp-mux\r\n"), void 0 !== e3.ssrc && e3.cname && (t3 += "a=ssrc:" + e3.ssrc + " cname:" + e3.cname + "\r\n"), t3;
        }, t2.parseMsid = function(e3) {
          let i3;
          const n2 = t2.matchPrefix(e3, "a=msid:");
          if (1 === n2.length)
            return i3 = n2[0].substring(7).split(" "), { stream: i3[0], track: i3[1] };
          const r2 = t2.matchPrefix(e3, "a=ssrc:").map((e4) => t2.parseSsrcMedia(e4)).filter((e4) => "msid" === e4.attribute);
          return r2.length > 0 ? (i3 = r2[0].value.split(" "), { stream: i3[0], track: i3[1] }) : void 0;
        }, t2.parseSctpDescription = function(e3) {
          const i3 = t2.parseMLine(e3), n2 = t2.matchPrefix(e3, "a=max-message-size:");
          let r2;
          n2.length > 0 && (r2 = parseInt(n2[0].substring(19), 10)), isNaN(r2) && (r2 = 65536);
          const o2 = t2.matchPrefix(e3, "a=sctp-port:");
          if (o2.length > 0)
            return { port: parseInt(o2[0].substring(12), 10), protocol: i3.fmt, maxMessageSize: r2 };
          const s2 = t2.matchPrefix(e3, "a=sctpmap:");
          if (s2.length > 0) {
            const e4 = s2[0].substring(10).split(" ");
            return { port: parseInt(e4[0], 10), protocol: e4[1], maxMessageSize: r2 };
          }
        }, t2.writeSctpDescription = function(e3, t3) {
          let i3 = [];
          return i3 = "DTLS/SCTP" !== e3.protocol ? ["m=" + e3.kind + " 9 " + e3.protocol + " " + t3.protocol + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctp-port:" + t3.port + "\r\n"] : ["m=" + e3.kind + " 9 " + e3.protocol + " " + t3.port + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctpmap:" + t3.port + " " + t3.protocol + " 65535\r\n"], void 0 !== t3.maxMessageSize && i3.push("a=max-message-size:" + t3.maxMessageSize + "\r\n"), i3.join("");
        }, t2.generateSessionId = function() {
          return Math.random().toString().substr(2, 22);
        }, t2.writeSessionBoilerplate = function(e3, i3, n2) {
          let r2;
          const o2 = void 0 !== i3 ? i3 : 2;
          r2 = e3 || t2.generateSessionId();
          return "v=0\r\no=" + (n2 || "thisisadapterortc") + " " + r2 + " " + o2 + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n";
        }, t2.getDirection = function(e3, i3) {
          const n2 = t2.splitLines(e3);
          for (let e4 = 0; e4 < n2.length; e4++)
            switch (n2[e4]) {
              case "a=sendrecv":
              case "a=sendonly":
              case "a=recvonly":
              case "a=inactive":
                return n2[e4].substring(2);
            }
          return i3 ? t2.getDirection(i3) : "sendrecv";
        }, t2.getKind = function(e3) {
          return t2.splitLines(e3)[0].split(" ")[0].substring(2);
        }, t2.isRejected = function(e3) {
          return "0" === e3.split(" ", 2)[1];
        }, t2.parseMLine = function(e3) {
          const i3 = t2.splitLines(e3)[0].substring(2).split(" ");
          return { kind: i3[0], port: parseInt(i3[1], 10), protocol: i3[2], fmt: i3.slice(3).join(" ") };
        }, t2.parseOLine = function(e3) {
          const i3 = t2.matchPrefix(e3, "o=")[0].substring(2).split(" ");
          return { username: i3[0], sessionId: i3[1], sessionVersion: parseInt(i3[2], 10), netType: i3[3], addressType: i3[4], address: i3[5] };
        }, t2.isValidSDP = function(e3) {
          if ("string" != typeof e3 || 0 === e3.length)
            return false;
          const i3 = t2.splitLines(e3);
          for (let e4 = 0; e4 < i3.length; e4++)
            if (i3[e4].length < 2 || "=" !== i3[e4].charAt(1))
              return false;
          return true;
        }, e2.exports = t2;
      }(NT);
      var DT = NT.exports, PT = i2(DT), LT = e({ __proto__: null, default: PT }, [DT]);
      function kT(e2) {
        if (!e2.RTCIceCandidate || e2.RTCIceCandidate && "foundation" in e2.RTCIceCandidate.prototype)
          return;
        const t2 = e2.RTCIceCandidate;
        e2.RTCIceCandidate = function(e3) {
          if ("object" == typeof e3 && e3.candidate && 0 === e3.candidate.indexOf("a=") && ((e3 = JSON.parse(JSON.stringify(e3))).candidate = e3.candidate.substr(2)), e3.candidate && e3.candidate.length) {
            const i3 = new t2(e3), n2 = PT.parseCandidate(e3.candidate), r2 = Object.assign(i3, n2);
            return r2.toJSON = function() {
              return { candidate: r2.candidate, sdpMid: r2.sdpMid, sdpMLineIndex: r2.sdpMLineIndex, usernameFragment: r2.usernameFragment };
            }, r2;
          }
          return new t2(e3);
        }, e2.RTCIceCandidate.prototype = t2.prototype, Cm(e2, "icecandidate", (t3) => (t3.candidate && Object.defineProperty(t3, "candidate", { value: new e2.RTCIceCandidate(t3.candidate), writable: "false" }), t3));
      }
      function MT(e2) {
        !e2.RTCIceCandidate || e2.RTCIceCandidate && "relayProtocol" in e2.RTCIceCandidate.prototype || Cm(e2, "icecandidate", (e3) => {
          if (e3.candidate) {
            const t2 = PT.parseCandidate(e3.candidate.candidate);
            "relay" === t2.type && (e3.candidate.relayProtocol = { 0: "tls", 1: "tcp", 2: "udp" }[t2.priority >> 24]);
          }
          return e3;
        });
      }
      function UT(e2, t2) {
        if (!e2.RTCPeerConnection)
          return;
        "sctp" in e2.RTCPeerConnection.prototype || Object.defineProperty(e2.RTCPeerConnection.prototype, "sctp", { get() {
          return void 0 === this._sctp ? null : this._sctp;
        } });
        const i3 = function(e3) {
          if (!e3 || !e3.sdp)
            return false;
          const t3 = PT.splitSections(e3.sdp);
          return t3.shift(), t3.some((e4) => {
            const t4 = PT.parseMLine(e4);
            return t4 && "application" === t4.kind && -1 !== t4.protocol.indexOf("SCTP");
          });
        }, n2 = function(e3) {
          const t3 = e3.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
          if (null === t3 || t3.length < 2)
            return -1;
          const i4 = parseInt(t3[1], 10);
          return i4 != i4 ? -1 : i4;
        }, r2 = function(e3) {
          let i4 = 65536;
          return "firefox" === t2.browser && (i4 = t2.version < 57 ? -1 === e3 ? 16384 : 2147483637 : t2.version < 60 ? 57 === t2.version ? 65535 : 65536 : 2147483637), i4;
        }, o2 = function(e3, i4) {
          let n3 = 65536;
          "firefox" === t2.browser && 57 === t2.version && (n3 = 65535);
          const r3 = PT.matchPrefix(e3.sdp, "a=max-message-size:");
          return r3.length > 0 ? n3 = parseInt(r3[0].substr(19), 10) : "firefox" === t2.browser && -1 !== i4 && (n3 = 2147483637), n3;
        }, s2 = e2.RTCPeerConnection.prototype.setRemoteDescription;
        e2.RTCPeerConnection.prototype.setRemoteDescription = function() {
          if (this._sctp = null, "chrome" === t2.browser && t2.version >= 76) {
            const { sdpSemantics: e3 } = this.getConfiguration();
            "plan-b" === e3 && Object.defineProperty(this, "sctp", { get() {
              return void 0 === this._sctp ? null : this._sctp;
            }, enumerable: true, configurable: true });
          }
          if (i3(arguments[0])) {
            const e3 = n2(arguments[0]), t3 = r2(e3), i4 = o2(arguments[0], e3);
            let s3;
            s3 = 0 === t3 && 0 === i4 ? Number.POSITIVE_INFINITY : 0 === t3 || 0 === i4 ? Math.max(t3, i4) : Math.min(t3, i4);
            const a2 = {};
            Object.defineProperty(a2, "maxMessageSize", { get: () => s3 }), this._sctp = a2;
          }
          return s2.apply(this, arguments);
        };
      }
      function xT(e2) {
        if (!e2.RTCPeerConnection || !("createDataChannel" in e2.RTCPeerConnection.prototype))
          return;
        function t2(e3, t3) {
          const i4 = e3.send;
          e3.send = function() {
            const n2 = arguments[0], r2 = n2.length || n2.size || n2.byteLength;
            if ("open" === e3.readyState && t3.sctp && r2 > t3.sctp.maxMessageSize)
              throw new TypeError("Message too large (can send a maximum of " + t3.sctp.maxMessageSize + " bytes)");
            return i4.apply(e3, arguments);
          };
        }
        const i3 = e2.RTCPeerConnection.prototype.createDataChannel;
        e2.RTCPeerConnection.prototype.createDataChannel = function() {
          const e3 = i3.apply(this, arguments);
          return t2(e3, this), e3;
        }, Cm(e2, "datachannel", (e3) => (t2(e3.channel, e3.target), e3));
      }
      function VT(e2) {
        if (!e2.RTCPeerConnection || "connectionState" in e2.RTCPeerConnection.prototype)
          return;
        const t2 = e2.RTCPeerConnection.prototype;
        Object.defineProperty(t2, "connectionState", { get() {
          return { completed: "connected", checking: "connecting" }[this.iceConnectionState] || this.iceConnectionState;
        }, enumerable: true, configurable: true }), Object.defineProperty(t2, "onconnectionstatechange", { get() {
          return this._onconnectionstatechange || null;
        }, set(e3) {
          this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), e3 && this.addEventListener("connectionstatechange", this._onconnectionstatechange = e3);
        }, enumerable: true, configurable: true }), ["setLocalDescription", "setRemoteDescription"].forEach((e3) => {
          const i3 = t2[e3];
          t2[e3] = function() {
            return this._connectionstatechangepoly || (this._connectionstatechangepoly = (e4) => {
              const t3 = e4.target;
              if (t3._lastConnectionState !== t3.connectionState) {
                t3._lastConnectionState = t3.connectionState;
                const i4 = new Event("connectionstatechange", e4);
                t3.dispatchEvent(i4);
              }
              return e4;
            }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), i3.apply(this, arguments);
          };
        });
      }
      function FT(e2, t2) {
        if (!e2.RTCPeerConnection)
          return;
        if ("chrome" === t2.browser && t2.version >= 71)
          return;
        if ("safari" === t2.browser && t2.version >= 605)
          return;
        const i3 = e2.RTCPeerConnection.prototype.setRemoteDescription;
        e2.RTCPeerConnection.prototype.setRemoteDescription = function(t3) {
          if (t3 && t3.sdp && -1 !== t3.sdp.indexOf("\na=extmap-allow-mixed")) {
            const i4 = t3.sdp.split("\n").filter((e3) => "a=extmap-allow-mixed" !== OT(e3).call(e3)).join("\n");
            e2.RTCSessionDescription && t3 instanceof e2.RTCSessionDescription ? arguments[0] = new e2.RTCSessionDescription({ type: t3.type, sdp: i4 }) : t3.sdp = i4;
          }
          return i3.apply(this, arguments);
        };
      }
      function BT(e2, t2) {
        if (!e2.RTCPeerConnection || !e2.RTCPeerConnection.prototype)
          return;
        const i3 = e2.RTCPeerConnection.prototype.addIceCandidate;
        i3 && 0 !== i3.length && (e2.RTCPeerConnection.prototype.addIceCandidate = function() {
          return arguments[0] ? ("chrome" === t2.browser && t2.version < 78 || "firefox" === t2.browser && t2.version < 68 || "safari" === t2.browser) && arguments[0] && "" === arguments[0].candidate ? Wh.resolve() : i3.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Wh.resolve());
        });
      }
      function jT(e2, t2) {
        if (!e2.RTCPeerConnection || !e2.RTCPeerConnection.prototype)
          return;
        const i3 = e2.RTCPeerConnection.prototype.setLocalDescription;
        i3 && 0 !== i3.length && (e2.RTCPeerConnection.prototype.setLocalDescription = function() {
          let e3 = arguments[0] || {};
          if ("object" != typeof e3 || e3.type && e3.sdp)
            return i3.apply(this, arguments);
          if (e3 = { type: e3.type, sdp: e3.sdp }, !e3.type)
            switch (this.signalingState) {
              case "stable":
              case "have-local-offer":
              case "have-remote-pranswer":
                e3.type = "offer";
                break;
              default:
                e3.type = "answer";
            }
          if (e3.sdp || "offer" !== e3.type && "answer" !== e3.type)
            return i3.apply(this, [e3]);
          return ("offer" === e3.type ? this.createOffer : this.createAnswer).apply(this).then((e4) => i3.apply(this, [e4]));
        });
      }
      var GT = Object.freeze({ __proto__: null, removeExtmapAllowMixed: FT, shimAddIceCandidateNullOrEmpty: BT, shimConnectionState: VT, shimMaxMessageSize: UT, shimParameterlessSetLocalDescription: jT, shimRTCIceCandidate: kT, shimRTCIceCandidateRelayProtocol: MT, shimSendThrowTypeError: xT });
      !function() {
        let { window: e2 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { shimChrome: true, shimFirefox: true, shimSafari: true };
        const i3 = ym, n2 = function(e3) {
          const t3 = { browser: null, version: null };
          if (void 0 === e3 || !e3.navigator)
            return t3.browser = "Not a browser.", t3;
          const { navigator: i4 } = e3;
          if (i4.mozGetUserMedia)
            t3.browser = "firefox", t3.version = Rm(i4.userAgent, /Firefox\/(\d+)\./, 1);
          else if (i4.webkitGetUserMedia || false === e3.isSecureContext && e3.webkitRTCPeerConnection)
            t3.browser = "chrome", t3.version = Rm(i4.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
          else {
            if (!e3.RTCPeerConnection || !i4.userAgent.match(/AppleWebKit\/(\d+)\./))
              return t3.browser = "Not a supported browser.", t3;
            t3.browser = "safari", t3.version = Rm(i4.userAgent, /AppleWebKit\/(\d+)\./, 1), t3.supportsUnifiedPlan = e3.RTCRtpTransceiver && "currentDirection" in e3.RTCRtpTransceiver.prototype;
          }
          return t3;
        }(e2), r2 = { browserDetails: n2, commonShim: GT, extractVersion: Rm, disableLog: vm, disableWarnings: Im, sdp: LT };
        switch (n2.browser) {
          case "chrome":
            if (!Gm || !Bm || !t2.shimChrome)
              return i3("Chrome shim is not included in this adapter release."), r2;
            if (null === n2.version)
              return i3("Chrome shim can not determine version, not shimming."), r2;
            i3("adapter.js shimming chrome."), r2.browserShim = Gm, BT(e2, n2), jT(e2), Pm(e2, n2), Lm(e2), Bm(e2, n2), km(e2), Fm(e2, n2), Mm(e2), Um(e2), xm(e2), jm(e2, n2), kT(e2), MT(e2), VT(e2), UT(e2, n2), xT(e2), FT(e2, n2);
            break;
          case "firefox":
            if (!eT || !Km || !t2.shimFirefox)
              return i3("Firefox shim is not included in this adapter release."), r2;
            i3("adapter.js shimming firefox."), r2.browserShim = eT, BT(e2, n2), jT(e2), Wm(e2, n2), Km(e2, n2), Hm(e2), zm(e2), Ym(e2), qm(e2), Xm(e2), Jm(e2), Qm(e2), Zm(e2), $m(e2), kT(e2), VT(e2), UT(e2, n2), xT(e2);
            break;
          case "safari":
            if (!lT || !t2.shimSafari)
              return i3("Safari shim is not included in this adapter release."), r2;
            i3("adapter.js shimming safari."), r2.browserShim = lT, BT(e2, n2), jT(e2), sT(e2), cT(e2), nT(e2), tT(e2), iT(e2), aT(e2), rT(e2), dT(e2), kT(e2), MT(e2), UT(e2, n2), xT(e2), FT(e2, n2);
            break;
          default:
            i3("Unsupported browser!");
        }
      }({ window: "undefined" == typeof window ? void 0 : window });
      var WT = be, HT = TypeError, KT = ce.match(/firefox\/(\d+)/i), YT = !!KT && +KT[1], qT = /MSIE|Trident/.test(ce), zT = ce.match(/AppleWebKit\/(\d+)\./), XT = !!zT && +zT[1], JT = wi, QT = d, ZT = De, $T = Xe, eS = Gi, tS = function(e2, t2) {
        if (!delete e2[t2])
          throw HT("Cannot delete property " + WT(t2) + " of " + WT(e2));
      }, iS = fn, nS = n, rS = Tp, oS = Bn, sS = YT, aS = qT, cS = Ee, dS = XT, lS = [], uS = QT(lS.sort), hS = QT(lS.push), pS = nS(function() {
        lS.sort(void 0);
      }), _S = nS(function() {
        lS.sort(null);
      }), ES = oS("sort"), fS = !nS(function() {
        if (cS)
          return cS < 70;
        if (!(sS && sS > 3)) {
          if (aS)
            return true;
          if (dS)
            return dS < 603;
          var e2, t2, i3, n2, r2 = "";
          for (e2 = 65; e2 < 76; e2++) {
            switch (t2 = String.fromCharCode(e2), e2) {
              case 66:
              case 69:
              case 70:
              case 72:
                i3 = 3;
                break;
              case 68:
              case 71:
                i3 = 4;
                break;
              default:
                i3 = 2;
            }
            for (n2 = 0; n2 < 47; n2++)
              lS.push({ k: t2 + n2, v: i3 });
          }
          for (lS.sort(function(e3, t3) {
            return t3.v - e3.v;
          }), n2 = 0; n2 < lS.length; n2++)
            t2 = lS[n2].k.charAt(0), r2.charAt(r2.length - 1) !== t2 && (r2 += t2);
          return "DGBEFHACIJK" !== r2;
        }
      });
      JT({ target: "Array", proto: true, forced: pS || !_S || !ES || !fS }, { sort: function(e2) {
        void 0 !== e2 && ZT(e2);
        var t2 = $T(this);
        if (fS)
          return void 0 === e2 ? uS(t2) : uS(t2, e2);
        var i3, n2, r2 = [], o2 = eS(t2);
        for (n2 = 0; n2 < o2; n2++)
          n2 in t2 && hS(r2, t2[n2]);
        for (rS(r2, function(e3) {
          return function(t3, i4) {
            return void 0 === i4 ? -1 : void 0 === t3 ? 1 : void 0 !== e3 ? +e3(t3, i4) || 0 : iS(t3) > iS(i4) ? 1 : -1;
          };
        }(e2)), i3 = eS(r2), n2 = 0; n2 < i3; )
          t2[n2] = r2[n2++];
        for (; n2 < o2; )
          tS(t2, n2++);
        return t2;
      } });
      var mS = Ji("Array").sort, TS = l, SS = mS, gS = Array.prototype, RS = function(e2) {
        var t2 = e2.sort;
        return e2 === gS || TS(gS, e2) && t2 === gS.sort ? SS : t2;
      }, CS = i2(RS), vS = h;
      wi({ global: true, forced: vS.globalThis !== vS }, { globalThis: vS });
      var IS = i2(h), yS = { exports: {} };
      !function(e2, i3) {
        !function(t2, n2) {
          var r2 = "function", o2 = "undefined", s2 = "object", a2 = "string", c2 = "major", d2 = "model", l2 = "name", u2 = "type", h2 = "vendor", p3 = "version", _2 = "architecture", E2 = "console", f2 = "mobile", m2 = "tablet", T2 = "smarttv", S2 = "wearable", g2 = "embedded", R3 = "Amazon", C2 = "Apple", v2 = "ASUS", I2 = "BlackBerry", y2 = "Browser", A2 = "Chrome", b2 = "Firefox", w2 = "Google", O2 = "Huawei", N2 = "LG", D2 = "Microsoft", P2 = "Motorola", L2 = "Opera", k2 = "Samsung", M2 = "Sharp", U2 = "Sony", x2 = "Xiaomi", V2 = "Zebra", F2 = "Facebook", B2 = "Chromium OS", j2 = "Mac OS", G2 = function(e3) {
            for (var t3 = {}, i4 = 0; i4 < e3.length; i4++)
              t3[e3[i4].toUpperCase()] = e3[i4];
            return t3;
          }, W2 = function(e3, t3) {
            return typeof e3 === a2 && -1 !== H2(t3).indexOf(H2(e3));
          }, H2 = function(e3) {
            return e3.toLowerCase();
          }, K2 = function(e3, t3) {
            if (typeof e3 === a2)
              return e3 = e3.replace(/^\s\s*/, ""), typeof t3 === o2 ? e3 : e3.substring(0, 350);
          }, Y2 = function(e3, t3) {
            for (var i4, o3, a3, c3, d3, l3, u3 = 0; u3 < t3.length && !d3; ) {
              var h3 = t3[u3], p4 = t3[u3 + 1];
              for (i4 = o3 = 0; i4 < h3.length && !d3 && h3[i4]; )
                if (d3 = h3[i4++].exec(e3))
                  for (a3 = 0; a3 < p4.length; a3++)
                    l3 = d3[++o3], typeof (c3 = p4[a3]) === s2 && c3.length > 0 ? 2 === c3.length ? typeof c3[1] == r2 ? this[c3[0]] = c3[1].call(this, l3) : this[c3[0]] = c3[1] : 3 === c3.length ? typeof c3[1] !== r2 || c3[1].exec && c3[1].test ? this[c3[0]] = l3 ? l3.replace(c3[1], c3[2]) : n2 : this[c3[0]] = l3 ? c3[1].call(this, l3, c3[2]) : n2 : 4 === c3.length && (this[c3[0]] = l3 ? c3[3].call(this, l3.replace(c3[1], c3[2])) : n2) : this[c3] = l3 || n2;
              u3 += 2;
            }
          }, q2 = function(e3, t3) {
            for (var i4 in t3)
              if (typeof t3[i4] === s2 && t3[i4].length > 0) {
                for (var r3 = 0; r3 < t3[i4].length; r3++)
                  if (W2(t3[i4][r3], e3))
                    return "?" === i4 ? n2 : i4;
              } else if (W2(t3[i4], e3))
                return "?" === i4 ? n2 : i4;
            return e3;
          }, z2 = { ME: "4.90", "NT 3.11": "NT3.51", "NT 4.0": "NT4.0", 2e3: "NT 5.0", XP: ["NT 5.1", "NT 5.2"], Vista: "NT 6.0", 7: "NT 6.1", 8: "NT 6.2", 8.1: "NT 6.3", 10: ["NT 6.4", "NT 10.0"], RT: "ARM" }, X2 = { browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [p3, [l2, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [p3, [l2, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [l2, p3], [/opios[\/ ]+([\w\.]+)/i], [p3, [l2, L2 + " Mini"]], [/\bopr\/([\w\.]+)/i], [p3, [l2, L2]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i, /(ba?idubrowser)[\/ ]?([\w\.]+)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i, /(weibo)__([\d\.]+)/i], [l2, p3], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [p3, [l2, "UC" + y2]], [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i], [p3, [l2, "WeChat(Win) Desktop"]], [/micromessenger\/([\w\.]+)/i], [p3, [l2, "WeChat"]], [/konqueror\/([\w\.]+)/i], [p3, [l2, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [p3, [l2, "IE"]], [/yabrowser\/([\w\.]+)/i], [p3, [l2, "Yandex"]], [/(avast|avg)\/([\w\.]+)/i], [[l2, /(.+)/, "$1 Secure " + y2], p3], [/\bfocus\/([\w\.]+)/i], [p3, [l2, b2 + " Focus"]], [/\bopt\/([\w\.]+)/i], [p3, [l2, L2 + " Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [p3, [l2, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [p3, [l2, "Dolphin"]], [/coast\/([\w\.]+)/i], [p3, [l2, L2 + " Coast"]], [/miuibrowser\/([\w\.]+)/i], [p3, [l2, "MIUI " + y2]], [/fxios\/([-\w\.]+)/i], [p3, [l2, b2]], [/\bqihu|(qi?ho?o?|360)browser/i], [[l2, "360 " + y2]], [/(oculus|samsung|sailfish|huawei)browser\/([\w\.]+)/i], [[l2, /(.+)/, "$1 " + y2], p3], [/(comodo_dragon)\/([\w\.]+)/i], [[l2, /_/g, " "], p3], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i], [l2, p3], [/(metasr)[\/ ]?([\w\.]+)/i, /(lbbrowser)/i, /\[(linkedin)app\]/i], [l2], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[l2, F2], p3], [/(kakao(?:talk|story))[\/ ]([\w\.]+)/i, /(naver)\(.*?(\d+\.[\w\.]+).*\)/i, /safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(chromium|instagram)[\/ ]([-\w\.]+)/i], [l2, p3], [/\bgsa\/([\w\.]+) .*safari\//i], [p3, [l2, "GSA"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [p3, [l2, A2 + " Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[l2, A2 + " WebView"], p3], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [p3, [l2, "Android " + y2]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [l2, p3], [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i], [p3, [l2, "Mobile Safari"]], [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i], [p3, l2], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [l2, [p3, q2, { "1.0": "/8", 1.2: "/1", 1.3: "/3", "2.0": "/412", "2.0.2": "/416", "2.0.3": "/417", "2.0.4": "/419", "?": "/" }]], [/(webkit|khtml)\/([\w\.]+)/i], [l2, p3], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[l2, "Netscape"], p3], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [p3, [l2, b2 + " Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i, /panasonic;(viera)/i], [l2, p3], [/(cobalt)\/([\w\.]+)/i], [l2, [p3, /master.|lts./, ""]]], cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i], [[_2, "amd64"]], [/(ia32(?=;))/i], [[_2, H2]], [/((?:i[346]|x)86)[;\)]/i], [[_2, "ia32"]], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i], [[_2, "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [[_2, "armhf"]], [/windows (ce|mobile); ppc;/i], [[_2, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i], [[_2, /ower/, "", H2]], [/(sun4\w)[;\)]/i], [[_2, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [[_2, H2]]], device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [d2, [h2, k2], [u2, m2]], [/\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i], [d2, [h2, k2], [u2, f2]], [/\((ip(?:hone|od)[\w ]*);/i], [d2, [h2, C2], [u2, f2]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [d2, [h2, C2], [u2, m2]], [/(macintosh);/i], [d2, [h2, C2]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [d2, [h2, M2], [u2, f2]], [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [d2, [h2, O2], [u2, m2]], [/(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [d2, [h2, O2], [u2, f2]], [/\b(poco[\w ]+)(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i], [[d2, /_/g, " "], [h2, x2], [u2, f2]], [/\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i], [[d2, /_/g, " "], [h2, x2], [u2, m2]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [d2, [h2, "OPPO"], [u2, f2]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [d2, [h2, "Vivo"], [u2, f2]], [/\b(rmx[12]\d{3})(?: bui|;|\))/i], [d2, [h2, "Realme"], [u2, f2]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [d2, [h2, P2], [u2, f2]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [d2, [h2, P2], [u2, m2]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [d2, [h2, N2], [u2, m2]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [d2, [h2, N2], [u2, f2]], [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [d2, [h2, "Lenovo"], [u2, m2]], [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[d2, /_/g, " "], [h2, "Nokia"], [u2, f2]], [/(pixel c)\b/i], [d2, [h2, w2], [u2, m2]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [d2, [h2, w2], [u2, f2]], [/droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [d2, [h2, U2], [u2, f2]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[d2, "Xperia Tablet"], [h2, U2], [u2, m2]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [d2, [h2, "OnePlus"], [u2, f2]], [/(alexa)webm/i, /(kf[a-z]{2}wi)( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [d2, [h2, R3], [u2, m2]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[d2, /(.+)/g, "Fire Phone $1"], [h2, R3], [u2, f2]], [/(playbook);[-\w\),; ]+(rim)/i], [d2, h2, [u2, m2]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [d2, [h2, I2], [u2, f2]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [d2, [h2, v2], [u2, m2]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [d2, [h2, v2], [u2, f2]], [/(nexus 9)/i], [d2, [h2, "HTC"], [u2, m2]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i], [h2, [d2, /_/g, " "], [u2, f2]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [d2, [h2, "Acer"], [u2, m2]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [d2, [h2, "Meizu"], [u2, f2]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i], [h2, d2, [u2, f2]], [/(kobo)\s(ereader|touch)/i, /(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [h2, d2, [u2, m2]], [/(surface duo)/i], [d2, [h2, D2], [u2, m2]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [d2, [h2, "Fairphone"], [u2, f2]], [/(u304aa)/i], [d2, [h2, "AT&T"], [u2, f2]], [/\bsie-(\w*)/i], [d2, [h2, "Siemens"], [u2, f2]], [/\b(rct\w+) b/i], [d2, [h2, "RCA"], [u2, m2]], [/\b(venue[\d ]{2,7}) b/i], [d2, [h2, "Dell"], [u2, m2]], [/\b(q(?:mv|ta)\w+) b/i], [d2, [h2, "Verizon"], [u2, m2]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [d2, [h2, "Barnes & Noble"], [u2, m2]], [/\b(tm\d{3}\w+) b/i], [d2, [h2, "NuVision"], [u2, m2]], [/\b(k88) b/i], [d2, [h2, "ZTE"], [u2, m2]], [/\b(nx\d{3}j) b/i], [d2, [h2, "ZTE"], [u2, f2]], [/\b(gen\d{3}) b.+49h/i], [d2, [h2, "Swiss"], [u2, f2]], [/\b(zur\d{3}) b/i], [d2, [h2, "Swiss"], [u2, m2]], [/\b((zeki)?tb.*\b) b/i], [d2, [h2, "Zeki"], [u2, m2]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[h2, "Dragon Touch"], d2, [u2, m2]], [/\b(ns-?\w{0,9}) b/i], [d2, [h2, "Insignia"], [u2, m2]], [/\b((nxa|next)-?\w{0,9}) b/i], [d2, [h2, "NextBook"], [u2, m2]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[h2, "Voice"], d2, [u2, f2]], [/\b(lvtel\-)?(v1[12]) b/i], [[h2, "LvTel"], d2, [u2, f2]], [/\b(ph-1) /i], [d2, [h2, "Essential"], [u2, f2]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [d2, [h2, "Envizen"], [u2, m2]], [/\b(trio[-\w\. ]+) b/i], [d2, [h2, "MachSpeed"], [u2, m2]], [/\btu_(1491) b/i], [d2, [h2, "Rotor"], [u2, m2]], [/(shield[\w ]+) b/i], [d2, [h2, "Nvidia"], [u2, m2]], [/(sprint) (\w+)/i], [h2, d2, [u2, f2]], [/(kin\.[onetw]{3})/i], [[d2, /\./g, " "], [h2, D2], [u2, f2]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [d2, [h2, V2], [u2, m2]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [d2, [h2, V2], [u2, f2]], [/smart-tv.+(samsung)/i], [h2, [u2, T2]], [/hbbtv.+maple;(\d+)/i], [[d2, /^/, "SmartTV"], [h2, k2], [u2, T2]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[h2, N2], [u2, T2]], [/(apple) ?tv/i], [h2, [d2, C2 + " TV"], [u2, T2]], [/crkey/i], [[d2, A2 + "cast"], [h2, w2], [u2, T2]], [/droid.+aft(\w)( bui|\))/i], [d2, [h2, R3], [u2, T2]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i], [d2, [h2, M2], [u2, T2]], [/(bravia[\w ]+)( bui|\))/i], [d2, [h2, U2], [u2, T2]], [/(mitv-\w{5}) bui/i], [d2, [h2, x2], [u2, T2]], [/Hbbtv.*(technisat) (.*);/i], [h2, d2, [u2, T2]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i], [[h2, K2], [d2, K2], [u2, T2]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[u2, T2]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [h2, d2, [u2, E2]], [/droid.+; (shield) bui/i], [d2, [h2, "Nvidia"], [u2, E2]], [/(playstation [345portablevi]+)/i], [d2, [h2, U2], [u2, E2]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [d2, [h2, D2], [u2, E2]], [/((pebble))app/i], [h2, d2, [u2, S2]], [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i], [d2, [h2, C2], [u2, S2]], [/droid.+; (glass) \d/i], [d2, [h2, w2], [u2, S2]], [/droid.+; (wt63?0{2,3})\)/i], [d2, [h2, V2], [u2, S2]], [/(quest( 2| pro)?)/i], [d2, [h2, F2], [u2, S2]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [h2, [u2, g2]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i], [d2, [u2, f2]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [d2, [u2, m2]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[u2, m2]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i], [[u2, f2]], [/(android[-\w\. ]{0,9});.+buil/i], [d2, [h2, "Generic"]]], engine: [[/windows.+ edge\/([\w\.]+)/i], [p3, [l2, "EdgeHTML"]], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [p3, [l2, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i], [l2, p3], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [p3, l2]], os: [[/microsoft (windows) (vista|xp)/i], [l2, p3], [/(windows) nt 6\.2; (arm)/i, /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i, /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i], [l2, [p3, q2, z2]], [/(win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[l2, "Windows"], [p3, q2, z2]], [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /cfnetwork\/.+darwin/i], [[p3, /_/g, "."], [l2, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[l2, j2], [p3, /_/g, "."]], [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i], [p3, l2], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i], [l2, p3], [/\(bb(10);/i], [p3, [l2, I2]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i], [p3, [l2, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [p3, [l2, b2 + " OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [p3, [l2, "webOS"]], [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i], [p3, [l2, "watchOS"]], [/crkey\/([\d\.]+)/i], [p3, [l2, A2 + "cast"]], [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i], [[l2, B2], p3], [/panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\/(\d+\.[\w\.]+)/i, /(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [l2, p3], [/(sunos) ?([\w\.\d]*)/i], [[l2, "Solaris"], p3], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i, /(unix) ?([\w\.]*)/i], [l2, p3]] }, J2 = function(e3, i4) {
            if (typeof e3 === s2 && (i4 = e3, e3 = n2), !(this instanceof J2))
              return new J2(e3, i4).getResult();
            var E3 = typeof t2 !== o2 && t2.navigator ? t2.navigator : n2, T3 = e3 || (E3 && E3.userAgent ? E3.userAgent : ""), S3 = E3 && E3.userAgentData ? E3.userAgentData : n2, g3 = i4 ? function(e4, t3) {
              var i5 = {};
              for (var n3 in e4)
                t3[n3] && t3[n3].length % 2 == 0 ? i5[n3] = t3[n3].concat(e4[n3]) : i5[n3] = e4[n3];
              return i5;
            }(X2, i4) : X2;
            return this.getBrowser = function() {
              var e4 = {};
              return e4[l2] = n2, e4[p3] = n2, Y2.call(e4, T3, g3.browser), e4[c2] = function(e5) {
                return typeof e5 === a2 ? e5.replace(/[^\d\.]/g, "").split(".")[0] : n2;
              }(e4[p3]), E3 && E3.brave && typeof E3.brave.isBrave == r2 && (e4[l2] = "Brave"), e4;
            }, this.getCPU = function() {
              var e4 = {};
              return e4[_2] = n2, Y2.call(e4, T3, g3.cpu), e4;
            }, this.getDevice = function() {
              var e4 = {};
              return e4[h2] = n2, e4[d2] = n2, e4[u2] = n2, Y2.call(e4, T3, g3.device), !e4[u2] && S3 && S3.mobile && (e4[u2] = f2), "Macintosh" == e4[d2] && E3 && typeof E3.standalone !== o2 && E3.maxTouchPoints && E3.maxTouchPoints > 2 && (e4[d2] = "iPad", e4[u2] = m2), e4;
            }, this.getEngine = function() {
              var e4 = {};
              return e4[l2] = n2, e4[p3] = n2, Y2.call(e4, T3, g3.engine), e4;
            }, this.getOS = function() {
              var e4 = {};
              return e4[l2] = n2, e4[p3] = n2, Y2.call(e4, T3, g3.os), !e4[l2] && S3 && "Unknown" != S3.platform && (e4[l2] = S3.platform.replace(/chrome os/i, B2).replace(/macos/i, j2)), e4;
            }, this.getResult = function() {
              return { ua: this.getUA(), browser: this.getBrowser(), engine: this.getEngine(), os: this.getOS(), device: this.getDevice(), cpu: this.getCPU() };
            }, this.getUA = function() {
              return T3;
            }, this.setUA = function(e4) {
              return T3 = typeof e4 === a2 && e4.length > 350 ? K2(e4, 350) : e4, this;
            }, this.setUA(T3), this;
          };
          J2.VERSION = "0.7.34", J2.BROWSER = G2([l2, p3, c2]), J2.CPU = G2([_2]), J2.DEVICE = G2([d2, h2, u2, E2, f2, T2, m2, S2, g2]), J2.ENGINE = J2.OS = G2([l2, p3]), e2.exports && (i3 = e2.exports = J2), i3.UAParser = J2;
          var Q2 = typeof t2 !== o2 && (t2.jQuery || t2.Zepto);
          if (Q2 && !Q2.ua) {
            var Z2 = new J2();
            Q2.ua = Z2.getResult(), Q2.ua.get = function() {
              return Z2.getUA();
            }, Q2.ua.set = function(e3) {
              Z2.setUA(e3);
              var t3 = Z2.getResult();
              for (var i4 in t3)
                Q2.ua[i4] = t3[i4];
            };
          }
        }("object" == typeof window ? window : t);
      }(yS, yS.exports);
      var AS = i2(yS.exports), bS = pn, wS = Ze, OS = Y, NS = Vo, DS = ht("iterator"), PS = Object, LS = function(e2) {
        if (OS(e2))
          return false;
        var t2 = PS(e2);
        return void 0 !== t2[DS] || "@@iterator" in t2 || wS(NS, bS(t2));
      }, kS = i2(LS), MS = bd.clear;
      wi({ global: true, bind: true, enumerable: true, forced: h.clearImmediate !== MS }, { clearImmediate: MS });
      var US = "function" == typeof Bun && Bun && "string" == typeof Bun.version, xS = h, VS = m, FS = w, BS = US, jS = ce, GS = Qc, WS = $c, HS = xS.Function, KS = /MSIE .\./.test(jS) || BS && function() {
        var e2 = xS.Bun.version.split(".");
        return e2.length < 3 || 0 == e2[0] && (e2[1] < 3 || 3 == e2[1] && 0 == e2[2]);
      }(), YS = wi, qS = h, zS = bd.set, XS = function(e2, t2) {
        var i3 = t2 ? 2 : 1;
        return KS ? function(n2, r2) {
          var o2 = WS(arguments.length, 1) > i3, s2 = FS(n2) ? n2 : HS(n2), a2 = o2 ? GS(arguments, i3) : [], c2 = o2 ? function() {
            VS(s2, this, a2);
          } : s2;
          return t2 ? e2(c2, r2) : e2(c2);
        } : e2;
      }, JS = qS.setImmediate ? XS(zS, false) : zS;
      YS({ global: true, bind: true, enumerable: true, forced: qS.setImmediate !== JS }, { setImmediate: JS });
      var QS = i2(ie.setImmediate), ZS = wi, $S = el, eg = De, tg = $c, ig = jn, ng = h.process;
      ZS({ global: true, enumerable: true, dontCallGetSet: true }, { queueMicrotask: function(e2) {
        tg(arguments.length, 1), eg(e2);
        var t2 = ig && ng.domain;
        $S(t2 ? t2.bind(e2) : e2);
      } });
      var rg = i2(ie.queueMicrotask);
      function og(e2, t2) {
        return function() {
          return e2.apply(t2, arguments);
        };
      }
      const { toString: sg } = Object.prototype, { getPrototypeOf: ag } = Object, cg = (dg = /* @__PURE__ */ Object.create(null), (e2) => {
        const t2 = sg.call(e2);
        return dg[t2] || (dg[t2] = t2.slice(8, -1).toLowerCase());
      });
      var dg;
      const lg = (e2) => (e2 = e2.toLowerCase(), (t2) => cg(t2) === e2), ug = (e2) => (t2) => typeof t2 === e2, { isArray: hg } = Array, pg = ug("undefined");
      const _g = lg("ArrayBuffer");
      const Eg = ug("string"), fg = ug("function"), mg = ug("number"), Tg = (e2) => null !== e2 && "object" == typeof e2, Sg = (e2) => {
        if ("object" !== cg(e2))
          return false;
        const t2 = ag(e2);
        return !(null !== t2 && t2 !== Object.prototype && null !== Object.getPrototypeOf(t2) || Symbol.toStringTag in e2 || kS(e2));
      }, gg = lg("Date"), Rg = lg("File"), Cg = lg("Blob"), vg = lg("FileList"), Ig = lg("URLSearchParams"), [yg, Ag, bg, wg] = ["ReadableStream", "Request", "Response", "Headers"].map(lg);
      function Og(e2, t2) {
        let i3, n2, { allOwnKeys: r2 = false } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        if (null != e2)
          if ("object" != typeof e2 && (e2 = [e2]), hg(e2))
            for (i3 = 0, n2 = e2.length; i3 < n2; i3++)
              t2.call(null, e2[i3], i3, e2);
          else {
            const n3 = r2 ? Object.getOwnPropertyNames(e2) : Object.keys(e2), o2 = n3.length;
            let s2;
            for (i3 = 0; i3 < o2; i3++)
              s2 = n3[i3], t2.call(null, e2[s2], s2, e2);
          }
      }
      function Ng(e2, t2) {
        t2 = t2.toLowerCase();
        const i3 = Object.keys(e2);
        let n2, r2 = i3.length;
        for (; r2-- > 0; )
          if (n2 = i3[r2], t2 === n2.toLowerCase())
            return n2;
        return null;
      }
      const Dg = void 0 !== IS ? IS : "undefined" != typeof self ? self : "undefined" != typeof window ? window : global, Pg = (e2) => !pg(e2) && e2 !== Dg;
      const Lg = (kg = "undefined" != typeof Uint8Array && ag(Uint8Array), (e2) => kg && e2 instanceof kg);
      var kg;
      const Mg = lg("HTMLFormElement"), Ug = ((e2) => {
        let { hasOwnProperty: t2 } = e2;
        return (e3, i3) => t2.call(e3, i3);
      })(Object.prototype), xg = lg("RegExp"), Vg = (e2, t2) => {
        const i3 = Object.getOwnPropertyDescriptors(e2), n2 = {};
        Og(i3, (i4, r2) => {
          let o2;
          false !== (o2 = t2(i4, r2, e2)) && (n2[r2] = o2 || i4);
        }), Object.defineProperties(e2, n2);
      }, Fg = "abcdefghijklmnopqrstuvwxyz", Bg = "0123456789", jg = { DIGIT: Bg, ALPHA: Fg, ALPHA_DIGIT: Fg + Fg.toUpperCase() + Bg };
      const Gg = lg("AsyncFunction"), Wg = (Hg = "function" == typeof QS, Kg = fg(Dg.postMessage), Hg ? QS : Kg ? (Yg = "axios@".concat(Math.random()), qg = [], Dg.addEventListener("message", (e2) => {
        let { source: t2, data: i3 } = e2;
        t2 === Dg && i3 === Yg && qg.length && qg.shift()();
      }, false), (e2) => {
        qg.push(e2), Dg.postMessage(Yg, "*");
      }) : (e2) => setTimeout(e2));
      var Hg, Kg, Yg, qg;
      const zg = void 0 !== rg ? rg.bind(Dg) : "undefined" != typeof process && process.nextTick || Wg;
      var Xg = { isArray: hg, isArrayBuffer: _g, isBuffer: function(e2) {
        return null !== e2 && !pg(e2) && null !== e2.constructor && !pg(e2.constructor) && fg(e2.constructor.isBuffer) && e2.constructor.isBuffer(e2);
      }, isFormData: (e2) => {
        let t2;
        return e2 && ("function" == typeof FormData && e2 instanceof FormData || fg(e2.append) && ("formdata" === (t2 = cg(e2)) || "object" === t2 && fg(e2.toString) && "[object FormData]" === e2.toString()));
      }, isArrayBufferView: function(e2) {
        let t2;
        return t2 = "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e2) : e2 && e2.buffer && _g(e2.buffer), t2;
      }, isString: Eg, isNumber: mg, isBoolean: (e2) => true === e2 || false === e2, isObject: Tg, isPlainObject: Sg, isReadableStream: yg, isRequest: Ag, isResponse: bg, isHeaders: wg, isUndefined: pg, isDate: gg, isFile: Rg, isBlob: Cg, isRegExp: xg, isFunction: fg, isStream: (e2) => Tg(e2) && fg(e2.pipe), isURLSearchParams: Ig, isTypedArray: Lg, isFileList: vg, forEach: Og, merge: function e2() {
        const { caseless: t2 } = Pg(this) && this || {}, i3 = {}, n2 = (n3, r2) => {
          const o2 = t2 && Ng(i3, r2) || r2;
          Sg(i3[o2]) && Sg(n3) ? i3[o2] = e2(i3[o2], n3) : Sg(n3) ? i3[o2] = e2({}, n3) : hg(n3) ? i3[o2] = n3.slice() : i3[o2] = n3;
        };
        for (let e3 = 0, t3 = arguments.length; e3 < t3; e3++)
          arguments[e3] && Og(arguments[e3], n2);
        return i3;
      }, extend: function(e2, t2, i3) {
        let { allOwnKeys: n2 } = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
        return Og(t2, (t3, n3) => {
          i3 && fg(t3) ? e2[n3] = og(t3, i3) : e2[n3] = t3;
        }, { allOwnKeys: n2 }), e2;
      }, trim: (e2) => OT(e2) ? OT(e2).call(e2) : e2.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), stripBOM: (e2) => (65279 === e2.charCodeAt(0) && (e2 = e2.slice(1)), e2), inherits: (e2, t2, i3, n2) => {
        e2.prototype = Object.create(t2.prototype, n2), e2.prototype.constructor = e2, Object.defineProperty(e2, "super", { value: t2.prototype }), i3 && Object.assign(e2.prototype, i3);
      }, toFlatObject: (e2, t2, i3, n2) => {
        let r2, o2, s2;
        const a2 = {};
        if (t2 = t2 || {}, null == e2)
          return t2;
        do {
          for (r2 = Object.getOwnPropertyNames(e2), o2 = r2.length; o2-- > 0; )
            s2 = r2[o2], n2 && !n2(s2, e2, t2) || a2[s2] || (t2[s2] = e2[s2], a2[s2] = true);
          e2 = false !== i3 && ag(e2);
        } while (e2 && (!i3 || i3(e2, t2)) && e2 !== Object.prototype);
        return t2;
      }, kindOf: cg, kindOfTest: lg, endsWith: (e2, t2, i3) => {
        e2 = String(e2), (void 0 === i3 || i3 > e2.length) && (i3 = e2.length), i3 -= t2.length;
        const n2 = e2.indexOf(t2, i3);
        return -1 !== n2 && n2 === i3;
      }, toArray: (e2) => {
        if (!e2)
          return null;
        if (hg(e2))
          return e2;
        let t2 = e2.length;
        if (!mg(t2))
          return null;
        const i3 = new Array(t2);
        for (; t2-- > 0; )
          i3[t2] = e2[t2];
        return i3;
      }, forEachEntry: (e2, t2) => {
        const i3 = (e2 && e2[Symbol.iterator]).call(e2);
        let n2;
        for (; (n2 = i3.next()) && !n2.done; ) {
          const i4 = n2.value;
          t2.call(e2, i4[0], i4[1]);
        }
      }, matchAll: (e2, t2) => {
        let i3;
        const n2 = [];
        for (; null !== (i3 = e2.exec(t2)); )
          n2.push(i3);
        return n2;
      }, isHTMLForm: Mg, hasOwnProperty: Ug, hasOwnProp: Ug, reduceDescriptors: Vg, freezeMethods: (e2) => {
        Vg(e2, (t2, i3) => {
          if (fg(e2) && -1 !== ["arguments", "caller", "callee"].indexOf(i3))
            return false;
          const n2 = e2[i3];
          fg(n2) && (t2.enumerable = false, "writable" in t2 ? t2.writable = false : t2.set || (t2.set = () => {
            throw Error("Can not rewrite read-only method '" + i3 + "'");
          }));
        });
      }, toObjectSet: (e2, t2) => {
        const i3 = {}, n2 = (e3) => {
          e3.forEach((e4) => {
            i3[e4] = true;
          });
        };
        return hg(e2) ? n2(e2) : n2(String(e2).split(t2)), i3;
      }, toCamelCase: (e2) => e2.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(e3, t2, i3) {
        return t2.toUpperCase() + i3;
      }), noop: () => {
      }, toFiniteNumber: (e2, t2) => null != e2 && Number.isFinite(e2 = +e2) ? e2 : t2, findKey: Ng, global: Dg, isContextDefined: Pg, ALPHABET: jg, generateString: function() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 16, t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : jg.ALPHA_DIGIT, i3 = "";
        const { length: n2 } = t2;
        for (; e2--; )
          i3 += t2[Math.random() * n2 | 0];
        return i3;
      }, isSpecCompliantForm: function(e2) {
        return !!(e2 && fg(e2.append) && "FormData" === e2[Symbol.toStringTag] && e2[Symbol.iterator]);
      }, toJSONObject: (e2) => {
        const t2 = new Array(10), i3 = (e3, n2) => {
          if (Tg(e3)) {
            if (t2.indexOf(e3) >= 0)
              return;
            if (!("toJSON" in e3)) {
              t2[n2] = e3;
              const r2 = hg(e3) ? [] : {};
              return Og(e3, (e4, t3) => {
                const o2 = i3(e4, n2 + 1);
                !pg(o2) && (r2[t3] = o2);
              }), t2[n2] = void 0, r2;
            }
          }
          return e3;
        };
        return i3(e2, 0);
      }, isAsyncFn: Gg, isThenable: (e2) => e2 && (Tg(e2) || fg(e2)) && fg(e2.then) && fg(e2.catch), setImmediate: Wg, asap: zg };
      function Jg(e2, t2, i3, n2, r2) {
        Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e2, this.name = "AxiosError", t2 && (this.code = t2), i3 && (this.config = i3), n2 && (this.request = n2), r2 && (this.response = r2, this.status = r2.status ? r2.status : null);
      }
      Xg.inherits(Jg, Error, { toJSON: function() {
        return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: Xg.toJSONObject(this.config), code: this.code, status: this.status };
      } });
      const Qg = Jg.prototype, Zg = {};
      ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach((e2) => {
        Zg[e2] = { value: e2 };
      }), Object.defineProperties(Jg, Zg), Object.defineProperty(Qg, "isAxiosError", { value: true }), Jg.from = (e2, t2, i3, n2, r2, o2) => {
        const s2 = Object.create(Qg);
        return Xg.toFlatObject(e2, s2, function(e3) {
          return e3 !== Error.prototype;
        }, (e3) => "isAxiosError" !== e3), Jg.call(s2, e2.message, t2, i3, n2, r2), s2.cause = e2, s2.name = e2.name, o2 && Object.assign(s2, o2), s2;
      };
      function $g(e2) {
        return Xg.isPlainObject(e2) || Xg.isArray(e2);
      }
      function eR(e2) {
        return Xg.endsWith(e2, "[]") ? e2.slice(0, -2) : e2;
      }
      function tR(e2, t2, i3) {
        return e2 ? e2.concat(t2).map(function(e3, t3) {
          return e3 = eR(e3), !i3 && t3 ? "[" + e3 + "]" : e3;
        }).join(i3 ? "." : "") : t2;
      }
      const iR = Xg.toFlatObject(Xg, {}, null, function(e2) {
        return /^is[A-Z]/.test(e2);
      });
      function nR(e2, t2, i3) {
        if (!Xg.isObject(e2))
          throw new TypeError("target must be an object");
        t2 = t2 || new FormData();
        const n2 = (i3 = Xg.toFlatObject(i3, { metaTokens: true, dots: false, indexes: false }, false, function(e3, t3) {
          return !Xg.isUndefined(t3[e3]);
        })).metaTokens, r2 = i3.visitor || d2, o2 = i3.dots, s2 = i3.indexes, a2 = (i3.Blob || "undefined" != typeof Blob && Blob) && Xg.isSpecCompliantForm(t2);
        if (!Xg.isFunction(r2))
          throw new TypeError("visitor must be a function");
        function c2(e3) {
          if (null === e3)
            return "";
          if (Xg.isDate(e3))
            return e3.toISOString();
          if (!a2 && Xg.isBlob(e3))
            throw new Jg("Blob is not supported. Use a Buffer instead.");
          return Xg.isArrayBuffer(e3) || Xg.isTypedArray(e3) ? a2 && "function" == typeof Blob ? new Blob([e3]) : Buffer.from(e3) : e3;
        }
        function d2(e3, i4, r3) {
          let a3 = e3;
          if (e3 && !r3 && "object" == typeof e3) {
            if (Xg.endsWith(i4, "{}"))
              i4 = n2 ? i4 : i4.slice(0, -2), e3 = JSON.stringify(e3);
            else if (Xg.isArray(e3) && function(e4) {
              return Xg.isArray(e4) && !e4.some($g);
            }(e3) || (Xg.isFileList(e3) || Xg.endsWith(i4, "[]")) && (a3 = Xg.toArray(e3)))
              return i4 = eR(i4), a3.forEach(function(e4, n3) {
                !Xg.isUndefined(e4) && null !== e4 && t2.append(true === s2 ? tR([i4], n3, o2) : null === s2 ? i4 : i4 + "[]", c2(e4));
              }), false;
          }
          return !!$g(e3) || (t2.append(tR(r3, i4, o2), c2(e3)), false);
        }
        const l2 = [], u2 = Object.assign(iR, { defaultVisitor: d2, convertValue: c2, isVisitable: $g });
        if (!Xg.isObject(e2))
          throw new TypeError("data must be an object");
        return function e3(i4, n3) {
          if (!Xg.isUndefined(i4)) {
            if (-1 !== l2.indexOf(i4))
              throw Error("Circular reference detected in " + n3.join("."));
            l2.push(i4), Xg.forEach(i4, function(i5, o3) {
              true === (!(Xg.isUndefined(i5) || null === i5) && r2.call(t2, i5, Xg.isString(o3) ? OT(o3).call(o3) : o3, n3, u2)) && e3(i5, n3 ? n3.concat(o3) : [o3]);
            }), l2.pop();
          }
        }(e2), t2;
      }
      function rR(e2) {
        const t2 = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" };
        return encodeURIComponent(e2).replace(/[!'()~]|%20|%00/g, function(e3) {
          return t2[e3];
        });
      }
      function oR(e2, t2) {
        this._pairs = [], e2 && nR(e2, this, t2);
      }
      const sR = oR.prototype;
      function aR(e2) {
        return encodeURIComponent(e2).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      }
      function cR(e2, t2, i3) {
        if (!t2)
          return e2;
        const n2 = i3 && i3.encode || aR, r2 = i3 && i3.serialize;
        let o2;
        if (o2 = r2 ? r2(t2, i3) : Xg.isURLSearchParams(t2) ? t2.toString() : new oR(t2, i3).toString(n2), o2) {
          const t3 = e2.indexOf("#");
          -1 !== t3 && (e2 = e2.slice(0, t3)), e2 += (-1 === e2.indexOf("?") ? "?" : "&") + o2;
        }
        return e2;
      }
      sR.append = function(e2, t2) {
        this._pairs.push([e2, t2]);
      }, sR.toString = function(e2) {
        const t2 = e2 ? function(t3) {
          return e2.call(this, t3, rR);
        } : rR;
        return this._pairs.map(function(e3) {
          return t2(e3[0]) + "=" + t2(e3[1]);
        }, "").join("&");
      };
      var dR = class {
        constructor() {
          this.handlers = [];
        }
        use(e2, t2, i3) {
          return this.handlers.push({ fulfilled: e2, rejected: t2, synchronous: !!i3 && i3.synchronous, runWhen: i3 ? i3.runWhen : null }), this.handlers.length - 1;
        }
        eject(e2) {
          this.handlers[e2] && (this.handlers[e2] = null);
        }
        clear() {
          this.handlers && (this.handlers = []);
        }
        forEach(e2) {
          Xg.forEach(this.handlers, function(t2) {
            null !== t2 && e2(t2);
          });
        }
      }, lR = { silentJSONParsing: true, forcedJSONParsing: true, clarifyTimeoutError: false }, uR = { exports: {} }, hR = wi, pR = N, _R = Qt.f;
      hR({ target: "Object", stat: true, forced: Object.defineProperty !== _R, sham: !pR }, { defineProperty: _R });
      var ER = ie.Object, fR = uR.exports = function(e2, t2, i3) {
        return ER.defineProperty(e2, t2, i3);
      };
      ER.defineProperty.sham && (fR.sham = true);
      var mR = i2(uR.exports), TR = TypeError, SR = Qn, gR = Gc, RR = te, CR = ht("species"), vR = Array, IR = function(e2) {
        var t2;
        return SR(e2) && (t2 = e2.constructor, (gR(t2) && (t2 === vR || SR(t2.prototype)) || RR(t2) && null === (t2 = t2[CR])) && (t2 = void 0)), void 0 === t2 ? vR : t2;
      }, yR = function(e2, t2) {
        return new (IR(e2))(0 === t2 ? 0 : t2);
      }, AR = n, bR = Ee, wR = ht("species"), OR = function(e2) {
        return bR >= 51 || !AR(function() {
          var t2 = [];
          return (t2.constructor = {})[wR] = function() {
            return { foo: 1 };
          }, 1 !== t2[e2](Boolean).foo;
        });
      }, NR = wi, DR = n, PR = Qn, LR = te, kR = Xe, MR = Gi, UR = function(e2) {
        if (e2 > 9007199254740991)
          throw TR("Maximum allowed index exceeded");
        return e2;
      }, xR = sp, VR = yR, FR = OR, BR = Ee, jR = ht("isConcatSpreadable"), GR = BR >= 51 || !DR(function() {
        var e2 = [];
        return e2[jR] = false, e2.concat()[0] !== e2;
      }), WR = function(e2) {
        if (!LR(e2))
          return false;
        var t2 = e2[jR];
        return void 0 !== t2 ? !!t2 : PR(e2);
      };
      NR({ target: "Array", proto: true, arity: 1, forced: !GR || !FR("concat") }, { concat: function(e2) {
        var t2, i3, n2, r2, o2, s2 = kR(this), a2 = VR(s2, 0), c2 = 0;
        for (t2 = -1, n2 = arguments.length; t2 < n2; t2++)
          if (WR(o2 = -1 === t2 ? s2 : arguments[t2]))
            for (r2 = MR(o2), UR(c2 + r2), i3 = 0; i3 < r2; i3++, c2++)
              i3 in o2 && xR(a2, c2, o2[i3]);
          else
            UR(c2 + 1), xR(a2, c2++, o2);
        return a2.length = c2, a2;
      } });
      var HR = {}, KR = R2, YR = Z, qR = Nr.f, zR = hp, XR = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
      HR.f = function(e2) {
        return XR && "Window" == KR(e2) ? function(e3) {
          try {
            return qR(e3);
          } catch (e4) {
            return zR(XR);
          }
        }(e2) : qR(YR(e2));
      };
      var JR = {}, QR = ht;
      JR.f = QR;
      var ZR = ie, $R = Ze, eC = JR, tC = Qt.f, iC = function(e2) {
        var t2 = ZR.Symbol || (ZR.Symbol = {});
        $R(t2, e2) || tC(t2, e2, { value: eC.f(e2) });
      }, nC = L, rC = ae, oC = ht, sC = pa, aC = function() {
        var e2 = rC("Symbol"), t2 = e2 && e2.prototype, i3 = t2 && t2.valueOf, n2 = oC("toPrimitive");
        t2 && !t2[n2] && sC(t2, n2, function(e3) {
          return nC(i3, this);
        }, { arity: 1 });
      }, cC = Jt, dC = K, lC = Xe, uC = Gi, hC = yR, pC = d([].push), _C = function(e2) {
        var t2 = 1 == e2, i3 = 2 == e2, n2 = 3 == e2, r2 = 4 == e2, o2 = 6 == e2, s2 = 7 == e2, a2 = 5 == e2 || o2;
        return function(c2, d2, l2, u2) {
          for (var h2, p3, _2 = lC(c2), E2 = dC(_2), f2 = cC(d2, l2), m2 = uC(E2), T2 = 0, S2 = u2 || hC, g2 = t2 ? S2(c2, m2) : i3 || s2 ? S2(c2, 0) : void 0; m2 > T2; T2++)
            if ((a2 || T2 in E2) && (p3 = f2(h2 = E2[T2], T2, _2), e2))
              if (t2)
                g2[T2] = p3;
              else if (p3)
                switch (e2) {
                  case 3:
                    return true;
                  case 5:
                    return h2;
                  case 6:
                    return T2;
                  case 2:
                    pC(g2, h2);
                }
              else
                switch (e2) {
                  case 4:
                    return false;
                  case 7:
                    pC(g2, h2);
                }
          return o2 ? -1 : n2 || r2 ? r2 : g2;
        };
      }, EC = { forEach: _C(0), map: _C(1), filter: _C(2), some: _C(3), every: _C(4), find: _C(5), findIndex: _C(6), filterReject: _C(7) }, fC = wi, mC = h, TC = L, SC = d, gC = N, RC = Se, CC = n, vC = Ze, IC = l, yC = ii, AC = Z, bC = Ct, wC = fn, OC = B, NC = Io, DC = to, PC = Nr, LC = HR, kC = jr, MC = O, UC = Qt, xC = Zr, VC = k, FC = pa, BC = pc, jC = Ye, GC = Dr, WC = nt, HC = ht, KC = JR, YC = iC, qC = aC, zC = Pa, XC = oa, JC = EC.forEach, QC = ur("hidden"), ZC = "Symbol", $C = "prototype", ev = XC.set, tv = XC.getterFor(ZC), iv = Object[$C], nv = mC.Symbol, rv = nv && nv[$C], ov = mC.TypeError, sv = mC.QObject, av = MC.f, cv = UC.f, dv = LC.f, lv = VC.f, uv = SC([].push), hv = jC("symbols"), pv = jC("op-symbols"), _v = jC("wks"), Ev = !sv || !sv[$C] || !sv[$C].findChild, fv = gC && CC(function() {
        return 7 != NC(cv({}, "a", { get: function() {
          return cv(this, "a", { value: 7 }).a;
        } })).a;
      }) ? function(e2, t2, i3) {
        var n2 = av(iv, t2);
        n2 && delete iv[t2], cv(e2, t2, i3), n2 && e2 !== iv && cv(iv, t2, n2);
      } : cv, mv = function(e2, t2) {
        var i3 = hv[e2] = NC(rv);
        return ev(i3, { type: ZC, tag: e2, description: t2 }), gC || (i3.description = t2), i3;
      }, Tv = function(e2, t2, i3) {
        e2 === iv && Tv(pv, t2, i3), yC(e2);
        var n2 = bC(t2);
        return yC(i3), vC(hv, n2) ? (i3.enumerable ? (vC(e2, QC) && e2[QC][n2] && (e2[QC][n2] = false), i3 = NC(i3, { enumerable: OC(0, false) })) : (vC(e2, QC) || cv(e2, QC, OC(1, {})), e2[QC][n2] = true), fv(e2, n2, i3)) : cv(e2, n2, i3);
      }, Sv = function(e2, t2) {
        yC(e2);
        var i3 = AC(t2), n2 = DC(i3).concat(vv(i3));
        return JC(n2, function(t3) {
          gC && !TC(gv, i3, t3) || Tv(e2, t3, i3[t3]);
        }), e2;
      }, gv = function(e2) {
        var t2 = bC(e2), i3 = TC(lv, this, t2);
        return !(this === iv && vC(hv, t2) && !vC(pv, t2)) && (!(i3 || !vC(this, t2) || !vC(hv, t2) || vC(this, QC) && this[QC][t2]) || i3);
      }, Rv = function(e2, t2) {
        var i3 = AC(e2), n2 = bC(t2);
        if (i3 !== iv || !vC(hv, n2) || vC(pv, n2)) {
          var r2 = av(i3, n2);
          return !r2 || !vC(hv, n2) || vC(i3, QC) && i3[QC][n2] || (r2.enumerable = true), r2;
        }
      }, Cv = function(e2) {
        var t2 = dv(AC(e2)), i3 = [];
        return JC(t2, function(e3) {
          vC(hv, e3) || vC(GC, e3) || uv(i3, e3);
        }), i3;
      }, vv = function(e2) {
        var t2 = e2 === iv, i3 = dv(t2 ? pv : AC(e2)), n2 = [];
        return JC(i3, function(e3) {
          !vC(hv, e3) || t2 && !vC(iv, e3) || uv(n2, hv[e3]);
        }), n2;
      };
      RC || (nv = function() {
        if (IC(rv, this))
          throw ov("Symbol is not a constructor");
        var e2 = arguments.length && void 0 !== arguments[0] ? wC(arguments[0]) : void 0, t2 = WC(e2), i3 = function(e3) {
          this === iv && TC(i3, pv, e3), vC(this, QC) && vC(this[QC], t2) && (this[QC][t2] = false), fv(this, t2, OC(1, e3));
        };
        return gC && Ev && fv(iv, t2, { configurable: true, set: i3 }), mv(t2, e2);
      }, FC(rv = nv[$C], "toString", function() {
        return tv(this).tag;
      }), FC(nv, "withoutSetter", function(e2) {
        return mv(WC(e2), e2);
      }), VC.f = gv, UC.f = Tv, xC.f = Sv, MC.f = Rv, PC.f = LC.f = Cv, kC.f = vv, KC.f = function(e2) {
        return mv(HC(e2), e2);
      }, gC && BC(rv, "description", { configurable: true, get: function() {
        return tv(this).description;
      } })), fC({ global: true, constructor: true, wrap: true, forced: !RC, sham: !RC }, { Symbol: nv }), JC(DC(_v), function(e2) {
        YC(e2);
      }), fC({ target: ZC, stat: true, forced: !RC }, { useSetter: function() {
        Ev = true;
      }, useSimple: function() {
        Ev = false;
      } }), fC({ target: "Object", stat: true, forced: !RC, sham: !gC }, { create: function(e2, t2) {
        return void 0 === t2 ? NC(e2) : Sv(NC(e2), t2);
      }, defineProperty: Tv, defineProperties: Sv, getOwnPropertyDescriptor: Rv }), fC({ target: "Object", stat: true, forced: !RC }, { getOwnPropertyNames: Cv }), qC(), zC(nv, ZC), GC[QC] = true;
      var Iv = Se && !!Symbol.for && !!Symbol.keyFor, yv = wi, Av = ae, bv = Ze, wv = fn, Ov = Ye, Nv = Iv, Dv = Ov("string-to-symbol-registry"), Pv = Ov("symbol-to-string-registry");
      yv({ target: "Symbol", stat: true, forced: !Nv }, { for: function(e2) {
        var t2 = wv(e2);
        if (bv(Dv, t2))
          return Dv[t2];
        var i3 = Av("Symbol")(t2);
        return Dv[t2] = i3, Pv[i3] = t2, i3;
      } });
      var Lv = wi, kv = Ze, Mv = ye, Uv = be, xv = Iv, Vv = Ye("symbol-to-string-registry");
      Lv({ target: "Symbol", stat: true, forced: !xv }, { keyFor: function(e2) {
        if (!Mv(e2))
          throw TypeError(Uv(e2) + " is not a symbol");
        if (kv(Vv, e2))
          return Vv[e2];
      } });
      var Fv = Qn, Bv = w, jv = R2, Gv = fn, Wv = d([].push), Hv = wi, Kv = ae, Yv = m, qv = L, zv = d, Xv = n, Jv = w, Qv = ye, Zv = Qc, $v = function(e2) {
        if (Bv(e2))
          return e2;
        if (Fv(e2)) {
          for (var t2 = e2.length, i3 = [], n2 = 0; n2 < t2; n2++) {
            var r2 = e2[n2];
            "string" == typeof r2 ? Wv(i3, r2) : "number" != typeof r2 && "Number" != jv(r2) && "String" != jv(r2) || Wv(i3, Gv(r2));
          }
          var o2 = i3.length, s2 = true;
          return function(e3, t3) {
            if (s2)
              return s2 = false, t3;
            if (Fv(this))
              return t3;
            for (var n3 = 0; n3 < o2; n3++)
              if (i3[n3] === e3)
                return t3;
          };
        }
      }, eI = Se, tI = String, iI = Kv("JSON", "stringify"), nI = zv(/./.exec), rI = zv("".charAt), oI = zv("".charCodeAt), sI = zv("".replace), aI = zv(1 .toString), cI = /[\uD800-\uDFFF]/g, dI = /^[\uD800-\uDBFF]$/, lI = /^[\uDC00-\uDFFF]$/, uI = !eI || Xv(function() {
        var e2 = Kv("Symbol")();
        return "[null]" != iI([e2]) || "{}" != iI({ a: e2 }) || "{}" != iI(Object(e2));
      }), hI = Xv(function() {
        return '"\\udf06\\ud834"' !== iI("\uDF06\uD834") || '"\\udead"' !== iI("\uDEAD");
      }), pI = function(e2, t2) {
        var i3 = Zv(arguments), n2 = $v(t2);
        if (Jv(n2) || void 0 !== e2 && !Qv(e2))
          return i3[1] = function(e3, t3) {
            if (Jv(n2) && (t3 = qv(n2, this, tI(e3), t3)), !Qv(t3))
              return t3;
          }, Yv(iI, null, i3);
      }, _I = function(e2, t2, i3) {
        var n2 = rI(i3, t2 - 1), r2 = rI(i3, t2 + 1);
        return nI(dI, e2) && !nI(lI, r2) || nI(lI, e2) && !nI(dI, n2) ? "\\u" + aI(oI(e2, 0), 16) : e2;
      };
      iI && Hv({ target: "JSON", stat: true, arity: 3, forced: uI || hI }, { stringify: function(e2, t2, i3) {
        var n2 = Zv(arguments), r2 = Yv(uI ? pI : iI, null, n2);
        return hI && "string" == typeof r2 ? sI(r2, cI, _I) : r2;
      } });
      var EI = jr, fI = Xe;
      wi({ target: "Object", stat: true, forced: !Se || n(function() {
        EI.f(1);
      }) }, { getOwnPropertySymbols: function(e2) {
        var t2 = EI.f;
        return t2 ? t2(fI(e2)) : [];
      } }), iC("asyncIterator"), iC("hasInstance"), iC("isConcatSpreadable"), iC("iterator"), iC("match"), iC("matchAll"), iC("replace"), iC("search"), iC("species"), iC("split");
      var mI = aC;
      iC("toPrimitive"), mI();
      var TI = ae, SI = Pa;
      iC("toStringTag"), SI(TI("Symbol"), "Symbol"), iC("unscopables"), Pa(h.JSON, "JSON", true);
      var gI = ie.Symbol, RI = ht, CI = Qt.f, vI = RI("metadata"), II = Function.prototype;
      void 0 === II[vI] && CI(II, vI, { value: null }), iC("dispose"), iC("metadata");
      var yI = gI;
      iC("asyncDispose");
      var AI = d, bI = ae("Symbol"), wI = bI.keyFor, OI = AI(bI.prototype.valueOf), NI = bI.isRegisteredSymbol || function(e2) {
        try {
          return void 0 !== wI(OI(e2));
        } catch (e3) {
          return false;
        }
      };
      wi({ target: "Symbol", stat: true }, { isRegisteredSymbol: NI });
      for (var DI = Ye, PI = ae, LI = d, kI = ye, MI = ht, UI = PI("Symbol"), xI = UI.isWellKnownSymbol, VI = PI("Object", "getOwnPropertyNames"), FI = LI(UI.prototype.valueOf), BI = DI("wks"), jI = 0, GI = VI(UI), WI = GI.length; jI < WI; jI++)
        try {
          var HI = GI[jI];
          kI(UI[HI]) && MI(HI);
        } catch (e2) {
        }
      var KI = function(e2) {
        if (xI && xI(e2))
          return true;
        try {
          for (var t2 = FI(e2), i3 = 0, n2 = VI(BI), r2 = n2.length; i3 < r2; i3++)
            if (BI[n2[i3]] == t2)
              return true;
        } catch (e3) {
        }
        return false;
      };
      wi({ target: "Symbol", stat: true, forced: true }, { isWellKnownSymbol: KI }), iC("matcher"), iC("observable"), wi({ target: "Symbol", stat: true, name: "isRegisteredSymbol" }, { isRegistered: NI }), wi({ target: "Symbol", stat: true, name: "isWellKnownSymbol", forced: true }, { isWellKnown: KI }), iC("metadataKey"), iC("patternMatch"), iC("replaceAll");
      var YI = i2(yI), qI = i2(JR.f("iterator"));
      function zI(e2) {
        return zI = "function" == typeof YI && "symbol" == typeof qI ? function(e3) {
          return typeof e3;
        } : function(e3) {
          return e3 && "function" == typeof YI && e3.constructor === YI && e3 !== YI.prototype ? "symbol" : typeof e3;
        }, zI(e2);
      }
      var XI = i2(JR.f("toPrimitive"));
      function JI(e2) {
        var t2 = function(e3, t3) {
          if ("object" !== zI(e3) || null === e3)
            return e3;
          var i3 = e3[XI];
          if (void 0 !== i3) {
            var n2 = i3.call(e3, t3 || "default");
            if ("object" !== zI(n2))
              return n2;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === t3 ? String : Number)(e3);
        }(e2, "string");
        return "symbol" === zI(t2) ? t2 : String(t2);
      }
      function QI(e2, t2, i3) {
        return (t2 = JI(t2)) in e2 ? mR(e2, t2, { value: i3, enumerable: true, configurable: true, writable: true }) : e2[t2] = i3, e2;
      }
      var ZI = i2(M_), $I = { isBrowser: true, classes: { URLSearchParams: void 0 !== ZI ? ZI : oR, FormData: "undefined" != typeof FormData ? FormData : null, Blob: "undefined" != typeof Blob ? Blob : null }, protocols: ["http", "https", "file", "blob", "url", "data"] };
      const ey = "undefined" != typeof window && "undefined" != typeof document, ty = "object" == typeof navigator && navigator || void 0, iy = ey && (!ty || ["ReactNative", "NativeScript", "NS"].indexOf(ty.product) < 0), ny = "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" == typeof self.importScripts, ry = ey && window.location.href || "http://localhost";
      function oy(e2, t2) {
        var i3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i3.push.apply(i3, n2);
        }
        return i3;
      }
      function sy(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i3 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? oy(Object(i3), true).forEach(function(t3) {
            QI(e2, t3, i3[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : oy(Object(i3)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
          });
        }
        return e2;
      }
      var ay = sy(sy({}, Object.freeze({ __proto__: null, hasBrowserEnv: ey, hasStandardBrowserEnv: iy, hasStandardBrowserWebWorkerEnv: ny, navigator: ty, origin: ry })), $I);
      var cy = ii, dy = L, ly = Ze, uy = l, hy = function() {
        var e2 = cy(this), t2 = "";
        return e2.hasIndices && (t2 += "d"), e2.global && (t2 += "g"), e2.ignoreCase && (t2 += "i"), e2.multiline && (t2 += "m"), e2.dotAll && (t2 += "s"), e2.unicode && (t2 += "u"), e2.unicodeSets && (t2 += "v"), e2.sticky && (t2 += "y"), t2;
      }, py = RegExp.prototype, _y = function(e2) {
        var t2 = e2.flags;
        return void 0 !== t2 || "flags" in py || ly(e2, "flags") || !uy(py, e2) ? t2 : dy(hy, e2);
      }, Ey = vh.charAt, fy = L, my = ii, Ty = w, Sy = R2, gy = /./.exec, Ry = TypeError, Cy = wi, vy = L, Iy = I, yy = Fa, Ay = nc, by = X, wy = Bi, Oy = fn, Ny = ii, Dy = Y, Py = R2, Ly = tn, ky = _y, My = ke, Uy = n, xy = Jc, Vy = function(e2, t2, i3) {
        return t2 + (i3 ? Ey(e2, t2).length : 1);
      }, Fy = function(e2, t2) {
        var i3 = e2.exec;
        if (Ty(i3)) {
          var n2 = fy(i3, e2, t2);
          return null !== n2 && my(n2), n2;
        }
        if ("RegExp" === Sy(e2))
          return fy(gy, e2, t2);
        throw Ry("RegExp#exec called on incompatible receiver");
      }, By = oa, jy = ht("matchAll"), Gy = "RegExp String", Wy = Gy + " Iterator", Hy = By.set, Ky = By.getterFor(Wy), Yy = TypeError, qy = Iy("".indexOf), zy = Iy("".matchAll), Xy = !!zy && !Uy(function() {
        zy("a", /./);
      }), Jy = yy(function(e2, t2, i3, n2) {
        Hy(this, { type: Wy, regexp: e2, string: t2, global: i3, unicode: n2, done: false });
      }, Gy, function() {
        var e2 = Ky(this);
        if (e2.done)
          return Ay(void 0, true);
        var t2 = e2.regexp, i3 = e2.string, n2 = Fy(t2, i3);
        return null === n2 ? (e2.done = true, Ay(void 0, true)) : e2.global ? ("" === Oy(n2[0]) && (t2.lastIndex = Vy(i3, wy(t2.lastIndex), e2.unicode)), Ay(n2, false)) : (e2.done = true, Ay(n2, false));
      }), Qy = function(e2) {
        var t2, i3, n2, r2 = Ny(this), o2 = Oy(e2), s2 = xy(r2, RegExp), a2 = Oy(ky(r2));
        return t2 = new s2(s2 === RegExp ? r2.source : r2, a2), i3 = !!~qy(a2, "g"), n2 = !!~qy(a2, "u"), t2.lastIndex = wy(r2.lastIndex), new Jy(t2, o2, i3, n2);
      };
      Cy({ target: "String", proto: true, forced: Xy }, { matchAll: function(e2) {
        var t2, i3, n2, r2, o2 = by(this);
        if (Dy(e2)) {
          if (Xy)
            return zy(o2, e2);
        } else {
          if (Ly(e2) && (t2 = Oy(by(ky(e2))), !~qy(t2, "g")))
            throw Yy("`.matchAll` does not allow non-global regexes");
          if (Xy)
            return zy(o2, e2);
          if (void 0 === (n2 = My(e2, jy)) && "RegExp" == Py(e2) && (n2 = Qy), n2)
            return vy(n2, e2, o2);
        }
        return i3 = Oy(o2), r2 = new RegExp(e2, "g"), vy(Qy, r2, i3);
      } });
      var Zy = Ji("String").matchAll, $y = l, eA = Zy, tA = String.prototype, iA = function(e2) {
        var t2 = e2.matchAll;
        return "string" == typeof e2 || e2 === tA || $y(tA, e2) && t2 === tA.matchAll ? eA : t2;
      }, nA = i2(iA);
      function rA(e2) {
        function t2(e3, i3, n2, r2) {
          let o2 = e3[r2++];
          if ("__proto__" === o2)
            return true;
          const s2 = Number.isFinite(+o2), a2 = r2 >= e3.length;
          if (o2 = !o2 && Xg.isArray(n2) ? n2.length : o2, a2)
            return Xg.hasOwnProp(n2, o2) ? n2[o2] = [n2[o2], i3] : n2[o2] = i3, !s2;
          n2[o2] && Xg.isObject(n2[o2]) || (n2[o2] = []);
          return t2(e3, i3, n2[o2], r2) && Xg.isArray(n2[o2]) && (n2[o2] = function(e4) {
            const t3 = {}, i4 = Object.keys(e4);
            let n3;
            const r3 = i4.length;
            let o3;
            for (n3 = 0; n3 < r3; n3++)
              o3 = i4[n3], t3[o3] = e4[o3];
            return t3;
          }(n2[o2])), !s2;
        }
        if (Xg.isFormData(e2) && Xg.isFunction(e2.entries)) {
          const i3 = {};
          return Xg.forEachEntry(e2, (e3, n2) => {
            t2(function(e4) {
              return nA(Xg).call(Xg, /\w+|\[(\w*)]/g, e4).map((e5) => "[]" === e5[0] ? "" : e5[1] || e5[0]);
            }(e3), n2, i3, 0);
          }), i3;
        }
        return null;
      }
      const oA = { transitional: lR, adapter: ["xhr", "http", "fetch"], transformRequest: [function(e2, t2) {
        const i3 = t2.getContentType() || "", n2 = i3.indexOf("application/json") > -1, r2 = Xg.isObject(e2);
        r2 && Xg.isHTMLForm(e2) && (e2 = new FormData(e2));
        if (Xg.isFormData(e2))
          return n2 ? JSON.stringify(rA(e2)) : e2;
        if (Xg.isArrayBuffer(e2) || Xg.isBuffer(e2) || Xg.isStream(e2) || Xg.isFile(e2) || Xg.isBlob(e2) || Xg.isReadableStream(e2))
          return e2;
        if (Xg.isArrayBufferView(e2))
          return e2.buffer;
        if (Xg.isURLSearchParams(e2))
          return t2.setContentType("application/x-www-form-urlencoded;charset=utf-8", false), e2.toString();
        let o2;
        if (r2) {
          if (i3.indexOf("application/x-www-form-urlencoded") > -1)
            return function(e3, t3) {
              return nR(e3, new ay.classes.URLSearchParams(), Object.assign({ visitor: function(e4, t4, i4, n3) {
                return ay.isNode && Xg.isBuffer(e4) ? (this.append(t4, e4.toString("base64")), false) : n3.defaultVisitor.apply(this, arguments);
              } }, t3));
            }(e2, this.formSerializer).toString();
          if ((o2 = Xg.isFileList(e2)) || i3.indexOf("multipart/form-data") > -1) {
            const t3 = this.env && this.env.FormData;
            return nR(o2 ? { "files[]": e2 } : e2, t3 && new t3(), this.formSerializer);
          }
        }
        return r2 || n2 ? (t2.setContentType("application/json", false), function(e3, t3, i4) {
          if (Xg.isString(e3))
            try {
              return (t3 || JSON.parse)(e3), OT(Xg).call(Xg, e3);
            } catch (e4) {
              if ("SyntaxError" !== e4.name)
                throw e4;
            }
          return (i4 || JSON.stringify)(e3);
        }(e2)) : e2;
      }], transformResponse: [function(e2) {
        const t2 = this.transitional || oA.transitional, i3 = t2 && t2.forcedJSONParsing, n2 = "json" === this.responseType;
        if (Xg.isResponse(e2) || Xg.isReadableStream(e2))
          return e2;
        if (e2 && Xg.isString(e2) && (i3 && !this.responseType || n2)) {
          const i4 = !(t2 && t2.silentJSONParsing) && n2;
          try {
            return JSON.parse(e2);
          } catch (e3) {
            if (i4) {
              if ("SyntaxError" === e3.name)
                throw Jg.from(e3, Jg.ERR_BAD_RESPONSE, this, null, this.response);
              throw e3;
            }
          }
        }
        return e2;
      }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: ay.classes.FormData, Blob: ay.classes.Blob }, validateStatus: function(e2) {
        return e2 >= 200 && e2 < 300;
      }, headers: { common: { Accept: "application/json, text/plain, */*", "Content-Type": void 0 } } };
      Xg.forEach(["delete", "get", "head", "post", "put", "patch"], (e2) => {
        oA.headers[e2] = {};
      });
      var sA = oA;
      const aA = Xg.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]);
      const cA = Symbol("internals");
      function dA(e2) {
        var t2;
        return e2 && OT(t2 = String(e2)).call(t2).toLowerCase();
      }
      function lA(e2) {
        return false === e2 || null == e2 ? e2 : Xg.isArray(e2) ? e2.map(lA) : String(e2);
      }
      function uA(e2, t2, i3, n2, r2) {
        return Xg.isFunction(n2) ? n2.call(this, t2, i3) : (r2 && (t2 = i3), Xg.isString(t2) ? Xg.isString(n2) ? -1 !== t2.indexOf(n2) : Xg.isRegExp(n2) ? n2.test(t2) : void 0 : void 0);
      }
      class hA {
        constructor(e2) {
          e2 && this.set(e2);
        }
        set(e2, t2, i3) {
          const n2 = this;
          function r2(e3, t3, i4) {
            const r3 = dA(t3);
            if (!r3)
              throw new Error("header name must be a non-empty string");
            const o3 = Xg.findKey(n2, r3);
            (!o3 || void 0 === n2[o3] || true === i4 || void 0 === i4 && false !== n2[o3]) && (n2[o3 || t3] = lA(e3));
          }
          const o2 = (e3, t3) => Xg.forEach(e3, (e4, i4) => r2(e4, i4, t3));
          if (Xg.isPlainObject(e2) || e2 instanceof this.constructor)
            o2(e2, t2);
          else if (Xg.isString(e2) && (e2 = OT(e2).call(e2)) && !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(OT(s2 = e2).call(s2)))
            o2(((e3) => {
              const t3 = {};
              let i4, n3, r3;
              return e3 && e3.split("\n").forEach(function(e4) {
                var o3, s3;
                r3 = e4.indexOf(":"), i4 = OT(o3 = e4.substring(0, r3)).call(o3).toLowerCase(), n3 = OT(s3 = e4.substring(r3 + 1)).call(s3), !i4 || t3[i4] && aA[i4] || ("set-cookie" === i4 ? t3[i4] ? t3[i4].push(n3) : t3[i4] = [n3] : t3[i4] = t3[i4] ? t3[i4] + ", " + n3 : n3);
              }), t3;
            })(e2), t2);
          else if (Xg.isHeaders(e2))
            for (const [t3, n3] of e2.entries())
              r2(n3, t3, i3);
          else
            null != e2 && r2(t2, e2, i3);
          var s2;
          return this;
        }
        get(e2, t2) {
          if (e2 = dA(e2)) {
            const i3 = Xg.findKey(this, e2);
            if (i3) {
              const e3 = this[i3];
              if (!t2)
                return e3;
              if (true === t2)
                return function(e4) {
                  const t3 = /* @__PURE__ */ Object.create(null), i4 = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
                  let n2;
                  for (; n2 = i4.exec(e4); )
                    t3[n2[1]] = n2[2];
                  return t3;
                }(e3);
              if (Xg.isFunction(t2))
                return t2.call(this, e3, i3);
              if (Xg.isRegExp(t2))
                return t2.exec(e3);
              throw new TypeError("parser must be boolean|regexp|function");
            }
          }
        }
        has(e2, t2) {
          if (e2 = dA(e2)) {
            const i3 = Xg.findKey(this, e2);
            return !(!i3 || void 0 === this[i3] || t2 && !uA(0, this[i3], i3, t2));
          }
          return false;
        }
        delete(e2, t2) {
          const i3 = this;
          let n2 = false;
          function r2(e3) {
            if (e3 = dA(e3)) {
              const r3 = Xg.findKey(i3, e3);
              !r3 || t2 && !uA(0, i3[r3], r3, t2) || (delete i3[r3], n2 = true);
            }
          }
          return Xg.isArray(e2) ? e2.forEach(r2) : r2(e2), n2;
        }
        clear(e2) {
          const t2 = Object.keys(this);
          let i3 = t2.length, n2 = false;
          for (; i3--; ) {
            const r2 = t2[i3];
            e2 && !uA(0, this[r2], r2, e2, true) || (delete this[r2], n2 = true);
          }
          return n2;
        }
        normalize(e2) {
          const t2 = this, i3 = {};
          return Xg.forEach(this, (n2, r2) => {
            var o2;
            const s2 = Xg.findKey(i3, r2);
            if (s2)
              return t2[s2] = lA(n2), void delete t2[r2];
            const a2 = e2 ? function(e3) {
              return OT(e3).call(e3).toLowerCase().replace(/([a-z\d])(\w*)/g, (e4, t3, i4) => t3.toUpperCase() + i4);
            }(r2) : OT(o2 = String(r2)).call(o2);
            a2 !== r2 && delete t2[r2], t2[a2] = lA(n2), i3[a2] = true;
          }), this;
        }
        concat() {
          for (var e2 = arguments.length, t2 = new Array(e2), i3 = 0; i3 < e2; i3++)
            t2[i3] = arguments[i3];
          return this.constructor.concat(this, ...t2);
        }
        toJSON(e2) {
          const t2 = /* @__PURE__ */ Object.create(null);
          return Xg.forEach(this, (i3, n2) => {
            null != i3 && false !== i3 && (t2[n2] = e2 && Xg.isArray(i3) ? i3.join(", ") : i3);
          }), t2;
        }
        [Symbol.iterator]() {
          return Object.entries(this.toJSON())[Symbol.iterator]();
        }
        toString() {
          return Object.entries(this.toJSON()).map((e2) => {
            let [t2, i3] = e2;
            return t2 + ": " + i3;
          }).join("\n");
        }
        get [Symbol.toStringTag]() {
          return "AxiosHeaders";
        }
        static from(e2) {
          return e2 instanceof this ? e2 : new this(e2);
        }
        static concat(e2) {
          const t2 = new this(e2);
          for (var i3 = arguments.length, n2 = new Array(i3 > 1 ? i3 - 1 : 0), r2 = 1; r2 < i3; r2++)
            n2[r2 - 1] = arguments[r2];
          return n2.forEach((e3) => t2.set(e3)), t2;
        }
        static accessor(e2) {
          const t2 = (this[cA] = this[cA] = { accessors: {} }).accessors, i3 = this.prototype;
          function n2(e3) {
            const n3 = dA(e3);
            t2[n3] || (!function(e4, t3) {
              const i4 = Xg.toCamelCase(" " + t3);
              ["get", "set", "has"].forEach((n4) => {
                Object.defineProperty(e4, n4 + i4, { value: function(e5, i5, r2) {
                  return this[n4].call(this, t3, e5, i5, r2);
                }, configurable: true });
              });
            }(i3, e3), t2[n3] = true);
          }
          return Xg.isArray(e2) ? e2.forEach(n2) : n2(e2), this;
        }
      }
      hA.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]), Xg.reduceDescriptors(hA.prototype, (e2, t2) => {
        let { value: i3 } = e2, n2 = t2[0].toUpperCase() + t2.slice(1);
        return { get: () => i3, set(e3) {
          this[n2] = e3;
        } };
      }), Xg.freezeMethods(hA);
      var pA = hA;
      function _A(e2, t2) {
        const i3 = this || sA, n2 = t2 || i3, r2 = pA.from(n2.headers);
        let o2 = n2.data;
        return Xg.forEach(e2, function(e3) {
          o2 = e3.call(i3, o2, r2.normalize(), t2 ? t2.status : void 0);
        }), r2.normalize(), o2;
      }
      function EA(e2) {
        return !(!e2 || !e2.__CANCEL__);
      }
      function fA(e2, t2, i3) {
        Jg.call(this, null == e2 ? "canceled" : e2, Jg.ERR_CANCELED, t2, i3), this.name = "CanceledError";
      }
      function mA(e2, t2, i3) {
        const n2 = i3.config.validateStatus;
        i3.status && n2 && !n2(i3.status) ? t2(new Jg("Request failed with status code " + i3.status, [Jg.ERR_BAD_REQUEST, Jg.ERR_BAD_RESPONSE][Math.floor(i3.status / 100) - 4], i3.config, i3.request, i3)) : e2(i3);
      }
      Xg.inherits(fA, Jg, { __CANCEL__: true });
      const TA = function(e2, t2) {
        let i3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 3, n2 = 0;
        const r2 = function(e3, t3) {
          e3 = e3 || 10;
          const i4 = new Array(e3), n3 = new Array(e3);
          let r3, o2 = 0, s2 = 0;
          return t3 = void 0 !== t3 ? t3 : 1e3, function(a2) {
            const c2 = Date.now(), d2 = n3[s2];
            r3 || (r3 = c2), i4[o2] = a2, n3[o2] = c2;
            let l2 = s2, u2 = 0;
            for (; l2 !== o2; )
              u2 += i4[l2++], l2 %= e3;
            if (o2 = (o2 + 1) % e3, o2 === s2 && (s2 = (s2 + 1) % e3), c2 - r3 < t3)
              return;
            const h2 = d2 && c2 - d2;
            return h2 ? Math.round(1e3 * u2 / h2) : void 0;
          };
        }(50, 250);
        return function(e3, t3) {
          let i4, n3, r3 = 0, o2 = 1e3 / t3;
          const s2 = function(t4) {
            let o3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Date.now();
            r3 = o3, i4 = null, n3 && (clearTimeout(n3), n3 = null), e3.apply(null, t4);
          };
          return [function() {
            const e4 = Date.now(), t4 = e4 - r3;
            for (var a2 = arguments.length, c2 = new Array(a2), d2 = 0; d2 < a2; d2++)
              c2[d2] = arguments[d2];
            t4 >= o2 ? s2(c2, e4) : (i4 = c2, n3 || (n3 = setTimeout(() => {
              n3 = null, s2(i4);
            }, o2 - t4)));
          }, () => i4 && s2(i4)];
        }((i4) => {
          const o2 = i4.loaded, s2 = i4.lengthComputable ? i4.total : void 0, a2 = o2 - n2, c2 = r2(a2);
          n2 = o2;
          e2({ loaded: o2, total: s2, progress: s2 ? o2 / s2 : void 0, bytes: a2, rate: c2 || void 0, estimated: c2 && s2 && o2 <= s2 ? (s2 - o2) / c2 : void 0, event: i4, lengthComputable: null != s2, [t2 ? "download" : "upload"]: true });
        }, i3);
      }, SA = (e2, t2) => {
        const i3 = null != e2;
        return [(n2) => t2[0]({ lengthComputable: i3, total: e2, loaded: n2 }), t2[1]];
      }, gA = (e2) => function() {
        for (var t2 = arguments.length, i3 = new Array(t2), n2 = 0; n2 < t2; n2++)
          i3[n2] = arguments[n2];
        return Xg.asap(() => e2(...i3));
      };
      var RA = ay.hasStandardBrowserEnv ? function() {
        const e2 = ay.navigator && /(msie|trident)/i.test(ay.navigator.userAgent), t2 = document.createElement("a");
        let i3;
        function n2(i4) {
          let n3 = i4;
          return e2 && (t2.setAttribute("href", n3), n3 = t2.href), t2.setAttribute("href", n3), { href: t2.href, protocol: t2.protocol ? t2.protocol.replace(/:$/, "") : "", host: t2.host, search: t2.search ? t2.search.replace(/^\?/, "") : "", hash: t2.hash ? t2.hash.replace(/^#/, "") : "", hostname: t2.hostname, port: t2.port, pathname: "/" === t2.pathname.charAt(0) ? t2.pathname : "/" + t2.pathname };
        }
        return i3 = n2(window.location.href), function(e3) {
          const t3 = Xg.isString(e3) ? n2(e3) : e3;
          return t3.protocol === i3.protocol && t3.host === i3.host;
        };
      }() : function() {
        return true;
      }, CA = ay.hasStandardBrowserEnv ? { write(e2, t2, i3, n2, r2, o2) {
        const s2 = [e2 + "=" + encodeURIComponent(t2)];
        Xg.isNumber(i3) && s2.push("expires=" + new Date(i3).toGMTString()), Xg.isString(n2) && s2.push("path=" + n2), Xg.isString(r2) && s2.push("domain=" + r2), true === o2 && s2.push("secure"), document.cookie = s2.join("; ");
      }, read(e2) {
        const t2 = document.cookie.match(new RegExp("(^|;\\s*)(" + e2 + ")=([^;]*)"));
        return t2 ? decodeURIComponent(t2[3]) : null;
      }, remove(e2) {
        this.write(e2, "", Date.now() - 864e5);
      } } : { write() {
      }, read: () => null, remove() {
      } };
      function vA(e2, t2) {
        return e2 && !function(e3) {
          return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e3);
        }(t2) ? function(e3, t3) {
          return t3 ? e3.replace(/\/?\/$/, "") + "/" + t3.replace(/^\/+/, "") : e3;
        }(e2, t2) : t2;
      }
      function IA(e2, t2) {
        var i3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i3.push.apply(i3, n2);
        }
        return i3;
      }
      const yA = (e2) => e2 instanceof pA ? function(e3) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i3 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? IA(Object(i3), true).forEach(function(t3) {
            QI(e3, t3, i3[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : IA(Object(i3)).forEach(function(t3) {
            Object.defineProperty(e3, t3, Object.getOwnPropertyDescriptor(i3, t3));
          });
        }
        return e3;
      }({}, e2) : e2;
      function AA(e2, t2) {
        t2 = t2 || {};
        const i3 = {};
        function n2(e3, t3, i4) {
          return Xg.isPlainObject(e3) && Xg.isPlainObject(t3) ? Xg.merge.call({ caseless: i4 }, e3, t3) : Xg.isPlainObject(t3) ? Xg.merge({}, t3) : Xg.isArray(t3) ? t3.slice() : t3;
        }
        function r2(e3, t3, i4) {
          return Xg.isUndefined(t3) ? Xg.isUndefined(e3) ? void 0 : n2(void 0, e3, i4) : n2(e3, t3, i4);
        }
        function o2(e3, t3) {
          if (!Xg.isUndefined(t3))
            return n2(void 0, t3);
        }
        function s2(e3, t3) {
          return Xg.isUndefined(t3) ? Xg.isUndefined(e3) ? void 0 : n2(void 0, e3) : n2(void 0, t3);
        }
        function a2(i4, r3, o3) {
          return o3 in t2 ? n2(i4, r3) : o3 in e2 ? n2(void 0, i4) : void 0;
        }
        const c2 = { url: o2, method: o2, data: o2, baseURL: s2, transformRequest: s2, transformResponse: s2, paramsSerializer: s2, timeout: s2, timeoutMessage: s2, withCredentials: s2, withXSRFToken: s2, adapter: s2, responseType: s2, xsrfCookieName: s2, xsrfHeaderName: s2, onUploadProgress: s2, onDownloadProgress: s2, decompress: s2, maxContentLength: s2, maxBodyLength: s2, beforeRedirect: s2, transport: s2, httpAgent: s2, httpsAgent: s2, cancelToken: s2, socketPath: s2, responseEncoding: s2, validateStatus: a2, headers: (e3, t3) => r2(yA(e3), yA(t3), true) };
        return Xg.forEach(Object.keys(Object.assign({}, e2, t2)), function(n3) {
          const o3 = c2[n3] || r2, s3 = o3(e2[n3], t2[n3], n3);
          Xg.isUndefined(s3) && o3 !== a2 || (i3[n3] = s3);
        }), i3;
      }
      var bA = (e2) => {
        const t2 = AA({}, e2);
        let i3, { data: n2, withXSRFToken: r2, xsrfHeaderName: o2, xsrfCookieName: s2, headers: a2, auth: c2 } = t2;
        if (t2.headers = a2 = pA.from(a2), t2.url = cR(vA(t2.baseURL, t2.url), e2.params, e2.paramsSerializer), c2 && a2.set("Authorization", "Basic " + btoa((c2.username || "") + ":" + (c2.password ? unescape(encodeURIComponent(c2.password)) : ""))), Xg.isFormData(n2)) {
          if (ay.hasStandardBrowserEnv || ay.hasStandardBrowserWebWorkerEnv)
            a2.setContentType(void 0);
          else if (false !== (i3 = a2.getContentType())) {
            const [e3, ...t3] = i3 ? i3.split(";").map((e4) => OT(e4).call(e4)).filter(Boolean) : [];
            a2.setContentType([e3 || "multipart/form-data", ...t3].join("; "));
          }
        }
        if (ay.hasStandardBrowserEnv && (r2 && Xg.isFunction(r2) && (r2 = r2(t2)), r2 || false !== r2 && RA(t2.url))) {
          const e3 = o2 && s2 && CA.read(s2);
          e3 && a2.set(o2, e3);
        }
        return t2;
      };
      var wA = "undefined" != typeof XMLHttpRequest && function(e2) {
        return new Wh(function(t2, i3) {
          const n2 = bA(e2);
          let r2 = n2.data;
          const o2 = pA.from(n2.headers).normalize();
          let s2, a2, c2, d2, l2, { responseType: u2, onUploadProgress: h2, onDownloadProgress: p3 } = n2;
          function _2() {
            d2 && d2(), l2 && l2(), n2.cancelToken && n2.cancelToken.unsubscribe(s2), n2.signal && n2.signal.removeEventListener("abort", s2);
          }
          let E2 = new XMLHttpRequest();
          function f2() {
            if (!E2)
              return;
            const n3 = pA.from("getAllResponseHeaders" in E2 && E2.getAllResponseHeaders());
            mA(function(e3) {
              t2(e3), _2();
            }, function(e3) {
              i3(e3), _2();
            }, { data: u2 && "text" !== u2 && "json" !== u2 ? E2.response : E2.responseText, status: E2.status, statusText: E2.statusText, headers: n3, config: e2, request: E2 }), E2 = null;
          }
          E2.open(n2.method.toUpperCase(), n2.url, true), E2.timeout = n2.timeout, "onloadend" in E2 ? E2.onloadend = f2 : E2.onreadystatechange = function() {
            E2 && 4 === E2.readyState && (0 !== E2.status || E2.responseURL && 0 === E2.responseURL.indexOf("file:")) && setTimeout(f2);
          }, E2.onabort = function() {
            E2 && (i3(new Jg("Request aborted", Jg.ECONNABORTED, e2, E2)), E2 = null);
          }, E2.onerror = function() {
            i3(new Jg("Network Error", Jg.ERR_NETWORK, e2, E2)), E2 = null;
          }, E2.ontimeout = function() {
            let t3 = n2.timeout ? "timeout of " + n2.timeout + "ms exceeded" : "timeout exceeded";
            const r3 = n2.transitional || lR;
            n2.timeoutErrorMessage && (t3 = n2.timeoutErrorMessage), i3(new Jg(t3, r3.clarifyTimeoutError ? Jg.ETIMEDOUT : Jg.ECONNABORTED, e2, E2)), E2 = null;
          }, void 0 === r2 && o2.setContentType(null), "setRequestHeader" in E2 && Xg.forEach(o2.toJSON(), function(e3, t3) {
            E2.setRequestHeader(t3, e3);
          }), Xg.isUndefined(n2.withCredentials) || (E2.withCredentials = !!n2.withCredentials), u2 && "json" !== u2 && (E2.responseType = n2.responseType), p3 && ([c2, l2] = TA(p3, true), E2.addEventListener("progress", c2)), h2 && E2.upload && ([a2, d2] = TA(h2), E2.upload.addEventListener("progress", a2), E2.upload.addEventListener("loadend", d2)), (n2.cancelToken || n2.signal) && (s2 = (t3) => {
            E2 && (i3(!t3 || t3.type ? new fA(null, e2, E2) : t3), E2.abort(), E2 = null);
          }, n2.cancelToken && n2.cancelToken.subscribe(s2), n2.signal && (n2.signal.aborted ? s2() : n2.signal.addEventListener("abort", s2)));
          const m2 = function(e3) {
            const t3 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e3);
            return t3 && t3[1] || "";
          }(n2.url);
          m2 && -1 === ay.protocols.indexOf(m2) ? i3(new Jg("Unsupported protocol " + m2 + ":", Jg.ERR_BAD_REQUEST, e2)) : E2.send(r2 || null);
        });
      };
      var OA = (e2, t2) => {
        const { length: i3 } = e2 = e2 ? e2.filter(Boolean) : [];
        if (t2 || i3) {
          let i4, n2 = new AbortController();
          const r2 = function(e3) {
            if (!i4) {
              i4 = true, s2();
              const t3 = e3 instanceof Error ? e3 : this.reason;
              n2.abort(t3 instanceof Jg ? t3 : new fA(t3 instanceof Error ? t3.message : t3));
            }
          };
          let o2 = t2 && setTimeout(() => {
            o2 = null, r2(new Jg("timeout ".concat(t2, " of ms exceeded"), Jg.ETIMEDOUT));
          }, t2);
          const s2 = () => {
            e2 && (o2 && clearTimeout(o2), o2 = null, e2.forEach((e3) => {
              e3.unsubscribe ? e3.unsubscribe(r2) : e3.removeEventListener("abort", r2);
            }), e2 = null);
          };
          e2.forEach((e3) => e3.addEventListener("abort", r2));
          const { signal: a2 } = n2;
          return a2.unsubscribe = () => Xg.asap(s2), a2;
        }
      }, NA = Gh, DA = gl;
      wi({ target: "Promise", stat: true, forced: true }, { withResolvers: function() {
        var e2 = DA.f(this);
        return { promise: e2.promise, resolve: e2.resolve, reject: e2.reject };
      } });
      var PA = gl, LA = tl;
      wi({ target: "Promise", stat: true, forced: true }, { try: function(e2) {
        var t2 = PA.f(this), i3 = LA(e2);
        return (i3.error ? t2.reject : t2.resolve)(i3.value), t2.promise;
      } });
      var kA = i2(NA), MA = JR.f("asyncIterator"), UA = i2(MA);
      function xA(e2, t2) {
        this.v = e2, this.k = t2;
      }
      function VA(e2) {
        var t2, i3;
        function n2(t3, i4) {
          try {
            var o2 = e2[t3](i4), s2 = o2.value, a2 = s2 instanceof xA;
            kA.resolve(a2 ? s2.v : s2).then(function(i5) {
              if (a2) {
                var c2 = "return" === t3 ? "return" : "next";
                if (!s2.k || i5.done)
                  return n2(c2, i5);
                i5 = e2[c2](i5).value;
              }
              r2(o2.done ? "return" : "normal", i5);
            }, function(e3) {
              n2("throw", e3);
            });
          } catch (e3) {
            r2("throw", e3);
          }
        }
        function r2(e3, r3) {
          switch (e3) {
            case "return":
              t2.resolve({ value: r3, done: true });
              break;
            case "throw":
              t2.reject(r3);
              break;
            default:
              t2.resolve({ value: r3, done: false });
          }
          (t2 = t2.next) ? n2(t2.key, t2.arg) : i3 = null;
        }
        this._invoke = function(e3, r3) {
          return new kA(function(o2, s2) {
            var a2 = { key: e3, arg: r3, resolve: o2, reject: s2, next: null };
            i3 ? i3 = i3.next = a2 : (t2 = i3 = a2, n2(e3, r3));
          });
        }, "function" != typeof e2.return && (this.return = void 0);
      }
      function FA(e2) {
        return function() {
          return new VA(e2.apply(this, arguments));
        };
      }
      function BA(e2) {
        return new xA(e2, 0);
      }
      function jA(e2) {
        var t2 = {}, i3 = false;
        function n2(t3, n3) {
          return i3 = true, { done: false, value: new xA(n3 = new kA(function(i4) {
            i4(e2[t3](n3));
          }), 1) };
        }
        return t2[void 0 !== YI && qI || "@@iterator"] = function() {
          return this;
        }, t2.next = function(e3) {
          return i3 ? (i3 = false, e3) : n2("next", e3);
        }, "function" == typeof e2.throw && (t2.throw = function(e3) {
          if (i3)
            throw i3 = false, e3;
          return n2("throw", e3);
        }), "function" == typeof e2.return && (t2.return = function(e3) {
          return i3 ? (i3 = false, e3) : n2("return", e3);
        }), t2;
      }
      VA.prototype["function" == typeof YI && UA || "@@asyncIterator"] = function() {
        return this;
      }, VA.prototype.next = function(e2) {
        return this._invoke("next", e2);
      }, VA.prototype.throw = function(e2) {
        return this._invoke("throw", e2);
      }, VA.prototype.return = function(e2) {
        return this._invoke("return", e2);
      };
      var GA = i2(MA);
      function WA(e2) {
        var t2, i3, n2, r2 = 2;
        for ("undefined" != typeof Symbol && (i3 = GA, n2 = Symbol.iterator); r2--; ) {
          if (i3 && null != (t2 = e2[i3]))
            return t2.call(e2);
          if (n2 && null != (t2 = e2[n2]))
            return new HA(t2.call(e2));
          i3 = "@@asyncIterator", n2 = "@@iterator";
        }
        throw new TypeError("Object is not async iterable");
      }
      function HA(e2) {
        function t2(e3) {
          if (Object(e3) !== e3)
            return Wh.reject(new TypeError(e3 + " is not an object."));
          var t3 = e3.done;
          return Wh.resolve(e3.value).then(function(e4) {
            return { value: e4, done: t3 };
          });
        }
        return HA = function(e3) {
          this.s = e3, this.n = e3.next;
        }, HA.prototype = { s: null, n: null, next: function() {
          return t2(this.n.apply(this.s, arguments));
        }, return: function(e3) {
          var i3 = this.s.return;
          return void 0 === i3 ? Wh.resolve({ value: e3, done: true }) : t2(i3.apply(this.s, arguments));
        }, throw: function(e3) {
          var i3 = this.s.return;
          return void 0 === i3 ? Wh.reject(e3) : t2(i3.apply(this.s, arguments));
        } }, new HA(e2);
      }
      const KA = function* (e2, t2) {
        let i3 = e2.byteLength;
        if (!t2 || i3 < t2)
          return void (yield e2);
        let n2, r2 = 0;
        for (; r2 < i3; )
          n2 = r2 + t2, yield e2.slice(r2, n2), r2 = n2;
      }, YA = function() {
        var e2 = FA(function* (e3, t2) {
          var i3, n2 = false, r2 = false;
          try {
            for (var o2, s2 = WA(qA(e3)); n2 = !(o2 = yield BA(s2.next())).done; n2 = false) {
              const e4 = o2.value;
              yield* jA(WA(KA(e4, t2)));
            }
          } catch (e4) {
            r2 = true, i3 = e4;
          } finally {
            try {
              n2 && null != s2.return && (yield BA(s2.return()));
            } finally {
              if (r2)
                throw i3;
            }
          }
        });
        return function(t2, i3) {
          return e2.apply(this, arguments);
        };
      }(), qA = function() {
        var e2 = FA(function* (e3) {
          if (e3[GA])
            return void (yield* jA(WA(e3)));
          const t2 = e3.getReader();
          try {
            for (; ; ) {
              const { done: e4, value: i3 } = yield BA(t2.read());
              if (e4)
                break;
              yield i3;
            }
          } finally {
            yield BA(t2.cancel());
          }
        });
        return function(t2) {
          return e2.apply(this, arguments);
        };
      }(), zA = (e2, t2, i3, n2) => {
        const r2 = YA(e2, t2);
        let o2, s2 = 0, a2 = (e3) => {
          o2 || (o2 = true, n2 && n2(e3));
        };
        return new ReadableStream({ async pull(e3) {
          try {
            const { done: t3, value: n3 } = await r2.next();
            if (t3)
              return a2(), void e3.close();
            let o3 = n3.byteLength;
            if (i3) {
              let e4 = s2 += o3;
              i3(e4);
            }
            e3.enqueue(new Uint8Array(n3));
          } catch (e4) {
            throw a2(e4), e4;
          }
        }, cancel: (e3) => (a2(e3), r2.return()) }, { highWaterMark: 2 });
      };
      function XA(e2, t2) {
        var i3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i3.push.apply(i3, n2);
        }
        return i3;
      }
      function JA(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i3 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? XA(Object(i3), true).forEach(function(t3) {
            QI(e2, t3, i3[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : XA(Object(i3)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
          });
        }
        return e2;
      }
      const QA = "function" == typeof fetch && "function" == typeof Request && "function" == typeof Response, ZA = QA && "function" == typeof ReadableStream, $A = QA && ("function" == typeof TextEncoder ? (eb = new TextEncoder(), (e2) => eb.encode(e2)) : async (e2) => new Uint8Array(await new Response(e2).arrayBuffer()));
      var eb;
      const tb = function(e2) {
        try {
          for (var t2 = arguments.length, i3 = new Array(t2 > 1 ? t2 - 1 : 0), n2 = 1; n2 < t2; n2++)
            i3[n2 - 1] = arguments[n2];
          return !!e2(...i3);
        } catch (e3) {
          return false;
        }
      }, ib = ZA && tb(() => {
        let e2 = false;
        const t2 = new Request(ay.origin, { body: new ReadableStream(), method: "POST", get duplex() {
          return e2 = true, "half";
        } }).headers.has("Content-Type");
        return e2 && !t2;
      }), nb = ZA && tb(() => Xg.isReadableStream(new Response("").body)), rb = { stream: nb && ((e2) => e2.body) };
      var ob;
      QA && (ob = new Response(), ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e2) => {
        !rb[e2] && (rb[e2] = Xg.isFunction(ob[e2]) ? (t2) => t2[e2]() : (t2, i3) => {
          throw new Jg("Response type '".concat(e2, "' is not supported"), Jg.ERR_NOT_SUPPORT, i3);
        });
      }));
      const sb = async (e2, t2) => {
        const i3 = Xg.toFiniteNumber(e2.getContentLength());
        return null == i3 ? (async (e3) => {
          if (null == e3)
            return 0;
          if (Xg.isBlob(e3))
            return e3.size;
          if (Xg.isSpecCompliantForm(e3)) {
            const t3 = new Request(ay.origin, { method: "POST", body: e3 });
            return (await t3.arrayBuffer()).byteLength;
          }
          return Xg.isArrayBufferView(e3) || Xg.isArrayBuffer(e3) ? e3.byteLength : (Xg.isURLSearchParams(e3) && (e3 += ""), Xg.isString(e3) ? (await $A(e3)).byteLength : void 0);
        })(t2) : i3;
      };
      var ab = QA && (async (e2) => {
        let { url: t2, method: i3, data: n2, signal: r2, cancelToken: o2, timeout: s2, onDownloadProgress: a2, onUploadProgress: c2, responseType: d2, headers: l2, withCredentials: u2 = "same-origin", fetchOptions: h2 } = bA(e2);
        d2 = d2 ? (d2 + "").toLowerCase() : "text";
        let p3, _2 = OA([r2, o2 && o2.toAbortSignal()], s2);
        const E2 = _2 && _2.unsubscribe && (() => {
          _2.unsubscribe();
        });
        let f2;
        try {
          if (c2 && ib && "get" !== i3 && "head" !== i3 && 0 !== (f2 = await sb(l2, n2))) {
            let e3, i4 = new Request(t2, { method: "POST", body: n2, duplex: "half" });
            if (Xg.isFormData(n2) && (e3 = i4.headers.get("content-type")) && l2.setContentType(e3), i4.body) {
              const [e4, t3] = SA(f2, TA(gA(c2)));
              n2 = zA(i4.body, 65536, e4, t3);
            }
          }
          Xg.isString(u2) || (u2 = u2 ? "include" : "omit");
          const r3 = "credentials" in Request.prototype;
          p3 = new Request(t2, JA(JA({}, h2), {}, { signal: _2, method: i3.toUpperCase(), headers: l2.normalize().toJSON(), body: n2, duplex: "half", credentials: r3 ? u2 : void 0 }));
          let o3 = await fetch(p3);
          const s3 = nb && ("stream" === d2 || "response" === d2);
          if (nb && (a2 || s3 && E2)) {
            const e3 = {};
            ["status", "statusText", "headers"].forEach((t4) => {
              e3[t4] = o3[t4];
            });
            const t3 = Xg.toFiniteNumber(o3.headers.get("content-length")), [i4, n3] = a2 && SA(t3, TA(gA(a2), true)) || [];
            o3 = new Response(zA(o3.body, 65536, i4, () => {
              n3 && n3(), E2 && E2();
            }), e3);
          }
          d2 = d2 || "text";
          let m2 = await rb[Xg.findKey(rb, d2) || "text"](o3, e2);
          return !s3 && E2 && E2(), await new Wh((t3, i4) => {
            mA(t3, i4, { data: m2, headers: pA.from(o3.headers), status: o3.status, statusText: o3.statusText, config: e2, request: p3 });
          });
        } catch (t3) {
          if (E2 && E2(), t3 && "TypeError" === t3.name && /fetch/i.test(t3.message))
            throw Object.assign(new Jg("Network Error", Jg.ERR_NETWORK, e2, p3), { cause: t3.cause || t3 });
          throw Jg.from(t3, t3 && t3.code, e2, p3);
        }
      });
      const cb = { http: null, xhr: wA, fetch: ab };
      Xg.forEach(cb, (e2, t2) => {
        if (e2) {
          try {
            Object.defineProperty(e2, "name", { value: t2 });
          } catch (e3) {
          }
          Object.defineProperty(e2, "adapterName", { value: t2 });
        }
      });
      const db = (e2) => "- ".concat(e2), lb = (e2) => Xg.isFunction(e2) || null === e2 || false === e2;
      var ub = { getAdapter: (e2) => {
        e2 = Xg.isArray(e2) ? e2 : [e2];
        const { length: t2 } = e2;
        let i3, n2;
        const r2 = {};
        for (let o2 = 0; o2 < t2; o2++) {
          let t3;
          if (i3 = e2[o2], n2 = i3, !lb(i3) && (n2 = cb[(t3 = String(i3)).toLowerCase()], void 0 === n2))
            throw new Jg("Unknown adapter '".concat(t3, "'"));
          if (n2)
            break;
          r2[t3 || "#" + o2] = n2;
        }
        if (!n2) {
          const e3 = Object.entries(r2).map((e4) => {
            let [t3, i4] = e4;
            return "adapter ".concat(t3, " ") + (false === i4 ? "is not supported by the environment" : "is not available in the build");
          });
          throw new Jg("There is no suitable adapter to dispatch the request " + (t2 ? e3.length > 1 ? "since :\n" + e3.map(db).join("\n") : " " + db(e3[0]) : "as no adapter specified"), "ERR_NOT_SUPPORT");
        }
        return n2;
      }, adapters: cb };
      function hb(e2) {
        if (e2.cancelToken && e2.cancelToken.throwIfRequested(), e2.signal && e2.signal.aborted)
          throw new fA(null, e2);
      }
      function pb(e2) {
        hb(e2), e2.headers = pA.from(e2.headers), e2.data = _A.call(e2, e2.transformRequest), -1 !== ["post", "put", "patch"].indexOf(e2.method) && e2.headers.setContentType("application/x-www-form-urlencoded", false);
        return ub.getAdapter(e2.adapter || sA.adapter)(e2).then(function(t2) {
          return hb(e2), t2.data = _A.call(e2, e2.transformResponse, t2), t2.headers = pA.from(t2.headers), t2;
        }, function(t2) {
          return EA(t2) || (hb(e2), t2 && t2.response && (t2.response.data = _A.call(e2, e2.transformResponse, t2.response), t2.response.headers = pA.from(t2.response.headers))), Wh.reject(t2);
        });
      }
      const _b = "1.7.7", Eb = {};
      ["object", "boolean", "number", "function", "string", "symbol"].forEach((e2, t2) => {
        Eb[e2] = function(i3) {
          return typeof i3 === e2 || "a" + (t2 < 1 ? "n " : " ") + e2;
        };
      });
      const fb = {};
      Eb.transitional = function(e2, t2, i3) {
        function n2(e3, t3) {
          return "[Axios v" + _b + "] Transitional option '" + e3 + "'" + t3 + (i3 ? ". " + i3 : "");
        }
        return (i4, r2, o2) => {
          if (false === e2)
            throw new Jg(n2(r2, " has been removed" + (t2 ? " in " + t2 : "")), Jg.ERR_DEPRECATED);
          return t2 && !fb[r2] && (fb[r2] = true, console.warn(n2(r2, " has been deprecated since v" + t2 + " and will be removed in the near future"))), !e2 || e2(i4, r2, o2);
        };
      };
      var mb = { assertOptions: function(e2, t2, i3) {
        if ("object" != typeof e2)
          throw new Jg("options must be an object", Jg.ERR_BAD_OPTION_VALUE);
        const n2 = Object.keys(e2);
        let r2 = n2.length;
        for (; r2-- > 0; ) {
          const o2 = n2[r2], s2 = t2[o2];
          if (s2) {
            const t3 = e2[o2], i4 = void 0 === t3 || s2(t3, o2, e2);
            if (true !== i4)
              throw new Jg("option " + o2 + " must be " + i4, Jg.ERR_BAD_OPTION_VALUE);
          } else if (true !== i3)
            throw new Jg("Unknown option " + o2, Jg.ERR_BAD_OPTION);
        }
      }, validators: Eb };
      const Tb = mb.validators;
      let Sb = class {
        constructor(e2) {
          this.defaults = e2, this.interceptors = { request: new dR(), response: new dR() };
        }
        async request(e2, t2) {
          try {
            return await this._request(e2, t2);
          } catch (e3) {
            if (e3 instanceof Error) {
              let t3;
              Error.captureStackTrace ? Error.captureStackTrace(t3 = {}) : t3 = new Error();
              const i3 = t3.stack ? t3.stack.replace(/^.+\n/, "") : "";
              try {
                e3.stack ? i3 && !String(e3.stack).endsWith(i3.replace(/^.+\n.+\n/, "")) && (e3.stack += "\n" + i3) : e3.stack = i3;
              } catch (e4) {
              }
            }
            throw e3;
          }
        }
        _request(e2, t2) {
          "string" == typeof e2 ? (t2 = t2 || {}).url = e2 : t2 = e2 || {}, t2 = AA(this.defaults, t2);
          const { transitional: i3, paramsSerializer: n2, headers: r2 } = t2;
          void 0 !== i3 && mb.assertOptions(i3, { silentJSONParsing: Tb.transitional(Tb.boolean), forcedJSONParsing: Tb.transitional(Tb.boolean), clarifyTimeoutError: Tb.transitional(Tb.boolean) }, false), null != n2 && (Xg.isFunction(n2) ? t2.paramsSerializer = { serialize: n2 } : mb.assertOptions(n2, { encode: Tb.function, serialize: Tb.function }, true)), t2.method = (t2.method || this.defaults.method || "get").toLowerCase();
          let o2 = r2 && Xg.merge(r2.common, r2[t2.method]);
          r2 && Xg.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (e3) => {
            delete r2[e3];
          }), t2.headers = pA.concat(o2, r2);
          const s2 = [];
          let a2 = true;
          this.interceptors.request.forEach(function(e3) {
            "function" == typeof e3.runWhen && false === e3.runWhen(t2) || (a2 = a2 && e3.synchronous, s2.unshift(e3.fulfilled, e3.rejected));
          });
          const c2 = [];
          let d2;
          this.interceptors.response.forEach(function(e3) {
            c2.push(e3.fulfilled, e3.rejected);
          });
          let l2, u2 = 0;
          if (!a2) {
            const e3 = [pb.bind(this), void 0];
            for (e3.unshift.apply(e3, s2), e3.push.apply(e3, c2), l2 = e3.length, d2 = Wh.resolve(t2); u2 < l2; )
              d2 = d2.then(e3[u2++], e3[u2++]);
            return d2;
          }
          l2 = s2.length;
          let h2 = t2;
          for (u2 = 0; u2 < l2; ) {
            const e3 = s2[u2++], t3 = s2[u2++];
            try {
              h2 = e3(h2);
            } catch (e4) {
              t3.call(this, e4);
              break;
            }
          }
          try {
            d2 = pb.call(this, h2);
          } catch (e3) {
            return Wh.reject(e3);
          }
          for (u2 = 0, l2 = c2.length; u2 < l2; )
            d2 = d2.then(c2[u2++], c2[u2++]);
          return d2;
        }
        getUri(e2) {
          return cR(vA((e2 = AA(this.defaults, e2)).baseURL, e2.url), e2.params, e2.paramsSerializer);
        }
      };
      Xg.forEach(["delete", "get", "head", "options"], function(e2) {
        Sb.prototype[e2] = function(t2, i3) {
          return this.request(AA(i3 || {}, { method: e2, url: t2, data: (i3 || {}).data }));
        };
      }), Xg.forEach(["post", "put", "patch"], function(e2) {
        function t2(t3) {
          return function(i3, n2, r2) {
            return this.request(AA(r2 || {}, { method: e2, headers: t3 ? { "Content-Type": "multipart/form-data" } : {}, url: i3, data: n2 }));
          };
        }
        Sb.prototype[e2] = t2(), Sb.prototype[e2 + "Form"] = t2(true);
      });
      var gb = Sb;
      class Rb {
        constructor(e2) {
          if ("function" != typeof e2)
            throw new TypeError("executor must be a function.");
          let t2;
          this.promise = new Wh(function(e3) {
            t2 = e3;
          });
          const i3 = this;
          this.promise.then((e3) => {
            if (!i3._listeners)
              return;
            let t3 = i3._listeners.length;
            for (; t3-- > 0; )
              i3._listeners[t3](e3);
            i3._listeners = null;
          }), this.promise.then = (e3) => {
            let t3;
            const n2 = new Wh((e4) => {
              i3.subscribe(e4), t3 = e4;
            }).then(e3);
            return n2.cancel = function() {
              i3.unsubscribe(t3);
            }, n2;
          }, e2(function(e3, n2, r2) {
            i3.reason || (i3.reason = new fA(e3, n2, r2), t2(i3.reason));
          });
        }
        throwIfRequested() {
          if (this.reason)
            throw this.reason;
        }
        subscribe(e2) {
          this.reason ? e2(this.reason) : this._listeners ? this._listeners.push(e2) : this._listeners = [e2];
        }
        unsubscribe(e2) {
          if (!this._listeners)
            return;
          const t2 = this._listeners.indexOf(e2);
          -1 !== t2 && this._listeners.splice(t2, 1);
        }
        toAbortSignal() {
          const e2 = new AbortController(), t2 = (t3) => {
            e2.abort(t3);
          };
          return this.subscribe(t2), e2.signal.unsubscribe = () => this.unsubscribe(t2), e2.signal;
        }
        static source() {
          let e2;
          const t2 = new Rb(function(t3) {
            e2 = t3;
          });
          return { token: t2, cancel: e2 };
        }
      }
      var Cb = Rb;
      const vb = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511 };
      Object.entries(vb).forEach((e2) => {
        let [t2, i3] = e2;
        vb[i3] = t2;
      });
      var Ib = vb;
      const yb = function e2(t2) {
        const i3 = new gb(t2), n2 = og(gb.prototype.request, i3);
        return Xg.extend(n2, gb.prototype, i3, { allOwnKeys: true }), Xg.extend(n2, i3, null, { allOwnKeys: true }), n2.create = function(i4) {
          return e2(AA(t2, i4));
        }, n2;
      }(sA);
      yb.Axios = gb, yb.CanceledError = fA, yb.CancelToken = Cb, yb.isCancel = EA, yb.VERSION = _b, yb.toFormData = nR, yb.AxiosError = Jg, yb.Cancel = yb.CanceledError, yb.all = function(e2) {
        return Wh.all(e2);
      }, yb.spread = function(e2) {
        return function(t2) {
          return e2.apply(null, t2);
        };
      }, yb.isAxiosError = function(e2) {
        return Xg.isObject(e2) && true === e2.isAxiosError;
      }, yb.mergeConfig = AA, yb.AxiosHeaders = pA, yb.formToJSON = (e2) => rA(Xg.isHTMLForm(e2) ? new FormData(e2) : e2), yb.getAdapter = ub.getAdapter, yb.HttpStatusCode = Ib, yb.default = yb;
      var Ab = yb;
      const bb = () => {
      };
      function wb() {
        const e2 = { promise: void 0, isResolved: false, isRejected: false, isFinished: false, resolve: void 0, reject: void 0, cancel: bb };
        return e2.promise = new Wh((t2, i3) => {
          e2.resolve = (i4) => {
            e2.isFinished || (e2.isResolved = true, e2.isFinished = true, t2(i4), e2.value = i4);
          }, e2.reject = (t3) => {
            e2.isFinished || (e2.isRejected = true, e2.isFinished = true, i3(t3));
          };
        }), e2;
      }
      const Ob = /* @__PURE__ */ new Map(), Nb2 = /* @__PURE__ */ new Map(), Db = /* @__PURE__ */ new Map();
      let Pb = function(e2) {
        return e2.WIN_10 = "Windows 10", e2.WIN_81 = "Windows 8.1", e2.WIN_8 = "Windows 8", e2.WIN_7 = "Windows 7", e2.WIN_VISTA = "Windows Vista", e2.WIN_SERVER_2003 = "Windows Server 2003", e2.WIN_XP = "Windows XP", e2.WIN_2000 = "Windows 2000", e2.ANDROID = "Android", e2.HARMONY_OS = "HarmonyOS", e2.OPEN_BSD = "Open BSD", e2.SUN_OS = "Sun OS", e2.LINUX = "Linux", e2.IOS = "iOS", e2.MAC_OS = "Mac OS", e2.CHROMIUM_OS = "Chromium OS", e2.QNX = "QNX", e2.UNIX = "UNIX", e2.BEOS = "BeOS", e2.OS_2 = "OS/2", e2.SEARCH_BOT = "Search Bot", e2;
      }({}), Lb = function(e2) {
        return e2.CHROME = "Chrome", e2.SAFARI = "Safari", e2.EDGE = "Edge", e2.FIREFOX = "Firefox", e2.OPERA = "OPR", e2.QQ = "QQBrowser", e2.WECHAT = "MicroMessenger", e2;
      }({});
      const kb = new AS();
      let Mb = kb.getResult(), Ub = null;
      function xb(e2) {
        if (!Ub) {
          e2 && kb.setUA(e2), Mb = kb.getResult();
          const t2 = function(e3) {
            if ("Blink" === e3.engine.name && "WeChat" !== e3.browser.name)
              return Lb.CHROME;
            switch (e3.browser.name) {
              case "Chrome Headless":
              case "Chrome":
              case "Chromium":
                return Lb.CHROME;
              case "Safari":
              case "Mobile Safari":
                return Lb.SAFARI;
              case "Edge":
                return Lb.EDGE;
              case "Firefox":
                return Lb.FIREFOX;
              case "QQ":
              case "QQBrowser":
                return Lb.QQ;
              case "Opera":
                return Lb.OPERA;
              case "WeChat":
                return Lb.WECHAT;
              default:
                return e3.browser.name || "";
            }
          }(Mb), i3 = Vb(Mb), n2 = function(e3) {
            return "Windows" === e3.os.name ? e3.os.version ? e3.os.name + " " + e3.os.version : e3.os.name : e3.os.name || "";
          }(Mb), r2 = Mb.os.version, o2 = Vb(Mb, false), s2 = Mb.device.type;
          if (!(t2 && i3 && n2 && r2))
            return { name: t2, version: i3, os: n2, osVersion: r2, browserVersion: o2, deviceType: s2 };
          Ub = { name: t2, version: i3, os: n2, osVersion: r2, browserVersion: o2, deviceType: s2 };
        }
        return Ub;
      }
      function Vb(e2) {
        let t2, i3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
        return t2 = "Blink" === e2.engine.name ? e2.engine.version || "" : e2.browser.version || "", i3 ? t2.split(".")[0] : t2;
      }
      function Fb() {
        return xb().os;
      }
      function Bb() {
        const e2 = xb();
        return "".concat(e2.os, " ").concat(e2.osVersion);
      }
      function jb() {
        const e2 = xb();
        return !!("WebKit" === Mb.engine.name && e2.os === Pb.MAC_OS && navigator.maxTouchPoints && navigator.maxTouchPoints > 0 && e2.name !== Lb.SAFARI || Yb() && e2.name !== Lb.SAFARI);
      }
      function Gb() {
        return xb().name === Lb.CHROME;
      }
      function Wb() {
        return xb().name === Lb.SAFARI;
      }
      function Hb() {
        return xb().name === Lb.EDGE;
      }
      function Kb() {
        return xb().name === Lb.FIREFOX;
      }
      function Yb() {
        return xb().os === Pb.IOS;
      }
      function qb(e2) {
        const t2 = xb();
        return !(t2.name !== Lb.CHROME || !t2.osVersion) && Number(t2.version) >= e2;
      }
      function zb(e2) {
        const t2 = xb();
        return !(t2.name !== Lb.CHROME || !t2.osVersion) && Number(t2.version) < e2;
      }
      function Xb(e2) {
        const t2 = xb();
        return !(t2.name !== Lb.EDGE || !t2.osVersion) && Number(t2.version) >= e2;
      }
      function Jb(e2) {
        const t2 = xb();
        return !(t2.name !== Lb.SAFARI || !t2.osVersion) && Number(t2.version) >= e2;
      }
      function Qb(e2, t2, i3) {
        const n2 = xb();
        if (n2.os !== Pb.IOS || !n2.osVersion)
          return false;
        const r2 = n2.osVersion.split(".");
        return i3 ? t2 && Number(r2[0]) === e2 && Number(r2[1]) < t2 || Number(r2[0]) < e2 : t2 ? Number(r2[0]) === e2 && Number(r2[1]) <= t2 || Number(r2[0]) < e2 : Number(r2[0]) <= e2;
      }
      function Zb(e2, t2, i3) {
        const n2 = xb();
        if (n2.name !== Lb.SAFARI || !n2.osVersion || !n2.browserVersion)
          return false;
        const r2 = n2.browserVersion.split(".");
        return i3 ? t2 && Number(r2[0]) === e2 && Number(r2[1]) < t2 || Number(r2[0]) < e2 : t2 ? Number(r2[0]) === e2 && Number(r2[1]) <= t2 || Number(r2[0]) < e2 : Number(r2[0]) <= e2;
      }
      function $b(e2) {
        const t2 = xb();
        return !(t2.name !== Lb.OPERA || !t2.osVersion) && Number(t2.version) >= e2;
      }
      function ew() {
        const e2 = xb();
        if (e2.os !== Pb.IOS || !e2.osVersion)
          return false;
        const t2 = e2.osVersion.split(".");
        return Number(t2[0]) < 14 || 14 === Number(t2[0]) && Number(t2[1]) <= 6;
      }
      function tw() {
        const e2 = xb();
        if (e2.os !== Pb.IOS || !e2.osVersion)
          return false;
        const t2 = e2.osVersion.split(".");
        return 15 === Number(t2[0]);
      }
      function iw() {
        const e2 = xb();
        if (e2.os !== Pb.IOS || !e2.osVersion)
          return false;
        const t2 = e2.osVersion.split(".");
        return 16 === Number(t2[0]);
      }
      function nw() {
        const e2 = xb();
        if (e2.os !== Pb.IOS || !e2.osVersion)
          return false;
        const t2 = e2.osVersion.split(".");
        return 15 === Number(t2[0]) && Number(t2[1]) >= 1;
      }
      function rw() {
        return Wb() && navigator.maxTouchPoints > 0;
      }
      function ow() {
        return xb().name === Lb.WECHAT;
      }
      function sw() {
        return window.navigator.appVersion && null !== window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./) && window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./)[1] <= 35;
      }
      function aw() {
        const e2 = Fb();
        return function() {
          const { deviceType: e3 } = xb();
          return "mobile" === e3 || "tablet" === e3;
        }() || e2 === Pb.ANDROID || e2 === Pb.IOS || e2 === Pb.HARMONY_OS;
      }
      function cw() {
        const e2 = xb();
        return e2.name !== Lb.EDGE && e2.name !== Lb.SAFARI && !!navigator.userAgent.toLocaleLowerCase().match(/chrome\/[\d]./i);
      }
      function dw() {
        return Fb() === Pb.ANDROID;
      }
      function lw() {
        const e2 = xb();
        return dw() && (e2.name === Lb.CHROME || e2.name === Lb.WECHAT || /chrome|chromium/i.test(navigator.userAgent));
      }
      function uw(e2, t2, i3) {
        return (t2 = function(e3) {
          var t3 = function(e4, t4) {
            if ("object" != typeof e4 || !e4)
              return e4;
            var i4 = e4[Symbol.toPrimitive];
            if (void 0 !== i4) {
              var n2 = i4.call(e4, "string");
              if ("object" != typeof n2)
                return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(e4);
          }(e3);
          return "symbol" == typeof t3 ? t3 : t3 + "";
        }(t2)) in e2 ? Object.defineProperty(e2, t2, { value: i3, enumerable: true, configurable: true, writable: true }) : e2[t2] = i3, e2;
      }
      function hw(e2, t2) {
        var i3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i3.push.apply(i3, n2);
        }
        return i3;
      }
      function pw(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i3 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? hw(Object(i3), true).forEach(function(t3) {
            uw(e2, t3, i3[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : hw(Object(i3)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
          });
        }
        return e2;
      }
      let _w = function(e2) {
        return e2.UNEXPECTED_ERROR = "UNEXPECTED_ERROR", e2.UNEXPECTED_RESPONSE = "UNEXPECTED_RESPONSE", e2.TIMEOUT = "TIMEOUT", e2.INVALID_PARAMS = "INVALID_PARAMS", e2.NOT_READABLE = "NOT_READABLE", e2.NOT_SUPPORTED = "NOT_SUPPORTED", e2.INVALID_OPERATION = "INVALID_OPERATION", e2.OPERATION_ABORTED = "OPERATION_ABORTED", e2.WEB_SECURITY_RESTRICT = "WEB_SECURITY_RESTRICT", e2.EXCHANGE_SDP_FAILED = "EXCHANGE_SDP_FAILED", e2.ADD_CANDIDATE_FAILED = "ADD_CANDIDATE_FAILED", e2.DATACHANNEL_FAILED = "DATACHANNEL_FAILED", e2.NETWORK_ERROR = "NETWORK_ERROR", e2.NETWORK_TIMEOUT = "NETWORK_TIMEOUT", e2.NETWORK_RESPONSE_ERROR = "NETWORK_RESPONSE_ERROR", e2.API_INVOKE_TIMEOUT = "API_INVOKE_TIMEOUT", e2.ENUMERATE_DEVICES_FAILED = "ENUMERATE_DEVICES_FAILED", e2.DEVICE_NOT_FOUND = "DEVICE_NOT_FOUND", e2.ELECTRON_IS_NULL = "ELECTRON_IS_NULL", e2.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR = "ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR", e2.CHROME_PLUGIN_NO_RESPONSE = "CHROME_PLUGIN_NO_RESPONSE", e2.CHROME_PLUGIN_NOT_INSTALL = "CHROME_PLUGIN_NOT_INSTALL", e2.MEDIA_OPTION_INVALID = "MEDIA_OPTION_INVALID", e2.PERMISSION_DENIED = "PERMISSION_DENIED", e2.CONSTRAINT_NOT_SATISFIED = "CONSTRAINT_NOT_SATISFIED", e2.TRACK_IS_DISABLED = "TRACK_IS_DISABLED", e2.GET_VIDEO_ELEMENT_VISIBLE_ERROR = "GET_VIDEO_ELEMENT_VISIBLE_ERROR", e2.SHARE_AUDIO_NOT_ALLOWED = "SHARE_AUDIO_NOT_ALLOWED", e2.LOW_STREAM_ENCODING_ERROR = "LOW_STREAM_ENCODING_ERROR", e2.SET_ENCODING_PARAMETER_ERROR = "SET_ENCODING_PARAMETER_ERROR", e2.TRACK_STATE_UNREACHABLE = "TRACK_STATE_UNREACHABLE", e2.INVALID_UINT_UID_FROM_STRING_UID = "INVALID_UINT_UID_FROM_STRING_UID", e2.CAN_NOT_GET_PROXY_SERVER = "CAN_NOT_GET_PROXY_SERVER", e2.CAN_NOT_GET_GATEWAY_SERVER = "CAN_NOT_GET_GATEWAY_SERVER", e2.VOID_GATEWAY_ADDRESS = "VOID_GATEWAY_ADDRESS", e2.UID_CONFLICT = "UID_CONFLICT", e2.MULTI_UNILBS_RESPONSE_ERROR = "MULTI_UNILBS_RESPONSE_ERROR", e2.UPDATE_TICKET_FAILED = "UPDATE_TICKET_FAILED", e2.TOKEN_EXPIRE = "TOKEN_EXPIRE", e2.INVALID_LOCAL_TRACK = "INVALID_LOCAL_TRACK", e2.INVALID_TRACK = "INVALID_TRACK", e2.SENDER_NOT_FOUND = "SENDER_NOT_FOUND", e2.CREATE_OFFER_FAILED = "CREATE_OFFER_FAILED", e2.SET_ANSWER_FAILED = "SET_ANSWER_FAILED", e2.ICE_FAILED = "ICE_FAILED", e2.PC_CLOSED = "PC_CLOSED", e2.SENDER_REPLACE_FAILED = "SENDER_REPLACE_FAILED", e2.GET_LOCAL_CAPABILITIES_FAILED = "GET_LOCAL_CAPABILITIES_FAILED", e2.GET_LOCAL_CONNECTION_PARAMS_FAILED = "GET_LOCAL_CONNECTION_PARAMS_FAILED", e2.SUBSCRIBE_FAILED = "SUBSCRIBE_FAILED", e2.UNSUBSCRIBE_FAILED = "UNSUBSCRIBE_FAILED", e2.GATEWAY_P2P_LOST = "GATEWAY_P2P_LOST", e2.NO_ICE_CANDIDATE = "NO_ICE_CANDIDATE", e2.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS = "CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS", e2.EXIST_DISABLED_VIDEO_TRACK = "EXIST_DISABLED_VIDEO_TRACK", e2.INVALID_REMOTE_USER = "INVALID_REMOTE_USER", e2.REMOTE_USER_IS_NOT_PUBLISHED = "REMOTE_USER_IS_NOT_PUBLISHED", e2.CUSTOM_REPORT_SEND_FAILED = "CUSTOM_REPORT_SEND_FAILED", e2.CUSTOM_REPORT_FREQUENCY_TOO_HIGH = "CUSTOM_REPORT_FREQUENCY_TOO_HIGH", e2.FETCH_AUDIO_FILE_FAILED = "FETCH_AUDIO_FILE_FAILED", e2.READ_LOCAL_AUDIO_FILE_ERROR = "READ_LOCAL_AUDIO_FILE_ERROR", e2.DECODE_AUDIO_FILE_FAILED = "DECODE_AUDIO_FILE_FAILED", e2.WS_ABORT = "WS_ABORT", e2.WS_DISCONNECT = "WS_DISCONNECT", e2.WS_ERR = "WS_ERR", e2.EXTERNAL_SIGNAL_ABORT = "EXTERNAL_SIGNAL_ABORT", e2.LIVE_STREAMING_TASK_CONFLICT = "LIVE_STREAMING_TASK_CONFLICT", e2.LIVE_STREAMING_INVALID_ARGUMENT = "LIVE_STREAMING_INVALID_ARGUMENT", e2.LIVE_STREAMING_INTERNAL_SERVER_ERROR = "LIVE_STREAMING_INTERNAL_SERVER_ERROR", e2.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED = "LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED", e2.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED = "LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED", e2.LIVE_STREAMING_CDN_ERROR = "LIVE_STREAMING_CDN_ERROR", e2.LIVE_STREAMING_INVALID_RAW_STREAM = "LIVE_STREAMING_INVALID_RAW_STREAM", e2.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT = "LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT", e2.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE = "LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE", e2.LIVE_STREAMING_WARN_FREQUENT_REQUEST = "LIVE_STREAMING_WARN_FREQUENT_REQUEST", e2.WEBGL_INTERNAL_ERROR = "WEBGL_INTERNAL_ERROR", e2.BEAUTY_PROCESSOR_INTERNAL_ERROR = "BEAUTY_PROCESSOR_INTERNAL_ERROR", e2.CROSS_CHANNEL_WAIT_STATUS_ERROR = "CROSS_CHANNEL_WAIT_STATUS_ERROR", e2.CROSS_CHANNEL_FAILED_JOIN_SRC = "CROSS_CHANNEL_FAILED_JOIN_SEC", e2.CROSS_CHANNEL_FAILED_JOIN_DEST = "CROSS_CHANNEL_FAILED_JOIN_DEST", e2.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST = "CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST", e2.CROSS_CHANNEL_SERVER_ERROR_RESPONSE = "CROSS_CHANNEL_SERVER_ERROR_RESPONSE", e2.METADATA_OUT_OF_RANGE = "METADATA_OUT_OF_RANGE", e2.LOCAL_AEC_ERROR = "LOCAL_AEC_ERROR", e2.INVALID_PLUGIN = "INVALID_PLUGIN", e2.DISCONNECT_P2P = "DISCONNECT_P2P", e2.CONVERTING_IMAGEDATA_TO_BLOB_FAILED = "CONVERTING_IMAGEDATA_TO_BLOB_FAILED", e2.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED = "CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED", e2.INIT_DATACHANNEL_TIMEOUT = "INIT_DATACHANNEL_TIMEOUT", e2.CREATE_DATACHANNEL_ERROR = "CREATE_DATACHANNEL_ERROR", e2.DATACHANNEL_CONNECTION_TIMEOUT = "DATACHANNEL_CONNECTION_TIMEOUT", e2.PROHIBITED_OPERATION = "PROHIBITED_OPERATION", e2.IMAGE_MODERATION_UPLOAD_FAILED = "IMAGE_MODERATION_UPLOAD_FAILED", e2.P2P_MESSAGE_FAILED = "P2P_MESSAGE_FAILED", e2;
      }({});
      class Ew extends Error {
        constructor(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "", i3 = arguments.length > 2 ? arguments[2] : void 0;
          super(t2), uw(this, "code", void 0), uw(this, "message", void 0), uw(this, "data", void 0), uw(this, "name", "AgoraRTCException"), this.code = e2, this.message = "AgoraRTCError ".concat(this.code, ": ").concat(t2), this.data = i3;
        }
        toString() {
          return this.data ? "".concat(this.message, "\ndata: ").concat(JSON.stringify(this.data)) : this.message;
        }
        print() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "error", t2 = arguments.length > 1 ? arguments[1] : void 0;
          return "error" === e2 && (t2 || console).error(this.toString()), "warning" === e2 && (t2 || console).warn(this.toString()), this;
        }
        throw(e2) {
          throw this.print("error", e2), this;
        }
      }
      function fw(e2, t2) {
        if ("boolean" != typeof e2)
          throw new Ew(_w.INVALID_PARAMS, "Invalid ".concat(t2, ": The value is of the boolean type."));
      }
      function mw(e2, t2, i3) {
        if (!Dn(i3).call(i3, e2))
          throw new Ew(_w.INVALID_PARAMS, "".concat(t2, " can only be set as ").concat(JSON.stringify(i3)));
      }
      function Tw(e2, t2) {
        let i3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e4;
        if (e2 < i3 || e2 > n2 || (!(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4]) && !function(e3) {
          return "number" == typeof e3 && e3 % 1 == 0;
        }(e2))
          throw new Ew(_w.INVALID_PARAMS, "invalid ".concat(t2, ": the value range is [").concat(i3, ", ").concat(n2, "]. integer only"));
      }
      function Sw(e2, t2) {
        if ("number" != typeof e2) {
          if (!(e2.min || e2.max || e2.ideal || e2.exact))
            throw new Ew(_w.INVALID_PARAMS, "".concat(t2, " is not a valid ConstrainLong"));
          void 0 !== e2.min && Tw(e2.min, "".concat(t2, ".min"), 0, 1 / 0), void 0 !== e2.max && Tw(e2.max, "".concat(t2, ".max"), 1, 1 / 0), void 0 !== e2.exact && Tw(e2.exact, "".concat(t2, ".exact"), 1, 1 / 0), void 0 !== e2.ideal && Tw(e2.ideal, "".concat(t2, ".ideal"), 1, 1 / 0);
        } else
          Tw(e2, t2, 1, 1 / 0);
      }
      function gw(e2, t2) {
        let i3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 255, r2 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];
        if (null == e2)
          throw new Ew(_w.INVALID_PARAMS, "".concat(t2 || "param", " cannot be empty"));
        if (!vw(e2, i3, n2, r2))
          throw new Ew(_w.INVALID_PARAMS, "Invalid ".concat(t2 || "string param", ": Length of the string: [").concat(i3, ",").concat(n2, "].").concat(r2 ? " ASCII characters only." : ""));
      }
      function Rw(e2, t2) {
        if (!Array.isArray(e2))
          throw new Ew(_w.INVALID_PARAMS, "".concat(t2, " should be an array"));
      }
      function Cw(e2) {
        return null == e2;
      }
      function vw(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, i3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 255, n2 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
        return "string" == typeof e2 && e2.length <= i3 && e2.length >= t2 && (!n2 || function(e3) {
          if ("string" != typeof e3)
            return false;
          for (let t3 = 0; t3 < e3.length; t3 += 1) {
            const i4 = e3.charCodeAt(t3);
            if (i4 < 0 || i4 > 255)
              return false;
          }
          return true;
        }(e2));
      }
      var Iw = function(e2) {
        return e2.COVERED = "COVERED", e2.POSITION = "POSITION", e2.SIZE = "SIZE", e2.STYLE = "STYLE", e2;
      }(Iw || {}), yw = function(e2) {
        return e2.UNMOUNTED = "UNMOUNTED", e2.INVALID_HTML_ELEMENT = "INVALID_HTML_ELEMENT", e2;
      }(yw || {});
      const Aw = new class {
        constructor() {
          uw(this, "_clientSize", null), uw(this, "getClientWidth", () => document.documentElement ? document.documentElement.clientWidth : document.body.clientWidth), uw(this, "getClientHeight", () => document.documentElement ? document.documentElement.clientHeight : document.body.clientHeight), uw(this, "getStyle", (e2) => window.getComputedStyle(e2, null)), uw(this, "checkCssVisibleProperty", (e2) => {
            var t2;
            let i3 = true;
            const n2 = this.getStyle(e2), { display: r2, visibility: o2, opacity: s2, filter: a2 } = n2;
            return ("none" === r2 || Dn(t2 = ["hidden", "collapse"]).call(t2, o2) || Number(s2) < 0.1) && (i3 = false), !!i3 && (a2 && a2.split(" ").filter((e3) => {
              var t3;
              const i4 = e3.split("(")[0];
              return Dn(t3 = ["brightness", "blur", "opacity"]).call(t3, i4);
            }).map((e3) => {
              const [t3, i4] = e3.split(/\(|\)/);
              return [t3, Number(i4.match(/^[0-9\.]+/))];
            }).forEach((e3) => {
              const [t3, n3] = e3;
              switch (t3) {
                case "brightness":
                  (n3 < 0.1 || n3 > 3) && (i3 = false);
                  break;
                case "blur":
                  n3 > 3 && (i3 = false);
                  break;
                case "opacity":
                  n3 < 0.1 && (i3 = false);
              }
            }), i3);
          }), uw(this, "checkPropertyUpToAllParentNodes", (e2, t2) => {
            let i3 = true, n2 = true;
            const r2 = (e3) => t2(e3);
            let o2 = e2;
            for (; o2 && n2; )
              r2(o2) || (i3 = false, n2 = false), o2 = o2.parentElement, o2 || (n2 = false);
            return i3;
          }), uw(this, "checkActualCssVisibleIncludeInherit", (e2) => this.checkPropertyUpToAllParentNodes(e2, this.checkCssVisibleProperty)), uw(this, "getSizeAboutClient", (e2) => {
            const { width: t2, height: i3, left: n2, right: r2, top: o2, bottom: s2 } = e2.getBoundingClientRect(), a2 = this.getClientWidth(), c2 = this.getClientHeight();
            return { width: t2, height: i3, left: n2, right: r2, top: o2, bottom: s2, clientWidth: a2, clientHeight: c2, clientMin: Math.min(a2, c2) };
          }), uw(this, "checkActualSize", () => {
            const { width: e2, height: t2, clientMin: i3 } = this._clientSize;
            return this.checkSizeIsVisible(e2, t2, i3);
          }), uw(this, "elementFromPoint", (e2, t2) => document.elementFromPoint ? document.elementFromPoint(e2, t2) : null), uw(this, "checkCoverForAPoint", (e2, t2, i3) => {
            const n2 = this.elementFromPoint(e2, t2);
            return null !== n2 && n2 !== i3;
          }), uw(this, "getPointPositionList", () => {
            const { width: e2, height: t2, left: i3, top: n2 } = this._clientSize, r2 = e2 / 6, o2 = t2 / 6, s2 = [], a2 = 10 ** 6;
            for (let e3 = 0; e3 < 5; e3++)
              for (let t3 = 0; t3 < 5; t3++) {
                const c2 = (i3 * a2 + (0 === e3 ? 0.1 : 4 === e3 ? (r2 * e3 * a2 - 1e5) / a2 : r2 * e3) * a2) / a2, d2 = (n2 * a2 + (0 === t3 ? 0.1 : 4 === t3 ? (o2 * t3 * a2 - 1e5) / a2 : o2 * t3) * a2) / a2;
                s2.push({ x: c2, y: d2 });
              }
            return [...s2];
          }), uw(this, "checkElementCover", (e2) => this.getPointPositionList().map((t2) => this.checkCoverForAPoint(t2.x, t2.y, e2)).filter((e3) => !!e3).length > 6), uw(this, "checkSizeIsVisible", (e2, t2, i3) => (e2 > 50 || i3 / e2 <= 10) && (t2 > 50 || i3 / t2 <= 10)), uw(this, "checkSizeOfPartInClient", () => {
            const { left: e2, right: t2, top: i3, bottom: n2, clientHeight: r2, clientWidth: o2, clientMin: s2 } = this._clientSize;
            let a2, c2, d2, l2;
            if (e2 < 0)
              a2 = 0;
            else {
              if (!(e2 < o2))
                return false;
              a2 = e2;
            }
            if (t2 < 0)
              return false;
            if (c2 = t2 < o2 ? t2 : o2, i3 < 0)
              d2 = 0;
            else {
              if (!(i3 < r2))
                return false;
              d2 = i3;
            }
            if (n2 < 0)
              return false;
            l2 = n2 < r2 ? n2 : r2;
            const u2 = c2 - a2, h2 = l2 - d2;
            return this.checkSizeIsVisible(u2, h2, s2);
          }), uw(this, "returnHiddenResult", (e2) => (this._clientSize = null, { visible: false, reason: e2 })), uw(this, "checkOneElementVisible", (e2) => {
            if (e2 instanceof HTMLElement) {
              if (this.checkElementIsMountedOnDom(e2)) {
                if (this.checkActualCssVisibleIncludeInherit(e2)) {
                  if (this._clientSize = this.getSizeAboutClient(e2), this.checkElementCover(e2))
                    return this.returnHiddenResult(Iw.COVERED);
                  {
                    const e3 = this.checkActualSize(), t2 = this.checkSizeOfPartInClient();
                    return e3 && !t2 ? this.returnHiddenResult(Iw.POSITION) : e3 ? (this._clientSize = null, { visible: true }) : this.returnHiddenResult(Iw.SIZE);
                  }
                }
                return this.returnHiddenResult(Iw.STYLE);
              }
              return this.returnHiddenResult(yw.UNMOUNTED);
            }
            return this.returnHiddenResult(yw.INVALID_HTML_ELEMENT);
          }), uw(this, "checkElementIsMountedOnDom", (e2) => this.checkPropertyUpToAllParentNodes(e2, (e3) => "HTML" !== e3.nodeName.toUpperCase() ? null !== e3.parentElement : !!document.documentElement));
        }
      }();
      function bw(e2) {
        return new TextEncoder().encode(e2);
      }
      const ww = function(e2, t2) {
        const i3 = new Uint8Array(e2.byteLength + t2.byteLength);
        return i3.set(new Uint8Array(e2), 0), i3.set(new Uint8Array(t2), e2.byteLength), i3;
      };
      const Ow = async (e2) => function(e3, t2) {
        let i3 = "";
        return new Uint8Array(e3).forEach((e4) => {
          i3 += e4.toString(t2).padStart(2, "0");
        }), i3;
      }(await crypto.subtle.digest("SHA-256", bw(e2)), 16);
      let Nw = class {
        constructor() {
          uw(this, "_events", {}), uw(this, "addListener", this.on);
        }
        getListeners(e2) {
          return this._events[e2] ? this._events[e2].map((e3) => e3.listener) : [];
        }
        on(e2, t2) {
          this._events[e2] || (this._events[e2] = []);
          const i3 = this._events[e2];
          -1 === this._indexOfListener(i3, t2) && i3.push({ listener: t2, once: false });
        }
        once(e2, t2) {
          this._events[e2] || (this._events[e2] = []);
          const i3 = this._events[e2];
          -1 === this._indexOfListener(i3, t2) && i3.push({ listener: t2, once: true });
        }
        off(e2, t2) {
          if (!this._events[e2])
            return;
          const i3 = this._events[e2], n2 = this._indexOfListener(i3, t2);
          -1 !== n2 && i3.splice(n2, 1), 0 === this._events[e2].length && delete this._events[e2];
        }
        removeAllListeners(e2) {
          e2 ? delete this._events[e2] : this._events = {};
        }
        emit(e2) {
          this._events[e2] || (this._events[e2] = []);
          const t2 = this._events[e2].map((e3) => e3);
          for (var i3 = arguments.length, n2 = new Array(i3 > 1 ? i3 - 1 : 0), r2 = 1; r2 < i3; r2++)
            n2[r2 - 1] = arguments[r2];
          for (let i4 = 0; i4 < t2.length; i4 += 1) {
            const r3 = t2[i4];
            r3.once && this.off(e2, r3.listener), r3.listener.apply(this, n2 || []);
          }
        }
        safeEmit(e2) {
          for (var t2 = arguments.length, i3 = new Array(t2 > 1 ? t2 - 1 : 0), n2 = 1; n2 < t2; n2++)
            i3[n2 - 1] = arguments[n2];
          [...this._events[e2] || []].forEach((t3) => {
            t3.once && this.off(e2, t3.listener);
            try {
              t3.listener.apply(this, i3);
            } catch (t4) {
              console.error("safeEmit event:".concat(e2, " error ").concat(null == t4 ? void 0 : t4.toString()));
            }
          });
        }
        _indexOfListener(e2, t2) {
          let i3 = e2.length;
          for (; i3--; )
            if (e2[i3].listener === t2)
              return i3;
          return -1;
        }
      };
      let Dw = null;
      function Pw() {
        if (Dw)
          return Dw;
        if (window.electron)
          return Dw = window.electron;
        if (!window.require)
          return null;
        try {
          return Dw = window.require("electron"), Dw;
        } catch (e2) {
          return null;
        }
      }
      let Lw = function(e2) {
        return e2.CREATE_CLIENT = "createClient", e2.CHECK_SYSTEM_REQUIREMENTS = "checkSystemRequirements", e2.SET_AREA = "setArea", e2.PRELOAD = "PRELOAD", e2.CHECK_VIDEO_TRACK_IS_ACTIVE = "checkVideoTrackIsActive", e2.CHECK_AUDIO_TRACK_IS_ACTIVE = "checkAudioTrackIsActive", e2.CREATE_MIC_AUDIO_TRACK = "createMicrophoneAudioTrack", e2.CREATE_CUSTOM_AUDIO_TRACK = "createCustomAudioTrack", e2.CREATE_BUFFER_AUDIO_TRACK = "createBufferSourceAudioTrack", e2.CREATE_CAM_VIDEO_TRACK = "createCameraVideoTrack", e2.CREATE_CUSTOM_VIDEO_TRACK = "createCustomVideoTrack", e2.CREATE_MIC_AND_CAM_TRACKS = "createMicrophoneAndCameraTracks", e2.CREATE_SCREEN_VIDEO_TRACK = "createScreenVideoTrack", e2.SET_ENCRYPTION_CONFIG = "Client.setEncryptionConfig", e2.START_PROXY_SERVER = "Client.startProxyServer", e2.STOP_PROXY_SERVER = "Client.stopProxyServer", e2.SET_PROXY_SERVER = "Client.setProxyServer", e2.SET_TURN_SERVER = "Client.setTurnServer", e2.SET_CLIENT_ROLE = "Client.setClientRole", e2.SET_LOW_STREAM_PARAMETER = "Client.setLowStreamParameter", e2.ENABLE_DUAL_STREAM = "Client.enableDualStream", e2.DISABLE_DUAL_STREAM = "Client.disableDualStream", e2.JOIN = "Client.join", e2.LEAVE = "Client.leave", e2.PUBLISH = "Client.publish", e2.UNPUBLISH = "Client.unpublish", e2.SUBSCRIBE = "Client.subscribe", e2.MASS_SUBSCRIBE = "Client.massSubscribe", e2.MASS_UNSUBSCRIBE = "Client.massUnsubscribe", e2.UNSUBSCRIBE = "Client.unsubscribe", e2.RENEW_TOKEN = "Client.renewToken", e2.SET_REMOTE_VIDEO_STREAM_TYPE = "Client.setRemoteVideoStreamType", e2.SET_STREAM_FALLBACK_OPTION = "Client.setStreamFallbackOption", e2.ENABLE_AUDIO_VOLUME_INDICATOR = "Client.enableAudioVolumeIndicator", e2.SEND_CUSTOM_REPORT_MESSAGE = "Client.sendCustomReportMessage", e2.INSPECT_VIDEO_CONTENT = "Client.inspectVideoContent", e2.STOP_INSPECT_VIDEO_CONTENT = "Client.stopInspectVideoContent", e2.JOIN_FALLBACK_TO_PROXY = "Client._joinFallbackToProxy", e2.ON_LIVE_STREAM_WARNING = "Client.onLiveStreamWarning", e2.ON_LIVE_STREAM_ERROR = "Client.onLiveStreamingError", e2.START_LIVE_STREAMING = "Client.startLiveStreaming", e2.SET_LIVE_TRANSCODING = "Client.setLiveTranscoding", e2.STOP_LIVE_STREAMING = "Client.stopLiveStreaming", e2.START_CHANNEL_MEDIA_RELAY = "Client.startChannelMediaRelay", e2.UPDATE_CHANNEL_MEDIA_RELAY = "Client.updateChannelMediaRelay", e2.STOP_CHANNEL_MEDIA_RELAY = "Client.stopChannelMediaRelay", e2.REQUEST_CONFIG_DISTRIBUTE = "_config-distribute-request", e2.SET_CONFIG_DISTRIBUTE = "_configDistribute", e2.LOCAL_TRACK_SET_MUTED = "LocalTrack.setMute", e2.LOCAL_AUDIO_TRACK_PLAY = "LocalAudioTrack.play", e2.LOCAL_AUDIO_TRACK_PLAY_IN_ELEMENT = "LocalAudioTrack.playInElement", e2.LOCAL_AUDIO_TRACK_STOP = "LocalAudioTrack.stop", e2.LOCAL_AUDIO_TRACK_SET_VOLUME = "LocalAudioTrack.setVolume", e2.MIC_AUDIO_TRACK_SET_DEVICE = "MicrophoneAudioTrack.setDevice", e2.BUFFER_AUDIO_TRACK_START = "BufferSourceAudioTrack.startProcessAudioBuffer", e2.BUFFER_AUDIO_TRACK_STOP = "BufferSourceAudioTrack.stopProcessAudioBuffer", e2.BUFFER_AUDIO_TRACK_PAUSE = "BufferSourceAudioTrack.pauseProcessAudioBuffer", e2.BUFFER_AUDIO_TRACK_RESUME = "BufferSourceAudioTrack.resumeProcessAudioBuffer", e2.BUFFER_AUDIO_TRACK_SEEK = "BufferSourceAudioTrack.seekAudioBuffer", e2.LOCAL_VIDEO_TRACK_PLAY = "LocalVideoTrack.play", e2.LOCAL_VIDEO_TRACK_STOP = "LocalVideoTrack.stop", e2.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE = "LocalVideoTrack.getVideoElementVisibleStatus", e2.LOCAL_VIDEO_TRACK_BEAUTY = "LocalVideoTrack.setBeautyEffect", e2.LOCAL_VIDEO_SEND_SEI_DATA = "LocalVideoTrack.sendSeiData", e2.CAM_VIDEO_TRACK_SET_DEVICE = "CameraVideoTrack.setDevice", e2.CAM_VIDEO_TRACK_SET_ENCODER_CONFIG = "CameraVideoTrack.setEncoderConfiguration", e2.REMOTE_VIDEO_TRACK_PLAY = "RemoteVideoTrack.play", e2.REMOTE_VIDEO_TRACK_STOP = "RemoteVideoTrack.stop", e2.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE = "RemoteVideoTrack.getVideoElementVisibleStatus", e2.REMOTE_AUDIO_TRACK_PLAY = "RemoteAudioTrack.play", e2.REMOTE_AUDIO_TRACK_STOP = "RemoteAudioTrack.stop", e2.REMOTE_AUDIO_SET_VOLUME = "RemoteAudioTrack.setVolume", e2.REMOTE_AUDIO_SET_OUTPUT_DEVICE = "RemoteAudioTrack.setOutputDevice", e2.GET_MEDIA_STREAM_TRACK = "Track.getMediaStreamTrack", e2.STREAM_TYPE_CHANGE = "streamTypeChange", e2.CONNECTION_STATE_CHANGE = "connectionStateChange", e2.LOAD_CONFIG_FROM_LOCALSTORAGE = "loadConfigFromLocalStorage", e2.IMAGE_MODERATION_UPLOAD = "imageModerationUpload", e2.REPUB_AFTER_PC_CONNECTED = "repubAfterPCConnected", e2;
      }({}), kw = function(e2) {
        return e2.TRACER = "tracer", e2;
      }({});
      function Mw(e2) {
        return Tw(e2.timeout, "config.timeout", 0, 1e5), Tw(e2.timeoutFactor, "config.timeoutFactor", 0, 100, false), Tw(e2.maxRetryCount, "config.maxRetryConfig", 0, 1 / 0), Tw(e2.maxRetryTimeout, "config.maxRetryTimeout", 0, 1 / 0), true;
      }
      let Uw = function(e2) {
        return e2[e2.AUDIENCE_LEVEL_LOW_LATENCY = 1] = "AUDIENCE_LEVEL_LOW_LATENCY", e2[e2.AUDIENCE_LEVEL_ULTRA_LOW_LATENCY = 2] = "AUDIENCE_LEVEL_ULTRA_LOW_LATENCY", e2[e2.AUDIENCE_LEVEL_SYNC_LATENCY = 3] = "AUDIENCE_LEVEL_SYNC_LATENCY", e2;
      }({}), xw = function(e2) {
        return e2.LEAVE = "LEAVE", e2.NETWORK_ERROR = "NETWORK_ERROR", e2.SERVER_ERROR = "SERVER_ERROR", e2.UID_BANNED = "UID_BANNED", e2.FALLBACK = "FALLBACK", e2.IP_BANNED = "IP_BANNED", e2.CHANNEL_BANNED = "CHANNEL_BANNED", e2.LICENSE_MISSING = "LICENSE_MISSING", e2.LICENSE_EXPIRED = "LICENSE_EXPIRED", e2.LICENSE_MINUTES_EXCEEDED = "LICENSE_MINUTES_EXCEEDED", e2.LICENSE_PERIOD_INVALID = "LICENSE_PERIOD_INVALID", e2.LICENSE_MULTIPLE_SDK_SERVICE = "LICENSE_MULTIPLE_SDK_SERVICE", e2.LICENSE_ILLEGAL = "LICENSE_ILLEGAL", e2.TOKEN_EXPIRE = "TOKEN_EXPIRE", e2;
      }({});
      function Vw(e2) {
        if (!Array.isArray(e2) || e2.length < 1)
          return false;
        try {
          e2.forEach((e3) => {
            if (!e3.urls)
              throw Error();
          });
        } catch (e3) {
          return false;
        }
        return true;
      }
      function Fw(e2) {
        return gw(e2.turnServerURL, "turnServerURL"), gw(e2.username, "username"), gw(e2.password, "password"), e2.udpport && Tw(e2.udpport, "udpport", 1, 99999, true), e2.forceturn && fw(e2.forceturn, "forceturn"), e2.security && fw(e2.security, "security"), e2.tcpport && Tw(e2.tcpport, "tcpport", 1, 99999, true), true;
      }
      function Bw(e2) {
        return void 0 !== e2.level && mw(e2.level, "level", [1, 2, 3]), void 0 !== e2.delay && Tw(e2.delay, "delay", 0, 3e3, true), true;
      }
      let jw = function(e2) {
        return e2.PEERCONNECTION_STATE_CHANGE = "peerconnection-state-change", e2.CONNECTION_STATE_CHANGE = "connection-state-change", e2.MEDIA_RECONNECT_START = "media-reconnect-start", e2.MEDIA_RECONNECT_END = "media-reconnect-end", e2.IS_USING_CLOUD_PROXY = "is-using-cloud-proxy", e2.USER_JOINED = "user-joined", e2.USER_LEAVED = "user-left", e2.USER_PUBLISHED = "user-published", e2.USER_UNPUBLISHED = "user-unpublished", e2.USER_INFO_UPDATED = "user-info-updated", e2.CLIENT_BANNED = "client-banned", e2.CHANNEL_MEDIA_RELAY_STATE = "channel-media-relay-state", e2.CHANNEL_MEDIA_RELAY_EVENT = "channel-media-relay-event", e2.VOLUME_INDICATOR = "volume-indicator", e2.CRYPT_ERROR = "crypt-error", e2.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = "token-privilege-will-expire", e2.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "token-privilege-did-expire", e2.NETWORK_QUALITY = "network-quality", e2.STREAM_TYPE_CHANGED = "stream-type-changed", e2.STREAM_FALLBACK = "stream-fallback", e2.RECEIVE_METADATA = "receive-metadata", e2.STREAM_MESSAGE = "stream-message", e2.LIVE_STREAMING_ERROR = "live-streaming-error", e2.LIVE_STREAMING_WARNING = "live-streaming-warning", e2.EXCEPTION = "exception", e2.ERROR = "error", e2.P2P_LOST = "p2p_lost", e2.JOIN_FALLBACK_TO_PROXY = "join-fallback-to-proxy", e2.CHANNEL_FALLBACK_TO_WEBSOCKET = "channel-fallback-to-websocket", e2.MEDIA_CONNECTION_TYPE_CHANGE = "media-connection-type-change", e2.PUBLISHED_USER_LIST = "published-user-list", e2.CONTENT_INSPECT_CONNECTION_STATE_CHANGE = "content-inspect-connection-state-change", e2.CONTENT_INSPECT_ERROR = "content-inspect-error", e2.CONTENT_INSPECT_RESULT = "content-inspect-result", e2.IMAGE_MODERATION_CONNECTION_STATE_CHANGE = "image-moderation-connection-state-change", e2;
      }({}), Gw = function(e2) {
        return e2.NETWORK_ERROR = "NETWORK_ERROR", e2.SERVER_ERROR = "SERVER_ERROR", e2.MULTI_IP = "MULTI_IP", e2.TIMEOUT = "TIMEOUT", e2.OFFLINE = "OFFLINE", e2.LEAVE = "LEAVE", e2.P2P_FAILED = "P2P_FAILED", e2.FALLBACK = "FALLBACK", e2.REGIONAL_DISTRIBUTION = "REGIONAL_DISTRIBUTION", e2;
      }({}), Ww = function(e2) {
        return e2.ONLINE = "ONLINE", e2.OFFLINE = "OFFLINE", e2;
      }({}), Hw = function(e2) {
        return e2.NETWORK_STATE_CHANGE = "NETWORK_STATE_CHANGE", e2.ONLINE = "ONLINE", e2.OFFLINE = "OFFLINE", e2;
      }({});
      function Kw(e2, t2) {
        for (var i3 = arguments.length, n2 = new Array(i3 > 2 ? i3 - 2 : 0), r2 = 2; r2 < i3; r2++)
          n2[r2 - 2] = arguments[r2];
        return 0 === e2.getListeners(t2).length ? Wh.reject(new Ew(_w.UNEXPECTED_ERROR, "can not emit promise")) : new Wh((i4, r3) => {
          e2.emit(t2, ...n2, i4, r3);
        });
      }
      function Yw(e2, t2) {
        if (0 === e2.getListeners(t2).length)
          return Wh.resolve();
        for (var i3 = arguments.length, n2 = new Array(i3 > 2 ? i3 - 2 : 0), r2 = 2; r2 < i3; r2++)
          n2[r2 - 2] = arguments[r2];
        return Kw(e2, t2, ...n2);
      }
      function qw(e2, t2) {
        if (0 === e2.getListeners(t2).length)
          return null;
        for (var i3 = arguments.length, n2 = new Array(i3 > 2 ? i3 - 2 : 0), r2 = 2; r2 < i3; r2++)
          n2[r2 - 2] = arguments[r2];
        return zw(e2, t2, ...n2);
      }
      function zw(e2, t2) {
        let i3 = null, n2 = null;
        for (var r2 = arguments.length, o2 = new Array(r2 > 2 ? r2 - 2 : 0), s2 = 2; s2 < r2; s2++)
          o2[s2 - 2] = arguments[s2];
        if (e2.emit(t2, ...o2, (e3) => {
          i3 = e3;
        }, (e3) => {
          n2 = e3;
        }), null !== n2)
          throw n2;
        if (null === i3)
          throw new Ew(_w.UNEXPECTED_ERROR, "handler is not sync");
        return i3;
      }
      const Xw = new class extends Nw {
        set networkState(e2) {
          this.emit(Hw.NETWORK_STATE_CHANGE, e2, this._networkState), e2 === Ww.ONLINE ? this.emit(Hw.ONLINE) : e2 === Ww.OFFLINE && (this.onlineWaiter = new Wh((e3) => {
            this.once(Hw.ONLINE, () => {
              this.onlineWaiter = void 0, e3(Ww.ONLINE);
            });
          }), this.emit(Hw.OFFLINE)), this._networkState = e2;
        }
        get networkState() {
          return this._networkState;
        }
        get isOnline() {
          return this._networkState === Ww.ONLINE;
        }
        constructor() {
          super(), uw(this, "_moduleName", "network-indicator"), uw(this, "_networkState", Ww.ONLINE), uw(this, "onlineWaiter", void 0), window.addEventListener("online", () => {
            this.networkState = Ww.ONLINE;
          }), window.addEventListener("offline", () => {
            this.networkState = Ww.OFFLINE;
          });
        }
      }();
      function Jw(e2, t2) {
        const i3 = e2.indexOf(t2);
        -1 !== i3 && e2.splice(i3, 1);
      }
      function Qw(e2) {
        const t2 = [];
        return e2.forEach((e3) => {
          -1 === t2.indexOf(e3) && t2.push(e3);
        }), t2;
      }
      function Zw(e2) {
        void 0 !== Wh ? Wh.resolve().then(e2) : setTimeout(e2, 0);
      }
      function $w(e2) {
        return JSON.parse(JSON.stringify(e2));
      }
      function eO(e2) {
        try {
          return $w(e2);
        } catch (t2) {
          return e2;
        }
      }
      const tO = {};
      function iO(e2, t2) {
        tO[t2] || (tO[t2] = true, e2());
      }
      function nO(e2) {
        const t2 = window.atob(e2), i3 = new Uint8Array(new ArrayBuffer(t2.length));
        for (let e3 = 0; e3 < t2.length; e3 += 1)
          i3[e3] = t2.charCodeAt(e3);
        return i3;
      }
      function rO(e2) {
        let t2 = "";
        for (let i3 = 0; i3 < e2.length; i3 += 1)
          t2 += String.fromCharCode(e2[i3]);
        return window.btoa(t2);
      }
      function oO(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 16, i3 = new TextEncoder().encode(e2);
        if (i3.length > t2)
          i3 = i3.slice(0, t2);
        else if (i3.length < t2) {
          const e3 = new Uint8Array(t2);
          e3.set(i3), i3 = e3;
        }
        return i3;
      }
      function sO() {
        for (var e2 = arguments.length, t2 = new Array(e2), i3 = 0; i3 < e2; i3++)
          t2[i3] = arguments[i3];
        const n2 = Xn(t2).call(t2, (e3, t3) => e3 + t3.length, 0), r2 = new Uint8Array(new ArrayBuffer(n2));
        let o2 = 0;
        return t2.forEach((e3) => {
          r2.set(e3, o2), o2 += e3.length;
        }), r2;
      }
      function aO(e2) {
        return window.TextEncoder ? new TextEncoder().encode(e2).length : e2.length;
      }
      function cO(e2) {
        let t2 = 0;
        return (/DingTalk/i.test(navigator.userAgent) || /AliApp/i.test(navigator.userAgent)) && e2.realFormData && (e2 = e2.realFormData), e2.forEach((e3) => {
          t2 += "string" == typeof e3 ? aO(e3) : e3.size;
        }), t2 + 138;
      }
      function dO(e2) {
        const t2 = new Ew(_w.TIMEOUT, "timeout");
        return new Wh((i3, n2) => {
          window.setTimeout(() => n2(t2), e2);
        });
      }
      function lO(e2) {
        return new Wh((t2) => {
          window.setTimeout(t2, e2);
        });
      }
      function uO() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 7, t2 = arguments.length > 1 ? arguments[1] : void 0;
        const i3 = Math.random().toString(16).substr(2, e2).toLowerCase();
        return i3.length === e2 ? "".concat(t2).concat(i3) : "".concat(t2).concat(i3) + uO(e2 - i3.length, "");
      }
      function hO() {
        return uO(32, "").toUpperCase();
      }
      const pO = () => {
      }, _O = new class {
        constructor() {
          uw(this, "fnMap", /* @__PURE__ */ new Map());
        }
        throttleByKey(e2, t2, i3, n2) {
          for (var r2 = arguments.length, o2 = new Array(r2 > 4 ? r2 - 4 : 0), s2 = 4; s2 < r2; s2++)
            o2[s2 - 4] = arguments[s2];
          if (this.fnMap.has(t2)) {
            const r3 = this.fnMap.get(t2);
            if (r3.threshold !== i3) {
              r3.fn(...r3.args), clearTimeout(r3.timer);
              const s3 = window.setTimeout(() => {
                const e3 = this.fnMap.get(t2);
                e3 && e3.fn(...e3.args), this.fnMap.delete(t2);
              }, i3);
              this.fnMap.set(t2, { fn: e2, threshold: i3, timer: s3, args: o2, skipFn: n2 });
            } else
              r3.skipFn && r3.skipFn(...r3.args), this.fnMap.set(t2, pw(pw({}, r3), {}, { fn: e2, args: o2, skipFn: n2 }));
          } else {
            const r3 = window.setTimeout(() => {
              const e3 = this.fnMap.get(t2);
              e3 && e3.fn(...e3.args), this.fnMap.delete(t2);
            }, i3);
            this.fnMap.set(t2, { fn: e2, threshold: i3, timer: r3, args: o2, skipFn: n2 });
          }
        }
      }(), EO = _O.throttleByKey.bind(_O);
      function fO(e2) {
        return "object" == typeof e2 && null !== e2 && !(e2 instanceof RegExp);
      }
      function mO(e2, t2) {
        if (!fO(e2) || !fO(t2))
          return t2;
        if (Array.isArray(e2) && !Array.isArray(t2) || !Array.isArray(e2) && Array.isArray(t2))
          return t2;
        if (Array.isArray(t2) && Array.isArray(e2)) {
          const i3 = [...e2];
          for (let n2 = 0; n2 < t2.length; n2++)
            i3[n2] = mO(e2[n2], t2[n2]);
          return i3;
        }
        {
          const i3 = pw({}, e2);
          for (const n2 in t2)
            Object.prototype.hasOwnProperty.call(t2, n2) && (Object.prototype.hasOwnProperty.call(e2, n2) ? i3[n2] = mO(e2[n2], t2[n2]) : i3[n2] = t2[n2]);
          return i3;
        }
      }
      function TO(e2, t2) {
        let i3 = [0];
        if (t2 && (i3 = new Array(t2).fill(0)), 0 === e2)
          return i3;
        let n2 = 0;
        for (; e2 > 0 && (i3[n2] = 255 & e2, e2 >>= 8, n2++, !t2 || n2 !== t2); )
          ;
        return i3;
      }
      function SO(e2) {
        return "number" == typeof e2 ? e2 : e2.exact || e2.ideal || e2.max || e2.min || 0;
      }
      function gO(e2) {
        const t2 = "0123456789abcdef";
        function i3(e3) {
          let i4, n3 = "";
          for (i4 = 0; i4 <= 3; i4++)
            n3 += t2.charAt(e3 >> 8 * i4 + 4 & 15) + t2.charAt(e3 >> 8 * i4 & 15);
          return n3;
        }
        function n2(e3, t3) {
          const i4 = (65535 & e3) + (65535 & t3);
          return (e3 >> 16) + (t3 >> 16) + (i4 >> 16) << 16 | 65535 & i4;
        }
        function r2(e3, t3, i4, r3, o3, s3) {
          return n2(function(e4, t4) {
            return e4 << t4 | e4 >>> 32 - t4;
          }(n2(n2(t3, e3), n2(r3, s3)), o3), i4);
        }
        function o2(e3, t3, i4, n3, o3, s3, a3) {
          return r2(t3 & i4 | ~t3 & n3, e3, t3, o3, s3, a3);
        }
        function s2(e3, t3, i4, n3, o3, s3, a3) {
          return r2(t3 & n3 | i4 & ~n3, e3, t3, o3, s3, a3);
        }
        function a2(e3, t3, i4, n3, o3, s3, a3) {
          return r2(t3 ^ i4 ^ n3, e3, t3, o3, s3, a3);
        }
        function c2(e3, t3, i4, n3, o3, s3, a3) {
          return r2(i4 ^ (t3 | ~n3), e3, t3, o3, s3, a3);
        }
        const d2 = function(e3) {
          let t3;
          const i4 = 1 + (e3.length + 8 >> 6), n3 = new Array(16 * i4);
          for (t3 = 0; t3 < 16 * i4; t3++)
            n3[t3] = 0;
          for (t3 = 0; t3 < e3.length; t3++)
            n3[t3 >> 2] |= e3.charCodeAt(t3) << t3 % 4 * 8;
          return n3[t3 >> 2] |= 128 << t3 % 4 * 8, n3[16 * i4 - 2] = 8 * e3.length, n3;
        }(e2);
        let l2, u2, h2, p3, _2, E2 = 1732584193, f2 = -271733879, m2 = -1732584194, T2 = 271733878;
        for (l2 = 0; l2 < d2.length; l2 += 16)
          u2 = E2, h2 = f2, p3 = m2, _2 = T2, E2 = o2(E2, f2, m2, T2, d2[l2 + 0], 7, -680876936), T2 = o2(T2, E2, f2, m2, d2[l2 + 1], 12, -389564586), m2 = o2(m2, T2, E2, f2, d2[l2 + 2], 17, 606105819), f2 = o2(f2, m2, T2, E2, d2[l2 + 3], 22, -1044525330), E2 = o2(E2, f2, m2, T2, d2[l2 + 4], 7, -176418897), T2 = o2(T2, E2, f2, m2, d2[l2 + 5], 12, 1200080426), m2 = o2(m2, T2, E2, f2, d2[l2 + 6], 17, -1473231341), f2 = o2(f2, m2, T2, E2, d2[l2 + 7], 22, -45705983), E2 = o2(E2, f2, m2, T2, d2[l2 + 8], 7, 1770035416), T2 = o2(T2, E2, f2, m2, d2[l2 + 9], 12, -1958414417), m2 = o2(m2, T2, E2, f2, d2[l2 + 10], 17, -42063), f2 = o2(f2, m2, T2, E2, d2[l2 + 11], 22, -1990404162), E2 = o2(E2, f2, m2, T2, d2[l2 + 12], 7, 1804603682), T2 = o2(T2, E2, f2, m2, d2[l2 + 13], 12, -40341101), m2 = o2(m2, T2, E2, f2, d2[l2 + 14], 17, -1502002290), f2 = o2(f2, m2, T2, E2, d2[l2 + 15], 22, 1236535329), E2 = s2(E2, f2, m2, T2, d2[l2 + 1], 5, -165796510), T2 = s2(T2, E2, f2, m2, d2[l2 + 6], 9, -1069501632), m2 = s2(m2, T2, E2, f2, d2[l2 + 11], 14, 643717713), f2 = s2(f2, m2, T2, E2, d2[l2 + 0], 20, -373897302), E2 = s2(E2, f2, m2, T2, d2[l2 + 5], 5, -701558691), T2 = s2(T2, E2, f2, m2, d2[l2 + 10], 9, 38016083), m2 = s2(m2, T2, E2, f2, d2[l2 + 15], 14, -660478335), f2 = s2(f2, m2, T2, E2, d2[l2 + 4], 20, -405537848), E2 = s2(E2, f2, m2, T2, d2[l2 + 9], 5, 568446438), T2 = s2(T2, E2, f2, m2, d2[l2 + 14], 9, -1019803690), m2 = s2(m2, T2, E2, f2, d2[l2 + 3], 14, -187363961), f2 = s2(f2, m2, T2, E2, d2[l2 + 8], 20, 1163531501), E2 = s2(E2, f2, m2, T2, d2[l2 + 13], 5, -1444681467), T2 = s2(T2, E2, f2, m2, d2[l2 + 2], 9, -51403784), m2 = s2(m2, T2, E2, f2, d2[l2 + 7], 14, 1735328473), f2 = s2(f2, m2, T2, E2, d2[l2 + 12], 20, -1926607734), E2 = a2(E2, f2, m2, T2, d2[l2 + 5], 4, -378558), T2 = a2(T2, E2, f2, m2, d2[l2 + 8], 11, -2022574463), m2 = a2(m2, T2, E2, f2, d2[l2 + 11], 16, 1839030562), f2 = a2(f2, m2, T2, E2, d2[l2 + 14], 23, -35309556), E2 = a2(E2, f2, m2, T2, d2[l2 + 1], 4, -1530992060), T2 = a2(T2, E2, f2, m2, d2[l2 + 4], 11, 1272893353), m2 = a2(m2, T2, E2, f2, d2[l2 + 7], 16, -155497632), f2 = a2(f2, m2, T2, E2, d2[l2 + 10], 23, -1094730640), E2 = a2(E2, f2, m2, T2, d2[l2 + 13], 4, 681279174), T2 = a2(T2, E2, f2, m2, d2[l2 + 0], 11, -358537222), m2 = a2(m2, T2, E2, f2, d2[l2 + 3], 16, -722521979), f2 = a2(f2, m2, T2, E2, d2[l2 + 6], 23, 76029189), E2 = a2(E2, f2, m2, T2, d2[l2 + 9], 4, -640364487), T2 = a2(T2, E2, f2, m2, d2[l2 + 12], 11, -421815835), m2 = a2(m2, T2, E2, f2, d2[l2 + 15], 16, 530742520), f2 = a2(f2, m2, T2, E2, d2[l2 + 2], 23, -995338651), E2 = c2(E2, f2, m2, T2, d2[l2 + 0], 6, -198630844), T2 = c2(T2, E2, f2, m2, d2[l2 + 7], 10, 1126891415), m2 = c2(m2, T2, E2, f2, d2[l2 + 14], 15, -1416354905), f2 = c2(f2, m2, T2, E2, d2[l2 + 5], 21, -57434055), E2 = c2(E2, f2, m2, T2, d2[l2 + 12], 6, 1700485571), T2 = c2(T2, E2, f2, m2, d2[l2 + 3], 10, -1894986606), m2 = c2(m2, T2, E2, f2, d2[l2 + 10], 15, -1051523), f2 = c2(f2, m2, T2, E2, d2[l2 + 1], 21, -2054922799), E2 = c2(E2, f2, m2, T2, d2[l2 + 8], 6, 1873313359), T2 = c2(T2, E2, f2, m2, d2[l2 + 15], 10, -30611744), m2 = c2(m2, T2, E2, f2, d2[l2 + 6], 15, -1560198380), f2 = c2(f2, m2, T2, E2, d2[l2 + 13], 21, 1309151649), E2 = c2(E2, f2, m2, T2, d2[l2 + 4], 6, -145523070), T2 = c2(T2, E2, f2, m2, d2[l2 + 11], 10, -1120210379), m2 = c2(m2, T2, E2, f2, d2[l2 + 2], 15, 718787259), f2 = c2(f2, m2, T2, E2, d2[l2 + 9], 21, -343485551), E2 = n2(E2, u2), f2 = n2(f2, h2), m2 = n2(m2, p3), T2 = n2(T2, _2);
        return i3(E2) + i3(f2) + i3(m2) + i3(T2);
      }
      let RO = 1, CO = console, vO = class {
        static setLogger(e2) {
          CO = e2;
        }
        constructor(e2, t2) {
          uw(this, "id", void 0), uw(this, "lockingPromise", Wh.resolve()), uw(this, "locks", 0), uw(this, "name", ""), uw(this, "lockId", void 0), this.lockId = RO++, e2 && (this.name = e2), t2 && (this.id = t2), this.logger("created");
        }
        logger(e2, t2) {
          const i3 = (this.id ? "[".concat(this.id, "]") : "") + "[lock-".concat(this.name, "-").concat(this.lockId, "]"), n2 = "created" === e2 ? "is ".concat(e2, ".") : "is ".concat(e2, ", current queue ").concat(this.locks, ". ").concat(null != t2 ? t2 : "");
          CO.debug("".concat(i3, " ").concat(n2));
        }
        setId(e2) {
          this.id = e2;
        }
        get isLocked() {
          return this.locks > 0;
        }
        lock(e2) {
          let t2;
          this.locks += 1, this.logger("locked", e2);
          const i3 = new Wh((i4) => {
            t2 = () => {
              this.locks -= 1, this.logger("unlocked", e2), i4();
            };
          }), n2 = this.lockingPromise.then(() => t2);
          return this.lockingPromise = this.lockingPromise.then(() => i3), n2;
        }
      };
      function IO(e2, t2) {
        return function(i3, n2, r2) {
          const o2 = r2.value;
          if ("function" != typeof o2)
            throw new Error("Cannot use mutex on object property.");
          return r2.value = async function() {
            const i4 = this[t2];
            if (!i4)
              throw new Error("mutex property key ".concat(t2, " doesn't exist on ").concat(e2));
            const r3 = await i4.lock("From ".concat(e2, ".").concat(n2));
            try {
              for (var s2 = arguments.length, a2 = new Array(s2), c2 = 0; c2 < s2; c2++)
                a2[c2] = arguments[c2];
              return await o2.apply(this, a2);
            } finally {
              r3();
            }
          }, r2;
        };
      }
      const yO = { timeout: 500, timeoutFactor: 1.5, maxRetryCount: 1 / 0, maxRetryTimeout: 1e4 };
      function AO(e2, t2) {
        const i3 = Math.floor(t2.timeout * Math.pow(t2.timeoutFactor, e2));
        return Math.min(t2.maxRetryTimeout, i3);
      }
      function bO(e2, t2, i3, n2) {
        const r2 = Object.assign({}, yO, n2);
        let o2 = r2.timeout;
        const s2 = async () => {
          await function(e3) {
            return new Wh((t3) => {
              window.setTimeout(t3, e3);
            });
          }(o2), o2 *= r2.timeoutFactor, o2 = Math.min(r2.maxRetryTimeout, o2);
        };
        let a2 = false;
        const c2 = new Wh(async (n3, o3) => {
          t2 = t2 || (() => false), i3 = i3 || (() => true);
          for (let c3 = 0; c3 < r2.maxRetryCount; c3 += 1) {
            if (a2)
              return o3(new Ew(_w.OPERATION_ABORTED));
            try {
              const i4 = await e2();
              if (!t2(i4, c3))
                return n3(i4);
              if (c3 + 1 === r2.maxRetryCount)
                return n3(i4);
              await s2();
            } catch (e3) {
              if (!i3(e3, c3))
                return o3(e3);
              if (c3 + 1 === r2.maxRetryCount)
                return o3(e3);
              await s2();
            }
          }
        });
        return c2.cancel = () => a2 = true, c2;
      }
      let wO, OO = class {
        constructor(e2) {
          uw(this, "input", []), uw(this, "size", void 0), this.size = e2;
        }
        add(e2) {
          this.input.push(e2), this.input.length > this.size && this.input.splice(0, 1);
        }
        mean() {
          var e2;
          return 0 === this.input.length ? 0 : Xn(e2 = this.input).call(e2, (e3, t2) => e3 + t2) / this.input.length;
        }
      }, NO = 0, DO = 0;
      function PO(e2, t2, i3, n2) {
        return new Wh((r2, o2) => {
          t2.responseType = t2.responseType || "json", t2.data && !i3 ? (t2.data = JSON.stringify(t2.data), NO += aO(t2.data)) : i3 && (t2.data.size ? NO += t2.data.size : t2.data instanceof FormData ? NO += cO(t2.data) : NO += aO(JSON.stringify(t2.data))), t2.headers = t2.headers || {}, t2.headers["Content-Type"] = t2.headers["Content-Type"] || "application/json", t2.method = "POST", t2.url = e2, Ab.request(t2).then((e3) => {
            "string" == typeof e3.data ? DO += aO(e3.data) : e3.data instanceof ArrayBuffer || e3.data instanceof Uint8Array ? DO += e3.data.byteLength : DO += aO(JSON.stringify(e3.data)), n2 && r2({ data: e3.data, headers: e3.headers }), r2(e3.data);
          }).catch((e3) => {
            Ab.isCancel(e3) ? o2(new Ew(_w.OPERATION_ABORTED, "cancel token canceled")) : "ECONNABORTED" === e3.code ? o2(new Ew(_w.NETWORK_TIMEOUT, e3.message)) : e3.response ? o2(new Ew(_w.NETWORK_RESPONSE_ERROR, e3.response.status)) : o2(new Ew(_w.NETWORK_ERROR, e3.message));
          });
        });
      }
      async function LO(e2, t2) {
        const i3 = new Blob([t2.data], { type: "buffer" });
        return await PO(e2, pw(pw({}, t2), {}, { data: i3, headers: { "Content-Type": "application/octet-stream" } }), true);
      }
      const kO = () => void 0 !== window.isSecureContext;
      function MO(e2) {
        if (Array.isArray(e2))
          return e2.map((e3) => e3);
        if (!UO(e2))
          return e2;
        const t2 = {};
        for (const i3 in e2) {
          const n2 = e2[i3];
          UO(n2) || Array.isArray(n2) ? t2[i3] = MO(n2) : t2[i3] = n2;
        }
        return t2;
      }
      function UO(e2) {
        return !("object" != typeof e2 || Array.isArray(e2) || !e2);
      }
      let xO = class {
        constructor(e2) {
          uw(this, "input", []), uw(this, "size", void 0), this.size = e2;
        }
        add(e2) {
          this.input.push(e2), this.input.length > this.size && this.input.splice(0, 1);
        }
        diffMean() {
          return 0 === this.input.length ? 0 : (this.input[this.input.length - 1] - this.input[0]) / this.input.length;
        }
      };
      const VO = { address: "unknown", candidateType: "unknown", id: "unknown", port: 0, priority: 0, protocol: "unknown", type: "unknown" }, FO = { timestamp: 0, bitrate: { actualEncoded: 0, transmit: 0 }, sendPacketLossRate: 0, recvPacketLossRate: 0, videoRecv: [], videoSend: [], audioRecv: [], audioSend: [], selectedCandidatePair: { id: "unknown", localCandidate: VO, remoteCandidate: VO }, updateInterval: 0 }, BO = { firsCount: 0, nacksCount: 0, plisCount: 0, framesDecodeCount: 0, framesDecodeInterval: 0, framesDecodeFreezeTime: 0, decodeFrameRate: 0, bytes: 0, packetsLost: 0, packetLostRate: 0, packets: 0, ssrc: 0, qpSumPerFrame: 0, framesDroppedCount: 0, outputFrameRate: 0, packetsDiscarded: 0, framesAssembledFromMultiplePackets: 0, totalProcessingDelay: 0, avgDecodeMs: 0, avgFramesAssembledFromMultiplePacketsMs: 0, avgProcessingDelayMs: 0, avgInterFrameDelayMs: 0, totalAssemblyTime: 0 }, jO = { firsCount: 0, nacksCount: 0, plisCount: 0, frameCount: 0, bytes: 0, packets: 0, packetsLost: 0, packetLostRate: 0, ssrc: 0, rttMs: 0, jitterMs: 0, qpSumPerFrame: 0 }, GO = { bytes: 0, packets: 0, packetsLost: 0, packetLostRate: 0, ssrc: 0, rttMs: 0, jitterMs: 0 }, WO = { jitterBufferMs: 0, jitterMs: 0, bytes: 0, packetsLost: 0, packetLostRate: 0, packetsDiscarded: 0, packets: 0, ssrc: 0, receivedFrames: 0, droppedFrames: 0, concealedSamples: 0 };
      let HO = class {
        constructor(e2, t2) {
          uw(this, "onFirstVideoReceived", void 0), uw(this, "onFirstVideoDecoded", void 0), uw(this, "onFirstAudioReceived", void 0), uw(this, "onFirstVideoDecodedTimeout", void 0), uw(this, "onFirstAudioDecoded", void 0), uw(this, "onSelectedLocalCandidateChanged", void 0), uw(this, "onSelectedRemoteCandidateChanged", void 0), uw(this, "videoIsReady", false), uw(this, "videoIsReady2", {}), uw(this, "pc", void 0), uw(this, "options", void 0), uw(this, "intervalTimer", void 0), uw(this, "stats", MO(FO)), uw(this, "isFirstVideoReceived", {}), uw(this, "isFirstVideoDecoded", {}), uw(this, "isFirstAudioReceived", {}), uw(this, "isFirstAudioDecoded", {}), uw(this, "isFirstVideoDecodedTimeout", {}), uw(this, "lossRateWindowStats", []), this.pc = e2, this.options = t2, this.intervalTimer = window.setInterval(async () => {
            this.updateStats();
          }, this.options.updateInterval);
        }
        getStats() {
          return this.stats;
        }
        getSelectedCandidatePair() {
          return new Wh((e2) => {
            e2({ local: pw({}, VO), remote: pw({}, VO) });
          });
        }
        setVideoIsReady(e2) {
          this.videoIsReady = e2;
        }
        setVideoIsReady2(e2, t2) {
          this.videoIsReady2[e2] = t2;
        }
        getVideoIsReady(e2) {
          return this.videoIsReady2[e2] || false;
        }
        setIsFirstAudioDecoded(e2) {
        }
        destroy() {
          window.clearInterval(this.intervalTimer), this.pc = void 0;
        }
        calcLossRate(e2) {
          this.lossRateWindowStats.push(e2), this.lossRateWindowStats.length > this.options.lossRateInterval && this.lossRateWindowStats.splice(0, 1);
          const t2 = this.lossRateWindowStats.length, i3 = ["videoSend", "audioSend", "videoRecv", "audioRecv"];
          let n2 = 0, r2 = 0, o2 = 0, s2 = 0;
          for (const a2 of i3)
            e2[a2].forEach((e3, i4) => {
              if (!this.lossRateWindowStats[t2 - 1][a2][i4] || !this.lossRateWindowStats[0][a2][i4])
                return;
              const c2 = this.lossRateWindowStats[t2 - 1][a2][i4].packets - this.lossRateWindowStats[0][a2][i4].packets, d2 = this.lossRateWindowStats[t2 - 1][a2][i4].packetsLost - this.lossRateWindowStats[0][a2][i4].packetsLost;
              "videoSend" === a2 || "audioSend" === a2 ? (n2 += c2, o2 += d2) : (r2 += c2, s2 += d2), Number.isNaN(c2) || Number.isNaN(c2) ? e3.packetLostRate = 0 : e3.packetLostRate = c2 <= 0 || d2 <= 0 ? 0 : d2 / (c2 + d2);
            });
          e2.sendPacketLossRate = n2 <= 0 || o2 <= 0 ? 0 : o2 / (n2 + o2), e2.recvPacketLossRate = r2 <= 0 || s2 <= 0 ? 0 : s2 / (r2 + s2);
        }
      }, KO = class extends HO {
        constructor() {
          super(...arguments), uw(this, "_stats", FO), uw(this, "lastDecodeVideoReceiverStats", /* @__PURE__ */ new Map());
        }
        async updateStats() {
          const e2 = await this._getStats(), t2 = this.statsResponsesToObjects(e2);
          this._stats = MO(FO);
          const i3 = t2.filter((e3) => "ssrc" === e3.type);
          this.processSSRCStats(i3);
          const n2 = t2.find((e3) => "VideoBwe" === e3.type);
          n2 && this.processBandwidthStats(n2), this._stats.timestamp = Date.now(), this.calcLossRate(this._stats), this.stats = this._stats;
        }
        processBandwidthStats(e2) {
          this._stats.bitrate = { actualEncoded: Number(e2.googActualEncBitrate), targetEncoded: Number(e2.googTargetEncBitrate), retransmit: Number(e2.googRetransmitBitrate), transmit: Number(e2.googTransmitBitrate) }, this._stats.sendBandwidth = Number(e2.googAvailableSendBandwidth);
        }
        processSSRCStats(e2) {
          e2.forEach((e3) => {
            var t2;
            const i3 = Dn(t2 = e3.id).call(t2, "send");
            switch ("".concat(e3.mediaType, "_").concat(i3 ? "send" : "recv")) {
              case "video_send": {
                const t3 = MO(jO);
                t3.codec = e3.googCodecName, t3.adaptionChangeReason = "none", e3.googCpuLimitedResolution && (t3.adaptionChangeReason = "cpu"), e3.googBandwidthLimitedResolution && (t3.adaptionChangeReason = "bandwidth"), t3.avgEncodeMs = Number(e3.googAvgEncodeMs), t3.inputFrame = { width: Number(e3.googFrameWidthInput) || Number(e3.googFrameWidthSent), height: Number(e3.googFrameHeightInput) || Number(e3.googFrameHeightSent), frameRate: Number(e3.googFrameRateInput) }, t3.sentFrame = { width: Number(e3.googFrameWidthSent), height: Number(e3.googFrameHeightSent), frameRate: Number(e3.googFrameRateInput) }, t3.firsCount = Number(e3.googFirReceived), t3.nacksCount = Number(e3.googNacksReceived), t3.plisCount = Number(e3.googPlisReceived), t3.frameCount = Number(e3.framesEncoded), t3.bytes = Number(e3.bytesSent), t3.packets = Number(e3.packetsSent), t3.packetsLost = Number(e3.packetsLost), t3.ssrc = Number(e3.ssrc), t3.rttMs = Number(e3.googRtt || 0), this._stats.videoSend.push(t3), this._stats.rtt = t3.rttMs;
                break;
              }
              case "video_recv": {
                const t3 = MO(BO), i4 = this.lastDecodeVideoReceiverStats.get(Number(e3.ssrc));
                if (t3.codec = e3.googCodecName, t3.targetDelayMs = Number(e3.googTargetDelayMs), t3.renderDelayMs = Number(e3.googRenderDelayMs), t3.currentDelayMs = Number(e3.googCurrentDelayMs), t3.minPlayoutDelayMs = Number(e3.googMinPlayoutDelayMs), t3.decodeMs = Number(e3.googDecodeMs), t3.maxDecodeMs = Number(e3.googMaxDecodeMs), t3.receivedFrame = { width: Number(e3.googFrameWidthReceived), height: Number(e3.googFrameHeightReceived), frameRate: Number(e3.googFrameRateReceived) }, t3.decodedFrame = { width: Number(e3.googFrameWidthReceived), height: Number(e3.googFrameHeightReceived), frameRate: Number(e3.googFrameRateDecoded) }, t3.decodeFrameRate = Number(e3.googFrameRateDecoded), t3.outputFrame = { width: Number(e3.googFrameWidthReceived), height: Number(e3.googFrameHeightReceived), frameRate: Number(e3.googFrameRateOutput) }, t3.jitterBufferMs = Number(e3.googJitterBufferMs), t3.firsCount = Number(e3.googFirsSent), t3.nacksCount = Number(e3.googNacksSent), t3.plisCount = Number(e3.googPlisSent), t3.framesDecodeCount = Number(e3.framesDecoded), t3.bytes = Number(e3.bytesReceived), t3.packets = Number(e3.packetsReceived), t3.packetsLost = Number(e3.packetsLost), t3.ssrc = Number(e3.ssrc), t3.packets > 0 && !this.isFirstVideoReceived[t3.ssrc] && (this.onFirstVideoReceived && this.onFirstVideoReceived(t3.ssrc), this.isFirstVideoReceived[t3.ssrc] = true), t3.framesDecodeCount > 0 && !this.isFirstVideoDecoded[t3.ssrc] && (this.onFirstVideoDecoded && this.onFirstVideoDecoded(t3.ssrc, t3.decodedFrame.width, t3.decodedFrame.height), this.isFirstVideoDecoded[t3.ssrc] = true), i4) {
                  const n2 = i4.stats, r2 = Date.now() - i4.lts;
                  t3.framesDecodeFreezeTime = n2.framesDecodeFreezeTime, t3.framesDecodeInterval = n2.framesDecodeInterval, t3.framesDecodeCount > n2.framesDecodeCount && this.isFirstVideoDecoded[t3.ssrc] ? (i4.lts = Date.now(), t3.framesDecodeInterval = r2, t3.framesDecodeInterval >= this.options.freezeRateLimit && (this.getVideoIsReady(parseInt(e3.ssrc, 10)) ? t3.framesDecodeFreezeTime += t3.framesDecodeInterval : this.setVideoIsReady2(parseInt(e3.ssrc, 10), true))) : t3.framesDecodeCount < i4.stats.framesDecodeCount && (t3.framesDecodeInterval = 0);
                }
                this.lastDecodeVideoReceiverStats.set(t3.ssrc, { stats: pw({}, t3), lts: Date.now() }), this._stats.videoRecv.push(t3);
                break;
              }
              case "audio_recv": {
                const t3 = MO(WO);
                t3.codec = e3.googCodecName, t3.outputLevel = Math.abs(Number(e3.audioOutputLevel)) / 32767, t3.decodingCNG = Number(e3.googDecodingCNG), t3.decodingCTN = Number(e3.googDecodingCTN), t3.decodingCTSG = Number(e3.googDecodingCTSG), t3.decodingNormal = Number(e3.googDecodingNormal), t3.decodingPLC = Number(e3.googDecodingPLC), t3.decodingPLCCNG = Number(e3.googDecodingPLCCNG), t3.expandRate = Number(e3.googExpandRate), t3.accelerateRate = Number(e3.googAccelerateRate), t3.preemptiveExpandRate = Number(e3.googPreemptiveExpandRate), t3.secondaryDecodedRate = Number(e3.googSecondaryDecodedRate), t3.speechExpandRate = Number(e3.googSpeechExpandRate), t3.preferredJitterBufferMs = Number(e3.googPreferredJitterBufferMs), t3.jitterBufferMs = Number(e3.googJitterBufferMs), t3.jitterMs = Number(e3.googJitterReceived), t3.bytes = Number(e3.bytesReceived), t3.packets = Number(e3.packetsReceived), t3.packetsLost = Number(e3.packetsLost), t3.ssrc = Number(e3.ssrc), t3.receivedFrames = Number(e3.googDecodingCTN) || Number(e3.packetsReceived), t3.droppedFrames = Number(e3.googDecodingPLC) + Number(e3.googDecodingPLCCNG) || Number(e3.packetsLost), t3.receivedFrames > 0 && !this.isFirstAudioReceived[t3.ssrc] && (this.onFirstAudioReceived && this.onFirstAudioReceived(t3.ssrc), this.isFirstAudioReceived[t3.ssrc] = true), t3.decodingNormal > 0 && !this.isFirstAudioDecoded[t3.ssrc] && (this.onFirstAudioDecoded && this.onFirstAudioDecoded(t3.ssrc), this.isFirstAudioDecoded[t3.ssrc] = true), this._stats.audioRecv.push(t3);
                break;
              }
              case "audio_send": {
                const t3 = MO(GO);
                t3.codec = e3.googCodecName, t3.inputLevel = Math.abs(Number(e3.audioInputLevel)) / 32767, t3.aecReturnLoss = Number(e3.googEchoCancellationReturnLoss || 0), t3.aecReturnLossEnhancement = Number(e3.googEchoCancellationReturnLossEnhancement || 0), t3.residualEchoLikelihood = Number(e3.googResidualEchoLikelihood || 0), t3.residualEchoLikelihoodRecentMax = Number(e3.googResidualEchoLikelihoodRecentMax || 0), t3.bytes = Number(e3.bytesSent), t3.packets = Number(e3.packetsSent), t3.packetsLost = Number(e3.packetsLost), t3.ssrc = Number(e3.ssrc), t3.rttMs = Number(e3.googRtt || 0), this._stats.rtt = t3.rttMs, this._stats.audioSend.push(t3);
                break;
              }
            }
          });
        }
        _getStats() {
          return new Wh((e2, t2) => {
            this.pc.getStats(e2, t2);
          });
        }
        statsResponsesToObjects(e2) {
          const t2 = [];
          return e2.result().forEach((e3) => {
            const i3 = { id: e3.id, timestamp: e3.timestamp.valueOf().toString(), type: e3.type };
            e3.names().forEach((t3) => {
              i3[t3] = e3.stat(t3);
            }), t2.push(i3);
          }), t2;
        }
      }, YO = function(e2) {
        return e2.BANDWIDTH = "bandwidth", e2.CPU = "cpu", e2.NONE = "none", e2.OTHER = "other", e2;
      }({}), qO = function(e2) {
        return e2.L1T1 = "L1T1", e2.L1T2 = "L1T2", e2.L1T3 = "L1T3", e2.L1T3_KEY = "L1T3_KEY", e2.L2T1_KEY = "L2T1_KEY", e2.L2T2_KEY = "L2T2_KEY", e2.L2T3_KEY = "L2T3_KEY", e2.L3T1_KEY = "L3T1_KEY", e2.L3T2_KEY = "L3T2_KEY", e2.L3T3_KEY = "L3T3_KEY", e2;
      }({}), zO = function(e2) {
        return e2[e2.new = 0] = "new", e2[e2.connecting = 1] = "connecting", e2[e2.connected = 2] = "connected", e2[e2.disconnected = 3] = "disconnected", e2[e2.failed = 4] = "failed", e2[e2.closed = 5] = "closed", e2;
      }({}), XO = function(e2) {
        return e2.CERTIFICATE = "certificate", e2.CODEC = "codec", e2.CANDIDATE_PAIR = "candidate-pair", e2.LOCAL_CANDIDATE = "local-candidate", e2.REMOTE_CANDIDATE = "remote-candidate", e2.INBOUND = "inbound-rtp", e2.TRACK = "track", e2.OUTBOUND = "outbound-rtp", e2.PC = "peer-connection", e2.REMOTE_INBOUND = "remote-inbound-rtp", e2.REMOTE_OUTBOUND = "remote-outbound-rtp", e2.TRANSPORT = "transport", e2.CSRC = "csrc", e2.DATA_CHANNEL = "data-channel", e2.STREAM = "stream", e2.SENDER = "sender", e2.RECEIVER = "receiver", e2;
      }({});
      var JO = function(e2) {
        return e2[e2.kNone = 1] = "kNone", e2[e2.kMillisecondsFromSeconds = 1e3] = "kMillisecondsFromSeconds", e2[e2.kBytesToBits = 8] = "kBytesToBits", e2;
      }(JO || {});
      function QO(e2, t2, i3, n2) {
        let r2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : JO.kNone;
        if (!t2)
          return;
        const o2 = Number(t2[i3]);
        if ("number" != typeof o2)
          return;
        const s2 = Number(t2[n2]);
        if ("number" != typeof s2)
          return;
        if (!e2)
          return s2 ? o2 / s2 * r2 : void 0;
        const a2 = Number(e2[i3]);
        if ("number" != typeof a2)
          return;
        const c2 = Number(e2[n2]);
        if ("number" != typeof c2)
          return;
        const d2 = s2 - c2;
        return d2 ? (o2 - a2) / d2 * r2 : void 0;
      }
      let ZO = class extends HO {
        constructor() {
          super(...arguments), uw(this, "_stats", FO), uw(this, "report", void 0), uw(this, "lastDecodeVideoReceiverStats", /* @__PURE__ */ new Map()), uw(this, "lastVideoFramesRecv", /* @__PURE__ */ new Map()), uw(this, "lastVideoFramesSent", /* @__PURE__ */ new Map()), uw(this, "lastVideoFramesDecode", /* @__PURE__ */ new Map()), uw(this, "lastVideoFramesOutput", /* @__PURE__ */ new Map()), uw(this, "lastVideoJBDelay", /* @__PURE__ */ new Map()), uw(this, "lastAudioJBDelay", /* @__PURE__ */ new Map()), uw(this, "mediaBytesSent", /* @__PURE__ */ new Map()), uw(this, "mediaBytesRetransmit", /* @__PURE__ */ new Map()), uw(this, "mediaBytesTargetEncode", /* @__PURE__ */ new Map()), uw(this, "lastDecodeAudioReceiverStats", /* @__PURE__ */ new Map()), uw(this, "lastEncoderMs", /* @__PURE__ */ new Map());
        }
        async updateStats() {
          this.report = await this.pc.getStats(), this._stats = MO(FO), this.report.forEach((e2) => {
            switch (e2.type) {
              case XO.OUTBOUND:
              case XO.INBOUND: {
                const t2 = e2.mediaType || e2.kind, i3 = !t2 && "frameWidth" in e2, n2 = !t2 && !("frameWidth" in e2);
                e2.type === XO.OUTBOUND ? "audio" === t2 || n2 ? this.processAudioOutboundStats(e2) : ("video" === t2 || i3) && this.processVideoOutboundStats(e2) : e2.type === XO.INBOUND && ("audio" === t2 || n2 ? this.processAudioInboundStats(e2) : ("video" === t2 || i3) && this.processVideoInboundStats(e2));
                break;
              }
              case XO.TRANSPORT: {
                const t2 = this.report.get(e2.selectedCandidatePairId);
                t2 && this.processCandidatePairStats(t2);
                break;
              }
              case XO.CANDIDATE_PAIR:
                e2.selected && this.processCandidatePairStats(e2);
            }
          }), this.updateSendBitrate(), this._stats.updateInterval = Date.now() - this.stats.timestamp, this._stats.timestamp = Date.now(), this.calcLossRate(this._stats), this.stats = this._stats;
        }
        async getSelectedCandidatePair() {
          const e2 = await this.pc.getStats(), t2 = { local: pw({}, VO), remote: pw({}, VO) };
          return e2.forEach((i3) => {
            let n2;
            if (i3.type === XO.TRANSPORT && (n2 = e2.get(i3.selectedCandidatePairId)), i3.type === XO.CANDIDATE_PAIR && i3.selected && (n2 = i3), n2) {
              const i4 = (e3, t3) => {
                e3.type = t3.type, e3.id = t3.id, t3.address && (e3.address = t3.address), t3.candidateType && (e3.candidateType = t3.candidateType), t3.port && (e3.port = t3.port), t3.priority && (e3.priority = t3.priority), t3.protocol && (e3.protocol = t3.protocol), t3.relayProtocol && (e3.relayProtocol = t3.relayProtocol);
              };
              if (n2.localCandidateId) {
                const r2 = e2.get(n2.localCandidateId);
                r2 && i4(t2.local, r2);
              }
              if (n2.remoteCandidateId) {
                const r2 = e2.get(n2.remoteCandidateId);
                r2 && i4(t2.remote, r2);
              }
            }
          }), t2;
        }
        processCandidatePairStats(e2) {
          if (this._stats.sendBandwidth = e2.availableOutgoingBitrate || 0, e2.currentRoundTripTime && (this._stats.rtt = 1e3 * e2.currentRoundTripTime), this._stats.videoSend.forEach((t2) => {
            e2.currentRoundTripTime && (t2.rttMs = 1e3 * e2.currentRoundTripTime);
          }), this._stats.audioSend.forEach((t2) => {
            e2.currentRoundTripTime && (t2.rttMs = 1e3 * e2.currentRoundTripTime);
          }), this._stats.selectedCandidatePair.id = e2.id, e2.localCandidateId) {
            const t2 = this.report.get(e2.localCandidateId);
            t2 && this.processCandidateStats(t2);
          }
          if (e2.remoteCandidateId) {
            const t2 = this.report.get(e2.remoteCandidateId);
            t2 && this.processCandidateStats(t2);
          }
        }
        processCandidateStats(e2) {
          let t2;
          e2.type === XO.LOCAL_CANDIDATE && (t2 = this._stats.selectedCandidatePair.localCandidate), e2.type === XO.REMOTE_CANDIDATE && (t2 = this._stats.selectedCandidatePair.remoteCandidate), t2 && (t2.type = e2.type, t2.id = e2.id, e2.address && (t2.address = e2.address), e2.candidateType && (t2.candidateType = e2.candidateType), e2.port && (t2.port = e2.port), e2.priority && (t2.priority = e2.priority), e2.protocol && (t2.protocol = e2.protocol), e2.relayProtocol && (t2.relayProtocol = e2.relayProtocol), e2.type === XO.LOCAL_CANDIDATE && this.stats.selectedCandidatePair.localCandidate.id !== t2.id && this.onSelectedLocalCandidateChanged && this.onSelectedLocalCandidateChanged(pw({}, t2), pw({}, this.stats.selectedCandidatePair.localCandidate)), e2.type === XO.REMOTE_CANDIDATE && this.stats.selectedCandidatePair.remoteCandidate.id !== t2.id && this.onSelectedRemoteCandidateChanged && this.onSelectedRemoteCandidateChanged(pw({}, t2), pw({}, this.stats.selectedCandidatePair.remoteCandidate)));
        }
        processAudioInboundStats(e2) {
          let t2 = this._stats.audioRecv.find((t3) => t3.ssrc === e2.ssrc);
          t2 || (t2 = MO(WO), this._stats.audioRecv.push(t2)), t2.ssrc = e2.ssrc, t2.packets = e2.packetsReceived, t2.packetsLost = e2.packetsLost, t2.packetsDiscarded = e2.packetsDiscarded, t2.bytes = e2.bytesReceived, t2.jitterMs = 1e3 * e2.jitter, t2.retransmittedBytesReceived = e2.retransmittedBytesReceived, t2.retransmittedPacketsReceived = e2.retransmittedPacketsReceived, t2.totalProcessingDelay = e2.totalProcessingDelay, t2.jitterBufferEmittedCount = e2.jitterBufferEmittedCount;
          const i3 = this.lastDecodeAudioReceiverStats.get(t2.ssrc);
          t2.avgProcessingDelayMs = QO(i3, t2, "totalProcessingDelay", "jitterBufferEmittedCount", JO.kMillisecondsFromSeconds), this.processAudioTrackReceiverStats(e2, e2.trackId, t2), e2.codecId && (t2.codec = this.getCodecFromCodecStats(e2.codecId)), t2.receivedFrames || (t2.receivedFrames = e2.packetsReceived), t2.droppedFrames || (t2.droppedFrames = e2.packetsLost), t2.receivedFrames > 0 && !this.isFirstAudioReceived[t2.ssrc] && (this.onFirstAudioReceived && this.onFirstAudioReceived(t2.ssrc), this.isFirstAudioReceived[t2.ssrc] = true), t2.outputLevel && t2.outputLevel > 0 && !this.isFirstAudioDecoded[t2.ssrc] && (this.onFirstAudioDecoded && this.onFirstAudioDecoded(t2.ssrc), this.isFirstAudioDecoded[t2.ssrc] = true), "number" == typeof e2.concealedSamples && (t2.concealedSamples = e2.concealedSamples), this.lastDecodeAudioReceiverStats.set(t2.ssrc, pw({}, t2));
        }
        processVideoInboundStats(e2) {
          let t2 = this._stats.videoRecv.find((t3) => t3.ssrc === e2.ssrc);
          t2 || (t2 = MO(BO), this._stats.videoRecv.push(t2)), t2.ssrc = e2.ssrc, t2.packets = e2.packetsReceived, t2.packetsLost = e2.packetsLost, t2.bytes = e2.bytesReceived, t2.firsCount = e2.firCount, t2.nacksCount = e2.nackCount, t2.plisCount = e2.pliCount, t2.framesDecodeCount = e2.framesDecoded, t2.framesDroppedCount = e2.framesDropped, t2.totalInterFrameDelay = e2.totalInterFrameDelay, t2.totalSquaredInterFrameDelay = e2.totalSquaredInterFrameDelay, t2.totalFreezesDuration = e2.totalFreezesDuration, t2.totalProcessingDelay = e2.totalProcessingDelay, t2.packetsDiscarded = e2.packetsDiscarded, t2.framesAssembledFromMultiplePackets = e2.framesAssembledFromMultiplePackets, t2.totalAssemblyTime = e2.totalAssemblyTime, t2.keyFramesDecoded = e2.keyFramesDecoded, t2.retransmittedBytesReceived = e2.retransmittedBytesReceived, t2.retransmittedPacketsReceived = e2.retransmittedPacketsReceived;
          const i3 = this.lastDecodeVideoReceiverStats.get(t2.ssrc), n2 = this.lastVideoFramesDecode.get(t2.ssrc), r2 = this.lastVideoFramesOutput.get(t2.ssrc), o2 = Date.now();
          if (t2.framesDecodeCount > 0 && !this.isFirstVideoDecoded[t2.ssrc]) {
            const e3 = t2.decodedFrame ? t2.decodedFrame.width : 0, i4 = t2.decodedFrame ? t2.decodedFrame.height : 0;
            this.onFirstVideoDecoded && this.onFirstVideoDecoded(t2.ssrc, e3, i4), this.isFirstVideoDecoded[t2.ssrc] = true;
          }
          if (i3) {
            const n3 = i3.stats, r3 = o2 - i3.lts;
            t2.framesDecodeFreezeTime = n3.framesDecodeFreezeTime, t2.framesDecodeInterval = n3.framesDecodeInterval, !this.isFirstVideoDecoded[t2.ssrc] && r3 > this.options.firstVideoDecodedTimeout && !this.isFirstVideoDecodedTimeout[t2.ssrc] && (this.onFirstVideoDecodedTimeout && this.onFirstVideoDecodedTimeout(t2.ssrc), this.isFirstVideoDecodedTimeout[t2.ssrc] = true), t2.framesDecodeCount > n3.framesDecodeCount && this.isFirstVideoDecoded[t2.ssrc] ? (i3.lts = Date.now(), t2.framesDecodeInterval = r3, t2.framesDecodeInterval >= this.options.freezeRateLimit && (this.getVideoIsReady(parseInt(e2.ssrc)) ? t2.framesDecodeFreezeTime += t2.framesDecodeInterval : this.setVideoIsReady2(parseInt(e2.ssrc, 10), true))) : t2.framesDecodeCount < n3.framesDecodeCount && (t2.framesDecodeInterval = 0), e2.framesDecoded && e2.qpSum && (i3.stats.framesDecodeCount > e2.framesDecoded ? t2.qpSumPerFrame = e2.qpSum / e2.framesDecoded : t2.qpSumPerFrame = (e2.qpSum - i3.qpSum) / (e2.framesDecoded - i3.stats.framesDecodeCount));
          }
          e2.totalDecodeTime && (t2.decodeMs = 1e3 * e2.totalDecodeTime, t2.avgDecodeMs = QO(null == i3 ? void 0 : i3.stats, t2, "decodeMs", "framesDecodeCount")), t2.avgProcessingDelayMs = QO(null == i3 ? void 0 : i3.stats, t2, "totalProcessingDelay", "framesDecodeCount", JO.kMillisecondsFromSeconds), t2.avgFramesAssembledFromMultiplePacketsMs = QO(null == i3 ? void 0 : i3.stats, t2, "totalAssemblyTime", "framesAssembledFromMultiplePackets", JO.kMillisecondsFromSeconds), t2.avgInterFrameDelayMs = QO(null == i3 ? void 0 : i3.stats, t2, "totalInterFrameDelay", "framesDecodeCount", JO.kMillisecondsFromSeconds), n2 && o2 - n2.lts >= 800 ? (t2.decodeFrameRate = Math.round((t2.framesDecodeCount - n2.count) / ((o2 - n2.lts) / 1e3)), this.lastVideoFramesDecode.set(t2.ssrc, { count: t2.framesDecodeCount, lts: o2, rate: t2.decodeFrameRate })) : n2 ? t2.decodeFrameRate = n2.rate : this.lastVideoFramesDecode.set(t2.ssrc, { count: t2.framesDecodeCount, lts: o2, rate: 0 }), t2.framesDroppedCount && e2.framesReceived && (r2 && o2 - r2.lts >= 800 ? (t2.outputFrameRate = Math.round((e2.framesReceived - t2.framesDroppedCount - r2.count) / ((o2 - r2.lts) / 1e3)), this.lastVideoFramesOutput.set(t2.ssrc, { count: e2.framesReceived - t2.framesDroppedCount, lts: o2, rate: Math.max(t2.outputFrameRate, 0) })) : r2 ? t2.outputFrameRate = r2.rate : this.lastVideoFramesOutput.set(t2.ssrc, { count: e2.framesReceived - t2.framesDroppedCount, lts: o2, rate: 0 })), this.processVideoTrackReceiverStats(e2, e2.trackId, t2), e2.codecId && (t2.codec = this.getCodecFromCodecStats(e2.codecId)), e2.framerateMean && (t2.framesRateFirefox = e2.framerateMean), t2.packets > 0 && !this.isFirstVideoReceived[t2.ssrc] && (this.onFirstVideoReceived && this.onFirstVideoReceived(t2.ssrc), this.isFirstVideoReceived[t2.ssrc] = true), this.lastDecodeVideoReceiverStats.set(t2.ssrc, { stats: pw({}, t2), lts: i3 ? i3.lts : Date.now(), qpSum: e2.qpSum });
        }
        processVideoOutboundStats(e2) {
          let t2 = this._stats.videoSend.find((t3) => t3.ssrc === e2.ssrc);
          t2 || (t2 = MO(jO), this._stats.videoSend.push(t2));
          const i3 = this.mediaBytesSent.get(e2.ssrc);
          if (i3)
            i3.add(e2.bytesSent);
          else {
            const t3 = new xO(10);
            t3.add(e2.bytesSent), this.mediaBytesSent.set(e2.ssrc, t3);
          }
          if (void 0 !== e2.retransmittedBytesSent) {
            const t3 = this.mediaBytesRetransmit.get(e2.ssrc);
            if (t3)
              t3.add(e2.retransmittedBytesSent);
            else {
              const t4 = new xO(10);
              t4.add(e2.retransmittedBytesSent), this.mediaBytesRetransmit.set(e2.ssrc, t4);
            }
          }
          if (e2.totalEncodedBytesTarget) {
            const t3 = this.mediaBytesTargetEncode.get(e2.ssrc);
            if (t3)
              t3.add(e2.totalEncodedBytesTarget);
            else {
              const t4 = new xO(10);
              t4.add(e2.totalEncodedBytesTarget), this.mediaBytesTargetEncode.set(e2.ssrc, t4);
            }
          }
          if (t2.ssrc = e2.ssrc, t2.bytes = e2.bytesSent, t2.packets = e2.packetsSent, t2.firsCount = e2.firCount, t2.nacksCount = e2.nackCount, t2.plisCount = e2.pliCount, t2.frameCount = e2.framesEncoded, t2.adaptionChangeReason = e2.qualityLimitationReason, t2.scalabilityMode = e2.scalabilityMode, t2.retransmittedBytesSent = e2.retransmittedBytesSent, t2.retransmittedPacketsSent = e2.retransmittedPacketsSent, t2.hugeFramesSent = e2.hugeFramesSent, t2.keyFramesEncoded = e2.keyFramesEncoded, e2.totalEncodeTime && e2.framesEncoded) {
            const i4 = this.lastEncoderMs.get(e2.ssrc);
            if (!i4 || i4.lastFrameCount > e2.framesEncoded)
              t2.avgEncodeMs = 1e3 * e2.totalEncodeTime / e2.framesEncoded;
            else {
              const n2 = e2.framesEncoded - i4.lastFrameCount, r2 = e2.totalEncodeTime - i4.lastEncoderTime;
              t2.avgEncodeMs = 1e3 * r2 / n2;
            }
          }
          if (e2.framesEncoded && e2.qpSum) {
            const i4 = this.lastEncoderMs.get(e2.ssrc);
            !i4 || i4.lastFrameCount > e2.framesEncoded ? t2.qpSumPerFrame = e2.qpSum / e2.framesEncoded : t2.qpSumPerFrame = (e2.qpSum - i4.lastQpSum) / (e2.framesEncoded - i4.lastFrameCount);
          }
          if (this.lastEncoderMs.set(e2.ssrc, { lastFrameCount: e2.framesEncoded, lastEncoderTime: e2.totalEncodeTime, lastQpSum: e2.qpSum, lts: Date.now() }), e2.codecId && (t2.codec = this.getCodecFromCodecStats(e2.codecId)), e2.mediaSourceId && this.processVideoMediaSource(e2.mediaSourceId, t2), this.processVideoTrackSenderStats(e2, e2.trackId, t2), e2.remoteId)
            this.processRemoteInboundStats(e2.remoteId, t2);
          else {
            const i4 = this.findRemoteStatsId(e2.ssrc, XO.REMOTE_INBOUND);
            i4 && this.processRemoteInboundStats(i4, t2);
          }
        }
        processAudioOutboundStats(e2) {
          let t2 = this._stats.audioSend.find((t3) => t3.ssrc === e2.ssrc);
          if (t2 || (t2 = MO(GO), this._stats.audioSend.push(t2)), t2.ssrc = e2.ssrc, t2.packets = e2.packetsSent, t2.bytes = e2.bytesSent, t2.retransmittedBytesSent = e2.retransmittedBytesSent, t2.retransmittedPacketsSent = e2.retransmittedPacketsSent, e2.mediaSourceId && this.processAudioMediaSource(e2.mediaSourceId, t2), e2.codecId && (t2.codec = this.getCodecFromCodecStats(e2.codecId)), this.processAudioTrackSenderStats(e2, e2.trackId, t2), e2.remoteId)
            this.processRemoteInboundStats(e2.remoteId, t2);
          else {
            const i3 = this.findRemoteStatsId(e2.ssrc, XO.REMOTE_INBOUND);
            i3 && this.processRemoteInboundStats(i3, t2);
          }
        }
        findRemoteStatsId(e2, t2) {
          var i3;
          const n2 = Array.from(Zh(i3 = this.report).call(i3)).find((i4) => i4.type === t2 && i4.ssrc === e2);
          return n2 ? n2.id : null;
        }
        processVideoMediaSource(e2, t2) {
          const i3 = this.report.get(e2);
          i3 && i3.width && i3.height && i3.framesPerSecond && (t2.inputFrame = { width: i3.width, height: i3.height, frameRate: i3.framesPerSecond });
        }
        processAudioMediaSource(e2, t2) {
          const i3 = this.report.get(e2);
          i3 && (t2.inputLevel = i3.audioLevel);
        }
        processVideoTrackSenderStats(e2, t2, i3) {
          var n2, r2, o2, s2;
          const a2 = t2 ? this.report.get(t2) : void 0, c2 = null !== (n2 = null == a2 ? void 0 : a2.framesSent) && void 0 !== n2 ? n2 : e2.framesSent;
          if ("number" != typeof c2)
            return;
          let d2 = null !== (r2 = null == a2 ? void 0 : a2.frameWidth) && void 0 !== r2 ? r2 : e2.frameWidth, l2 = null !== (o2 = null == a2 ? void 0 : a2.frameHeight) && void 0 !== o2 ? o2 : e2.frameHeight, u2 = null !== (s2 = null == a2 ? void 0 : a2.framesPerSecond) && void 0 !== s2 ? s2 : e2.framesPerSecond;
          if ("number" == typeof d2 && "number" == typeof l2 || (d2 = 0, l2 = 0), null == u2) {
            const e3 = Date.now(), t3 = this.lastVideoFramesSent.get(i3.ssrc);
            t3 && e3 - t3.lts >= 800 ? (u2 = Math.round((c2 - t3.count) / ((e3 - t3.lts) / 1e3)), this.lastVideoFramesSent.set(i3.ssrc, { count: c2, lts: e3, rate: u2 })) : t3 ? u2 = t3.rate : this.lastVideoFramesSent.set(i3.ssrc, { count: c2, lts: e3, rate: 0 });
          }
          i3.sentFrame = { width: d2, height: l2, frameRate: Math.max(0, u2) };
        }
        processVideoTrackReceiverStats(e2, t2, i3) {
          var n2, r2, o2, s2, a2;
          const c2 = t2 ? this.report.get(t2) : void 0, d2 = null !== (n2 = null == c2 ? void 0 : c2.framesReceived) && void 0 !== n2 ? n2 : e2.framesReceived, l2 = null !== (r2 = null == c2 ? void 0 : c2.frameWidth) && void 0 !== r2 ? r2 : e2.frameWidth, u2 = null !== (o2 = null == c2 ? void 0 : c2.frameHeight) && void 0 !== o2 ? o2 : e2.frameHeight, h2 = null !== (s2 = null == c2 ? void 0 : c2.jitterBufferDelay) && void 0 !== s2 ? s2 : e2.jitterBufferDelay, p3 = null !== (a2 = null == c2 ? void 0 : c2.jitterBufferEmittedCount) && void 0 !== a2 ? a2 : e2.jitterBufferEmittedCount;
          if ("number" == typeof d2) {
            const e3 = this.lastVideoFramesRecv.get(i3.ssrc), t3 = Date.now();
            i3.framesReceivedCount = d2;
            let n3 = 0;
            e3 && t3 - e3.lts >= 800 ? (n3 = Math.round((d2 - e3.count) / ((t3 - e3.lts) / 1e3)), this.lastVideoFramesRecv.set(i3.ssrc, { count: d2, lts: t3, rate: n3 })) : e3 ? n3 = e3.rate : this.lastVideoFramesRecv.set(i3.ssrc, { count: d2, lts: t3, rate: 0 }), i3.receivedFrame = { width: l2 || 0, height: u2 || 0, frameRate: n3 || 0 }, i3.decodedFrame = { width: l2 || 0, height: u2 || 0, frameRate: i3.decodeFrameRate || 0 }, i3.outputFrame = { width: l2 || 0, height: u2 || 0, frameRate: i3.outputFrameRate || i3.decodeFrameRate || 0 };
          }
          if (h2 && p3) {
            const e3 = this.lastVideoJBDelay.get(i3.ssrc) || { jitterBufferDelay: 0, jitterBufferEmittedCount: 0, jitterBufferMs: 0 };
            let t3 = e3.jitterBufferMs;
            const n3 = p3 - e3.jitterBufferEmittedCount;
            n3 > 0 && (t3 = 1e3 * (h2 - e3.jitterBufferDelay) / n3), i3.jitterBufferMs = t3, i3.currentDelayMs = Math.round(t3), this.lastVideoJBDelay.set(i3.ssrc, { jitterBufferDelay: h2, jitterBufferEmittedCount: p3, jitterBufferMs: i3.currentDelayMs });
          }
        }
        processAudioTrackSenderStats(e2, t2, i3) {
          var n2, r2, o2, s2;
          const a2 = t2 ? this.report.get(t2) : void 0, c2 = null !== (n2 = null !== (r2 = null == a2 ? void 0 : a2.echoReturnLoss) && void 0 !== r2 ? r2 : e2.echoReturnLoss) && void 0 !== n2 ? n2 : 0, d2 = null !== (o2 = null !== (s2 = null == a2 ? void 0 : a2.echoReturnLossEnhancement) && void 0 !== s2 ? s2 : e2.echoReturnLossEnhancement) && void 0 !== o2 ? o2 : 0;
          i3.aecReturnLoss = c2, i3.aecReturnLossEnhancement = d2;
        }
        processAudioTrackReceiverStats(e2, t2, i3) {
          var n2, r2, o2, s2, a2, c2, d2;
          const l2 = t2 ? this.report.get(t2) : void 0, u2 = null !== (n2 = null == l2 ? void 0 : l2.removedSamplesForAcceleration) && void 0 !== n2 ? n2 : e2.removedSamplesForAcceleration, h2 = null !== (r2 = null == l2 ? void 0 : l2.totalSamplesReceived) && void 0 !== r2 ? r2 : e2.totalSamplesReceived, p3 = null !== (o2 = null == l2 ? void 0 : l2.jitterBufferDelay) && void 0 !== o2 ? o2 : e2.jitterBufferDelay, _2 = null !== (s2 = null == l2 ? void 0 : l2.jitterBufferEmittedCount) && void 0 !== s2 ? s2 : e2.jitterBufferEmittedCount, E2 = null !== (a2 = null == l2 ? void 0 : l2.audioLevel) && void 0 !== a2 ? a2 : null == e2 ? void 0 : e2.audioLevel, f2 = null !== (c2 = null == l2 ? void 0 : l2.totalSamplesDuration) && void 0 !== c2 ? c2 : null == e2 ? void 0 : e2.totalSamplesDuration, m2 = null !== (d2 = null == l2 ? void 0 : l2.concealedSamples) && void 0 !== d2 ? d2 : e2.concealedSamples;
          if (u2 && h2 && (i3.accelerateRate = u2 / h2), p3 && _2) {
            const e3 = this.lastAudioJBDelay.get(i3.ssrc) || { jitterBufferDelay: 0, jitterBufferEmittedCount: 0, jitterBufferMs: 0 };
            let t3 = e3.jitterBufferMs;
            const n3 = _2 - e3.jitterBufferEmittedCount;
            n3 > 0 && (t3 = 1e3 * (p3 - e3.jitterBufferDelay) / n3), i3.jitterBufferMs = Math.round(t3), this.lastAudioJBDelay.set(i3.ssrc, { jitterBufferDelay: p3, jitterBufferEmittedCount: _2, jitterBufferMs: i3.jitterBufferMs });
          }
          i3.outputLevel = E2;
          let T2 = 1920;
          f2 && h2 && (T2 = h2 / f2 / 50, i3.receivedFrames = Math.round(h2 / T2)), m2 && (i3.droppedFrames = Math.round(m2 / T2));
        }
        processRemoteInboundStats(e2, t2) {
          const i3 = this.report.get(e2);
          i3 && (t2.packetsLost = i3.packetsLost, i3.roundTripTime && (t2.rttMs = 1e3 * i3.roundTripTime), i3.jitter && (t2.jitterMs = 1e3 * i3.jitter), i3.timestamp && (t2.timestamp = i3.timestamp));
        }
        getCodecFromCodecStats(e2) {
          const t2 = this.report.get(e2);
          if (!t2)
            return "";
          const i3 = t2.mimeType.match(/\/(.*)$/);
          return i3 && i3[1] ? i3[1] : "";
        }
        updateSendBitrate() {
          let e2 = 0, t2 = null, i3 = null;
          this.mediaBytesSent.forEach((t3) => {
            e2 += t3.diffMean();
          }), this.mediaBytesRetransmit.forEach((e3) => {
            t2 = null === t2 ? e3.diffMean() : t2 + e3.diffMean();
          }), this.mediaBytesTargetEncode.forEach((e3) => {
            i3 = null === i3 ? e3.diffMean() : i3 + e3.diffMean();
          });
          const n2 = null !== t2 ? e2 - t2 : e2;
          this._stats.bitrate = { actualEncoded: 8 * n2 / (this.options.updateInterval / 1e3), transmit: 8 * e2 / (this.options.updateInterval / 1e3) }, null !== t2 && (this._stats.bitrate.retransmit = 8 * t2 / (this.options.updateInterval / 1e3)), null !== i3 && (this._stats.bitrate.targetEncoded = 8 * i3 / (this.options.updateInterval / 1e3));
        }
      }, $O = class extends HO {
        updateStats() {
          return Wh.resolve();
        }
      };
      function eN(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 250, i3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 8, n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 500, r2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1e4;
        const o2 = function() {
          const e3 = navigator.userAgent.toLocaleLowerCase().match(/chrome\/[\d]*/i);
          return e3 && e3[0] ? Number(e3[0].split("/")[1]) : null;
        }();
        return o2 ? o2 < 76 ? new KO(e2, { updateInterval: t2, lossRateInterval: i3, freezeRateLimit: n2, firstVideoDecodedTimeout: r2 }) : new ZO(e2, { updateInterval: t2, lossRateInterval: i3, freezeRateLimit: n2, firstVideoDecodedTimeout: r2 }) : function(e3) {
          if (!window.RTCStatsReport)
            return false;
          const t3 = e3.getStats();
          return !!(t3 instanceof Wh || function(e4) {
            return !!e4 && ("object" == typeof e4 || "function" == typeof e4) && "function" == typeof e4.then;
          }(t3));
        }(e2) ? new ZO(e2, { updateInterval: t2, lossRateInterval: i3, freezeRateLimit: n2, firstVideoDecodedTimeout: r2 }) : new $O(e2, { updateInterval: t2, lossRateInterval: i3, freezeRateLimit: n2, firstVideoDecodedTimeout: r2 });
      }
      const tN = function(e2) {
        if (e2.match(/[0-9]+\.[0-9]+\.[0-9]+$/))
          return e2;
        const t2 = e2.match(/([0-9]+\.[0-9]+\.[0-9]+)\-([0-9]+)/);
        if (t2 && t2[1] && t2[2]) {
          const e3 = t2[1], i3 = t2[2];
          return "".concat(e3, ".").concat(i3);
        }
        return "4.0.0.999";
      }("4.23.0"), iN = function() {
        try {
          return true === JSON.parse("true");
        } catch (e2) {
          return true;
        }
      }();
      let nN = function(e2) {
        return e2.Default = "default", e2.Auto = "auto", e2.Relay = "relay", e2.SdRtn = "sd-rtn", e2;
      }({});
      const rN = function() {
        const e2 = "us".concat("erna", "me"), t2 = "pa".concat("sswo", "rd"), i3 = ["t", "s", "t"];
        i3.splice(1, 0, "e");
        const n2 = i3.join(""), r2 = [];
        for (let e3 = 0; e3 < 6; e3++)
          r2.push("1");
        const o2 = r2.join(""), s2 = {};
        return s2[e2] = n2, s2[t2] = o2, Object.assign(s2, { turnServerURL: "", tcpport: 3433, udpport: 3478, forceturn: false });
      }();
      window.DEFAULT_TURN_CONFIG = rN;
      const oN = { MIN_FRAME_RATE: 1, MAX_FRAME_RATE: 30, MAX_THRESHOLD_FRAMERATE: 30, BITRATE_MIN_THRESHOLD: 100, BITRATE_MAX_THRESHOLD: 100, MAX_SCALE: 5, BWE_SCALE_UP_THRESHOLD: 0.6, BWE_SCALE_DOWN_THRESHOLD: 0.6, PERF_SCALE_UP_THRESHOLD: 0.7, PERF_SCALE_DOWN_THRESHOLD: 0.6, MOTION_RESOLUTION_FACTOR: 0.8, MOTION_BITRATE_FACTOR: 0.6, DETAIL_FRAMERATE_FACTOR: 0.8, DETAIL_BITRATE_FACTOR: 0.6, BALANCE_RESOLUTION_FACTOR: 0.9, BALANCE_FRAMERATE_FACTOR: 0.9, BALANCE_BITRATE_FACTOR: 0.6, OVERUSE_TIMES_THRESHOLD: 10, UNDERUSE_TIMES_THRESHOLD: 40 }, sN = "v4.23.0-0-g98fcf352-dirty(12/19/2024, 4:39:56 PM)", aN = pw(pw({ PROCESS_ID: "", ENCRYPT_AES: true, AREAS: ["CHINA", "GLOBAL"], WEBCS_DOMAIN: ["webrtc2-ap-web-1.agora.io", "webrtc2-2.ap.sd-rtn.com"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-ap-web-3.agora.io", "webrtc2-4.ap.sd-rtn.com"], PROXY_CS: ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"], CDS_AP: ["cds-ap-web-1.agora.io", "cds-web-2.ap.sd-rtn.com", "cds-ap-web-3.agora.io", "cds-web-4.ap.sd-rtn.com"], ACCOUNT_REGISTER: ["sua-ap-web-1.agora.io", "sua-web-2.ap.sd-rtn.com", "sua-ap-web-3.agora.io", "sua-web-4.ap.sd-rtn.com"], UAP_AP: ["uap-ap-web-1.agora.io", "uap-web-2.ap.sd-rtn.com", "uap-ap-web-3.agora.io", "uap-web-4.ap.sd-rtn.com"], LOG_UPLOAD_SERVER: "logservice.agora.io", EVENT_REPORT_DOMAIN: "statscollector-1.agora.io", EVENT_REPORT_BACKUP_DOMAIN: "web-2.statscollector.sd-rtn.com", ENABLE_EVENT_REPORT: true, GATEWAY_ADDRESS: [], GATEWAY_WSS_ADDRESS: "", LIVE_STREAMING_ADDRESS: "", HTTP_CONNECT_TIMEOUT: 5e3, SIGNAL_REQUEST_TIMEOUT: 1e4, REPORT_STATS: true, UPLOAD_LOG: false, NOT_REPORT_EVENT: [], PING_PONG_TIME_OUT: 10, WEBSOCKET_TIMEOUT_MIN: 1e4, EVENT_REPORT_SEND_INTERVAL: 3e3, CONFIG_DISTRIBUTE_INTERVAL: 3e5, ENABLE_CONFIG_DISTRIBUTE: true, CANDIDATE_TIMEOUT: 5e3, SHOW_REPORT_INVOKER_LOG: false, SHOW_REPORT_USER_INVOKER_LOG: true, JOIN_EXTEND: "", PUB_EXTEND: "", SUB_EXTEND: "", FORCE_TURN: false, TURN_ENABLE_TCP: true, TURN_ENABLE_UDP: true, MAX_UPLOAD_CACHE: 50, UPLOAD_CACHE_INTERVAL: 2e3, AJAX_REQUEST_CONCURRENT: 3, REPORT_APP_SCENARIO: void 0, GATEWAY_DOMAINS: ["edge.agora.io", "edge.sd-rtn.com"], CONNECT_GATEWAY_WITHOUT_DOMAIN: false, WORKER_DOMAIN: "edge.agora.io", TURN_DOMAIN: "edge.agora.io", EVENT_REPORT_RETRY: true, CHROME_FORCE_PLAN_B: false, AUDIO_SOURCE_VOLUME_UPDATE_INTERVAL: 400, AUDIO_SOURCE_AVG_VOLUME_DURATION: 3e3, AUDIO_VOLUME_INDICATION_INTERVAL: 2e3, VOLUME_VOICE_WEIGHT: 10, GET_VOLUME_OF_MUTED_AUDIO_TRACK: false, STATS_UPDATE_INTERVAL: 250, NORMAL_EVENT_QUEUE_CAPACITY: 100, CUSTOM_REPORT: true, CUSTOM_REPORT_LIMIT: 20, PROXY_SERVER_TYPE2: "webnginx-proxy.agora.io", PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.sd-rtn.com", "webrtc-cloud-proxy.agora.io"], CUSTOM_PUB_ANSWER_MODIFIER: null, CUSTOM_SUB_ANSWER_MODIFIER: null, CUSTOM_PUB_OFFER_MODIFIER: null, CUSTOM_SUB_OFFER_MODIFIER: null, DSCP_TYPE: "high", REMOVE_NEW_CODECS: true, FRAGEMENT_LENGTH: 3, WEBSOCKET_COMPRESS: false, SIMULCAST: false, PRELOAD_MEDIA_COUNT: 0, CHECK_VIDEO_VISIBLE_INTERVAL: 3e4, CHECK_LOCAL_STATS_INTERVAL: 250, PROFILE_SWITCH_INTERVAL: 2e3, UNSUPPORTED_VIDEO_CODEC: [], ENUMERATE_DEVICES_INTERVAL: false, ENUMERATE_DEVICES_INTERVAL_TIME: 1e4, USE_NEW_TOKEN: false, CLOSE_AFB_FOR_LOCAL_AP: true, JOIN_MAX_CONCURRENCY: 6, JOIN_WITH_FALLBACK_SIGNAL_PROXY: true, JOIN_WITH_FALLBACK_MEDIA_PROXY: true, JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE: false, JOIN_GATEWAY_TRY_443PORT_DURATION: 2e3, JOIN_GATEWAY_USE_443PORT_ONLY: false, JOIN_GATEWAY_USE_DUAL_DOMAIN: true, JOIN_GATEWAY_FALLBACK_PORT: 443, USE_TURN_SERVER_OF_GATEWAY: false, H264_PROFILE_LEVEL_ID: "", USE_NEW_LOG: false, LOG_VERSION: 3, MEDIA_DEVICE_CONSTRAINTS: null, ENCRYPT_PROXY_USERNAME_AND_PSW: true, SDP_LOGGING: false, CSP_DETECTED_HOSTNAME_LIST: ["agora.io", "sd-rtn.com"], REMOTE_AUDIO_TRACK_USES_WEB_AUDIO: false, LOCAL_AUDIO_TRACK_USES_WEB_AUDIO: false, BITRATE_ADAPTER_TYPE: "STANDARD_BITRATE", AI_DENOISER_PARAMETERS: { excludedLinks: [] }, ADJUST_3A_FROM_PLUGINS: true, RAISE_H264_BASELINE_PRIORITY: true, FILTER_SEND_H264_BASELINE: false, FIRST_H264_PROFILE_LEVEL_ID: "42001f", FIRST_PACKETIZATION_MODE: "", X_GOOGLE_START_BITRATE: void 0, NEW_REPORT_SERVER: false, NEW_REPORT_SERVER_DOMAINS: ["data-reporting.agora.io", "data-reporting.agora.io"], VIDEO_INSPECT_WORKER_MESSAGE_LENGTH_LIMIT: 3e5, VIDEO_INSPECT_INTERVAL_MINIMUM: 1e3, VIDEO_INSPECT_QUALITY_RATIO: 0.9, VIDEO_INSPECT_WORKER_MANAGER_HOST: "edge.agora.io", VIDEO_INSPECT_WORKER_MANAGER_PORT: "", VIDEO_INSPECT_WORKER_PORT: "", SHOW_VIDEO_INSPECT_WORKER_MESSAGE: false, STATS_COLLECTOR_PORT: 443, FORCE_TURN_TCP: false, WEBAUDIO_INIT_OPTIONS: void 0, FILTER_VIDEO_FEC: true, FILTER_AUDIO_FEC: false, CHROME_DUAL_STREAM_USE_ENCODING: true, DISABLE_DUAL_STREAM_USE_ENCODING: false, EXTENSION_USAGE_UPLOAD_INTERVAL: 1e4, ICE_RESTART: true, ICE_RESTART_INTERVAL: 1e4, NEW_ICE_RESTART: false, TRANSMITTER_INITIAL_RTT: 30, TRANSMITTER_INITIAL_RTO: 30, TRANSMITTER_MAX_BATCH_ACK_COUNT: 2, TRANSMITTER_MAX_RTO: 500, DATACHANNEL_COMPRESS: false, FINGERPRINT: null, DC_JOIN_WITH_FAILBACK: 5e3, ENABLE_VIDEO_FRAME_CALLBACK: true, VIDEO_FREEZE_DURATION: 500, SPATIALIZER_PARAMETERS: {}, UPLOAD_LOG_INTERVAL: 3e3, UPLOAD_LOG_REQUEST_RETRY_INTERVAL: 2e3, UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL: 2e4, UPLOAD_LOG_TRY_INTERVAL_WHILE_OFF: 5e3, UPLOAD_LOG_RETRY_INTERVAL_V1: 1e4, UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1: 200, UPLOAD_LOG_LENGTH_EACH_TIME: 10, APP_TYPE: 0, DISABLE_WEBAUDIO: false, CHANNEL_MEDIA_RELAY_SERVERS: void 0, KEEP_LAST_FRAME: true, FORWARD_P2P_CREATION: true, SYNC_GROUP: true, BLOCK_LOCAL_CLIENT: false, AP_AREA: true, ENABLE_ENCODED_TRANSFORM: false, ENABLE_VIDEO_SEI: false, IMAGE_MODERATION_WORKER_HOST: "edge.agora.io", IMAGE_MODERATION_WORKER_MESSAGE_LENGTH_LIMIT: 3e5, IMAGE_MODERATION_INTERVAL_MINIMUM: 1e3, SHOW_IMAGE_MODERATION_WORKER_MESSAGE: false, IMAGE_MODERATION_QUALITY_RATIO: 0.9, IMAGE_MODERATION_UPLOAD_REPORT_INTERVAL: 5e3, SHOW_GLOBAL_CLIENT_LIST: false, DATASTREAM_MAX_RETRANSMITS: 10, TCP_CANDIDATE_ONLY: false, EXTERNAL_SIGNAL_REQUEST_TIMEOUT: 3e3, SHOW_P2P_LOG: false, MAX_P2P_TIMEOUT: 3e4, P2P_TOKEN_INTERVAL: 1e3, SHOW_DATASTREAM2_LOG: false, RESTRICTION_SET_PLAYBACK_DEVICE: true, USE_PURE_ENCRYPTION_MASTER_KEY: false, ACCOUNT_REGISTER_RETRY_TIMEOUT: 1, ACCOUNT_REGISTER_RETRY_RATIO: 2, ACCOUNT_REGISTER_RETRY_TIMEOUT_MAX: 6e4, ACCOUNT_REGISTER_RETRY_COUNT_MAX: 1e5, AUDIO_CONTEXT: null, WEBCS_BACKUP_CONNECT_TIMEOUT: 6e3, PLAYER_STATE_DEFER: 2e3, SIGNAL_REQUEST_WATCH_INTERVAL: 1e3, FILEPATH_LENMAX: 255, DUALSTREAM_OPERATION_CHECK: true, MEDIA_ELEMENT_EXISTS_DEPTH: 3, SHIM_CANDIDATE: false, LEAVE_MSG_TIMEOUT: 2e3, STATS_FILTER: { transportId: true, googTrackId: true }, FILTER_VIDEO_CODEC: [], USE_NEW_NETWORK_CONFIG: false, AUTO_RESET_AUDIO_ROUTE: false, PLUGIN_INFO: [], OVERUSE_DETECTOR_PARAMS: oN, ENABLE_AG_ADAPTATION: true, FORCE_AG_HIGH_FRAMERATE: false, FORCE_SUPPORT_AG_ADAPTATION: false, CUSTOM_ADAPTATION_DEFAULT_MODE: "", ENCODER_CONFIG_LIMIT: {}, CAMERA_CAPTURE_CONFIG: void 0, HIDE_NO_POSTER: false, AP_CACHE_NUM: 10, AP_UPDATE_INTERVAL: 12e4, AP_CACHE_LIFETIME: 12e4, MAX_PRELOAD_ASYNC_LENGTH: 3, ENABLE_PRELOAD: true, DISABLE_SCREEN_SHARE_REMB: false }, { ENABLE_PUBLISHED_USER_LIST: true, MAX_SUBSCRIPTION: 50, SUBSCRIBE_AUDIO_FILTER_TOPN: void 0, ENABLE_PUBLISH_AUDIO_FILTER: void 0, ENABLE_USER_LICENSE_CHECK: true, USE_PUB_RTX: true, USE_SUB_RTX: true, DISABLE_FEC: void 0, ENABLE_NTP_REPORT: false, ENABLE_INSTANT_VIDEO: false, ENABLE_DATASTREAM_2: false, ENABLE_USER_AUTO_REBALANCE_CHECK: true, USE_XR: true, ENABLE_LOSSBASED_BWE: true, ENABLE_AUT_CC: false, ENABLE_CC_FALLBACK: void 0, ENABLE_PREALLOC_PC: false, SUBSCRIBE_TWCC: true, PUBLISH_TWCC: false, ENABLE_SVC: false, ENABLE_SVC_DEFAULT_CODECS: ["H264", "VP8", "VP9", "AV1"], SVC: [], ENABLE_FULL_LINK_AV_SYNC: false, SVC_MODE: null, PRE_SUB_NUM: 2, ENABLE_PRE_SUB: false, ENABLE_AUT_FEEDBACK: false, SVC_EXTENDED: ["VP9"] }), {}, { USE_CANDIDATE_FROM_AP_DETAIL: false, AP_REQUEST_DETAIL: void 0, ENABLE_ROLE_SELECT_EDGE: false, CLIENT_ROLE_OPTIONS: void 0, RESTART_SEQUENCE: ["udp_tcp_relay", "relay"], COMPATIBLE_SDP_EXTENSION: ["gdpr_forbidden"], LIMIT_BITRATE: void 0, EXPERIMENTS: {} });
      function cN(e2, t2, i3) {
        var n2, r2, o2;
        Dn(n2 = Object.keys(aN)).call(n2, e2) && (!i3 && Dn(r2 = Object.keys(lN)).call(r2, e2) || (aN[e2] = t2, "ENABLE_VIDEO_SEI" === e2 && true === t2 && (aN.ENABLE_ENCODED_TRANSFORM = true), "USE_NEW_NETWORK_CONFIG" === e2 && t2 && (o2 = !!t2, aN.USE_NEW_NETWORK_CONFIG = o2, o2 && (aN.WEBCS_DOMAIN = ["webrtc2-2.ap.sd-rtn.com"], aN.WEBCS_DOMAIN_BACKUP_LIST = ["webrtc2-4.ap.sd-rtn.com"], aN.CDS_AP = ["cds-web-2.ap.sd-rtn.com", "cds-web-4.ap.sd-rtn.com"], aN.ACCOUNT_REGISTER = ["sua-web-2.ap.sd-rtn.com", "sua-web-4.ap.sd-rtn.com"], aN.EVENT_REPORT_DOMAIN = "web-2.statscollector.sd-rtn.com", aN.EVENT_REPORT_BACKUP_DOMAIN = "statscollector-1.agora.io", aN.GATEWAY_DOMAINS = ["edge.sd-rtn.com"])), "ENABLE_PRE_SUB" === e2 && t2 && (aN.ENABLE_INSTANT_VIDEO = true, aN.ENABLE_PREALLOC_PC = true), "ENABLE_SVC" === e2 && t2 && (aN.ENABLE_AUT_CC = true)));
      }
      function dN(e2) {
        return aN[e2];
      }
      iN || (aN.WEBCS_DOMAIN = ["ap-web-1-oversea.agora.io", "ap-web-1-north-america.agora.io"], aN.WEBCS_DOMAIN_BACKUP_LIST = ["ap-web-2-oversea.agora.io", "ap-web-2-north-america.agora.io"], aN.PROXY_CS = ["proxy-ap-web-oversea.agora.io", "proxy-ap-web-america.agora.io"], aN.CDS_AP = ["cds-ap-web-oversea.agora.io", "cds-ap-web-america.agora.io", "cds-ap-web-america2.agora.io"], aN.ACCOUNT_REGISTER = ["sua-ap-web-oversea.agora.io", "sua-ap-web-america.agora.io", "sua-ap-web-america2.agora.io"], aN.UAP_AP = ["uap-ap-web-oversea.agora.io", "uap-ap-web-america.agora.io", "uap-ap-web-america2.agora.io"], aN.LOG_UPLOAD_SERVER = "logservice-oversea.agora.io", aN.EVENT_REPORT_DOMAIN = "statscollector-1-oversea.agora.io", aN.EVENT_REPORT_BACKUP_DOMAIN = "statscollector-2-oversea.agora.io", aN.PROXY_SERVER_TYPE3 = "webrtc-cloud-proxy.agora.io", aN.AREAS = ["NORTH_AMERICA", "OVERSEA"]);
      const lN = {};
      var uN = function(e2) {
        return e2.SET_SESSION_ID = "SET_SESSION_ID", e2.SET_P2P_ID = "SET_P2P_id", e2.SET_DC_ID = "SET_DC_id", e2.SET_UID = "SET_UID", e2.SET_INT_UID = "SET_INT_UID", e2.SET_PUB_ID = "SET_PUB_ID", e2.SET_CLOUD_PROXY_SERVER_MODE = "SET_CLOUD_PROXY_SERVER_MODE", e2.KEY_METRIC_CLIENT_CREATED = "KEY_METRIC_CLIENT_CREATED", e2.KEY_METRIC_JOIN_START = "KEY_METRIC_JOIN_START", e2.AVOID_JOIN_START = "AVOID_JOIN_START", e2.KEY_METRIC_JOIN_END = "KEY_METRIC_JOIN_END", e2.KEY_METRIC_REQUEST_AP_START = "KEY_METRIC_REQUEST_AP_START", e2.KEY_METRIC_REQUEST_AP_END = "KEY_METRIC_REQUEST_AP_END", e2.KEY_METRIC_JOIN_GATEWAY_START = "KEY_METRIC_JOIN_GATEWAY_START", e2.KEY_METRIC_JOIN_GATEWAY_END = "KEY_METRIC_JOIN_GATEWAY_END", e2.KEY_METRIC_PEER_CONNECTION_START = "KEY_METRIC_PEER_CONNECTION_START", e2.KEY_METRIC_PEER_CONNECTION_END = "KEY_METRIC_PEER_CONNECTION_END", e2.KEY_METRIC_DESCRIPTION_START = "KEY_METRIC_DESCRIPTION_START", e2.KEY_METRIC_ICE_CONNECTION_END = "KEY_METRIC_ICE_CONNECTION_END", e2.KEY_METRIC_SIGNAL_CHANNEL_OPEN = "KEY_METRIC_SIGNAL_CHANNEL_OPEN", e2.KEY_METRIC_PUBLISH = "KEY_METRIC_PUBLISH", e2.KEY_METRIC_SUBSCRIBE = "KEY_METRIC_SUBSCRIBE", e2.RECORD_JOIN_CHANNEL_SERVICE = "RECORD_JOIN_CHANNEL_SERVICE", e2.RESET_JOIN_CHANNEL_SERVICE_RECORDS = "RESET_JOIN_CHANNEL_SERVICE_RECORDS", e2.RESET_KEY_METRICS = "RESET_KEY_METRICS", e2.SET_USE_P2P = "SET_USE_P2P", e2.SET_TRANSPORT_TYPE = "SET_TRANSPORT_TYPE", e2;
      }(uN || {});
      let hN = function(e2) {
        return e2.h264 = "h264", e2.h265 = "h265", e2.vp8 = "vp8", e2.vp9 = "vp9", e2.av1 = "av1", e2;
      }({});
      !function(e2) {
        e2.opus = "opus", e2.pcma = "pcma", e2.pcmu = "pcmu", e2.g722 = "g722";
      }({});
      const pN = 128, _N = 96, EN = 1e3, fN = 10;
      let mN = 0;
      var TN = (() => {
        var e2 = { 8: (e3, t3, i4) => {
          i4.r(t3), i4.d(t3, { Parser: () => C2, Printer: () => b2, parse: () => D2, print: () => P2 });
          const n2 = "\n", r2 = "".concat("\r").concat(n2), o2 = " ";
          let s2;
          function a2(e4) {
            return e4 >= "0" && e4 <= "9";
          }
          function c2(e4) {
            return e4 >= "!" && e4 <= "~";
          }
          function d2(e4) {
            return c2(e4) || e4 >= "Â" && e4 <= "Ã¿";
          }
          function l2(e4) {
            return "!" === e4 || e4 >= "#" && e4 <= "'" || e4 >= "*" && e4 <= "+" || e4 >= "-" && e4 <= "." || e4 >= "0" && e4 <= "9" || e4 >= "A" && e4 <= "Z" || e4 >= "^" && e4 <= "~";
          }
          function u2(e4) {
            return e4 >= "1" && e4 <= "9";
          }
          function h2(e4) {
            return e4 >= "A" && e4 <= "Z" || e4 >= "a" && e4 <= "z";
          }
          function p3(e4) {
            return "d" === e4 || "h" === e4 || "m" === e4 || "s" === e4;
          }
          function _2(e4) {
            return e4 > "" && e4 < "	" || e4 > "\v" && e4 < "\f" || e4 > "" && e4 < "Ã¿";
          }
          function E2(e4) {
            return h2(e4) || a2(e4) || "+" === e4 || "/" === e4;
          }
          function f2(e4) {
            return a2(e4) || h2(e4) || "+" === e4 || "/" === e4 || "-" === e4 || "_" === e4;
          }
          function m2(e4) {
            return h2(e4) || a2(e4) || "+" === e4 || "/" === e4;
          }
          function T2(e4, t4) {
            var i5 = Object.keys(e4);
            if (Object.getOwnPropertySymbols) {
              var n3 = Object.getOwnPropertySymbols(e4);
              t4 && (n3 = n3.filter(function(t5) {
                return Object.getOwnPropertyDescriptor(e4, t5).enumerable;
              })), i5.push.apply(i5, n3);
            }
            return i5;
          }
          function S2(e4) {
            for (var t4 = 1; t4 < arguments.length; t4++) {
              var i5 = null != arguments[t4] ? arguments[t4] : {};
              t4 % 2 ? T2(Object(i5), true).forEach(function(t5) {
                g2(e4, t5, i5[t5]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(i5)) : T2(Object(i5)).forEach(function(t5) {
                Object.defineProperty(e4, t5, Object.getOwnPropertyDescriptor(i5, t5));
              });
            }
            return e4;
          }
          function g2(e4, t4, i5) {
            return t4 in e4 ? Object.defineProperty(e4, t4, { value: i5, enumerable: true, configurable: true, writable: true }) : e4[t4] = i5, e4;
          }
          !function(e4) {
            e4.VERSION = "v", e4.ORIGIN = "o", e4.SESSION_NAME = "s", e4.INFORMATION = "i", e4.URI = "u", e4.EMAIL = "e", e4.PHONE = "p", e4.CONNECTION = "c", e4.BANDWIDTH = "b", e4.TIME = "t", e4.REPEAT = "r", e4.ZONE_ADJUSTMENTS = "z", e4.KEY = "k", e4.ATTRIBUTE = "a", e4.MEDIA = "m";
          }(s2 || (s2 = {}));
          class R3 {
            consumeText(e4, t4) {
              let i5 = t4;
              for (; i5 < e4.length; ) {
                const t5 = e4[i5];
                if ("\0" === t5 || "\r" === t5 || t5 === n2)
                  break;
                i5 += 1;
              }
              if (i5 - t4 == 0)
                throw new Error("Invalid text, at ".concat(e4));
              return i5;
            }
            consumeUnicastAddress(e4, t4, i5) {
              return this.consumeTill(e4, t4, o2);
            }
            consumeOneOrMore(e4, t4, i5) {
              let n3 = t4;
              for (; i5(e4[n3]); )
                n3++;
              if (n3 - t4 == 0)
                throw new Error("Invalid rule at ".concat(t4, "."));
              return n3;
            }
            consumeSpace(e4, t4) {
              if (e4[t4] === o2)
                return t4 + 1;
              throw new Error("Invalid space at ".concat(t4, "."));
            }
            consumeIP4Address(e4, t4) {
              let i5 = t4;
              for (let t5 = 0; t5 < 4; t5++)
                if (i5 = this.consumeDecimalUChar(e4, i5), 3 !== t5) {
                  if ("." !== e4[i5])
                    throw new Error("Invalid IP4 address.");
                  i5++;
                }
              return i5;
            }
            consumeDecimalUChar(e4, t4) {
              let i5 = t4;
              for (let t5 = 0; t5 < 3 && a2(e4[i5]); t5++, i5++)
                ;
              if (i5 - t4 == 0)
                throw new Error("Invalid decimal uchar.");
              const n3 = parseInt(e4.slice(t4, i5));
              if (n3 >= 0 && n3 <= 255)
                return i5;
              throw new Error("Invalid decimal uchar");
            }
            consumeIP6Address(e4, t4) {
              let i5 = this.consumeHexpart(e4, t4);
              return ":" === e4[i5] ? (i5 += 1, i5 = this.consumeIP4Address(e4, i5), i5) : i5;
            }
            consumeHexpart(e4, t4) {
              let i5 = t4;
              if (":" === e4[i5] && ":" === e4[i5 + 1]) {
                i5 += 2;
                try {
                  i5 = this.consumeHexseq(e4, i5);
                } catch (e5) {
                }
                return i5;
              }
              if (i5 = this.consumeHexseq(e4, i5), ":" === e4[i5] && ":" === e4[i5 + 1]) {
                i5 += 2;
                try {
                  i5 = this.consumeHexseq(e4, i5);
                } catch (e5) {
                }
                return i5;
              }
              return i5;
            }
            consumeHexseq(e4, t4) {
              let i5 = t4;
              for (; i5 = this.consumeHex4(e4, i5), ":" === e4[i5] && ":" !== e4[i5 + 1]; )
                i5 += 1;
              return i5;
            }
            consumeHex4(e4, t4) {
              let i5 = 0;
              for (; i5 < 4; i5++)
                if (!((n3 = e4[t4 + i5]) >= "0" && n3 <= "9" || n3 >= "a" && n3 <= "f" || n3 >= "A" && n3 <= "F")) {
                  if (0 === i5)
                    throw new Error("Invalid hex 4");
                  break;
                }
              var n3;
              return t4 + i5;
            }
            consumeFQDN(e4, t4) {
              let i5 = t4;
              for (; a2(e4[i5]) || h2(e4[i5]) || "-" === e4[i5] || "." === e4[i5]; )
                i5 += 1;
              if (i5 - t4 < 4)
                throw new Error("Invalid FQDN");
              return i5;
            }
            consumeExtnAddr(e4, t4) {
              return this.consumeOneOrMore(e4, t4, d2);
            }
            consumeMulticastAddress(e4, t4, i5) {
              switch (i5) {
                case "IP4":
                case "ip4":
                  return this.consumeIP4MulticastAddress(e4, t4);
                case "IP6":
                case "ip6":
                  return this.consumeIP6MulticastAddress(e4, t4);
                default:
                  try {
                    return this.consumeFQDN(e4, t4);
                  } catch (i6) {
                    return this.consumeExtnAddr(e4, t4);
                  }
              }
            }
            consumeIP6MulticastAddress(e4, t4) {
              const i5 = this.consumeHexpart(e4, t4);
              return "/" === e4[i5] ? this.consumeInteger(e4, i5 + 1) : i5;
            }
            consumeIP4MulticastAddress(e4, t4) {
              let i5 = t4 + 3;
              const n3 = e4.slice(t4, i5), r3 = parseInt(n3);
              if (r3 < 224 || r3 > 239)
                throw new Error("Invalid IP4 multicast address, IPv4 multicast addresses may be in the range 224.0.0.0 to 239.255.255.255.");
              for (let t5 = 0; t5 < 3; t5++) {
                if ("." !== e4[i5])
                  throw new Error("Invalid IP4 multicast address.");
                i5 += 1, i5 = this.consumeDecimalUChar(e4, i5);
              }
              return "/" === e4[i5] && (i5 += 1), i5 = this.consumeTTL(e4, i5), "/" === e4[i5] && (i5 = this.consumeInteger(e4, i5)), i5;
            }
            consumeInteger(e4, t4) {
              if (!u2(e4[t4]))
                throw new Error("Invalid integer.");
              for (t4 += 1; a2(e4[t4]); )
                t4 += 1;
              return t4;
            }
            consumeTTL(e4, t4) {
              if ("0" === e4[t4])
                return t4 + 1;
              if (!u2(e4[t4]))
                throw new Error("Invalid TTL.");
              t4 += 1;
              for (let i5 = 0; i5 < 2 && a2(e4[t4]); i5++)
                t4 += 1;
              return t4;
            }
            consumeToken(e4, t4) {
              return this.consumeOneOrMore(e4, t4, l2);
            }
            consumeTime(e4, t4) {
              let i5 = t4;
              if ("0" === e4[i5])
                return i5 + 1;
              for (u2(e4[i5]) && (i5 += 1); a2(e4[i5]); )
                i5++;
              if (i5 - t4 < 10)
                throw new Error("Invalid time");
              return i5;
            }
            consumeAddress(e4, t4) {
              return this.consumeTill(e4, t4, o2);
            }
            consumeTypedTime(e4, t4) {
              let i5 = t4;
              return i5 = this.consumeOneOrMore(e4, i5, a2), p3(e4[i5]) ? i5 + 1 : i5;
            }
            consumeRepeatInterval(e4, t4) {
              if (!u2(e4[t4]))
                throw new Error("Invalid repeat interval");
              for (t4 += 1; a2(e4[t4]); )
                t4 += 1;
              return p3(e4[t4]) && (t4 += 1), t4;
            }
            consumePort(e4, t4) {
              return this.consumeOneOrMore(e4, t4, a2);
            }
            consume(e4, t4, i5) {
              for (let n3 = 0; n3 < i5.length; n3++) {
                if (t4 + n3 >= e4.length)
                  throw new Error("consume exceeding value length");
                if (e4[t4 + n3] !== i5[n3])
                  throw new Error("consume ".concat(i5, " failed at ").concat(n3));
              }
              return t4 + i5.length;
            }
            consumeTill(e4, t4, i5) {
              let n3 = t4;
              for (; n3 < e4.length && ("string" != typeof i5 || e4[n3] !== i5) && ("function" != typeof i5 || !i5(e4[n3])); )
                n3++;
              return n3;
            }
          }
          class C2 extends R3 {
            constructor() {
              super(), g2(this, "records", []), g2(this, "currentLine", 0);
            }
            parse(e4) {
              const t4 = this.probeEOL(e4);
              this.records = e4.split(t4).filter((e5) => !!OT(e5).call(e5)).map(this.parseLine), this.currentLine = 0;
              const i5 = this.parseVersion(), n3 = this.parseOrigin(), r3 = this.parseSessionName(), o3 = this.parseInformation(), s3 = this.parseUri(), a3 = this.parseEmail(), c3 = this.parsePhone(), d3 = this.parseConnection(), l3 = this.parseBandWidth(), u3 = this.parseTimeFields(), h3 = this.parseKey(), p4 = this.parseSessionAttribute(), _3 = this.parseMediaDescription();
              if (this.currentLine !== this.records.length)
                throw new Error("parsing failed, non exhaustive sdp lines.");
              return { version: i5, origin: n3, sessionName: r3, information: o3, uri: s3, emails: a3, phones: c3, connection: d3, bandwidths: l3, timeFields: u3, key: h3, attributes: p4, mediaDescriptions: _3 };
            }
            getCurrentRecord() {
              const e4 = this.records[this.currentLine];
              if (!e4)
                throw new Error("Record doesn't exit.");
              return e4;
            }
            probeEOL(e4) {
              for (let t4 = 0; t4 < e4.length; t4++)
                if (e4[t4] === n2)
                  return "\r" === e4[t4 - 1] ? r2 : n2;
              throw new Error("Invalid newline character.");
            }
            parseLine(e4, t4) {
              if (e4.length < 2)
                throw new Error("Invalid sdp line, sdp line should be of form <type>=<value>.");
              const i5 = e4[0];
              if ("=" !== e4[1])
                throw new Error('Invalid sdp line, <type> should be a single character followed by an "=" sign.');
              return { type: i5, value: e4.slice(2), line: t4, cur: 0 };
            }
            parseSessionAttribute() {
              const e4 = new I2();
              for (; this.currentLine < this.records.length; ) {
                const t4 = this.getCurrentRecord();
                if (t4.type !== s2.ATTRIBUTE)
                  break;
                const i5 = { attField: this.extractOneOrMore(t4, (e5) => l2(e5) && ":" !== e5), _cur: 0 };
                ":" === t4.value[t4.cur] && (t4.cur += 1, i5.attValue = this.extractOneOrMore(t4, _2)), e4.parse(i5), this.currentLine++;
              }
              return e4.digest();
            }
            parseMediaAttributes(e4) {
              const t4 = new y2(e4);
              for (; this.currentLine < this.records.length; ) {
                const e5 = this.getCurrentRecord();
                if (e5.type !== s2.ATTRIBUTE)
                  break;
                const i5 = { attField: this.extractOneOrMore(e5, (e6) => l2(e6) && ":" !== e6), _cur: 0 };
                ":" === e5.value[e5.cur] && (e5.cur += 1, i5.attValue = this.extractOneOrMore(e5, _2)), t4.parse(i5), this.currentLine++;
              }
              return t4.digest();
            }
            parseKey() {
              const e4 = this.getCurrentRecord();
              if (e4.type === s2.KEY) {
                if ("prompt" === e4.value || "clear:" === e4.value || "base64:" === e4.value || "uri:" === e4.value)
                  return e4.value;
                throw this.currentLine++, new Error("Invalid key.");
              }
            }
            parseZone() {
              const e4 = this.getCurrentRecord();
              if (e4.type === s2.ZONE_ADJUSTMENTS) {
                const t4 = [];
                for (; ; )
                  try {
                    const i5 = this.extract(e4, this.consumeTime);
                    this.consumeSpaceForRecord(e4);
                    let n3 = false;
                    "-" === e4.value[e4.cur] && (n3 = true, e4.cur += 1);
                    const r3 = this.extract(e4, this.consumeTypedTime);
                    t4.push({ time: i5, typedTime: r3, back: n3 });
                  } catch (e5) {
                    break;
                  }
                if (0 === t4.length)
                  throw new Error("Invalid zone adjustments");
                return this.currentLine++, t4;
              }
              return [];
            }
            parseRepeat() {
              const e4 = [];
              for (; ; ) {
                const t4 = this.getCurrentRecord();
                if (t4.type !== s2.REPEAT)
                  break;
                {
                  const i5 = this.extract(t4, this.consumeRepeatInterval), n3 = this.parseTypedTime(t4);
                  e4.push({ repeatInterval: i5, typedTimes: n3 }), this.currentLine++;
                }
              }
              return e4;
            }
            parseTypedTime(e4) {
              const t4 = [];
              for (; ; )
                try {
                  this.consumeSpaceForRecord(e4), t4.push(this.extract(e4, this.consumeTypedTime));
                } catch (e5) {
                  break;
                }
              if (0 === t4.length)
                throw new Error("Invalid typed time.");
              return t4;
            }
            parseTime() {
              const e4 = this.getCurrentRecord(), t4 = this.extract(e4, this.consumeTime);
              this.consumeSpaceForRecord(e4);
              const i5 = this.extract(e4, this.consumeTime);
              return this.currentLine++, { startTime: t4, stopTime: i5 };
            }
            parseBandWidth() {
              const e4 = [];
              for (; this.currentLine < this.records.length; ) {
                const t4 = this.getCurrentRecord();
                if (t4.type !== s2.BANDWIDTH)
                  break;
                {
                  const i5 = this.extractOneOrMore(t4, l2);
                  if (":" !== t4.value[t4.cur])
                    throw new Error("Invalid bandwidth field.");
                  t4.cur++;
                  const n3 = this.extractOneOrMore(t4, a2);
                  e4.push({ bwtype: i5, bandwidth: n3 }), this.currentLine++;
                }
              }
              return e4;
            }
            parseVersion() {
              const e4 = this.getCurrentRecord();
              if (e4.type !== s2.VERSION)
                throw new Error("first sdp record must be version");
              const t4 = e4.value.slice(0, this.consumeOneOrMore(e4.value, 0, a2));
              if (t4.length !== e4.value.length)
                throw new Error('invalid proto version, "v='.concat(e4.value, '"'));
              return this.currentLine++, t4;
            }
            parseOrigin() {
              const e4 = this.getCurrentRecord();
              if (e4.type !== s2.ORIGIN)
                throw new Error("second line of sdp must be origin");
              const t4 = this.extractOneOrMore(e4, d2);
              this.consumeSpaceForRecord(e4);
              const i5 = this.extractOneOrMore(e4, a2);
              this.consumeSpaceForRecord(e4);
              const n3 = this.extractOneOrMore(e4, a2);
              this.consumeSpaceForRecord(e4);
              const r3 = this.extractOneOrMore(e4, l2);
              this.consumeSpaceForRecord(e4);
              const o3 = this.extractOneOrMore(e4, l2);
              this.consumeSpaceForRecord(e4);
              const c3 = this.extract(e4, this.consumeUnicastAddress);
              return this.currentLine++, { username: t4, sessId: i5, sessVersion: n3, nettype: r3, addrtype: o3, unicastAddress: c3 };
            }
            parseSessionName() {
              const e4 = this.getCurrentRecord();
              if (e4.type === s2.SESSION_NAME) {
                const t4 = this.extract(e4, this.consumeText);
                return this.currentLine++, t4;
              }
            }
            parseInformation() {
              const e4 = this.getCurrentRecord();
              if (e4.type !== s2.INFORMATION)
                return;
              const t4 = this.extract(e4, this.consumeText);
              return this.currentLine++, t4;
            }
            parseUri() {
              const e4 = this.getCurrentRecord();
              if (e4.type === s2.URI)
                return this.currentLine++, e4.value;
            }
            parseEmail() {
              const e4 = [];
              for (; ; ) {
                const t4 = this.getCurrentRecord();
                if (t4.type !== s2.EMAIL)
                  break;
                e4.push(t4.value), this.currentLine++;
              }
              return e4;
            }
            parsePhone() {
              const e4 = [];
              for (; ; ) {
                const t4 = this.getCurrentRecord();
                if (t4.type !== s2.PHONE)
                  break;
                e4.push(t4.value), this.currentLine++;
              }
              return e4;
            }
            parseConnection() {
              const e4 = this.getCurrentRecord();
              if (e4.type === s2.CONNECTION) {
                const t4 = this.extractOneOrMore(e4, l2);
                this.consumeSpaceForRecord(e4);
                const i5 = this.extractOneOrMore(e4, l2);
                this.consumeSpaceForRecord(e4);
                const n3 = this.extract(e4, this.consumeAddress);
                return this.currentLine++, { nettype: t4, addrtype: i5, address: n3 };
              }
            }
            parseMedia() {
              const e4 = this.getCurrentRecord(), t4 = this.extract(e4, this.consumeToken);
              this.consumeSpaceForRecord(e4);
              let i5 = this.extract(e4, this.consumePort);
              "/" === e4.value[e4.cur] && (e4.cur += 1, i5 += this.extract(e4, this.consumeInteger)), this.consumeSpaceForRecord(e4);
              const n3 = [];
              for (n3.push(this.extract(e4, this.consumeToken)); "/" === e4.value[e4.cur]; )
                e4.cur += 1, n3.push(this.extract(e4, this.consumeToken));
              if (0 === n3.length)
                throw new Error("Invalid proto");
              const r3 = this.parseFmt(e4);
              return this.currentLine++, { mediaType: t4, port: i5, protos: n3, fmts: r3 };
            }
            parseTimeFields() {
              const e4 = [];
              for (; this.getCurrentRecord().type === s2.TIME; ) {
                const t4 = this.parseTime(), i5 = this.parseRepeat(), n3 = this.parseZone();
                e4.push({ time: t4, repeats: i5, zones: n3 });
              }
              return e4;
            }
            parseMediaDescription() {
              const e4 = [];
              for (; this.currentLine < this.records.length && this.getCurrentRecord().type === s2.MEDIA; ) {
                const t4 = this.parseMedia(), i5 = this.parseInformation(), n3 = this.parseConnections(), r3 = this.parseBandWidth(), o3 = this.parseKey(), s3 = this.parseMediaAttributes(t4);
                e4.push({ media: t4, information: i5, connections: n3, bandwidths: r3, key: o3, attributes: s3 });
              }
              return e4;
            }
            parseConnections() {
              const e4 = [];
              for (; this.currentLine < this.records.length && this.getCurrentRecord().type === s2.CONNECTION; )
                e4.push(this.parseConnection());
              return e4;
            }
            parseFmt(e4) {
              const t4 = [];
              for (; ; )
                try {
                  this.consumeSpaceForRecord(e4), t4.push(this.extract(e4, this.consumeToken));
                } catch (e5) {
                  break;
                }
              if (0 === t4.length)
                throw new Error("Invalid fmts");
              return t4;
            }
            extract(e4, t4) {
              for (var i5 = arguments.length, n3 = new Array(i5 > 2 ? i5 - 2 : 0), r3 = 2; r3 < i5; r3++)
                n3[r3 - 2] = arguments[r3];
              const o3 = t4.call(this, e4.value, e4.cur, ...n3), s3 = e4.value.slice(e4.cur, o3);
              return e4.cur = o3, s3;
            }
            extractOneOrMore(e4, t4) {
              const i5 = this.consumeOneOrMore(e4.value, e4.cur, t4), n3 = e4.value.slice(e4.cur, i5);
              return e4.cur = i5, n3;
            }
            consumeSpaceForRecord(e4) {
              if (e4.value[e4.cur] !== o2)
                throw new Error("Invalid space at ".concat(e4.cur, "."));
              e4.cur += 1;
            }
          }
          class v2 extends R3 {
            constructor() {
              super(...arguments), g2(this, "attributes", void 0), g2(this, "digested", false);
            }
            extractOneOrMore(e4, t4, i5) {
              const n3 = this.consumeOneOrMore(e4.attValue, e4._cur, t4), r3 = e4.attValue.slice(e4._cur, n3), [o3, s3] = i5 || [];
              if ("number" == typeof o3 && r3.length < o3)
                throw new Error("error in length, should be more or equal than ".concat(o3, " characters."));
              if ("number" == typeof s3 && r3.length > s3)
                throw new Error("error in length, should be less or equal than ".concat(s3, " characters."));
              return e4._cur = n3, r3;
            }
            consumeAttributeSpace(e4) {
              if (e4.attValue[e4._cur] !== o2)
                throw new Error("Invalid space at ".concat(e4._cur, "."));
              e4._cur += 1;
            }
            extract(e4, t4) {
              if (!e4.attValue)
                throw new Error("Nothing to extract from attValue.");
              for (var i5 = arguments.length, n3 = new Array(i5 > 2 ? i5 - 2 : 0), r3 = 2; r3 < i5; r3++)
                n3[r3 - 2] = arguments[r3];
              const o3 = t4.call(this, e4.attValue, e4._cur, ...n3), s3 = e4.attValue.slice(e4._cur, o3);
              return e4._cur = o3, s3;
            }
            atEnd(e4) {
              if (!e4.attValue)
                throw new Error();
              return e4._cur >= e4.attValue.length;
            }
            peekChar(e4) {
              if (!e4.attValue)
                throw new Error();
              return e4.attValue[e4._cur];
            }
            peek(e4, t4) {
              if (!e4.attValue)
                throw new Error();
              for (let i5 = 0; i5 < t4.length; i5++)
                if (t4[i5] !== e4.attValue[e4._cur + i5])
                  return false;
              return true;
            }
            parseIceUfrag(e4) {
              if (this.attributes.iceUfrag)
                throw new Error("Invalid ice-ufrag, should be only a single line if 'a=ice-ufrag'");
              this.attributes.iceUfrag = this.extractOneOrMore(e4, E2, [4, 256]);
            }
            parseIcePwd(e4) {
              if (this.attributes.icePwd)
                throw new Error("Invalid ice-pwd, should be only a single line if 'a=ice-pwd'");
              this.attributes.icePwd = this.extractOneOrMore(e4, E2, [22, 256]);
            }
            parseIceOptions(e4) {
              if (this.attributes.iceOptions)
                throw new Error("Invalid ice-options, should be only one 'ice-options' line");
              const t4 = [];
              for (; !this.atEnd(e4); ) {
                t4.push(this.extractOneOrMore(e4, E2));
                try {
                  this.consumeAttributeSpace(e4);
                } catch (t5) {
                  if (this.atEnd(e4))
                    break;
                  throw t5;
                }
              }
              this.attributes.iceOptions = t4;
            }
            parseFingerprint(e4) {
              const t4 = this.extract(e4, this.consumeToken);
              this.consumeAttributeSpace(e4);
              const i5 = this.extract(e4, this.consumeTill);
              this.attributes.fingerprints.push({ hashFunction: t4, fingerprint: i5 });
            }
            parseExtmap(e4) {
              const t4 = this.extractOneOrMore(e4, a2);
              let i5;
              "/" === this.peekChar(e4) && (this.extract(e4, this.consume, "/"), i5 = this.extract(e4, this.consumeToken)), this.consumeAttributeSpace(e4);
              const n3 = this.extract(e4, this.consumeTill, o2), r3 = S2(S2({ entry: parseInt(t4, 10) }, i5 && { direction: i5 }), {}, { extensionName: n3 });
              this.peekChar(e4) === o2 && (this.consumeAttributeSpace(e4), r3.extensionAttributes = this.extract(e4, this.consumeTill)), this.attributes.extmaps.push(r3);
            }
            parseSetup(e4) {
              if (this.attributes.setup)
                throw new Error("must only be one single 'a=setup' line.");
              const t4 = this.extract(e4, this.consumeTill);
              if ("active" !== t4 && "passive" !== t4 && "actpass" !== t4 && "holdconn" !== t4)
                throw new Error("role must be one of 'active', 'passive', 'actpass', 'holdconn'.");
              this.attributes.setup = t4;
            }
          }
          class I2 extends v2 {
            constructor() {
              super(...arguments), g2(this, "attributes", { unrecognized: [], groups: [], extmaps: [], fingerprints: [], identities: [] });
            }
            parse(e4) {
              if (this.digested)
                throw new Error("already digested");
              try {
                switch (e4.attField) {
                  case "group":
                    this.parseGroup(e4);
                    break;
                  case "ice-lite":
                    this.parseIceLite();
                    break;
                  case "ice-ufrag":
                    this.parseIceUfrag(e4);
                    break;
                  case "ice-pwd":
                    this.parseIcePwd(e4);
                    break;
                  case "ice-options":
                    this.parseIceOptions(e4);
                    break;
                  case "fingerprint":
                    this.parseFingerprint(e4);
                    break;
                  case "setup":
                    this.parseSetup(e4);
                    break;
                  case "tls-id":
                    this.parseTlsId(e4);
                    break;
                  case "identity":
                    this.parseIdentity(e4);
                    break;
                  case "extmap":
                    this.parseExtmap(e4);
                    break;
                  case "msid-semantic":
                    this.parseMsidSemantic(e4);
                    break;
                  default:
                    e4.ignored = true, this.attributes.unrecognized.push(e4);
                }
              } catch (t4) {
                throw console.error("parsing session attribute ".concat(e4.attField, ' error, "a=').concat(e4.attField, ":").concat(e4.attValue, '"')), t4;
              }
              if (!e4.ignored && e4.attValue && !this.atEnd(e4))
                throw new Error("attribute parsing error");
            }
            digest() {
              return this.digested = true, this.attributes;
            }
            parseGroup(e4) {
              const t4 = this.extract(e4, this.consumeToken), i5 = [];
              for (; !this.atEnd(e4) && this.peekChar(e4) === o2; )
                this.consumeAttributeSpace(e4), i5.push(this.extract(e4, this.consumeToken));
              this.attributes.groups.push({ semantic: t4, identificationTag: i5 });
            }
            parseIceLite() {
              if (this.attributes.iceLite)
                throw new Error("Invalid ice-lite, should be only a single line of 'a=ice-lite'");
              this.attributes.iceLite = true;
            }
            parseTlsId(e4) {
              if (this.attributes.tlsId)
                throw new Error("must be only one tld-id line");
              this.attributes.tlsId = this.extractOneOrMore(e4, f2);
            }
            parseIdentity(e4) {
              const t4 = this.extractOneOrMore(e4, m2), i5 = [];
              for (; !this.atEnd(e4) && this.peekChar(e4) === o2; ) {
                this.consumeAttributeSpace(e4);
                const t5 = this.extract(e4, this.consumeToken);
                this.extract(e4, this.consume, "=");
                const n3 = this.extractOneOrMore(e4, (e5) => e5 !== o2 && _2(e5));
                i5.push({ name: t5, value: n3 });
              }
              this.attributes.identities.push({ assertionValue: t4, extensions: i5 });
            }
            parseMsidSemantic(e4) {
              this.peekChar(e4) === o2 && this.consumeAttributeSpace(e4);
              const t4 = { semantic: this.extract(e4, this.consumeToken), identifierList: [] };
              for (; ; ) {
                try {
                  this.consumeAttributeSpace(e4);
                } catch (e5) {
                  break;
                }
                if ("*" === this.peekChar(e4)) {
                  this.extract(e4, this.consume, "*"), t4.applyForAll = true;
                  break;
                }
                {
                  const i5 = this.extract(e4, this.consumeTill, o2);
                  t4.identifierList.push(i5);
                }
              }
              this.attributes.msidSemantic = t4;
            }
          }
          class y2 extends v2 {
            constructor(e4) {
              super(), g2(this, "attributes", void 0), -1 !== e4.protos.indexOf("RTP") || e4.protos.indexOf("rtp"), this.attributes = { unrecognized: [], candidates: [], extmaps: [], fingerprints: [], imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: [], ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: [] };
            }
            parse(e4) {
              if (this.digested)
                throw new Error("already digested");
              try {
                switch (e4.attField) {
                  case "extmap":
                    this.parseExtmap(e4);
                    break;
                  case "setup":
                    this.parseSetup(e4);
                    break;
                  case "ice-ufrag":
                    this.parseIceUfrag(e4);
                    break;
                  case "ice-pwd":
                    this.parseIcePwd(e4);
                    break;
                  case "ice-options":
                    this.parseIceOptions(e4);
                    break;
                  case "candidate":
                    this.parseCandidate(e4);
                    break;
                  case "remote-candidate":
                    this.parseRemoteCandidate(e4);
                    break;
                  case "end-of-candidates":
                    this.parseEndOfCandidates();
                    break;
                  case "fingerprint":
                    this.parseFingerprint(e4);
                    break;
                  case "rtpmap":
                    this.parseRtpmap(e4);
                    break;
                  case "ptime":
                    this.parsePtime(e4);
                    break;
                  case "maxptime":
                    this.parseMaxPtime(e4);
                    break;
                  case "sendrecv":
                  case "recvonly":
                  case "sendonly":
                  case "inactive":
                    this.parseDirection(e4);
                    break;
                  case "ssrc":
                    this.parseSSRC(e4);
                    break;
                  case "fmtp":
                    this.parseFmtp(e4);
                    break;
                  case "rtcp-fb":
                    this.parseRtcpFb(e4);
                    break;
                  case "rtcp-mux":
                    this.parseRTCPMux();
                    break;
                  case "rtcp-mux-only":
                    this.parseRTCPMuxOnly();
                    break;
                  case "rtcp-rsize":
                    this.parseRTCPRsize();
                    break;
                  case "rtcp":
                    this.parseRTCP(e4);
                    break;
                  case "mid":
                    this.parseMid(e4);
                    break;
                  case "msid":
                    this.parseMsid(e4);
                    break;
                  case "imageattr":
                    this.parseImageAttr(e4);
                    break;
                  case "rid":
                    this.parseRid(e4);
                    break;
                  case "simulcast":
                    this.parseSimulcast(e4);
                    break;
                  case "sctp-port":
                    this.parseSctpPort(e4);
                    break;
                  case "max-message-size":
                    this.parseMaxMessageSize(e4);
                    break;
                  case "ssrc-group":
                    this.parseSSRCGroup(e4);
                    break;
                  default:
                    e4.ignored = true, this.attributes.unrecognized.push(e4);
                }
              } catch (t4) {
                throw console.error("parsing media attribute ".concat(e4.attField, ' error, "a=').concat(e4.attField, ":").concat(e4.attValue, '"')), t4;
              }
              if (!e4.ignored && e4.attValue && !this.atEnd(e4))
                throw new Error("attribute parsing error");
            }
            parseCandidate(e4) {
              const t4 = this.extractOneOrMore(e4, E2, [1, 32]);
              this.consumeAttributeSpace(e4);
              const i5 = this.extractOneOrMore(e4, a2, [1, 5]);
              this.consumeAttributeSpace(e4);
              const n3 = this.extract(e4, this.consumeToken);
              this.consumeAttributeSpace(e4);
              const r3 = this.extractOneOrMore(e4, a2, [1, 10]);
              this.consumeAttributeSpace(e4);
              const s3 = this.extract(e4, this.consumeAddress);
              this.consumeAttributeSpace(e4);
              const d3 = this.extract(e4, this.consumePort);
              this.consumeAttributeSpace(e4), this.extract(e4, this.consume, "typ"), this.consumeAttributeSpace(e4);
              const l3 = { foundation: t4, componentId: i5, transport: n3, priority: r3, connectionAddress: s3, port: d3, type: this.extract(e4, this.consumeToken), extension: {} };
              for (this.peek(e4, " raddr") && (this.extract(e4, this.consume, " raddr"), this.consumeAttributeSpace(e4), l3.relAddr = this.extract(e4, this.consumeAddress)), this.peek(e4, " rport") && (this.extract(e4, this.consume, " rport"), this.consumeAttributeSpace(e4), l3.relPort = this.extract(e4, this.consumePort)); this.peekChar(e4) === o2; ) {
                this.consumeAttributeSpace(e4);
                const t5 = this.extract(e4, this.consumeToken);
                this.consumeAttributeSpace(e4), l3.extension[t5] = this.extractOneOrMore(e4, c2);
              }
              this.attributes.candidates.push(l3);
            }
            parseRemoteCandidate(e4) {
              const t4 = [];
              for (; ; ) {
                const i5 = this.extractOneOrMore(e4, a2, [1, 5]);
                this.consumeAttributeSpace(e4);
                const n3 = this.extract(e4, this.consumeAddress);
                this.consumeAttributeSpace(e4);
                const r3 = this.extract(e4, this.consumePort);
                t4.push({ componentId: i5, connectionAddress: n3, port: r3 });
                try {
                  this.consumeAttributeSpace(e4);
                } catch (e5) {
                  break;
                }
              }
              this.attributes.remoteCandidatesList.push(t4);
            }
            parseEndOfCandidates() {
              if (this.attributes.endOfCandidates)
                throw new Error("must be only one line of end-of-candidates");
              this.attributes.endOfCandidates = true;
            }
            parseRtpmap(e4) {
              const t4 = this.extract(e4, this.consumeToken);
              this.consumeAttributeSpace(e4);
              const i5 = this.extract(e4, this.consumeTill, "/");
              this.extract(e4, this.consume, "/");
              const n3 = { encodingName: i5, clockRate: this.extractOneOrMore(e4, a2) };
              this.atEnd(e4) || "/" !== this.peekChar(e4) || (this.extract(e4, this.consume, "/"), n3.encodingParameters = parseInt(this.extract(e4, this.consumeTill), 10));
              const r3 = this.attributes.payloads.find((e5) => e5.payloadType === parseInt(t4, 10));
              r3 ? r3.rtpMap = n3 : this.attributes.payloads.push({ payloadType: parseInt(t4, 10), rtpMap: n3, rtcpFeedbacks: [] });
            }
            parsePtime(e4) {
              if (this.attributes.ptime)
                throw new Error("must be only one line of ptime");
              this.attributes.ptime = this.extract(e4, this.consumeTill);
            }
            parseMaxPtime(e4) {
              if (this.attributes.maxPtime)
                throw new Error("must be only one line of ptime");
              this.attributes.maxPtime = this.extract(e4, this.consumeTill);
            }
            parseDirection(e4) {
              if (this.attributes.direction)
                throw new Error("must be only one line of direction info");
              this.attributes.direction = e4.attField;
            }
            parseSSRC(e4) {
              const t4 = this.extractOneOrMore(e4, a2);
              this.consumeAttributeSpace(e4);
              const i5 = this.extract(e4, this.consumeTill, ":");
              let n3;
              ":" === this.peekChar(e4) && (this.extract(e4, this.consume, ":"), n3 = this.extract(e4, this.consumeTill));
              const r3 = this.attributes.ssrcs.find((e5) => e5.ssrcId === parseInt(t4, 10));
              r3 ? r3.attributes[i5] = n3 : this.attributes.ssrcs.push({ ssrcId: parseInt(t4, 10), attributes: { [i5]: n3 } });
            }
            parseFmtp(e4) {
              const t4 = this.extract(e4, this.consumeTill, o2);
              this.consumeAttributeSpace(e4);
              const i5 = this.extract(e4, this.consumeTill), n3 = {};
              i5.split(";").forEach((e5) => {
                let [t5, i6] = e5.split("=");
                t5 = OT(t5).call(t5);
                const r4 = "string" == typeof i6 ? OT(i6).call(i6) : null;
                "string" == typeof t5 && t5.length > 0 && (n3[t5] = r4);
              });
              const r3 = this.attributes.payloads.find((e5) => e5.payloadType === parseInt(t4, 10));
              r3 ? r3.fmtp = { parameters: n3 } : this.attributes.payloads.push({ payloadType: parseInt(t4, 10), rtcpFeedbacks: [], fmtp: { parameters: n3 } });
            }
            parseFmtParameters(e4) {
              const t4 = {}, i5 = this.extract(e4, this.consumeTill, "=");
              e4._cur++;
              const n3 = this.extract(e4, this.consumeTill, ";");
              for (t4[i5] = n3; ";" === e4.attValue[e4._cur]; ) {
                const i6 = this.extract(e4, this.consumeTill, "=");
                e4._cur++;
                const n4 = this.extract(e4, this.consumeTill, ";");
                t4[i6] = n4;
              }
              return t4;
            }
            parseRtcpFb(e4) {
              let t4 = "";
              t4 = "*" === this.peekChar(e4) ? this.extract(e4, this.consume, "*") : this.extract(e4, this.consumeTill, o2), this.consumeAttributeSpace(e4);
              const i5 = this.extract(e4, this.consumeTill, o2);
              let n3;
              if ("trr-int" === i5)
                n3 = { type: i5, interval: this.extract(e4, this.consumeTill) };
              else {
                const t5 = { type: i5 };
                this.peekChar(e4) === o2 && (this.consumeAttributeSpace(e4), t5.parameter = this.extract(e4, this.consumeToken), this.peekChar(e4) === o2 && (t5.additional = this.extract(e4, this.consumeTill))), n3 = t5;
              }
              if ("*" === t4)
                this.attributes.rtcpFeedbackWildcards.push(n3);
              else {
                const e5 = this.attributes.payloads.find((e6) => e6.payloadType === parseInt(t4, 10));
                e5 ? e5.rtcpFeedbacks.push(n3) : this.attributes.payloads.push({ payloadType: parseInt(t4, 10), rtcpFeedbacks: [n3] });
              }
            }
            parseRTCPMux() {
              if (this.attributes.rtcpMux)
                throw new Error("must be single line of rtcp-mux");
              this.attributes.rtcpMux = true;
            }
            parseRTCPMuxOnly() {
              if (this.attributes.rtcpMuxOnly)
                throw new Error("must be single line of rtcp-only");
              this.attributes.rtcpMuxOnly = true;
            }
            parseRTCPRsize() {
              if (this.attributes.rtcpRsize)
                throw new Error("must be single line of rtcp-rsize");
              this.attributes.rtcpRsize = true;
            }
            parseRTCP(e4) {
              if (this.attributes.rtcp)
                throw new Error("must be single line of rtcp");
              const t4 = { port: this.extract(e4, this.consumePort) };
              this.peekChar(e4) === o2 && (this.consumeAttributeSpace(e4), t4.netType = this.extractOneOrMore(e4, l2), this.consumeAttributeSpace(e4), t4.addressType = this.extractOneOrMore(e4, l2), this.consumeAttributeSpace(e4), t4.address = this.extract(e4, this.consumeAddress)), this.attributes.rtcp = t4;
            }
            parseMsid(e4) {
              const t4 = { id: this.extractOneOrMore(e4, l2, [1, 64]) };
              this.peekChar(e4) === o2 && (this.consumeAttributeSpace(e4), t4.appdata = this.extractOneOrMore(e4, l2, [1, 64])), this.attributes.msids.push(t4);
            }
            parseImageAttr(e4) {
              this.attributes.imageattr.push(e4.attValue);
            }
            parseRid(e4) {
              const t4 = this.extractOneOrMore(e4, (e5) => h2(e5) || a2(e5) || "_" === e5 || "-" === e5);
              this.consumeAttributeSpace(e4);
              const i5 = { id: t4, direction: this.extract(e4, this.consumeToken), params: [] };
              if (this.peekChar(e4) === o2) {
                if (this.consumeAttributeSpace(e4), this.peek(e4, "pt=")) {
                  this.extract(e4, this.consume, "pt=");
                  const t5 = [];
                  for (; ; ) {
                    const i6 = this.extract(e4, this.consumeToken);
                    t5.push(i6);
                    try {
                      this.extract(e4, this.consume, ",");
                    } catch (e5) {
                      break;
                    }
                  }
                  i5.payloads = t5, this.peekChar(e4) === o2 && this.extract(e4, this.consume, o2);
                }
                for (; ; ) {
                  const t5 = this.extract(e4, this.consumeToken);
                  switch (t5) {
                    case "depend": {
                      const n3 = { type: t5, rids: this.extract(e4, this.consume, "=").split(",") };
                      i5.params.push(n3);
                      break;
                    }
                    default: {
                      const n3 = { type: t5 };
                      "=" === this.peekChar(e4) && (this.extract(e4, this.consume, "="), n3.val = this.extract(e4, this.consumeTill, ";")), i5.params.push(n3);
                    }
                  }
                  try {
                    this.extract(e4, this.consume, ";");
                  } catch (e5) {
                    break;
                  }
                }
              }
              this.attributes.rids.push(i5);
            }
            parseSimulcast(e4) {
              if (this.attributes.simulcast)
                throw new Error("must be single line of simulcast");
              this.attributes.simulcast = e4.attValue, this.extract(e4, this.consumeTill);
            }
            parseSctpPort(e4) {
              this.attributes.sctpPort = this.extractOneOrMore(e4, a2, [1, 5]);
            }
            parseMaxMessageSize(e4) {
              this.attributes.maxMessageSize = this.extractOneOrMore(e4, a2, [1, void 0]);
            }
            digest() {
              return this.digested = true, this.attributes;
            }
            parseMid(e4) {
              this.attributes.mid = this.extract(e4, this.consumeToken);
            }
            parseSSRCGroup(e4) {
              const t4 = this.extract(e4, this.consumeToken), i5 = [];
              for (; ; )
                try {
                  this.consumeAttributeSpace(e4);
                  const t5 = this.extract(e4, this.consumeInteger);
                  i5.push(parseInt(t5, 10));
                } catch (e5) {
                  break;
                }
              this.attributes.ssrcGroups.push({ semantic: t4, ssrcIds: i5 });
            }
          }
          function A2(e4, t4, i5) {
            return t4 in e4 ? Object.defineProperty(e4, t4, { value: i5, enumerable: true, configurable: true, writable: true }) : e4[t4] = i5, e4;
          }
          class b2 {
            constructor() {
              A2(this, "eol", r2);
            }
            print(e4, t4) {
              let i5 = "";
              return t4 && (this.eol = t4), i5 += this.printVersion(e4.version), i5 += this.printOrigin(e4.origin), i5 += this.printSessionName(e4.sessionName), i5 += this.printInformation(e4.information), i5 += this.printUri(e4.uri), i5 += this.printEmail(e4.emails), i5 += this.printPhone(e4.phones), i5 += this.printConnection(e4.connection), i5 += this.printBandwidth(e4.bandwidths), i5 += this.printTimeFields(e4.timeFields), i5 += this.printKey(e4.key), i5 += this.printSessionAttributes(e4.attributes), i5 += this.printMediaDescription(e4.mediaDescriptions), i5;
            }
            printVersion(e4) {
              return "v=".concat(e4).concat(this.eol);
            }
            printOrigin(e4) {
              return "o=".concat(e4.username, " ").concat(e4.sessId, " ").concat(e4.sessVersion, " ").concat(e4.nettype, " ").concat(e4.addrtype, " ").concat(e4.unicastAddress).concat(this.eol);
            }
            printSessionName(e4) {
              return e4 ? "s=".concat(e4).concat(this.eol) : "";
            }
            printInformation(e4) {
              return e4 ? "i=".concat(e4).concat(this.eol) : "";
            }
            printUri(e4) {
              return e4 ? "u=".concat(e4).concat(this.eol) : "";
            }
            printEmail(e4) {
              let t4 = "";
              for (const i5 of e4)
                t4 += "e=".concat(i5).concat(this.eol);
              return t4;
            }
            printPhone(e4) {
              let t4 = "";
              for (const i5 of e4)
                t4 += "e=".concat(i5).concat(this.eol);
              return t4;
            }
            printConnection(e4) {
              return e4 ? "c=".concat(e4.nettype, " ").concat(e4.addrtype, " ").concat(e4.address).concat(this.eol) : "";
            }
            printBandwidth(e4) {
              let t4 = "";
              for (const i5 of e4)
                t4 += "b=".concat(i5.bwtype, ":").concat(i5.bandwidth).concat(this.eol);
              return t4;
            }
            printTimeFields(e4) {
              let t4 = "";
              for (const i5 of e4) {
                t4 += "t=".concat(i5.time.startTime, " ").concat(i5.time.startTime).concat(this.eol);
                for (const e5 of i5.repeats)
                  t4 += "r=".concat(e5.repeatInterval, " ").concat(e5.typedTimes.join(" ")).concat(this.eol);
                i5.zoneAdjustments && (t4 += "z=", t4 += "z=".concat(i5.zoneAdjustments.map((e5) => "".concat(e5.time, " ").concat(e5.back ? "-" : "", " ").concat(e5.typedTime)).join(" ")).concat(this.eol), t4 += this.eol);
              }
              return t4;
            }
            printKey(e4) {
              return e4 ? "k=".concat(e4).concat(this.eol) : "";
            }
            printAttributes(e4) {
              let t4 = "";
              for (const i5 of e4)
                t4 += "a=".concat(i5.attField).concat(i5.attValue ? ":".concat(i5.attValue) : "").concat(this.eol);
              return t4;
            }
            printMediaDescription(e4) {
              let t4 = "";
              for (const i5 of e4)
                t4 += this.printMedia(i5.media), t4 += this.printInformation(i5.information), t4 += this.printConnections(i5.connections), t4 += this.printBandwidth(i5.bandwidths), t4 += this.printKey(i5.key), t4 += this.printMediaAttributes(i5);
              return t4;
            }
            printConnections(e4) {
              let t4 = "";
              for (const i5 of e4)
                t4 += this.printConnection(i5);
              return t4;
            }
            printMedia(e4) {
              return "m=".concat(e4.mediaType, " ").concat(e4.port, " ").concat(e4.protos.join("/"), " ").concat(e4.fmts.join(" ")).concat(this.eol);
            }
            printSessionAttributes(e4) {
              return new O2(this.eol).print(e4);
            }
            printMediaAttributes(e4) {
              return new N2(this.eol).print(e4);
            }
          }
          class w2 {
            constructor(e4) {
              A2(this, "eol", void 0), this.eol = e4;
            }
            printIceUfrag(e4) {
              return void 0 === e4 ? "" : "a=ice-ufrag:".concat(e4).concat(this.eol);
            }
            printIcePwd(e4) {
              return void 0 === e4 ? "" : "a=ice-pwd:".concat(e4).concat(this.eol);
            }
            printIceOptions(e4) {
              return void 0 === e4 ? "" : "a=ice-options:".concat(e4.join(o2)).concat(this.eol);
            }
            printFingerprints(e4) {
              return e4.length > 0 ? e4.map((e5) => "a=fingerprint:".concat(e5.hashFunction).concat(o2).concat(e5.fingerprint)).join(this.eol) + this.eol : "";
            }
            printExtmap(e4) {
              return e4.map((e5) => "a=extmap:".concat(e5.entry).concat(e5.direction ? "/".concat(e5.direction) : "").concat(o2).concat(e5.extensionName).concat(e5.extensionAttributes ? "".concat(o2).concat(e5.extensionAttributes) : "").concat(this.eol)).join("");
            }
            printSetup(e4) {
              return void 0 === e4 ? "" : "a=setup:".concat(e4).concat(this.eol);
            }
            printUnrecognized(e4) {
              return e4.map((e5) => "a=".concat(e5.attField).concat(e5.attValue ? ":".concat(e5.attValue) : "").concat(this.eol)).join("");
            }
          }
          class O2 extends w2 {
            print(e4) {
              let t4 = "";
              return t4 += this.printGroups(e4.groups), t4 += this.printMsidSemantic(e4.msidSemantic), t4 += this.printIceLite(e4.iceLite), t4 += this.printIceUfrag(e4.iceUfrag), t4 += this.printIcePwd(e4.icePwd), t4 += this.printIceOptions(e4.iceOptions), t4 += this.printFingerprints(e4.fingerprints), t4 += this.printSetup(e4.setup), t4 += this.printTlsId(e4.tlsId), t4 += this.printIdentity(e4.identities), t4 += this.printExtmap(e4.extmaps), t4 += this.printUnrecognized(e4.unrecognized), t4;
            }
            printGroups(e4) {
              let t4 = "";
              return e4.length > 0 && (t4 += e4.map((e5) => "a=group:".concat(e5.semantic).concat(e5.identificationTag.map((e6) => "".concat(o2).concat(e6)).join("")).concat(this.eol)).join("")), t4;
            }
            printIceLite(e4) {
              return void 0 === e4 ? "" : "a=ice-lite" + this.eol;
            }
            printTlsId(e4) {
              return e4 ? "a=tls-id:".concat(e4).concat(this.eol) : "";
            }
            printIdentity(e4) {
              return 0 === e4.length ? "" : e4.map((e5) => "a=identity:".concat(e5.assertionValue).concat(e5.extensions.map((e6) => "".concat(o2).concat(e6.name).concat(e6.value ? "=".concat(e6.value) : "")))).join(this.eol) + this.eol;
            }
            printMsidSemantic(e4) {
              if (!e4)
                return "";
              let t4 = "a=msid-semantic:".concat(e4.semantic);
              return e4.applyForAll ? t4 += "".concat(o2, "*") : e4.identifierList.length > 0 && (t4 += e4.identifierList.map((e5) => "".concat(o2).concat(e5))), t4 + this.eol;
            }
          }
          class N2 extends w2 {
            print(e4) {
              const t4 = e4.attributes;
              let i5 = "";
              return i5 += this.printRTCP(t4.rtcp), i5 += this.printIceUfrag(t4.iceUfrag), i5 += this.printIcePwd(t4.icePwd), i5 += this.printIceOptions(t4.iceOptions), i5 += this.printCandidates(t4.candidates), i5 += this.printRemoteCandidatesList(t4.remoteCandidatesList), i5 += this.printEndOfCandidates(t4.endOfCandidates), i5 += this.printFingerprints(t4.fingerprints), i5 += this.printSetup(t4.setup), i5 += this.printMid(t4.mid), i5 += this.printExtmap(t4.extmaps), i5 += this.printRTPRelated(t4), i5 += this.printPtime(t4.ptime), i5 += this.printMaxPtime(t4.maxPtime), i5 += this.printDirection(t4.direction), i5 += this.printSSRCGroups(t4.ssrcGroups), i5 += this.printSSRC(t4.ssrcs), i5 += this.printRTCPMux(t4.rtcpMux), i5 += this.printRTCPMuxOnly(t4.rtcpMuxOnly), i5 += this.printRTCPRsize(t4.rtcpRsize), i5 += this.printMSId(t4.msids), i5 += this.printImageattr(t4.imageattr), i5 += this.printRid(t4.rids), i5 += this.printSimulcast(t4.simulcast), i5 += this.printSCTPPort(t4.sctpPort), i5 += this.printMaxMessageSize(t4.maxMessageSize), i5 += this.printUnrecognized(t4.unrecognized), i5;
            }
            printCandidates(e4) {
              return e4.map((e5) => "a=candidate:".concat(e5.foundation).concat(o2).concat(e5.componentId).concat(o2).concat(e5.transport).concat(o2).concat(e5.priority).concat(o2).concat(e5.connectionAddress).concat(o2).concat(e5.port).concat(o2, "typ").concat(o2).concat(e5.type).concat(e5.relAddr ? "".concat(o2, "raddr").concat(o2).concat(e5.relAddr) : "").concat(e5.relPort ? "".concat(o2, "rport").concat(o2).concat(e5.relPort) : "").concat(Object.keys(e5.extension).map((t4) => "".concat(o2).concat(t4).concat(o2).concat(e5.extension[t4])).join("")).concat(this.eol)).join("");
            }
            printRemoteCandidatesList(e4) {
              return e4.map((e5) => "a=remote-candidates:".concat(e5.join(o2)).concat(this.eol)).join("");
            }
            printEndOfCandidates(e4) {
              return void 0 === e4 ? "" : "a=end-of-candidates" + this.eol;
            }
            printRTPRelated(e4) {
              if (!e4.payloads)
                return "";
              const t4 = e4.payloads;
              let i5 = "";
              i5 += e4.rtcpFeedbackWildcards.map((e5) => this.printRTCPFeedback("*", e5)).join("");
              for (const e5 of t4)
                i5 += this.printRtpMap(e5.payloadType, e5.rtpMap), i5 += this.printFmtp(e5.payloadType, e5.fmtp), i5 += e5.rtcpFeedbacks.map((t5) => this.printRTCPFeedback(e5.payloadType, t5)).join("");
              return i5;
            }
            printFmtp(e4, t4) {
              if (!t4)
                return "";
              const i5 = Object.keys(t4.parameters);
              return 1 === i5.length && null === t4.parameters[i5[0]] ? "a=fmtp:".concat(e4).concat(o2).concat(i5[0]).concat(this.eol) : "a=fmtp:".concat(e4).concat(o2).concat(Object.keys(t4.parameters).map((e5) => "".concat(e5, "=").concat(t4.parameters[e5])).join(";")).concat(this.eol);
            }
            printRtpMap(e4, t4) {
              return t4 ? "a=rtpmap:".concat(e4).concat(o2).concat(t4.encodingName, "/").concat(t4.clockRate).concat(t4.encodingParameters ? "/".concat(t4.encodingParameters) : "").concat(this.eol) : "";
            }
            printRTCPFeedback(e4, t4) {
              let i5 = "a=rtcp-fb:".concat(e4).concat(o2), n3 = t4;
              return "trr-int" === n3.type ? i5 += "ttr-int".concat(o2).concat(n3.interval) : (i5 += "".concat(n3.type), n3.parameter && (i5 += "".concat(o2).concat(n3.parameter), n3.additional && (i5 += "".concat(o2).concat(n3.additional)))), i5 + this.eol;
            }
            printPtime(e4) {
              return void 0 === e4 ? "" : "a=ptime:".concat(e4).concat(this.eol);
            }
            printMaxPtime(e4) {
              return void 0 === e4 ? "" : "a=maxptime:".concat(e4).concat(this.eol);
            }
            printDirection(e4) {
              return void 0 === e4 ? "" : "a=".concat(e4).concat(this.eol);
            }
            printSSRC(e4) {
              return e4.map((e5) => Object.keys(e5.attributes).map((t4) => "a=ssrc:".concat(e5.ssrcId.toString(10)).concat(o2).concat(t4).concat(e5.attributes[t4] ? ":".concat(e5.attributes[t4]) : "").concat(this.eol)).join("")).join("");
            }
            printRTCPMux(e4) {
              return void 0 === e4 ? "" : "a=rtcp-mux".concat(this.eol);
            }
            printRTCPMuxOnly(e4) {
              return void 0 === e4 ? "" : "a=rtcp-mux-only".concat(this.eol);
            }
            printRTCPRsize(e4) {
              return void 0 === e4 ? "" : "a=rtcp-rsize".concat(this.eol);
            }
            printRTCP(e4) {
              if (void 0 === e4)
                return "";
              let t4 = "a=rtcp:".concat(e4.port);
              return e4.netType && (t4 += "".concat(o2).concat(e4.netType)), e4.addressType && (t4 += "".concat(o2).concat(e4.addressType)), e4.address && (t4 += "".concat(o2).concat(e4.address)), t4 + this.eol;
            }
            printMSId(e4) {
              return e4.map((e5) => "a=msid:".concat(e5.id).concat(e5.appdata ? "".concat(o2).concat(e5.appdata) : "").concat(this.eol)).join("");
            }
            printImageattr(e4) {
              return e4.map((e5) => "a=imageattr:".concat(e5).concat(this.eol)).join("");
            }
            printRid(e4) {
              return e4.map((e5) => {
                let t4 = "a=rid:".concat(e5.id).concat(o2).concat(e5.direction);
                return e5.payloads && (t4 += "".concat(o2, "pt=").concat(e5.payloads.join(","))), e5.params.length > 0 && (t4 += "".concat(o2).concat(e5.params.map((e6) => "depend" === e6.type ? "depend=".concat(e6.rids.join(",")) : "".concat(e6.type, "=").concat(e6.val)).join(";"))), t4 + this.eol;
              }).join("");
            }
            printSimulcast(e4) {
              return void 0 === e4 ? "" : "a=simulcast:".concat(e4).concat(this.eol);
            }
            printSCTPPort(e4) {
              return void 0 === e4 ? "" : "a=sctp-port:".concat(e4).concat(this.eol);
            }
            printMaxMessageSize(e4) {
              return void 0 === e4 ? "" : "a=max-message-size:".concat(e4).concat(this.eol);
            }
            printMid(e4) {
              return void 0 === e4 ? "" : "a=mid:".concat(e4).concat(this.eol);
            }
            printSSRCGroups(e4) {
              return e4.map((e5) => "a=ssrc-group:".concat(e5.semantic).concat(e5.ssrcIds.map((e6) => "".concat(o2).concat(e6.toString(10))).join("")).concat(this.eol)).join("");
            }
          }
          function D2(e4) {
            return new C2().parse(e4);
          }
          function P2(e4, t4) {
            return new b2().print(e4, t4);
          }
        } }, t2 = {};
        function i3(n2) {
          if (t2[n2])
            return t2[n2].exports;
          var r2 = t2[n2] = { exports: {} };
          return e2[n2](r2, r2.exports, i3), r2.exports;
        }
        return i3.d = (e3, t3) => {
          for (var n2 in t3)
            i3.o(t3, n2) && !i3.o(e3, n2) && Object.defineProperty(e3, n2, { enumerable: true, get: t3[n2] });
        }, i3.o = (e3, t3) => Object.prototype.hasOwnProperty.call(e3, t3), i3.r = (e3) => {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e3, "__esModule", { value: true });
        }, i3(8);
      })();
      function SN(e2) {
        return TN.parse(e2);
      }
      function gN(e2, t2) {
        return TN.print(e2, t2);
      }
      var RN = Ji("Array").keys, CN = pn, vN = Ze, IN = l, yN = RN, AN = Array.prototype, bN = { DOMTokenList: true, NodeList: true }, wN = function(e2) {
        var t2 = e2.keys;
        return e2 === AN || IN(AN, e2) && t2 === AN.keys || vN(bN, CN(e2)) ? yN : t2;
      }, ON = i2(wN);
      function NN(e2, t2, i3) {
        return (t2 = function(e3) {
          var t3 = function(e4, t4) {
            if ("object" != typeof e4 || !e4)
              return e4;
            var i4 = e4[Symbol.toPrimitive];
            if (void 0 !== i4) {
              var n2 = i4.call(e4, "string");
              if ("object" != typeof n2)
                return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(e4);
          }(e3);
          return "symbol" == typeof t3 ? t3 : t3 + "";
        }(t2)) in e2 ? Object.defineProperty(e2, t2, { value: i3, enumerable: true, configurable: true, writable: true }) : e2[t2] = i3, e2;
      }
      function DN(e2, t2) {
        var i3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i3.push.apply(i3, n2);
        }
        return i3;
      }
      function PN(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i3 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? DN(Object(i3), true).forEach(function(t3) {
            NN(e2, t3, i3[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : DN(Object(i3)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
          });
        }
        return e2;
      }
      const LN = new class extends Nw {
        constructor() {
          super(...arguments), NN(this, "currentUploadLogID", 0);
        }
        reportLogUploadError(e2) {
          const { errorRange: t2 } = e2;
          t2[t2.length - 1] && t2[t2.length - 1] > this.currentUploadLogID && (this.currentUploadLogID = t2[t2.length - 1], this.emit("REPORT_LOG_UPLOAD", e2));
        }
      }();
      class kN {
        constructor(e2) {
          NN(this, "logger", void 0), NN(this, "prefixLists", []), this.logger = e2;
        }
        debug() {
          for (var e2 = arguments.length, t2 = new Array(e2), i3 = 0; i3 < e2; i3++)
            t2[i3] = arguments[i3];
          this.logger.debug(...this.prefixLists, ...t2);
        }
        info() {
          for (var e2 = arguments.length, t2 = new Array(e2), i3 = 0; i3 < e2; i3++)
            t2[i3] = arguments[i3];
          this.logger.info(...this.prefixLists, ...t2);
        }
        warning() {
          for (var e2 = arguments.length, t2 = new Array(e2), i3 = 0; i3 < e2; i3++)
            t2[i3] = arguments[i3];
          this.logger.warning(...this.prefixLists, ...t2);
        }
        error() {
          for (var e2 = arguments.length, t2 = new Array(e2), i3 = 0; i3 < e2; i3++)
            t2[i3] = arguments[i3];
          this.logger.error(...this.prefixLists, ...t2);
        }
        prefix(e2) {
          return this.prefixLists.push(e2), this;
        }
        popPrefix() {
          return this.prefixLists.pop(), this;
        }
      }
      function MN() {
        const e2 = /* @__PURE__ */ new Date();
        return e2.toTimeString().split(" ")[0] + ":" + e2.getMilliseconds();
      }
      function UN() {
        const e2 = /* @__PURE__ */ new Date(), t2 = /((\d+:){2}\d+)/.exec((/* @__PURE__ */ new Date()).toUTCString());
        return t2 ? (null == t2 ? void 0 : t2[0]) + ":" + e2.getUTCMilliseconds() : e2.toTimeString().split(" ")[0] + ":" + e2.getMilliseconds();
      }
      const xN = { DEBUG: 0, INFO: 1, WARNING: 2, ERROR: 3, NONE: 4 }, VN = Date.now(), FN2 = (e2) => {
        for (const t2 in xN)
          if (Object.prototype.hasOwnProperty.call(xN, t2) && xN[t2] === e2)
            return t2;
        return "DEFAULT";
      };
      const BN = new class {
        constructor() {
          NN(this, "proxyServerURL", void 0), NN(this, "logLevel", xN.DEBUG), NN(this, "uploadState", "collecting"), NN(this, "uploadLogWaitingList", []), NN(this, "uploadLogUploadingList", []), NN(this, "uploadErrorCount", 0), NN(this, "currentLogID", 0), NN(this, "url", void 0), NN(this, "extLog", (e2, t2) => {
            this.appendLogToWaitingList(e2, ...t2);
          });
        }
        debug() {
          for (var e2 = arguments.length, t2 = new Array(e2), i3 = 0; i3 < e2; i3++)
            t2[i3] = arguments[i3];
          const n2 = [xN.DEBUG].concat(t2);
          this.log.apply(this, n2);
        }
        info() {
          for (var e2 = arguments.length, t2 = new Array(e2), i3 = 0; i3 < e2; i3++)
            t2[i3] = arguments[i3];
          const n2 = [xN.INFO].concat(t2);
          this.log.apply(this, n2);
        }
        warning() {
          for (var e2 = arguments.length, t2 = new Array(e2), i3 = 0; i3 < e2; i3++)
            t2[i3] = arguments[i3];
          const n2 = [xN.WARNING].concat(t2);
          this.log.apply(this, n2);
        }
        warn() {
          this.warning(...arguments);
        }
        error() {
          for (var e2 = arguments.length, t2 = new Array(e2), i3 = 0; i3 < e2; i3++)
            t2[i3] = arguments[i3];
          const n2 = [xN.ERROR].concat(t2);
          this.log.apply(this, n2);
        }
        upload() {
          for (var e2 = arguments.length, t2 = new Array(e2), i3 = 0; i3 < e2; i3++)
            t2[i3] = arguments[i3];
          const n2 = [xN.DEBUG].concat(t2);
          this.uploadLog.apply(this, n2);
        }
        setLogLevel(e2) {
          e2 = Math.min(Math.max(0, e2), 4), this.logLevel = e2;
        }
        enableLogUpload() {
          cN("UPLOAD_LOG", true);
        }
        disableLogUpload() {
          cN("UPLOAD_LOG", false), this.uploadLogUploadingList = [], this.uploadLogWaitingList = [];
        }
        setProxyServer(e2) {
          this.proxyServerURL = e2;
        }
        prefix(e2) {
          return new kN(this).prefix(e2);
        }
        log() {
          for (var e2 = arguments.length, t2 = new Array(e2), i3 = 0; i3 < e2; i3++)
            t2[i3] = arguments[i3];
          if (Date.now() - VN < 100)
            return void setTimeout(() => {
              this.log(...t2);
            }, Date.now() - VN);
          const n2 = Math.max(0, Math.min(4, t2[0]));
          if (t2[0] = MN() + " Agora-SDK [".concat(FN2(n2), "]:"), this.appendLogToWaitingList(n2, ...t2), n2 < this.logLevel)
            return;
          const r2 = MN() + " %cAgora-SDK [".concat(FN2(n2), "]:");
          let o2 = [];
          if (!dN("USE_NEW_LOG"))
            switch (n2) {
              case xN.DEBUG:
                o2 = [r2, "color: #64B5F6;"].concat(t2.slice(1)), console.log.apply(console, o2);
                break;
              case xN.INFO:
                o2 = [r2, "color: #1E88E5; font-weight: bold;"].concat(t2.slice(1)), console.log.apply(console, o2);
                break;
              case xN.WARNING:
                o2 = [r2, "color: #FB8C00; font-weight: bold;"].concat(t2.slice(1)), console.warn.apply(console, o2);
                break;
              case xN.ERROR:
                o2 = [r2, "color: #B00020; font-weight: bold;"].concat(t2.slice(1)), console.error.apply(console, o2);
            }
        }
        uploadLog() {
          for (var e2 = arguments.length, t2 = new Array(e2), i3 = 0; i3 < e2; i3++)
            t2[i3] = arguments[i3];
          if (Date.now() - VN < 100)
            return void setTimeout(() => {
              this.uploadLog(...t2);
            }, Date.now() - VN);
          const n2 = Math.max(0, Math.min(4, t2[0]));
          t2[0] = MN() + " Agora-SDK [".concat(FN2(n2), "]:"), this.appendLogToWaitingList(n2, ...t2);
        }
        appendLogToWaitingList(e2) {
          if (!dN("UPLOAD_LOG"))
            return;
          for (var t2 = arguments.length, i3 = new Array(t2 > 1 ? t2 - 1 : 0), n2 = 1; n2 < t2; n2++)
            i3[n2 - 1] = arguments[n2];
          Array.isArray(i3[0]) ? i3[0][0] = UN() + " Agora-SDK [".concat(FN2(e2), "]:") : i3[0] = UN() + " Agora-SDK [".concat(FN2(e2), "]:");
          let r2 = "";
          i3.forEach((e3) => {
            "object" == typeof e3 && (e3 = JSON.stringify(e3)), r2 += "".concat(e3, " ");
          }), this.uploadLogWaitingList.push({ payload_str: r2, log_level: e2, log_item_id: this.currentLogID++ }), "uploading" === this.uploadState && 0 === this.uploadLogUploadingList.length && this.uploadLogInterval();
        }
        startUpload() {
          this.uploadState = "uploading", 0 === this.uploadLogUploadingList.length && this.uploadLogInterval();
        }
        async uploadLogs() {
          const e2 = this.uploadLogUploadingList, t2 = { sdk_version: tN, process_id: dN("PROCESS_ID"), payload: JSON.stringify(e2) };
          return bO(async () => {
            const e3 = await Ab.post(this.url || (this.proxyServerURL ? "https://".concat(this.proxyServerURL, "/ls/?h=").concat(dN("LOG_UPLOAD_SERVER"), "&p=443&d=upload/v1") : "https://".concat(dN("LOG_UPLOAD_SERVER"), "/upload/v1")), t2, { responseType: "text" });
            if ("OK" !== e3.data) {
              const t3 = new Error("unexpected upload log response");
              throw t3.response = e3, t3;
            }
          }, () => (this.uploadLogUploadingList = [], false), (t3) => {
            const i3 = { status: -1, message: t3.message, errorRange: e2.map((e3) => e3.log_item_id) };
            return t3.response ? (i3.status = t3.response.status, i3.data = t3.response.data, i3.headers = t3.response.headers) : t3.request && (i3.status = t3.request.status), LN.reportLogUploadError(i3), true;
          }, { timeout: dN("UPLOAD_LOG_REQUEST_RETRY_INTERVAL"), maxRetryTimeout: dN("UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL") });
        }
        uploadLogInterval() {
          0 === this.uploadLogUploadingList.length && 0 === this.uploadLogWaitingList.length || (0 === this.uploadLogUploadingList.length && (this.uploadLogUploadingList = this.uploadLogWaitingList.splice(0, dN("UPLOAD_LOG_LENGTH_EACH_TIME"))), this.uploadLogs().then(() => {
            this.uploadErrorCount = 0, this.uploadLogWaitingList.length > 0 && window.setTimeout(() => this.uploadLogInterval(), dN("UPLOAD_LOG_INTERVAL"));
          }).catch((e2) => {
            this.uploadErrorCount += 1, this.uploadErrorCount < 2 ? window.setTimeout(() => this.uploadLogInterval(), dN("UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1")) : window.setTimeout(() => this.uploadLogInterval(), dN("UPLOAD_LOG_RETRY_INTERVAL_V1"));
          }));
        }
      }();
      var jN;
      function GN(e2) {
        return gw(e2.reportId, "params.reportId", 0, 100, false), gw(e2.category, "params.category", 0, 100, false), gw(e2.event, "params.event", 0, 100, false), gw(e2.label, "params.label", 0, 100, false), Tw(e2.value, "params.value", Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, false), true;
      }
      (jN = {}).FREE = "free", jN.UPLOADING = "uploading", function(e2) {
        e2[e2.MISC = 0] = "MISC", e2[e2.INTERNAL_EVENT = 1] = "INTERNAL_EVENT", e2[e2.PUBLIC_EVENT = 2] = "PUBLIC_EVENT", e2[e2.WEB_EVENT = 3] = "WEB_EVENT", e2[e2.INTERNAL_API = 4] = "INTERNAL_API", e2[e2.WEB_API = 5] = "WEB_API", e2[e2.PUBLIC_API = 6] = "PUBLIC_API";
      }({});
      const WN = { sid: "", lts: 0, success: null, cname: null, uid: null, peer: null, cid: null, elapse: null, extend: null, vid: 0 };
      let HN = function(e2) {
        return e2.PUBLISH = "publish", e2.SUBSCRIBE = "subscribe", e2.WS_COMPRESSOR_INIT = "ws_compressor_init", e2.SESSION_INIT = "session_init", e2.JOIN_CHOOSE_SERVER = "join_choose_server", e2.REQ_USER_ACCOUNT = "req_user_account", e2.JOIN_GATEWAY = "join_gateway", e2.REJOIN_GATEWAY = "rejoin_gateway", e2.STREAM_SWITCH = "stream_switch", e2.REQUEST_PROXY_WORKER_MANAGER = "request_proxy_worker_manager", e2.REQUEST_PROXY_APPCENTER = "request_proxy_appcenter", e2.FIRST_VIDEO_RECEIVED = "first_video_received", e2.FIRST_AUDIO_RECEIVED = "first_audio_received", e2.FIRST_VIDEO_DECODE = "first_video_decode", e2.FIRST_AUDIO_DECODE = "first_audio_decode", e2.ON_ADD_AUDIO_STREAM = "on_add_audio_stream", e2.ON_ADD_VIDEO_STREAM = "on_add_video_stream", e2.ON_UPDATE_STREAM = "on_update_stream", e2.ON_REMOVE_STREAM = "on_remove_stream", e2.USER_ANALYTICS = "req_user_analytics", e2.PC_STATS = "pc_stats", e2.UPDATE_REMOTE_RTPCAPABILITIES = "update_remote_rtpCapabilities", e2;
      }({}), KN = function(e2) {
        return e2.SESSION = "io.agora.pb.Wrtc.Session", e2.JOIN_CHOOSE_SERVER = "io.agora.pb.Wrtc.JoinChooseServer", e2.REQ_USER_ACCOUNT = "io.agora.pb.Wrtc.ReqUserAccount", e2.JOIN_GATEWAY = "io.agora.pb.Wrtc.JoinGateway", e2.RE_JOIN_GATEWAY = "io.agora.pb.Wrtc.ReJoinGateway", e2.PUBLISH = "io.agora.pb.Wrtc.Publish", e2.SUBSCRIBE = "io.agora.pb.Wrtc.Subscribe", e2.WS_COMPRESSOR_INIT = "io.agora.pb.Wrtc.WsCompressorInit", e2.STREAM_SWITCH = "io.agora.pb.Wrtc.StreamSwitch", e2.AUDIO_SENDING_STOPPED = "io.agora.pb.Wrtc.AudioSendingStopped", e2.VIDEO_SENDING_STOPPED = "io.agora.pb.Wrtc.VideoSendingStopped", e2.REQUEST_PROXY_APPCENTER = "io.agora.pb.Wrtc.RequestProxyAppCenter", e2.REQUEST_PROXY_WORKER_MANAGER = "io.agora.pb.Wrtc.RequestProxyWorkerManager", e2.API_INVOKE = "io.agora.pb.Wrtc.ApiInvoke", e2.FIRST_VIDEO_RECEIVED = "io.agora.pb.Wrtc.FirstVideoReceived", e2.FIRST_AUDIO_RECEIVED = "io.agora.pb.Wrtc.FirstAudioReceived", e2.FIRST_VIDEO_DECODE = "io.agora.pb.Wrtc.FirstVideoDecode", e2.FIRST_AUDIO_DECODE = "io.agora.pb.Wrtc.FirstAudioDecode", e2.ON_ADD_AUDIO_STREAM = "io.agora.pb.Wrtc.OnAddAudioStream", e2.ON_ADD_VIDEO_STREAM = "io.agora.pb.Wrtc.OnAddVideoStream", e2.ON_UPDATE_STREAM = "io.agora.pb.Wrtc.OnUpdateStream", e2.ON_REMOVE_STREAM = "io.agora.pb.Wrtc.OnRemoveStream", e2.JOIN_CHANNEL_TIMEOUT = "io.agora.pb.Wrtc.JoinChannelTimeout", e2.PEER_PUBLISH_STATUS = "io.agora.pb.Wrtc.PeerPublishStatus", e2.WORKER_EVENT = "io.agora.pb.Wrtc.WorkerEvent", e2.AP_WORKER_EVENT = "io.agora.pb.Wrtc.APWorkerEvent", e2.JOIN_WEB_PROXY_AP = "io.agora.pb.Wrtc.JoinWebProxyAP", e2.WEBSOCKET_QUIT = "io.agora.pb.Wrtc.WebSocketQuit", e2.USER_ANALYTICS = "io.agora.pb.Wrtc.UserAnalytics", e2.AUTOPLAY_FAILED = "io.agora.pb.Wrtc.AutoplayFailed", e2.PC_STATS = "io.agora.pb.Wrtc.PCStats", e2.UPDATE_REMOTE_RTPCAPABILITIES = "io.agora.pb.Wrtc.UpdateRemoteRTPCapabilities", e2;
      }({});
      !function(e2) {
        e2[e2.WORKER_EVENT = 156] = "WORKER_EVENT", e2[e2.AP_WORKER_EVENT = 160] = "AP_WORKER_EVENT";
      }({});
      let YN = function(e2) {
        return e2[e2.SESSION = 26] = "SESSION", e2[e2.JOIN_CHOOSE_SERVER = 27] = "JOIN_CHOOSE_SERVER", e2[e2.REQ_USER_ACCOUNT = 196] = "REQ_USER_ACCOUNT", e2[e2.JOIN_GATEWAY = 28] = "JOIN_GATEWAY", e2[e2.PUBLISH = 30] = "PUBLISH", e2[e2.SUBSCRIBE = 29] = "SUBSCRIBE", e2[e2.WS_COMPRESSOR_INIT = 9430] = "WS_COMPRESSOR_INIT", e2[e2.STREAM_SWITCH = 32] = "STREAM_SWITCH", e2[e2.AUDIO_SENDING_STOPPED = 33] = "AUDIO_SENDING_STOPPED", e2[e2.VIDEO_SENDING_STOPPED = 34] = "VIDEO_SENDING_STOPPED", e2[e2.REQUEST_PROXY_APPCENTER = 35] = "REQUEST_PROXY_APPCENTER", e2[e2.REQUEST_PROXY_WORKER_MANAGER = 36] = "REQUEST_PROXY_WORKER_MANAGER", e2[e2.API_INVOKE = 41] = "API_INVOKE", e2[e2.FIRST_VIDEO_RECEIVED = 348] = "FIRST_VIDEO_RECEIVED", e2[e2.FIRST_AUDIO_RECEIVED = 349] = "FIRST_AUDIO_RECEIVED", e2[e2.FIRST_VIDEO_DECODE = 350] = "FIRST_VIDEO_DECODE", e2[e2.FIRST_AUDIO_DECODE = 351] = "FIRST_AUDIO_DECODE", e2[e2.ON_ADD_AUDIO_STREAM = 352] = "ON_ADD_AUDIO_STREAM", e2[e2.ON_ADD_VIDEO_STREAM = 353] = "ON_ADD_VIDEO_STREAM", e2[e2.ON_UPDATE_STREAM = 356] = "ON_UPDATE_STREAM", e2[e2.ON_REMOVE_STREAM = 355] = "ON_REMOVE_STREAM", e2[e2.JOIN_CHANNEL_TIMEOUT = 407] = "JOIN_CHANNEL_TIMEOUT", e2[e2.PEER_PUBLISH_STATUS = 408] = "PEER_PUBLISH_STATUS", e2[e2.WORKER_EVENT = 156] = "WORKER_EVENT", e2[e2.AP_WORKER_EVENT = 160] = "AP_WORKER_EVENT", e2[e2.JOIN_WEB_PROXY_AP = 700] = "JOIN_WEB_PROXY_AP", e2[e2.WEBSOCKET_QUIT = 671] = "WEBSOCKET_QUIT", e2[e2.USER_ANALYTICS = 1e4] = "USER_ANALYTICS", e2[e2.AUTOPLAY_FAILED = 9178] = "AUTOPLAY_FAILED", e2;
      }({});
      function qN() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        return function(t2, i3, n2) {
          const r2 = n2.value;
          if ("function" == typeof r2) {
            const o2 = e2.className || t2.__className__ || ("AgoraRTCClient" === t2.constructor.name ? "Client" : t2.constructor.name);
            n2.value = function() {
              for (var t3, n3 = arguments.length, s2 = new Array(n3), a2 = 0; a2 < n3; a2++)
                s2[a2] = arguments[a2];
              let c2 = s2;
              if (e2.argsMap)
                try {
                  c2 = e2.argsMap(this, ...s2);
                } catch (e3) {
                  BN.warning(e3), c2 = [];
                }
              try {
                JSON.stringify(c2);
              } catch (e3) {
                BN.warning("arguments for method ".concat(o2, ".").concat(String(i3), " not serializable for apiInvoke.")), c2 = [];
              }
              const d2 = (e2.report || zN).reportApiInvoke(this._sessionId || null, { id: this._clientId || (null === (t3 = this.store) || void 0 === t3 ? void 0 : t3.clientId) || this._ID, name: "".concat(o2, ".").concat(String(i3)), options: c2, tag: kw.TRACER, reportResult: e2.reportResult }, e2.throttleTime);
              try {
                const t4 = r2.apply(this, s2);
                return t4 instanceof Wh ? t4.then((t5) => (d2.onSuccess(e2.reportResult && t5), t5)).catch((e3) => {
                  throw d2.onError(e3), e3;
                }) : (d2.onSuccess(e2.reportResult && t4), t4);
              } catch (e3) {
                throw d2.onError(e3), e3;
              }
            };
          }
          return n2;
        };
      }
      const zN = new class {
        constructor() {
          NN(this, "baseInfoMap", /* @__PURE__ */ new Map()), NN(this, "proxyServer", void 0), NN(this, "eventUploadTimer", void 0), NN(this, "setSessionIdTimer", void 0), NN(this, "url", void 0), NN(this, "sids", /* @__PURE__ */ new Set()), NN(this, "backupUrl", void 0), NN(this, "_appId", void 0), NN(this, "_aid", 0), NN(this, "keyEventUploadPendingItems", []), NN(this, "normalEventUploadPendingItems", []), NN(this, "apiInvokeUploadPendingItems", []), NN(this, "apiInvokeCount", 0), NN(this, "apiInvokeLoggedCount", 0), NN(this, "ltsList", []), NN(this, "lastSendNormalEventTime", Date.now()), NN(this, "customReportCounterTimer", void 0), NN(this, "customReportCount", 0), NN(this, "extApiInvoke", async (e2) => {
            for (const t2 of e2) {
              const e3 = PN(PN({}, t2), {}, { sid: null, invokeId: ++this.apiInvokeCount, tag: kw.TRACER });
              this.sendApiInvoke(e3);
            }
          }), this.eventUploadTimer = window.setInterval(this.doSend.bind(this), dN("EVENT_REPORT_SEND_INTERVAL")), this.setSessionIdTimer = window.setInterval(this.appendSessionId.bind(this), dN("EVENT_REPORT_SEND_INTERVAL"));
        }
        getBaseInfoBySessionId(e2) {
          return this.baseInfoMap.get(e2);
        }
        setAppId(e2) {
          this._appId = e2, this._aid = parseInt(e2.replace(/[a-fA-F0-9]{8}/g, (e3) => {
            let [t2, i3] = e3;
            return t2 + i3;
          }), 16) || 0;
        }
        reportApiInvoke(e2, t2, i3) {
          t2.timeout = t2.timeout || 6e4, t2.reportResult = void 0 === t2.reportResult || t2.reportResult;
          const n2 = Date.now();
          this.apiInvokeCount += 1;
          const r2 = this.apiInvokeCount, o2 = !!dN("SHOW_REPORT_INVOKER_LOG"), s2 = !!dN("SHOW_REPORT_USER_INVOKER_LOG"), a2 = o2 || s2 && t2.id;
          a2 && (this.apiInvokeLoggedCount += 1);
          const c2 = this.apiInvokeLoggedCount;
          function d2(e3, i4) {
            if (a2) {
              let n3 = "[apiInvoke-".concat(c2, "]");
              t2.id && (n3 += "[".concat(t2.id, "]")), t2.name && (n3 += "[".concat(t2.name, "]")), BN.info("".concat(n3, " ").concat(e3), "start" === e3 ? t2.options : i4 || "");
            }
          }
          const l2 = () => ({ tag: t2.tag, invokeId: r2, sid: e2, name: t2.name, apiInvokeTime: n2, options: t2.options, states: t2.states || null });
          d2("start");
          let u2 = false;
          lO(t2.timeout).then(() => {
            u2 || (this.sendApiInvoke(PN(PN({}, l2()), {}, { error: _w.API_INVOKE_TIMEOUT, success: false })), d2("timeout"));
          });
          const h2 = new Ew(_w.UNEXPECTED_ERROR, "".concat(t2.name, ": this api invoke is end"));
          return { onSuccess: (e3) => {
            const n3 = () => {
              if (u2)
                throw h2;
              return u2 = true, this.sendApiInvoke(PN(PN({}, l2()), {}, { success: true }, t2.reportResult && { result: e3 })), d2("onSuccess"), e3;
            };
            return i3 ? EO(n3, t2.name + "Success", i3, () => u2 = true) : n3();
          }, onError: (e3) => {
            const n3 = () => {
              if (u2)
                throw e3;
              u2 = true, this.sendApiInvoke(PN(PN({}, l2()), {}, { success: false, error: e3 })), d2("onFailure", e3.toString());
            };
            return i3 ? EO(n3, t2.name + "Error", i3, () => u2 = true) : n3();
          } };
        }
        sessionInit(e2, t2) {
          if (this.baseInfoMap.has(e2))
            return;
          const i3 = Date.now(), n2 = this.createBaseInfo(e2, i3);
          n2.cname = t2.cname;
          const r2 = Object.assign({}, { willUploadConsoleLog: dN("UPLOAD_LOG"), maxTouchPoints: navigator.maxTouchPoints, areaVersion: iN ? "global" : "oversea", areas: dN("AREAS") && dN("AREAS").join(",") }, t2.extend), { stringUid: o2, channelProfile: s2, channelMode: a2, isABTestSuccess: c2, lsid: d2, clientRole: l2 } = t2, u2 = Date.now(), h2 = PN(PN({}, n2), {}, { eventType: HN.SESSION_INIT, appid: t2.appid, browser: navigator.userAgent, buildFormat: t2.buildFormat, build: sN, lts: u2, elapse: u2 - i3, extend: JSON.stringify(r2), mode: t2.mode, process: dN("PROCESS_ID"), appType: dN("APP_TYPE"), success: true, version: tN, stringUid: o2, channelProfile: s2, channelMode: a2, isABTestSuccess: c2, lsid: d2, clientType: Dn(p3 = window.navigator.userAgent).call(p3, "AgoraWebView") ? 42 : 20, clientRole: l2, serviceId: dN("PROCESS_ID"), extensionID: dN("PLUGIN_INFO").join(",") || "" });
          var p3;
          this.send({ type: KN.SESSION, data: h2 }, true);
        }
        joinChooseServer(e2, t2) {
          const i3 = this.baseInfoMap.get(e2);
          if (!i3)
            return;
          const n2 = i3.info, r2 = Date.now(), o2 = PN(PN({}, n2), {}, { role: t2.role, eventType: HN.JOIN_CHOOSE_SERVER, lts: r2, eventElapse: t2.elapse || r2 - t2.lts, chooseServerAddr: t2.csAddr, errorCode: t2.ec, elapse: r2 - i3.startTime, success: t2.succ, chooseServerAddrList: JSON.stringify(t2.serverList), uid: t2.uid ? parseInt(t2.uid) : null, cid: t2.cid ? parseInt(t2.cid) : null, chooseServerIp: t2.csIp || "", opid: t2.opid, unilbsServerIds: t2.unilbsServerIds, extend: t2.extend || void 0, isHttp3: t2.isHttp3, corssRegionTagReq: t2.corssRegionTagReq || void 0, corssRegionTagRes: t2.corssRegionTagRes || void 0 });
          this.send({ type: KN.JOIN_CHOOSE_SERVER, data: o2 }, true);
        }
        reqUserAccount(e2, t2) {
          const i3 = this.baseInfoMap.get(e2);
          if (!i3)
            return;
          const n2 = i3.info, r2 = Date.now(), o2 = PN(PN({}, n2), {}, { eventType: HN.REQ_USER_ACCOUNT, lts: r2, success: t2.success, serverAddress: t2.serverAddr, stringUid: t2.stringUid, uid: t2.uid, errorCode: t2.errorCode, elapse: t2.elapse || r2 - i3.startTime, eventElapse: r2 - t2.lts, extend: JSON.stringify(t2.extend) });
          this.send({ type: KN.REQ_USER_ACCOUNT, data: o2 }, true);
        }
        joinGateway(e2, t2) {
          const i3 = this.baseInfoMap.get(e2);
          if (!i3)
            return;
          const n2 = i3.info;
          t2.vid && (n2.vid = t2.vid), n2.uid = t2.uid, n2.cid = t2.cid;
          const r2 = Date.now(), { firstSuccess: o2, avoidJoinStartTime: s2, addr: a2, isProxy: c2 } = t2, d2 = r2 - (o2 && s2 ? s2 : i3.startTime), l2 = PN(PN({}, n2), {}, { eventType: HN.JOIN_GATEWAY, lts: r2, gatewayAddr: t2.addr, success: t2.succ, errorCode: t2.ec, errorMsg: t2.errorMsg || "", elapse: d2, eventElapse: r2 - t2.lts, firstSuccess: o2, signalChannel: t2.signalChannel, preload: t2.preload ? 1 : 0 }), u2 = l2.success ? 1 : 0;
          if (t2.succ && (i3.lastJoinSuccessTime = r2), o2)
            this.send({ type: KN.JOIN_GATEWAY, data: l2 }, true);
          else {
            let e3;
            if (a2)
              if (c2) {
                const t4 = a2.match(/h=(\d{1,3}-){3}\d{1,3}/g), i4 = a2.match(/p=[0-9]{1,6}/g);
                e3 = { isSuccess: u2, gatewayIp: t4 && t4.length ? t4[0].split("=")[1].replace(/-/g, ".") : "", port: i4 && i4.length ? i4[0].split("=")[1] : "", isProxy: c2 ? 1 : 0 };
              } else {
                const t4 = a2.match(/wss:\/\/(\d{1,3}-){3}\d{1,3}/g), i4 = a2.match(/(:|p=)[0-9]{1,6}/g);
                e3 = { isSuccess: u2, gatewayIp: t4 && t4.length ? t4[0].split("//")[1].replace(/-/g, ".") : "", port: i4 && i4.length ? i4[0].split(/:|p=/g)[1] : "", isProxy: c2 ? 1 : 0 };
              }
            else
              e3 = { isSuccess: u2, gatewayIp: "", port: "", isProxy: c2 ? 1 : 0 };
            delete l2.success, delete l2.eventType, delete l2.firstSuccess, l2.vid = Number(l2.vid);
            const t3 = Object.assign({}, l2, e3, { eventType: HN.REJOIN_GATEWAY });
            this.send({ type: KN.RE_JOIN_GATEWAY, data: t3 }, true);
          }
        }
        joinChannelTimeout(e2, t2) {
          const i3 = this.baseInfoMap.get(e2);
          if (!i3)
            return;
          const n2 = Date.now(), r2 = PN(PN({}, i3.info), {}, { lts: n2, timeout: t2, elapse: n2 - i3.startTime });
          this.send({ type: KN.JOIN_CHANNEL_TIMEOUT, data: r2 }, true);
        }
        publish(e2, t2) {
          const i3 = this.baseInfoMap.get(e2);
          if (!i3)
            return;
          const n2 = i3.info, r2 = Date.now(), o2 = PN(PN({}, n2), {}, { eventType: HN.PUBLISH, lts: r2, eventElapse: t2.eventElapse, elapse: r2 - i3.startTime, success: t2.succ, errorCode: t2.ec, videoName: t2.videoName, audioName: t2.audioName, screenName: t2.screenName, screenshare: t2.screenshare, audio: t2.audio, video: t2.video, p2pid: t2.p2pid, publishRequestid: t2.publishRequestid });
          this.send({ type: KN.PUBLISH, data: o2 }, true);
        }
        subscribe(e2, t2, i3) {
          const n2 = this.baseInfoMap.get(e2);
          if (!n2)
            return;
          const r2 = n2.info, o2 = Date.now(), s2 = PN(PN({}, r2), {}, { eventType: HN.SUBSCRIBE, lts: o2, eventElapse: t2.eventElapse, elapse: o2 - n2.startTime, success: t2.succ, errorCode: t2.ec, video: t2.video, audio: t2.audio, subscribeRequestid: t2.subscribeRequestid, p2pid: t2.p2pid, preSsrc: t2.preSsrc ? 1 : 0 }, i3 && { extend: JSON.stringify({ isMassSubscribe: true }) });
          "string" == typeof t2.peerid ? s2.peerSuid = t2.peerid : s2.peer = t2.peerid, this.send({ type: KN.SUBSCRIBE, data: s2 }, true);
        }
        wsCompressorInit(e2) {
          var t2;
          const i3 = [...ON(t2 = this.baseInfoMap).call(t2)], n2 = i3.length ? i3[0] : "UnableToGetSid", r2 = this.baseInfoMap.get(n2);
          if (!r2)
            return;
          const o2 = r2.info, s2 = Date.now(), a2 = PN(PN({}, o2), {}, { eventType: HN.WS_COMPRESSOR_INIT, lts: s2, eventElapse: e2.eventElapse, elapse: s2 - r2.startTime, status: e2.status ? 1 : 2 });
          this.send({ type: KN.WS_COMPRESSOR_INIT, data: a2 }, true);
        }
        firstRemoteVideoDecode(e2, t2, i3, n2) {
          const r2 = this.baseInfoMap.get(e2);
          if (!r2)
            return;
          const o2 = r2.info, s2 = Date.now(), a2 = PN(PN(PN({}, o2), n2), {}, { elapse: s2 - r2.startTime, eventType: t2, lts: s2, firstDecodeFrame: Math.max((n2.firstFrame || s2) - r2.startTime, 0), apEnd: Math.max(n2.apEnd - r2.startTime, 0), apStart: Math.max(n2.apStart - r2.startTime, 0), joinGwEnd: Math.max(n2.joinGwEnd - r2.startTime, 0), joinGwStart: Math.max(n2.joinGwStart - r2.startTime, 0), pcEnd: Math.max(n2.pcEnd - r2.startTime, 0), pcStart: Math.max(n2.pcStart - r2.startTime, 0), subscriberEnd: Math.max(n2.subscriberEnd - r2.startTime, 0), subscriberStart: Math.max(n2.subscriberStart - r2.startTime, 0), videoAddNotify: Math.max(n2.videoAddNotify - r2.startTime, 0) });
          this.send({ type: i3, data: a2 }, true);
        }
        firstRemoteFrame(e2, t2, i3, n2) {
          const r2 = this.baseInfoMap.get(e2);
          if (!r2)
            return;
          const o2 = r2.info, s2 = Date.now(), a2 = PN(PN(PN({}, o2), n2), {}, { elapse: s2 - r2.startTime, eventType: t2, lts: s2 });
          this.send({ type: i3, data: a2 }, true);
        }
        pcStats(e2, t2) {
          const i3 = this.baseInfoMap.get(e2);
          if (!i3)
            return;
          const n2 = i3.info, r2 = Date.now(), o2 = PN(PN(PN({}, n2), t2), {}, { vid: void 0 === n2.vid ? 0 : Number(n2.vid), elapse: r2 - i3.startTime, eventType: HN.PC_STATS, lts: r2, preallocation: t2.preallocation ? 1 : 0 });
          this.send({ type: KN.PC_STATS, data: o2 }, true);
        }
        updateRemoteRTPCapabilities(e2, t2) {
          if (e2) {
            const i3 = this.baseInfoMap.get(e2);
            if (!i3)
              return;
            const n2 = i3.info, r2 = Date.now(), o2 = PN(PN(PN({}, n2), t2), {}, { vid: void 0 === n2.vid ? 0 : Number(n2.vid), eventType: HN.UPDATE_REMOTE_RTPCAPABILITIES, lts: r2 });
            this.send({ type: KN.UPDATE_REMOTE_RTPCAPABILITIES, data: o2 }, true);
          }
        }
        onGatewayStream(e2, t2, i3, n2) {
          const r2 = this.baseInfoMap.get(e2);
          if (!r2)
            return;
          const o2 = r2.info, s2 = Date.now(), a2 = PN(PN(PN({}, o2), n2), {}, { eventType: t2, lts: s2 });
          this.send({ type: i3, data: a2 }, true);
        }
        streamSwitch(e2, t2) {
          const i3 = this.baseInfoMap.get(e2);
          if (!i3)
            return;
          const n2 = i3.info, r2 = Date.now(), o2 = PN(PN({}, n2), {}, { eventType: HN.STREAM_SWITCH, lts: r2, isDual: t2.isdual, elapse: r2 - i3.startTime, success: t2.succ });
          this.send({ type: KN.STREAM_SWITCH, data: o2 }, true);
        }
        requestProxyAppCenter(e2, t2) {
          const i3 = this.baseInfoMap.get(e2);
          if (!i3)
            return;
          const n2 = i3.info, r2 = Date.now(), o2 = PN(PN({}, n2), {}, { eventType: HN.REQUEST_PROXY_APPCENTER, lts: r2, eventElapse: r2 - t2.lts, elapse: r2 - i3.startTime, APAddr: t2.APAddr, workerManagerList: t2.workerManagerList, response: t2.response, errorCode: t2.ec, success: t2.succ });
          this.send({ type: KN.REQUEST_PROXY_APPCENTER, data: o2 }, true);
        }
        requestProxyWorkerManager(e2, t2) {
          const i3 = this.baseInfoMap.get(e2);
          if (!i3)
            return;
          const n2 = i3.info, r2 = Date.now(), o2 = PN(PN({}, n2), {}, { eventType: HN.REQUEST_PROXY_WORKER_MANAGER, lts: r2, eventElapse: r2 - t2.lts, elapse: r2 - i3.startTime, workerManagerAddr: t2.workerManagerAddr, response: t2.response, errorCode: t2.ec, success: t2.succ });
          this.send({ type: KN.REQUEST_PROXY_WORKER_MANAGER, data: o2 }, true);
        }
        setProxyServer(e2) {
          this.proxyServer = e2, e2 ? BN.debug("reportProxyServerurl: ".concat(e2)) : BN.debug("disable reportProxyServerurl: ".concat(e2));
        }
        peerPublishStatus(e2, t2) {
          const i3 = this.baseInfoMap.get(e2);
          if (!i3)
            return;
          const n2 = i3.info, r2 = Date.now(), o2 = PN(PN({}, n2), {}, { subscribeElapse: t2.subscribeElapse, peer: t2.peer, peerPublishDuration: Math.max(t2.audioPublishDuration, t2.videoPublishDuration), audiotag: t2.audioPublishDuration > 0 ? 1 : -1, videotag: t2.videoPublishDuration > 0 ? 1 : -1, lts: r2, elapse: r2 - i3.startTime, joinChannelSuccessElapse: r2 - (i3.lastJoinSuccessTime || r2), peerPublishDurationVideo: t2.videoPublishDuration, peerPublishDurationAudio: t2.audioPublishDuration });
          this.send({ type: KN.PEER_PUBLISH_STATUS, data: o2 }, true);
        }
        workerEvent(e2, t2) {
          const i3 = this.baseInfoMap.get(e2);
          if (!i3)
            return;
          const n2 = i3.info, r2 = Date.now();
          (function(e3, t3, i4) {
            const n3 = e3[t3];
            if (!n3 || "string" != typeof n3)
              return [e3];
            e3[t3] = "";
            const r3 = aO(JSON.stringify(e3));
            let o2 = 0;
            const s2 = [];
            let a2 = 0;
            for (let c2 = 0; c2 < n3.length; c2++)
              a2 += n3.charCodeAt(c2) <= 127 ? 1 : 3, a2 <= i4 - r3 || (s2[s2.length] = pw(pw({}, e3), {}, { [t3]: n3.substring(o2, c2) }), o2 = c2, a2 = n3.charCodeAt(c2) <= 127 ? 1 : 3);
            return o2 !== n3.length - 1 && (s2[s2.length] = pw(pw({}, e3), {}, { [t3]: n3.substring(o2) })), s2;
          })(PN(PN(PN({}, n2), t2), {}, { elapse: r2 - i3.startTime, lts: r2, productType: "WebRTC" }), "payload", 1300).forEach((e3) => this.send({ type: KN.WORKER_EVENT, data: e3 }, true));
        }
        apworkerEvent(e2, t2) {
          const i3 = this.baseInfoMap.get(e2);
          if (!i3)
            return;
          const n2 = i3.info, r2 = Date.now(), o2 = PN(PN(PN({}, n2), t2), {}, { elapse: r2 - i3.startTime, lts: r2 });
          this.send({ type: KN.AP_WORKER_EVENT, data: o2 }, true);
        }
        joinWebProxyAP(e2, t2) {
          const i3 = this.baseInfoMap.get(e2);
          if (!i3)
            return;
          const n2 = i3.info, r2 = Date.now(), o2 = PN(PN(PN({}, n2), t2), {}, { elapse: r2 - i3.startTime, lts: r2, extend: t2.extend || void 0 });
          this.send({ type: KN.JOIN_WEB_PROXY_AP, data: o2 }, true);
        }
        WebSocketQuit(e2, t2) {
          const i3 = this.baseInfoMap.get(e2);
          if (!i3)
            return;
          const n2 = i3.info, r2 = Date.now(), o2 = PN(PN(PN({}, n2), t2), {}, { elapse: r2 - i3.startTime, lts: r2 });
          this.send({ type: KN.WEBSOCKET_QUIT, data: o2 }, true);
        }
        async sendCustomReportMessage(e2, t2) {
          if (this.customReportCount += t2.length, this.customReportCount > dN("CUSTOM_REPORT_LIMIT"))
            throw new Ew(_w.CUSTOM_REPORT_FREQUENCY_TOO_HIGH);
          this.customReportCounterTimer || (this.customReportCounterTimer = window.setInterval(() => {
            this.customReportCount = 0;
          }, 5e3));
          const i3 = Date.now(), n2 = t2.map((t3) => ({ type: KN.USER_ANALYTICS, data: PN(PN({ sid: e2 }, t3), {}, { lts: i3 }) }));
          try {
            dN("NEW_REPORT_SERVER") ? await this.postDataToStatsCollector2(n2) : await this.postDataToStatsCollector(n2);
          } catch (e3) {
            throw BN.error("send custom report message failed", e3.toString()), new Ew(_w.CUSTOM_REPORT_SEND_FAILED, e3.message);
          }
        }
        sendApiInvoke(e2) {
          const t2 = dN("NOT_REPORT_EVENT");
          if (e2.tag && Dn(t2) && Dn(t2).call(t2, e2.tag))
            return false;
          if (null === e2.sid)
            return this.apiInvokeUploadPendingItems.push(e2), false;
          const i3 = this.baseInfoMap.get(e2.sid);
          if (!i3)
            return this.apiInvokeUploadPendingItems.push(e2), false;
          const { cname: n2, uid: r2, cid: o2 } = i3.info;
          let s2;
          if (e2.lts = e2.lts || Date.now(), e2.error)
            if (e2.error instanceof Ew) {
              const { code: t3, message: i4 } = e2.error;
              s2 = t3 || i4 || e2.error.toString();
            } else
              s2 = e2.error.toString();
          const a2 = { invokeId: e2.invokeId, sid: e2.sid, cname: n2, cid: o2, uid: r2, lts: e2.lts, success: e2.success, elapse: e2.lts - i3.startTime, execElapse: e2.lts - e2.apiInvokeTime, apiName: e2.name, options: e2.options ? JSON.stringify(e2.options) : void 0, execStates: e2.states ? JSON.stringify(e2.states) : void 0, execResult: e2.result ? JSON.stringify(e2.result) : void 0, errorCode: e2.error ? s2 : void 0, errorMsg: e2.error ? JSON.stringify(e2.error) : void 0 };
          return this.send({ type: KN.API_INVOKE, data: a2 }, false), true;
        }
        addSid(e2) {
          this.sids.add(e2);
        }
        removeSid(e2) {
          this.sids.delete(e2);
        }
        appendSessionId() {
          const e2 = this.apiInvokeUploadPendingItems;
          if (0 === e2.length)
            return;
          const t2 = Array.from(this.sids).find((e3) => null !== e3);
          t2 && e2.forEach((e3) => {
            e3 && (e3.sid = t2, this.sendApiInvoke(Object.assign({}, e3)));
          }), e2.length = 0;
        }
        send(e2, t2) {
          if (t2)
            return this.keyEventUploadPendingItems.push(e2), void this.sendItems(this.keyEventUploadPendingItems, true);
          this.normalEventUploadPendingItems.push(e2), this.normalEventUploadPendingItems.length > dN("NORMAL_EVENT_QUEUE_CAPACITY") && this.normalEventUploadPendingItems.splice(0, 1), this.normalEventUploadPendingItems.length >= 10 && this.sendItems(this.normalEventUploadPendingItems, false);
        }
        doSend() {
          this.keyEventUploadPendingItems.length > 0 && this.sendItems(this.keyEventUploadPendingItems, true), this.normalEventUploadPendingItems.length > 0 && Date.now() - this.lastSendNormalEventTime >= 5e3 && this.sendItems(this.normalEventUploadPendingItems, false);
        }
        sendItems(e2, t2) {
          const i3 = [], n2 = [];
          for (; e2.length; ) {
            const t3 = e2.shift();
            i3.length < 20 ? i3.push(t3) : n2.push(t3);
          }
          e2.push(...n2);
          for (const e3 of [...i3]) {
            var r2;
            -1 !== this.ltsList.indexOf(e3.data.lts) ? (e3.data.lts = this.ltsList[this.ltsList.length - 1] + 1, this.ltsList.push(e3.data.lts)) : (this.ltsList.push(e3.data.lts), CS(r2 = this.ltsList).call(r2, (e4, t3) => e4 - t3));
          }
          return t2 || (this.lastSendNormalEventTime = Date.now()), dN("ENABLE_EVENT_REPORT") ? (i3.length && (dN("NEW_REPORT_SERVER") ? this.postDataToStatsCollector2(i3) : this.postDataToStatsCollector(i3)).catch(((e3) => (i4) => {
            dN("EVENT_REPORT_RETRY") && (t2 ? this.keyEventUploadPendingItems = this.keyEventUploadPendingItems.concat(e3) : (this.normalEventUploadPendingItems = this.normalEventUploadPendingItems.concat(e3), this.normalEventUploadPendingItems.length > dN("NORMAL_EVENT_QUEUE_CAPACITY") && (this.normalEventUploadPendingItems.splice(0, this.normalEventUploadPendingItems.length - dN("NORMAL_EVENT_QUEUE_CAPACITY")), BN.warning("report: drop normal events"))));
          })(i3)), e2) : e2;
        }
        async postDataToStatsCollector2(e2) {
          Xw.networkState === Ww.OFFLINE && await Wh.race([Xw.onlineWaiter, lO(2 * yO.maxRetryTimeout)]);
          const t2 = (e3) => {
            let t3 = new Uint8Array();
            return e3.forEach((e4) => {
              const i4 = bw(JSON.stringify(e4.data)), n3 = new ArrayBuffer(5), r2 = ((e5) => {
                let t4 = 0;
                return Object.entries(KN).forEach((i5) => {
                  let [n4, r3] = i5;
                  r3 === e5.type && (t4 = YN[n4]);
                }), t4;
              })(e4), o2 = new DataView(n3);
              o2.setUint16(0, i4.byteLength, true), o2.setUint8(2, 255 & r2), o2.setUint8(3, r2 >>> 8 & 255), o2.setUint8(4, r2 >>> 16 & 255), t3 = ww(t3, new Uint8Array(n3)), t3 = ww(t3, i4);
            }), t3;
          }, i3 = "event";
          let n2 = this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(dN("NEW_REPORT_SERVER_DOMAINS")[0], "&p=443&d=").concat(i3) : "https://".concat(dN("NEW_REPORT_SERVER_DOMAINS")[0], "/").concat(i3);
          for (let r2 = 0; r2 < 2; r2 += 1) {
            1 === r2 && (n2 = this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(dN("NEW_REPORT_SERVER_DOMAINS")[1], "&p=443&d=").concat(i3) : "https://".concat(dN("NEW_REPORT_SERVER_DOMAINS")[1], "/").concat(i3));
            try {
              await PO(n2, { timeout: 1e4, data: t2(e2), headers: PN(PN({ biz: "webrtc", sendts: Math.round(Date.now() / 1e3), debug: "false" }, this._appId && { appid: this._appId }), {}, { "Content-Type": "application/octet-stream" }) }, true);
            } catch (e3) {
              if (1 === r2)
                throw e3;
              continue;
            }
            return;
          }
        }
        async postDataToStatsCollector(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          const i3 = ((e3) => {
            const t3 = e3 && e3.data.sid && this.baseInfoMap.get(e3.data.sid);
            return t3 && t3.info.vid && +t3.info.vid || 0;
          })(e2[0]), n2 = i3 ? void 0 : this._aid, r2 = { msgType: "EventMessages", sentTs: Math.round(Date.now() / 1e3), payloads: e2.map((e3) => JSON.stringify(e3)), vid: i3, aid: n2 };
          Xw.networkState === Ww.OFFLINE && await Wh.race([Xw.onlineWaiter, lO(2 * yO.maxRetryTimeout)]);
          const o2 = t2 ? "/events/proto-raws" : "/events/messages";
          let s2 = this.url || (this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(dN("EVENT_REPORT_DOMAIN"), "&p=").concat(dN("STATS_COLLECTOR_PORT"), "&d=").concat(o2) : "https://".concat(dN("EVENT_REPORT_DOMAIN"), ":").concat(dN("STATS_COLLECTOR_PORT")).concat(o2));
          for (let e3 = 0; e3 < 2; e3 += 1) {
            1 === e3 && (s2 = this.backupUrl || (this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(dN("EVENT_REPORT_BACKUP_DOMAIN"), "&p=").concat(dN("STATS_COLLECTOR_PORT"), "&d=").concat(o2) : "https://".concat(dN("EVENT_REPORT_BACKUP_DOMAIN"), ":").concat(dN("STATS_COLLECTOR_PORT")).concat(o2)));
            try {
              t2 ? await LO(s2, { timeout: 1e4, data: r2 }) : await PO(s2, { timeout: 1e4, data: r2 });
            } catch (t3) {
              if (1 === e3)
                throw t3;
              continue;
            }
            return;
          }
        }
        createBaseInfo(e2, t2) {
          const i3 = Object.assign({}, WN);
          return i3.sid = e2, this.baseInfoMap.set(e2, { info: i3, startTime: t2 }), i3;
        }
        reportResourceTiming(e2, t2) {
          const i3 = performance.getEntriesByName(e2), n2 = i3[i3.length - 1];
          n2 && this.reportApiInvoke(t2, { name: "Client.resourceTiming", options: n2, tag: kw.TRACER }).onSuccess();
        }
      }();
      LN.on("REPORT_LOG_UPLOAD", (e2) => {
        e2.networkState = Xw.networkState, zN.reportApiInvoke(null, { name: "logUploadError", options: e2, tag: kw.TRACER }).onSuccess("logUploadError");
      });
      class XN extends Ew {
        constructor(e2) {
          super(e2, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "", arguments.length > 2 ? arguments[2] : void 0), NN(this, "name", "AgoraRTCException");
        }
        print() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "error";
          return super.print(e2, BN);
        }
        throw() {
          super.throw(BN);
        }
      }
      const JN = { getDisplayMedia: false, getStreamFromExtension: false, supportUnifiedPlan: false, supportMinBitrate: false, supportSetRtpSenderParameters: false, supportDualStream: true, webAudioMediaStreamDest: false, supportReplaceTrack: false, supportWebGL: false, webAudioWithAEC: false, supportRequestFrame: false, supportShareAudio: false, supportDualStreamEncoding: false, supportDataChannel: false, supportPCSetConfiguration: false, supportWebRTCEncodedTransform: false, supportWebRTCInsertableStream: false, supportRequestVideoFrameCallback: false, supportWebCrypto: false };
      function QN() {
        return JN;
      }
      function ZN() {
        return "setSinkId" in HTMLAudioElement.prototype && (!dN("RESTRICTION_SET_PLAYBACK_DEVICE") || (Gb() || Hb()) && !aw());
      }
      function $N() {
        return !JN.supportUnifiedPlan || dN("CHROME_FORCE_PLAN_B") && cw();
      }
      let eD = function(e2) {
        return e2.IOS_15_16_INTERRUPTION_START = "ios15_16-interruption-start", e2.IOS_15_16_INTERRUPTION_END = "ios15_16-interruption-end", e2.IOS_INTERRUPTION_START = "ios-interruption-start", e2.IOS_INTERRUPTION_END = "ios-interruption-end", e2.STATE_CHANGE = "state-change", e2;
      }({});
      function tD(e2, t2, i3) {
        return { sampleRate: e2, stereo: t2, bitrate: i3 };
      }
      function iD(e2, t2, i3, n2, r2) {
        return { width: e2, height: t2, frameRate: i3, bitrateMin: n2, bitrateMax: r2 };
      }
      function nD(e2, t2, i3, n2, r2) {
        return { width: { max: e2 }, height: { max: t2 }, frameRate: i3, bitrateMin: n2, bitrateMax: r2 };
      }
      function rD(e2, t2) {
        return { numSpatialLayers: e2, numTemporalLayers: t2 };
      }
      const oD = { "90p": iD(160, 90), "90p_1": iD(160, 90), "120p": iD(160, 120, 15, 30, 65), "120p_1": iD(160, 120, 15, 30, 65), "120p_3": iD(120, 120, 15, 30, 50), "120p_4": iD(212, 120), "180p": iD(320, 180, 15, 30, 140), "180p_1": iD(320, 180, 15, 30, 140), "180p_3": iD(180, 180, 15, 30, 100), "180p_4": iD(240, 180, 15, 30, 120), "240p": iD(320, 240, 15, 40, 200), "240p_1": iD(320, 240, 15, 40, 200), "240p_3": iD(240, 240, 15, 40, 140), "240p_4": iD(424, 240, 15, 40, 220), "360p": iD(640, 360, 15, 80, 400), "360p_1": iD(640, 360, 15, 80, 400), "360p_3": iD(360, 360, 15, 80, 260), "360p_4": iD(640, 360, 30, 80, 600), "360p_6": iD(360, 360, 30, 80, 400), "360p_7": iD(480, 360, 15, 80, 320), "360p_8": iD(480, 360, 30, 80, 490), "360p_9": iD(640, 360, 15, 80, 800), "360p_10": iD(640, 360, 24, 80, 800), "360p_11": iD(640, 360, 24, 80, 1e3), "480p": iD(640, 480, 15, 100, 500), "480p_1": iD(640, 480, 15, 100, 500), "480p_2": iD(640, 480, 30, 100, 1e3), "480p_3": iD(480, 480, 15, 100, 400), "480p_4": iD(640, 480, 30, 100, 750), "480p_6": iD(480, 480, 30, 100, 600), "480p_8": iD(848, 480, 15, 100, 610), "480p_9": iD(848, 480, 30, 100, 930), "480p_10": iD(640, 480, 10, 100, 400), "720p": iD(1280, 720, 15, 120, 1130), "720p_auto": iD(1280, 720, 30, 900, 3e3), "720p_1": iD(1280, 720, 15, 120, 1130), "720p_2": iD(1280, 720, 30, 120, 2e3), "720p_3": iD(1280, 720, 30, 120, 1710), "720p_5": iD(960, 720, 15, 120, 910), "720p_6": iD(960, 720, 30, 120, 1380), "1080p": iD(1920, 1080, 15, 120, 2080), "1080p_1": iD(1920, 1080, 15, 120, 2080), "1080p_2": iD(1920, 1080, 30, 120, 3e3), "1080p_3": iD(1920, 1080, 30, 120, 3150), "1080p_5": iD(1920, 1080, 60, 120, 4780), "1440p": iD(2560, 1440, 30, 120, 4850), "1440p_1": iD(2560, 1440, 30, 120, 4850), "1440p_2": iD(2560, 1440, 60, 120, 7350), "4k": iD(3840, 2160, 30, 120, 8910), "4k_1": iD(3840, 2160, 30, 120, 8910), "4k_3": iD(3840, 2160, 60, 120, 13500) }, sD = { "480p": nD(640, 480, 5), "480p_1": nD(640, 480, 5), "480p_2": nD(640, 480, 30), "480p_3": nD(640, 480, 15), "720p": nD(1280, 720, 5), "720p_auto": iD(1280, 720, 30, 900, 3e3), "720p_1": nD(1280, 720, 5), "720p_2": nD(1280, 720, 30), "720p_3": nD(1280, 720, 15), "1080p": nD(1920, 1080, 5), "1080p_1": nD(1920, 1080, 5), "1080p_2": nD(1920, 1080, 30), "1080p_3": nD(1920, 1080, 15) }, aD = { "1SL1TL": rD(1, 1), "3SL3TL": rD(3, 3), "2SL3TL": rD(2, 3) };
      function cD(e2) {
        return e2 || (e2 = "480p_1"), "string" == typeof e2 ? Object.assign({}, oD[e2]) : e2;
      }
      function dD(e2) {
        return "string" == typeof e2 ? Object.assign({}, sD[e2]) : e2;
      }
      function lD(e2) {
        return "string" == typeof e2 ? Object.assign({}, aD[e2]) : e2;
      }
      const uD = { speech_low_quality: tD(16e3, false), speech_standard: tD(32e3, false, 18), music_standard: tD(48e3, false), standard_stereo: tD(48e3, true, 56), high_quality: tD(48e3, false, 128), high_quality_stereo: tD(48e3, true, 192) };
      function hD(e2) {
        return "string" == typeof e2 ? Object.assign({}, uD[e2]) : e2;
      }
      const pD = [];
      function _D(e2) {
        return mw(e2, "mediaSource", ["screen", "window", "application"]), true;
      }
      let ED = function(e2) {
        return e2.NEED_RENEGOTIATE = "@need_renegotiate", e2.NEED_REPLACE_TRACK = "@need_replace_track", e2.NEED_REPLACE_MIXING_TRACK = "@need_replace_mixing_track", e2.NEED_CLOSE = "@need_close", e2.NEED_ENABLE_TRACK = "@need_enable_track", e2.NEED_DISABLE_TRACK = "@need_disable_track", e2.NEED_SESSION_ID = "@need_sid", e2.SET_OPTIMIZATION_MODE = "@set_optimization_mode", e2.GET_STATS = "@get_stats", e2.GET_RTC_STATS = "@get_rtc_stats", e2.GET_LOW_VIDEO_TRACK = "@get_low_video_track", e2.NEED_RESET_REMOTE_SDP = "@need_reset_remote_sdp", e2.NEED_UPDATE_VIDEO_ENCODER = "@need_update_video_encoder", e2.NEED_UPDATE_VIDEO_SEND_PARAMETERS = "@need_update_video_send_parameters", e2.NEED_MUTE_TRACK = "@need_mute_track", e2.NEED_UNMUTE_TRACK = "@need_unmute_track", e2;
      }({}), fD = function(e2) {
        return e2.SCREEN_TRACK = "screen_track", e2.CUSTOM_TRACK = "custome_track", e2.LOW_STREAM = "low_stream", e2.SCREEN_LOW_TRACK = "screen_low_track", e2;
      }({});
      let mD = function(e2) {
        return e2[e2.HIGH_STREAM = 0] = "HIGH_STREAM", e2[e2.LOW_STREAM = 1] = "LOW_STREAM", e2;
      }({}), TD = function(e2) {
        return e2[e2.HIGH_STREAM = 0] = "HIGH_STREAM", e2[e2.LOW_STREAM = 1] = "LOW_STREAM", e2[e2.HIGH_STREAM_LAYER1 = 4] = "HIGH_STREAM_LAYER1", e2[e2.HIGH_STREAM_LAYER2 = 5] = "HIGH_STREAM_LAYER2", e2[e2.HIGH_STREAM_LAYER3 = 6] = "HIGH_STREAM_LAYER3", e2[e2.HIGH_STREAM_LAYER4 = 7] = "HIGH_STREAM_LAYER4", e2[e2.HIGH_STREAM_LAYER5 = 8] = "HIGH_STREAM_LAYER5", e2[e2.HIGH_STREAM_LAYER6 = 9] = "HIGH_STREAM_LAYER6", e2;
      }({}), SD = function(e2) {
        return e2[e2.DISABLE = 0] = "DISABLE", e2[e2.LOW_STREAM = 1] = "LOW_STREAM", e2[e2.AUDIO_ONLY = 2] = "AUDIO_ONLY", e2[e2.HIGH_STREAM_LAYER1 = 3] = "HIGH_STREAM_LAYER1", e2[e2.HIGH_STREAM_LAYER2 = 4] = "HIGH_STREAM_LAYER2", e2[e2.HIGH_STREAM_LAYER3 = 5] = "HIGH_STREAM_LAYER3", e2[e2.HIGH_STREAM_LAYER4 = 6] = "HIGH_STREAM_LAYER4", e2[e2.HIGH_STREAM_LAYER5 = 7] = "HIGH_STREAM_LAYER5", e2[e2.HIGH_STREAM_LAYER6 = 8] = "HIGH_STREAM_LAYER6", e2;
      }({}), gD = function(e2) {
        return e2.TRANSCEIVER_UPDATED = "transceiver-updated", e2.SEI_TO_SEND = "sei-to-send", e2.SEI_RECEIVED = "sei-received", e2.TRACK_UPDATED = "track-updated", e2;
      }({}), RD = function(e2) {
        return e2.SOURCE_STATE_CHANGE = "source-state-change", e2.TRACK_ENDED = "track-ended", e2.BEAUTY_EFFECT_OVERLOAD = "beauty-effect-overload", e2.VIDEO_ELEMENT_VISIBLE_STATUS = "video-element-visible-status", e2.CLOSED = "closed", e2;
      }({}), CD = function(e2) {
        return e2.FIRST_FRAME_DECODED = "first-frame-decoded", e2.VIDEO_ELEMENT_VISIBLE_STATUS = "video-element-visible-status", e2.VIDEO_STATE_CHANGED = "video-state-changed", e2;
      }({}), vD = function(e2) {
        return e2.AUDIO = "audio", e2.VIDEO = "video", e2.DATA = "data", e2;
      }({}), ID = function(e2) {
        return e2.AUDIO_SOURCE_STATE_CHANGE = "audio_source_state_change", e2.RECEIVE_TRACK_BUFFER = "receive_track_buffer", e2.ON_AUDIO_BUFFER = "on_audio_buffer", e2.UPDATE_SOURCE = "update_source", e2;
      }({});
      !function(e2) {
        e2.UPDATE_TRACK_SOURCE = "update-track-source";
      }({});
      const yD = { sendVolumeLevel: 0, sendBitrate: 0, sendBytes: 0, sendPackets: 0, sendPacketsLost: 0, sendJitterMs: 0, sendRttMs: 0, currentPacketLossRate: 0 }, AD = { sendBytes: 0, sendBitrate: 0, sendPackets: 0, sendPacketsLost: 0, sendJitterMs: 0, sendRttMs: 0, sendResolutionHeight: 0, sendResolutionWidth: 0, captureResolutionHeight: 0, captureResolutionWidth: 0, targetSendBitrate: 0, totalDuration: 0, totalFreezeTime: 0, currentPacketLossRate: 0 }, bD = { transportDelay: 0, end2EndDelay: 0, receiveBitrate: 0, receiveLevel: 0, receiveBytes: 0, receiveDelay: 0, receivePackets: 0, receivePacketsLost: 0, receivePacketsDiscarded: 0, totalDuration: 0, totalFreezeTime: 0, freezeRate: 0, packetLossRate: 0, currentPacketLossRate: 0, publishDuration: -1 }, wD = { uplinkNetworkQuality: 0, downlinkNetworkQuality: 0 }, OD = { transportDelay: 0, end2EndDelay: 0, receiveBitrate: 0, receiveBytes: 0, receiveDelay: 0, receivePackets: 0, receivePacketsLost: 0, receiveResolutionHeight: 0, receiveResolutionWidth: 0, totalDuration: 0, totalFreezeTime: 0, freezeRate: 0, packetLossRate: 0, currentPacketLossRate: 0, publishDuration: -1 };
      let ND = function(e2) {
        return e2.ON_TRACK = "on_track", e2.ON_NODE = "on_node", e2;
      }({}), DD = function(e2) {
        return e2.REQUEST_UPDATE_CONSTRAINTS = "request_update_constraints", e2.REQUEST_CONSTRAINTS = "request_constraints", e2;
      }({}), PD = function(e2) {
        return e2.IDLE = "IDLE", e2.INITING = "INITING", e2.INITEND = "INITEND", e2;
      }({}), LD = function(e2) {
        return e2.STATE_CHANGE = "state_change", e2.RECORDING_DEVICE_CHANGED = "recordingDeviceChanged", e2.PLAYOUT_DEVICE_CHANGED = "playoutDeviceChanged", e2.CAMERA_DEVICE_CHANGED = "cameraDeviceChanged", e2;
      }({}), kD = function(e2) {
        return e2.NONE = "none", e2.INIT = "init", e2.CANPLAY = "canplay", e2.PLAYING = "playing", e2.PAUSED = "paused", e2.SUSPEND = "suspend", e2.STALLED = "stalled", e2.WAITING = "waiting", e2.ERROR = "error", e2.DESTROYED = "destroyed", e2.ABORT = "abort", e2.ENDED = "ended", e2.EMPTIED = "emptied", e2.LOADEDDATA = "loadeddata", e2;
      }({}), MD = function(e2) {
        return e2[e2.VideoStateStopped = 0] = "VideoStateStopped", e2[e2.VideoStateStarting = 1] = "VideoStateStarting", e2[e2.VideoStateDecoding = 2] = "VideoStateDecoding", e2[e2.VideoStateFrozen = 3] = "VideoStateFrozen", e2;
      }({});
      const UD = { uninit: 100, none: 110, init: 120, loadeddata: 130, canplay: 200, playing: 210, paused: 220, suspend: 300, stalled: 310, waiting: 320, error: 330, destroyed: 340, abort: 350, ended: 360, emptied: 370 };
      let xD = function(e2) {
        return e2.OPEN = "open", e2.MESSAGE = "message", e2.CLOSE = "close", e2.CLOSING = "closing", e2.ERROR = "error", e2;
      }({});
      function VD(e2, t2, i3, n2, r2) {
        var o2, s2, a2 = {};
        return Object.keys(n2).forEach(function(e3) {
          a2[e3] = n2[e3];
        }), a2.enumerable = !!a2.enumerable, a2.configurable = !!a2.configurable, ("value" in a2 || a2.initializer) && (a2.writable = true), a2 = Xn(o2 = cr(s2 = i3.slice()).call(s2)).call(o2, function(i4, n3) {
          return n3(e2, t2, i4) || i4;
        }, a2), r2 && void 0 !== a2.initializer && (a2.value = a2.initializer ? a2.initializer.call(r2) : void 0, a2.initializer = void 0), void 0 === a2.initializer && (Object.defineProperty(e2, t2, a2), a2 = null), a2;
      }
      function FD(e2, t2, i3) {
        return (t2 = function(e3) {
          var t3 = function(e4, t4) {
            if ("object" != typeof e4 || !e4)
              return e4;
            var i4 = e4[Symbol.toPrimitive];
            if (void 0 !== i4) {
              var n2 = i4.call(e4, "string");
              if ("object" != typeof n2)
                return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(e4);
          }(e3);
          return "symbol" == typeof t3 ? t3 : t3 + "";
        }(t2)) in e2 ? Object.defineProperty(e2, t2, { value: i3, enumerable: true, configurable: true, writable: true }) : e2[t2] = i3, e2;
      }
      function BD(e2, t2) {
        var i3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i3.push.apply(i3, n2);
        }
        return i3;
      }
      function jD(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i3 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? BD(Object(i3), true).forEach(function(t3) {
            FD(e2, t3, i3[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : BD(Object(i3)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
          });
        }
        return e2;
      }
      class GD extends Nw {
        set _mediaStreamTrack(e2) {
          e2 !== this.mediaStreamTrack && (this.safeEmit(gD.TRACK_UPDATED, e2), this.mediaStreamTrack = e2);
        }
        get _mediaStreamTrack() {
          return this.mediaStreamTrack;
        }
        constructor(e2, t2) {
          super(), FD(this, "trackMediaType", void 0), FD(this, "_ID", void 0), FD(this, "_rtpTransceiver", void 0), FD(this, "_lowRtpTransceiver", void 0), FD(this, "_hints", []), FD(this, "_isClosed", false), FD(this, "_originMediaStreamTrack", void 0), FD(this, "mediaStreamTrack", void 0), FD(this, "_external", {}), this._ID = t2 || uO(8, "track-"), this._originMediaStreamTrack = e2, this.mediaStreamTrack = e2, function(e3) {
            Dn(pD).call(pD, e3) || pD.push(e3);
          }(this);
        }
        toString() {
          return this._ID;
        }
        getTrackId() {
          return this._ID;
        }
        getMediaStreamTrack(e2) {
          return e2 || iO(() => {
            var e3;
            zN.reportApiInvoke(null, { name: Lw.GET_MEDIA_STREAM_TRACK, options: [], tag: kw.TRACER }).onSuccess((null === (e3 = this._mediaStreamTrack) || void 0 === e3 ? void 0 : e3.label) || "");
          }, this.mediaStreamTrack.id || this.getTrackId()), this._mediaStreamTrack;
        }
        getRTCRtpTransceiver(e2) {
          return e2 === mD.LOW_STREAM ? this._lowRtpTransceiver : this._rtpTransceiver;
        }
        getMediaStreamTrackSettings() {
          return this.getMediaStreamTrack(true).getSettings();
        }
        close() {
          this._isClosed = true, this._lowRtpTransceiver = void 0, this._rtpTransceiver = void 0, function(e2) {
            const t2 = pD.indexOf(e2);
            -1 !== t2 && pD.splice(t2, 1);
          }(this), this.emit(RD.CLOSED), this.removeAllListeners(gD.SEI_RECEIVED);
        }
        _updateRtpTransceiver(e2, t2) {
          if (t2 === mD.LOW_STREAM) {
            if (this._lowRtpTransceiver === e2)
              return;
            this._lowRtpTransceiver = e2;
          } else {
            if (this._rtpTransceiver === e2)
              return;
            this._rtpTransceiver = e2;
          }
          this.emit(gD.TRANSCEIVER_UPDATED, e2, t2);
        }
      }
      class WD extends GD {
        get isExternalTrack() {
          return this._isExternalTrack;
        }
        get muted() {
          return this._muted;
        }
        get enabled() {
          return this._enabled;
        }
        get processorContext() {
          return this._processorContext;
        }
        constructor(e2, t2) {
          super(e2, t2), FD(this, "_enabled", true), FD(this, "_muted", false), FD(this, "_isExternalTrack", false), FD(this, "_isClosed", false), FD(this, "_enabledMutex", void 0), FD(this, "processor", void 0), FD(this, "_processorContext", void 0), FD(this, "_handleTrackEnded", () => {
            this.onTrackEnded();
          }), this._enabledMutex = new vO("".concat(this.getTrackId())), e2.addEventListener("ended", this._handleTrackEnded);
        }
        getTrackLabel() {
          var e2, t2;
          return null !== (e2 = null === (t2 = this._originMediaStreamTrack) || void 0 === t2 ? void 0 : t2.label) && void 0 !== e2 ? e2 : "";
        }
        close() {
          this._isClosed || (this.stop(), this._originMediaStreamTrack.stop(), this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack.stop(), this._mediaStreamTrack = null), this._originMediaStreamTrack = null, this._enabledMutex = null, BN.debug("[".concat(this.getTrackId(), "] close")), this.emit(ED.NEED_CLOSE), super.close());
        }
        async _updateOriginMediaStreamTrack(e2, t2) {
          let i3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          this._isExternalTrack = i3, e2 !== this._originMediaStreamTrack && (this._originMediaStreamTrack && (this._originMediaStreamTrack.removeEventListener("ended", this._handleTrackEnded), t2 && this._originMediaStreamTrack.stop()), e2.addEventListener("ended", this._handleTrackEnded), this._originMediaStreamTrack = e2, this._muted && (this._originMediaStreamTrack.enabled = false), this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await Yw(this, ED.NEED_REPLACE_TRACK, this), this.processor && this._processorContext && this.processor.updateInput({ track: this._originMediaStreamTrack, context: this._processorContext }));
        }
        _getDefaultPlayerConfig() {
          return {};
        }
        onTrackEnded() {
          BN.debug("[".concat(this.getTrackId(), "] track ended")), this.safeEmit(RD.TRACK_ENDED);
        }
        stateCheck(e2, t2) {
          if (BN.debug("check track state, [muted: ".concat(this._muted, ", enabled: ").concat(this._enabled, "] to [").concat(e2, ": ").concat(t2, "]")), fw(t2, e2), this._enabled && this._muted && "enabled" === e2 && false === t2)
            throw new Ew(_w.TRACK_STATE_UNREACHABLE, "cannot set enabled while the track is muted").print("error", BN);
          if (!this._enabled && !this._muted && "muted" === e2 && true === t2)
            throw new Ew(_w.TRACK_STATE_UNREACHABLE, "cannot set muted while the track is disabled").print("error", BN);
        }
        getProcessorStats() {
          return this._processorContext && this._processorContext.gatherStats() || [];
        }
        getProcessorUsage() {
          return this._processorContext ? this._processorContext.gatherUsage() : Wh.resolve([]);
        }
      }
      const HD = window.AudioContext || window.webkitAudioContext;
      let KD = null;
      const YD = new class extends Nw {
        constructor() {
          super(...arguments), FD(this, "prevState", void 0), FD(this, "curState", void 0), FD(this, "currentTime", void 0), FD(this, "currentTimeStuckAt", void 0), FD(this, "interruptDetectorTrack", void 0), FD(this, "onLocalAudioTrackMute", () => {
            BN.info("ios15-interruption-start"), this.emit(eD.IOS_15_16_INTERRUPTION_START);
          }), FD(this, "onLocalAudioTrackUnmute", async () => {
            BN.info("ios15-interruption-end"), "running" !== this.curState || this.duringInterruption ? BN.info("ios15-interruption-end-canceled") : (KD && await KD.suspend(), this.emit(eD.IOS_15_16_INTERRUPTION_END));
          });
        }
        get duringInterruption() {
          return "running" === this.prevState && "interrupted" === this.curState;
        }
        bindInterruptDetectorTrack(e2) {
          BN.debug("webaudio bindInterruptDetectorTrack ".concat(e2.getTrackId())), this.interruptDetectorTrack || (this.interruptDetectorTrack = e2, this.interruptDetectorTrack._mediaStreamTrack.onmute = this.onLocalAudioTrackMute, this.interruptDetectorTrack._mediaStreamTrack.onunmute = this.onLocalAudioTrackUnmute);
        }
        unbindInterruptDetectorTrack(e2) {
          BN.debug("webaudio unbindInterruptDetectorTrack ".concat(e2.getTrackId())), this.interruptDetectorTrack && this.interruptDetectorTrack === e2 && (this.interruptDetectorTrack._mediaStreamTrack && (this.interruptDetectorTrack._mediaStreamTrack.onmute = null, this.interruptDetectorTrack._mediaStreamTrack.onunmute = null), this.interruptDetectorTrack = void 0);
        }
      }();
      function qD() {
        if (!KD) {
          if (function() {
            if (!HD)
              return void BN.error("your browser is not support web audio");
            BN.info("create audio context");
            const e2 = jD({}, dN("WEBAUDIO_INIT_OPTIONS"));
            BN.debug("audio context init option:", JSON.stringify(e2)), KD = new HD(e2), YD.curState = KD.state, KD.onstatechange = () => {
              YD.prevState = YD.curState, YD.curState = KD ? KD.state : void 0;
              const { prevState: e3, curState: t2 } = YD, i3 = "running" === t2, n2 = "interrupted" === t2, r2 = "running" === e3, o2 = "suspended" === e3, s2 = "interrupted" === e3, a2 = xb().osVersion;
              (Yb() || rw()) && r2 && n2 && (BN.info("ios".concat(a2, "-interruption-start")), YD.emit(eD.IOS_INTERRUPTION_START)), (Yb() || rw()) && (o2 || s2) && i3 && (BN.info("ios".concat(a2, "-interruption-end")), YD.emit(eD.IOS_INTERRUPTION_END)), e3 !== t2 && YD.emit(eD.STATE_CHANGE, t2, e3);
            }, setInterval(() => {
              var e3;
              const t2 = null === (e3 = KD) || void 0 === e3 ? void 0 : e3.currentTime;
              YD.currentTime !== t2 ? (YD.currentTimeStuckAt && (BN.debug("AudioContext current time resume at ".concat(t2)), YD.currentTimeStuckAt = void 0), YD.currentTime = t2) : (t2 !== YD.currentTimeStuckAt && (zN.reportApiInvoke(null, { name: "WEB_AUDIO_CURRENT_TIME_STUCK", options: { currentTime: t2 }, tag: kw.TRACER }).onSuccess(), BN.warning("AudioContext current time stuck at ".concat(t2))), YD.currentTimeStuckAt = t2);
            }, 5e3), async function(e3) {
              const t2 = ["click", "contextmenu", "auxclick", "dblclick", "mousedown", "mouseup", "touchend", "keydown", "keyup"];
              let i3, n2 = false, r2 = false, o2 = false;
              function s2(t3) {
                "running" === e3.state ? a2(false) : Yb() || rw() ? "suspended" === e3.state && (a2(true), t3 && e3.resume().then(c2, c2)) : "closed" !== e3.state && (a2(true), t3 && e3.resume().then(c2, c2));
              }
              function a2(e4) {
                if (n2 !== e4) {
                  n2 = e4;
                  for (let i4 = 0, n3 = t2; i4 < n3.length; i4 += 1) {
                    const t3 = n3[i4];
                    e4 ? window.addEventListener(t3, d2, { capture: true, passive: true }) : window.removeEventListener(t3, d2, { capture: true, passive: true });
                  }
                }
              }
              function c2() {
                s2(false);
              }
              function d2() {
                s2(true);
              }
              function l2(e4) {
                if (!o2)
                  if (i3.paused)
                    if (e4) {
                      let t3;
                      u2(false), o2 = true;
                      try {
                        t3 = i3.play(), t3 ? t3.then(h2, h2) : (i3.addEventListener("playing", h2), i3.addEventListener("abort", h2), i3.addEventListener("error", h2));
                      } catch (e5) {
                        h2();
                      }
                    } else
                      u2(true);
                  else
                    u2(false);
              }
              function u2(e4) {
                if (r2 !== e4) {
                  r2 = e4;
                  for (let i4 = 0, n3 = t2; i4 < n3.length; i4++) {
                    const t3 = n3[i4];
                    e4 ? window.addEventListener(t3, p3, { capture: true, passive: true }) : window.removeEventListener(t3, p3, { capture: true, passive: true });
                  }
                }
              }
              function h2() {
                i3.removeEventListener("playing", h2), i3.removeEventListener("abort", h2), i3.removeEventListener("error", h2), o2 = false, l2(false);
              }
              function p3() {
                l2(true);
              }
              if (Yb()) {
                const t3 = e3.createMediaStreamDestination(), n3 = document.createElement("div");
                n3.innerHTML = "<audio x-webkit-airplay='deny'></audio>", i3 = n3.children.item(0), i3.controls = false, i3.disableRemotePlayback = true, i3.preload = "auto", i3.srcObject = t3.stream, l2(true);
              }
              YD.on(eD.STATE_CHANGE, function() {
                s2(true);
              }), s2(false);
            }(KD);
          }(), !KD)
            throw new Ew(_w.NOT_SUPPORTED, "can not create audio context");
          return KD;
        }
        return KD;
      }
      function zD(e2) {
        if (function() {
          if (null !== XD)
            return XD;
          const e3 = qD(), t3 = e3.createBufferSource(), i4 = e3.createGain(), n2 = e3.createGain();
          t3.connect(i4), t3.connect(n2), t3.disconnect(i4);
          let r2 = false;
          try {
            t3.disconnect(i4);
          } catch (e4) {
            r2 = true;
          }
          return t3.disconnect(), XD = r2, r2;
        }())
          return;
        const t2 = e2.connect, i3 = e2.disconnect;
        e2.connect = (i4, n2, r2) => {
          var o2;
          return e2._inputNodes || (e2._inputNodes = []), Dn(o2 = e2._inputNodes).call(o2, i4) || (i4 instanceof AudioNode ? (e2._inputNodes.push(i4), t2.call(e2, i4, n2, r2)) : t2.call(e2, i4, n2)), e2;
        }, e2.disconnect = (n2, r2, o2) => {
          i3.call(e2), n2 ? Jw(e2._inputNodes, n2) : e2._inputNodes = [];
          for (const i4 of e2._inputNodes)
            t2.call(e2, i4);
        };
      }
      let XD = null;
      function JD(e2, t2) {
        let i3 = false;
        const n2 = 1 / t2;
        if (dN("DISABLE_WEBAUDIO")) {
          const t3 = window.setInterval(() => {
            i3 ? window.clearInterval(t3) : e2(performance.now() / 1e3);
          }, 1e3 * n2);
        } else {
          const t3 = qD();
          let r2 = t3.createGain();
          r2.gain.value = 0, r2.connect(t3.destination);
          const o2 = () => {
            if (i3)
              return void (r2 = null);
            const s2 = t3.createOscillator();
            s2.onended = o2, s2.connect(r2), s2.start(0), s2.stop(t3.currentTime + n2), e2(t3.currentTime);
          };
          o2();
        }
        return () => {
          i3 = true;
        };
      }
      class QD {
        constructor() {
          FD(this, "context", void 0), FD(this, "analyserNode", void 0), FD(this, "sourceNode", void 0), this.context = qD(), this.analyserNode = this.context.createAnalyser(), this.analyserNode.fftSize = 2048, this.analyserNode.smoothingTimeConstant = 0.4;
        }
        updateSource(e2) {
          if (e2 !== this.sourceNode) {
            if (this.sourceNode)
              try {
                this.sourceNode.disconnect(this.analyserNode);
              } catch (e3) {
              }
            this.sourceNode = e2, null == e2 || e2.connect(this.analyserNode);
          }
        }
        getVolumeLevel() {
          if (!this.sourceNode)
            return 0;
          if (!this.context || Yb() || rw() || "running" !== this.context.state && this.context.resume(), !this.analyserNode)
            return 0;
          const e2 = new Float32Array(this.analyserNode.fftSize);
          if (this.analyserNode.getFloatTimeDomainData)
            this.analyserNode.getFloatTimeDomainData(e2);
          else {
            const t3 = new Uint8Array(this.analyserNode.fftSize);
            this.analyserNode.getByteTimeDomainData(t3);
            for (let i3 = 0; i3 < e2.length; ++i3)
              e2[i3] = t3[i3] / 128 - 1;
          }
          const t2 = Xn(e2).call(e2, (e3, t3) => e3 + t3 * t3, 0) / e2.length;
          return Math.max(10 * Math.log10(t2) + 100, 0) / 100;
        }
        getAnalyserNode() {
          return this.analyserNode;
        }
        rebuildAnalyser() {
          try {
            var e2, t2;
            null === (e2 = this.sourceNode) || void 0 === e2 || e2.disconnect(this.analyserNode), this.analyserNode = this.context.createAnalyser(), this.analyserNode.fftSize = 2048, this.analyserNode.smoothingTimeConstant = 0.4, null === (t2 = this.sourceNode) || void 0 === t2 || t2.connect(this.analyserNode);
          } catch (e3) {
            BN.warning("rebuild analyser node failed.");
          }
        }
        destroy() {
          this.updateSource(void 0);
        }
      }
      class ZD extends Nw {
        get processSourceNode() {
          return this.sourceNode;
        }
        set processedNode(e2) {
          var t2;
          if (!this.isDestroyed && this._processedNode !== e2) {
            try {
              var i3;
              null === (i3 = this.sourceNode) || void 0 === i3 || i3.disconnect(this.outputNode);
            } catch (e3) {
            }
            null === (t2 = this._processedNode) || void 0 === t2 || t2.disconnect(), this._processedNode = e2, this.connect();
          }
        }
        get processedNode() {
          return this._processedNode;
        }
        constructor() {
          super(), FD(this, "outputNode", void 0), FD(this, "outputTrack", void 0), FD(this, "isPlayed", false), FD(this, "sourceNode", void 0), FD(this, "context", void 0), FD(this, "audioBufferNode", void 0), FD(this, "destNode", void 0), FD(this, "audioOutputLevel", 0), FD(this, "volumeLevelAnalyser", void 0), FD(this, "_processedNode", void 0), FD(this, "playNode", void 0), FD(this, "isDestroyed", false), FD(this, "onNoAudioInput", void 0), FD(this, "isNoAudioInput", false), FD(this, "_noAudioInputCount", 0), this.context = qD(), this.playNode = this.context.destination, this.outputNode = this.context.createGain(), zD(this.outputNode), this.volumeLevelAnalyser = new QD();
        }
        startGetAudioBuffer(e2) {
          this.audioBufferNode || (this.audioBufferNode = this.context.createScriptProcessor(e2), this.outputNode.connect(this.audioBufferNode), this.audioBufferNode.connect(this.context.destination), this.audioBufferNode.onaudioprocess = (e3) => {
            this.emit(ID.ON_AUDIO_BUFFER, function(e4) {
              for (let t2 = 0; t2 < e4.outputBuffer.numberOfChannels; t2 += 1) {
                const i3 = e4.outputBuffer.getChannelData(t2);
                for (let e5 = 0; e5 < i3.length; e5 += 1)
                  i3[e5] = 0;
              }
              return e4.inputBuffer;
            }(e3));
          });
        }
        stopGetAudioBuffer() {
          this.audioBufferNode && (this.audioBufferNode.onaudioprocess = null, this.outputNode.disconnect(this.audioBufferNode), this.audioBufferNode = void 0);
        }
        createOutputTrack() {
          if (!QN().webAudioMediaStreamDest)
            throw new Ew(_w.NOT_SUPPORTED, "your browser is not support audio processor");
          return this.destNode && this.outputTrack || (this.destNode = this.context.createMediaStreamDestination(), this.outputNode.connect(this.destNode), this.outputTrack = this.destNode.stream.getAudioTracks()[0]), this.outputTrack;
        }
        play(e2) {
          "running" !== this.context.state && Zw(() => {
            YD.emit("autoplay-failed");
          }), this.isPlayed = true, this.playNode = e2 || this.context.destination, this.outputNode.connect(this.playNode);
        }
        stop() {
          if (this.isPlayed)
            try {
              this.outputNode.disconnect(this.playNode);
            } catch (e2) {
            }
          this.isPlayed = false;
        }
        getAccurateVolumeLevel() {
          return this.volumeLevelAnalyser.getVolumeLevel();
        }
        async checkHasAudioInput() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
          if (e2 > 5)
            return this.isNoAudioInput = true, this.onNoAudioInput && this.onNoAudioInput(), false;
          Yb() || rw() ? "suspended" === this.context.state && this.context.resume() : "running" !== this.context.state && this.context.resume();
          const t2 = this.volumeLevelAnalyser.getAnalyserNode();
          let i3;
          t2.getFloatTimeDomainData ? (i3 = new Float32Array(t2.fftSize), t2.getFloatTimeDomainData(i3)) : (i3 = new Uint8Array(t2.fftSize), t2.getByteTimeDomainData(i3));
          let n2 = false;
          for (let e3 = 0; e3 < i3.length; e3++)
            0 !== i3[e3] && (n2 = true);
          return n2 ? (this.isNoAudioInput = false, true) : (await lO(200), await this.checkHasAudioInput(e2 ? e2 + 1 : 1) && n2);
        }
        getAudioVolume() {
          return this.outputNode.gain.value;
        }
        setVolume(e2) {
          this.outputNode.gain.setValueAtTime(e2, this.context.currentTime);
        }
        destroy() {
          this.disconnect(), this.stop(), this.isDestroyed = true, this.onNoAudioInput = void 0;
        }
        disconnect() {
          var e2, t2;
          null === (e2 = this.processedNode) || void 0 === e2 || e2.disconnect(), null === (t2 = this.sourceNode) || void 0 === t2 || t2.disconnect(), this.outputNode && this.outputNode.disconnect();
        }
        connect() {
          var e2;
          this.processedNode ? null === (e2 = this.processedNode) || void 0 === e2 || e2.connect(this.outputNode) : this.sourceNode && this.sourceNode.connect(this.outputNode), this.volumeLevelAnalyser.updateSource(this.outputNode);
        }
      }
      class $D extends ZD {
        get isFreeze() {
          return false;
        }
        constructor(e2, t2, i3) {
          var n2;
          if (super(), FD(this, "sourceNode", void 0), FD(this, "track", void 0), FD(this, "clonedTrack", void 0), FD(this, "audioElement", void 0), FD(this, "isCurrentTrackCloned", false), FD(this, "isRemoteTrack", false), FD(this, "originVolumeLevelAnalyser", void 0), FD(this, "rebuildWebAudio", async () => {
            if (BN.debug("ready to rebuild web audio, state:", this.context.state), this.isNoAudioInput && await this.checkHasAudioInput(), !this.isNoAudioInput || this.isDestroyed)
              return document.body.removeEventListener("click", this.rebuildWebAudio, true), void BN.debug("rebuild web audio success, current volume status", this.getAccurateVolumeLevel());
            this.context.resume().then(() => BN.info("resume success")), BN.debug("rebuild web audio because of ios 12 bugs"), this.disconnect();
            const e3 = this.track;
            this.track = this.track.clone(), this.isCurrentTrackCloned ? e3.stop() : this.isCurrentTrackCloned = true;
            const t3 = new MediaStream([this.track]);
            this.sourceNode = this.context.createMediaStreamSource(t3), zD(this.sourceNode), this.volumeLevelAnalyser.rebuildAnalyser();
            const i4 = this.outputNode.gain.value;
            this.outputNode = this.context.createGain(), this.outputNode.gain.setValueAtTime(i4, this.context.currentTime), zD(this.outputNode), this.emit(ID.UPDATE_SOURCE), this.connect(), this.audioElement.srcObject = t3, this.isPlayed && this.play(this.playNode), this.checkHasAudioInput();
          }), "audio" !== e2.kind)
            throw new Ew(_w.UNEXPECTED_ERROR);
          this.track = e2;
          const r2 = new MediaStream([this.track]);
          if (this.isRemoteTrack = !!t2, this.sourceNode = this.context.createMediaStreamSource(r2), zD(this.sourceNode), i3) {
            const e3 = i3.clone();
            e3.enabled = true, this.clonedTrack = e3, BN.debug("create an unmuted track ".concat(e3.id, " from the original track ").concat(i3.id, " to get the volume"));
            const t3 = this.context.createMediaStreamSource(new MediaStream([e3]));
            zD(t3), this.originVolumeLevelAnalyser = new QD(), this.originVolumeLevelAnalyser.updateSource(t3);
          }
          this.connect(), this.audioElement = document.createElement("audio"), this.audioElement.srcObject = r2;
          const o2 = xb();
          t2 && o2.os === Pb.IOS && Number(null === (n2 = o2.osVersion) || void 0 === n2 ? void 0 : n2.split(".")[0]) < 15 && (YD.on(eD.STATE_CHANGE, () => {
            "suspended" === this.context.state ? document.body.addEventListener("click", this.rebuildWebAudio, true) : "running" === this.context.state && this.rebuildWebAudio();
          }), this.checkHasAudioInput().then((e3) => {
            e3 || document.body.addEventListener("click", this.rebuildWebAudio, true);
          }));
        }
        updateTrack(e2) {
          this.sourceNode.disconnect(), this.track = e2, this.isCurrentTrackCloned = false;
          const t2 = new MediaStream([e2]);
          this.sourceNode = this.context.createMediaStreamSource(t2), zD(this.sourceNode), this.processedNode || this.sourceNode.connect(this.outputNode), this.emit(ID.UPDATE_SOURCE), this.audioElement.srcObject = t2;
        }
        destroy() {
          var e2;
          this.audioElement.srcObject = null, this.audioElement.remove(), YD.off("state-change", this.rebuildWebAudio), null === (e2 = this.originVolumeLevelAnalyser) || void 0 === e2 || e2.destroy(), this.clonedTrack = void 0, super.destroy();
        }
        createMediaStreamSourceNode(e2) {
          return this.context.createMediaStreamSource(new MediaStream([e2]));
        }
        updateOriginTrack(e2) {
          const t2 = e2.clone();
          t2.enabled = true, this.clonedTrack && (this.clonedTrack.stop(), this.clonedTrack = t2), BN.debug("create an unmuted track ".concat(t2.id, " from the original track ").concat(e2.id, " to get the volume"));
          const i3 = this.context.createMediaStreamSource(new MediaStream([t2]));
          zD(i3), this.originVolumeLevelAnalyser && this.originVolumeLevelAnalyser.updateSource(i3);
        }
        getOriginVolumeLevel() {
          return this.originVolumeLevelAnalyser ? this.originVolumeLevelAnalyser.getVolumeLevel() : this.getAccurateVolumeLevel();
        }
      }
      async function eP(e2, t2, i3) {
        const n2 = (e3, t3) => e3 ? "number" != typeof e3 ? e3.max || e3.exact || e3.ideal || e3.min || t3 : e3 : t3, r2 = { audio: !!i3 && { mandatory: { chromeMediaSource: "desktop" } }, video: { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: e2, maxHeight: n2(t2.height, 1080), maxWidth: n2(t2.width, 1920) } } };
        return t2.frameRate && "number" != typeof t2.frameRate ? (r2.video.mandatory.maxFrameRate = t2.frameRate.max, r2.video.mandatory.minFrameRate = t2.frameRate.min) : "number" == typeof t2.frameRate && (r2.video.mandatory.maxFrameRate = t2.frameRate), await navigator.mediaDevices.getUserMedia(r2);
      }
      async function tP(e2, t2) {
        const i3 = await iP(e2.mediaSource), { sourceId: n2, audio: r2 } = await function(e3) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          return new Wh((i4, n3) => {
            const r3 = document.createElement("div");
            r3.innerText = "share screen", r3.setAttribute("style", "text-align: center; height: 25px; line-height: 25px; border-radius: 4px 4px 0 0; background: #D4D2D4; border-bottom:  solid 1px #B9B8B9;");
            const o2 = document.createElement("div");
            o2.setAttribute("style", "width: 100%; height: 500px; padding: 15px 25px ; box-sizing: border-box;");
            const s2 = document.createElement("div");
            s2.innerText = "Agora Web Screensharing wants to share the contents of your screen with webdemo.agorabeckon.com. Choose what you'd like to share.", s2.setAttribute("style", "height: 12%;");
            const a2 = document.createElement("div");
            a2.setAttribute("style", "width: 100%; height: 80%; background: #FFF; border:  solid 1px #CBCBCB; display: flex; flex-wrap: wrap; justify-content: space-around; overflow-y: scroll; padding: 0 15px; box-sizing: border-box;");
            const c2 = document.createElement("div");
            c2.setAttribute("style", "display: flex; justify-content: space-between; padding: 16px 0;");
            const d2 = document.createElement("button");
            d2.innerHTML = "cancel", d2.setAttribute("style", "width: 85px;"), d2.onclick = () => {
              document.body.removeChild(h2);
              const e4 = new Error("NotAllowedError");
              e4.name = "NotAllowedError", n3(e4);
            };
            let l2 = t3;
            const u2 = document.createElement("div");
            if (t3) {
              const e4 = document.createElement("input");
              e4.setAttribute("type", "checkbox");
              const t4 = document.createElement("span");
              e4.setAttribute("style", "margin-right: 6px;"), t4.innerText = "Share audio", e4.checked = l2, e4.onchange = () => {
                l2 = e4.checked;
              }, u2.appendChild(e4), u2.appendChild(t4);
            }
            c2.appendChild(u2), c2.appendChild(d2), o2.appendChild(s2), o2.appendChild(a2), o2.appendChild(c2);
            const h2 = document.createElement("div");
            h2.setAttribute("style", "position: fixed; z-index: 99999999; top: 50%; left: 50%; width: 620px; height: 525px; background: #ECECEC; border-radius: 4px; -webkit-transform: translate(-50%,-50%); transform: translate(-50%,-50%);"), h2.appendChild(r3), h2.appendChild(o2), document.body.appendChild(h2), e3.map((e4) => {
              if (e4.id) {
                const t4 = document.createElement("div");
                t4.setAttribute("style", "width: 30%; height: 160px; padding: 20px 0; text-align: center;box-sizing: content-box;");
                let n4 = e4.thumbnail;
                try {
                  const { width: e5 } = n4.getSize();
                  e5 > 1920 && (n4 = n4.resize({ width: 1920 }));
                } catch (e5) {
                  throw e5 && e5.message.startsWith("Illegal invocation") && console.error("Operate thumbnail error, please try to set contextIsolation: false. (https://github.com/electron/electron/issues/34953)"), e5;
                }
                t4.innerHTML = '<div style="height: 120px; display: table-cell; vertical-align: middle;"><img style="width: 100%; background: #333333; box-shadow: 1px 1px 1px 1px rgba(0, 0, 0, 0.2);" src=' + n4.toDataURL() + ' /></div><span style="	height: 40px; line-height: 40px; display: inline-block; width: 70%; word-break: keep-all; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">' + e4.name.replace(/[\u00A0-\u9999<>\&]/g, function(e5) {
                  return "&#" + e5.charCodeAt(0) + ";";
                }) + "</span>", t4.onclick = () => {
                  document.body.removeChild(h2), i4({ sourceId: e4.id, audio: l2 });
                }, a2.appendChild(t4);
              }
            });
          });
        }(i3, t2);
        return await eP(n2, e2, r2);
      }
      async function iP(e2) {
        let t2 = ["window", "screen"];
        "application" !== e2 && "window" !== e2 || (t2 = ["window"]), "screen" === e2 && (t2 = ["screen"]);
        const i3 = Pw();
        if (!i3)
          throw console.error("failed to fetch electron, please mount it to window"), new Ew(_w.ELECTRON_IS_NULL);
        let n2 = null;
        try {
          var r2;
          n2 = (null === (r2 = i3.desktopCapturer) || void 0 === r2 ? void 0 : r2.getSources({ types: t2 })) || i3.ipcRenderer.invoke("DESKTOP_CAPTURER_GET_SOURCES", { types: t2 });
        } catch (e3) {
          n2 = null;
        }
        n2 && n2.then || (n2 = new Wh((e3, n3) => {
          i3.desktopCapturer.getSources({ types: t2 }, (t3, i4) => {
            t3 ? n3(t3) : e3(i4);
          });
        }));
        try {
          return await n2;
        } catch (e3) {
          throw new Ew(_w.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR, e3.toString());
        }
      }
      const nP = new vO("safari");
      let rP = false, oP = false;
      async function sP(e2, t2) {
        let i3 = 0, n2 = null;
        for (; i3 < 2; )
          try {
            n2 = await aP(e2, t2, i3 > 0);
            break;
          } catch (e3) {
            if (e3 instanceof Ew)
              throw BN.error("[".concat(t2, "] ").concat(e3.toString())), e3;
            const n3 = cP(e3.name || e3.code || e3, e3.message);
            if (n3.code === _w.MEDIA_OPTION_INVALID) {
              BN.debug("[".concat(t2, "] detect media option invalid, retry")), i3 += 1, await lO(500);
              continue;
            }
            throw BN.error("[".concat(t2, "] ").concat(n3.toString())), n3;
          }
        if (!n2)
          throw new Ew(_w.UNEXPECTED_ERROR, "can not find stream after getUserMedia");
        return n2;
      }
      async function aP(e2, t2, i3) {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia)
          throw new Ew(_w.NOT_SUPPORTED, "can not find getUserMedia");
        i3 && (e2.video && (delete e2.video.width, delete e2.video.height), e2.screen && (delete e2.screen.width, delete e2.screen.height));
        const n2 = QN(), r2 = new MediaStream();
        if (e2.audioSource && r2.addTrack(e2.audioSource), e2.videoSource && r2.addTrack(e2.videoSource), !e2.audio && !e2.video && !e2.screen)
          return BN.debug("Using Video Source/ Audio Source"), r2;
        if (e2.screen)
          if (Pw())
            e2.screen.sourceId ? dP(r2, await eP(e2.screen.sourceId, e2.screen, !!e2.screenAudio)) : dP(r2, await tP(e2.screen, !!e2.screenAudio));
          else if (Gb() && e2.screen.extensionId && e2.screen.mandatory) {
            if (!n2.getStreamFromExtension)
              throw new Ew(_w.NOT_SUPPORTED, "This browser does not support screen sharing");
            BN.debug("[".concat(t2, '] Screen access on chrome stable, looking for extension"'));
            const i4 = await (s2 = e2.screen.extensionId, a2 = t2, new Wh((e3, t3) => {
              try {
                chrome.runtime.sendMessage(s2, { getStream: true }, (i5) => {
                  if (!i5 || !i5.streamId)
                    return BN.error("[".concat(a2, "] No response from Chrome Plugin. Plugin not installed properly"), i5), void t3(new Ew(_w.CHROME_PLUGIN_NO_RESPONSE, "No response from Chrome Plugin. Plugin not installed properly"));
                  e3(i5.streamId);
                });
              } catch (e4) {
                BN.error("[".concat(a2, "] AgoraRTC screensharing plugin is not accessible(").concat(s2, ")"), e4.toString()), t3(new Ew(_w.CHROME_PLUGIN_NOT_INSTALL));
              }
            }));
            e2.screen.mandatory.chromeMediaSourceId = i4, dP(r2, await navigator.mediaDevices.getUserMedia({ video: { mandatory: e2.screen.mandatory } }));
          } else if (n2.getDisplayMedia) {
            var o2;
            e2.screen.mediaSource && _D(e2.screen.mediaSource);
            const i4 = { width: e2.screen.width, height: e2.screen.height, frameRate: e2.screen.frameRate, displaySurface: null !== (o2 = e2.screen.displaySurface) && void 0 !== o2 ? o2 : "screen" === e2.screen.mediaSource ? "monitor" : e2.screen.mediaSource }, { selfBrowserSurface: n3, surfaceSwitching: s3, systemAudio: a3, preferCurrentTab: c3 } = e2.screen, d3 = { selfBrowserSurface: n3, surfaceSwitching: s3, systemAudio: a3, preferCurrentTab: c3 };
            !n3 && delete d3.selfBrowserSurface, !s3 && delete d3.surfaceSwitching, !a3 && delete d3.systemAudio, !c3 && delete d3.preferCurrentTab, BN.debug("[".concat(t2, "] getDisplayMedia:"), JSON.stringify({ video: i4, audio: e2.screenAudio, controls: d3 })), dP(r2, await navigator.mediaDevices.getDisplayMedia(jD({ video: i4, audio: e2.screenAudio }, d3)));
          } else {
            if (!Kb())
              throw BN.error("[".concat(t2, "] This browser does not support screenSharing")), new Ew(_w.NOT_SUPPORTED, "This browser does not support screen sharing");
            {
              e2.screen.mediaSource && _D(e2.screen.mediaSource);
              const i4 = { video: { mediaSource: e2.screen.mediaSource, width: e2.screen.width, height: e2.screen.height, frameRate: e2.screen.frameRate } };
              BN.debug("[".concat(t2, "] getUserMedia: ").concat(JSON.stringify(i4))), dP(r2, await navigator.mediaDevices.getUserMedia(i4));
            }
          }
        var s2, a2;
        if (!e2.video && !e2.audio)
          return r2;
        let c2 = { video: e2.video, audio: e2.audio }, d2 = dN("MEDIA_DEVICE_CONSTRAINTS");
        if (d2)
          try {
            "string" == typeof d2 && (d2 = JSON.parse(d2)), c2 = mO(c2, d2);
          } catch (e3) {
          }
        BN.debug("[".concat(t2, "] GetUserMedia"), JSON.stringify(c2)), xb();
        let l2, u2 = null;
        (Wb() || Yb() || jb()) && (u2 = await nP.lock());
        try {
          l2 = await navigator.mediaDevices.getUserMedia(c2);
        } catch (e3) {
          throw u2 && u2(), e3;
        }
        return c2.audio && (rP = true), c2.video && (oP = true), dP(r2, l2), u2 && u2(), r2;
      }
      function cP(e2, t2) {
        switch (e2) {
          case "Starting video failed":
          case "OverconstrainedError":
          case "TrackStartError":
            return new Ew(_w.MEDIA_OPTION_INVALID, "".concat(e2, ": ").concat(t2));
          case "NotFoundError":
          case "DevicesNotFoundError":
            return new Ew(_w.DEVICE_NOT_FOUND, "".concat(e2, ": ").concat(t2));
          case "NotSupportedError":
            return new Ew(_w.NOT_SUPPORTED, "".concat(e2, ": ").concat(t2));
          case "NotReadableError":
            return new Ew(_w.NOT_READABLE, "".concat(e2, ": ").concat(t2));
          case "InvalidStateError":
          case "NotAllowedError":
          case "PERMISSION_DENIED":
          case "PermissionDeniedError":
            return new Ew(_w.PERMISSION_DENIED, "".concat(e2, ": ").concat(t2));
          case "ConstraintNotSatisfiedError":
            return new Ew(_w.CONSTRAINT_NOT_SATISFIED, "".concat(e2, ": ").concat(t2));
          default:
            return BN.error("getUserMedia unexpected error", e2), new Ew(_w.UNEXPECTED_ERROR, "".concat(e2, ": ").concat(t2));
        }
      }
      function dP(e2, t2) {
        const i3 = e2.getVideoTracks()[0], n2 = e2.getAudioTracks()[0], r2 = t2.getVideoTracks()[0], o2 = t2.getAudioTracks()[0];
        o2 && (n2 && e2.removeTrack(n2), e2.addTrack(o2)), r2 && (i3 && e2.removeTrack(i3), e2.addTrack(r2));
      }
      const lP = new class extends Nw {
        get state() {
          return this._state;
        }
        set state(e2) {
          e2 !== this._state && (this.emit(LD.STATE_CHANGE, e2), this._state = e2);
        }
        constructor() {
          super(), FD(this, "_state", PD.IDLE), FD(this, "isAccessMicrophonePermission", false), FD(this, "isAccessCameraPermission", false), FD(this, "lastAccessMicrophonePermission", false), FD(this, "lastAccessCameraPermission", false), FD(this, "checkdeviceMatched", false), FD(this, "deviceInfoMap", /* @__PURE__ */ new Map()), this.init().then(() => {
            navigator.mediaDevices.addEventListener && navigator.mediaDevices.addEventListener("devicechange", this.updateDevicesInfo.bind(this)), window.setInterval(() => {
              (dN("ENUMERATE_DEVICES_INTERVAL") || (dw() || Fb() === Pb.HARMONY_OS) && cw()) && this.updateDevicesInfo();
            }, dN("ENUMERATE_DEVICES_INTERVAL_TIME"));
          }).catch((e2) => BN.error(e2.toString()));
        }
        async enumerateDevices(e2, t2) {
          let i3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices)
            return new Ew(_w.NOT_SUPPORTED, "enumerateDevices() not supported.").throw();
          const n2 = await navigator.mediaDevices.enumerateDevices(), r2 = this.checkMediaDeviceInfoIsOk(n2);
          let o2 = !this.isAccessMicrophonePermission && e2, s2 = !this.isAccessCameraPermission && t2;
          r2.audio && (o2 = false), r2.video && (s2 = false);
          let a2 = null, c2 = null, d2 = null;
          if (!i3 && (o2 || s2)) {
            if (nP.isLocked && (BN.debug("[device manager] wait GUM lock"), (await nP.lock())(), BN.debug("[device manager] GUM unlock")), rP && (o2 = false, this.isAccessMicrophonePermission = true), oP && (s2 = false, this.isAccessCameraPermission = true), BN.debug("[device manager] check media device permissions", e2, t2, o2, s2), o2 && s2) {
              try {
                d2 = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
              } catch (e3) {
                const t3 = cP(e3.name || e3.code || e3, e3.message);
                if (t3.code === _w.PERMISSION_DENIED)
                  throw t3;
                BN.warning("getUserMedia failed in getDevices", t3);
              }
              this.isAccessCameraPermission = true, this.isAccessMicrophonePermission = true;
            } else if (o2) {
              try {
                a2 = await navigator.mediaDevices.getUserMedia({ audio: e2 });
              } catch (e3) {
                const t3 = cP(e3.name || e3.code || e3, e3.message);
                if (t3.code === _w.PERMISSION_DENIED)
                  throw t3;
                BN.warning("getUserMedia failed in getDevices", t3);
              }
              this.isAccessMicrophonePermission = true;
            } else if (s2) {
              try {
                c2 = await navigator.mediaDevices.getUserMedia({ video: t2 });
              } catch (e3) {
                const t3 = cP(e3.name || e3.code || e3, e3.message);
                if (t3.code === _w.PERMISSION_DENIED)
                  throw t3;
                BN.warning("getUserMedia failed in getDevices", t3);
              }
              this.isAccessCameraPermission = true;
            }
            BN.debug("[device manager] mic permission", e2, "cam permission", t2);
          }
          try {
            const e3 = await navigator.mediaDevices.enumerateDevices();
            return a2 && a2.getTracks().forEach((e4) => e4.stop()), c2 && c2.getTracks().forEach((e4) => e4.stop()), d2 && d2.getTracks().forEach((e4) => e4.stop()), a2 = null, c2 = null, d2 = null, e3;
          } catch (e3) {
            return a2 && a2.getTracks().forEach((e4) => e4.stop()), c2 && c2.getTracks().forEach((e4) => e4.stop()), d2 && d2.getTracks().forEach((e4) => e4.stop()), a2 = null, c2 = null, d2 = null, new Ew(_w.ENUMERATE_DEVICES_FAILED, e3.toString()).throw();
          }
        }
        async getRecordingDevices() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
          return (await this.enumerateDevices(true, false, e2)).filter((e3) => "audioinput" === e3.kind);
        }
        async getCamerasDevices() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
          return (await this.enumerateDevices(false, true, e2)).filter((e3) => "videoinput" === e3.kind);
        }
        async getSpeakers() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
          return (await this.enumerateDevices(true, false, e2)).filter((e3) => "audiooutput" === e3.kind);
        }
        searchDeviceIdByName(e2) {
          let t2 = null;
          return this.deviceInfoMap.forEach((i3) => {
            i3.device.label === e2 && (t2 = i3.device.deviceId);
          }), t2;
        }
        async getDeviceById(e2) {
          const t2 = (await this.enumerateDevices(true, true, true)).find((t3) => t3.deviceId === e2);
          if (!t2)
            throw new Ew(_w.DEVICE_NOT_FOUND, "deviceId: ".concat(e2));
          return t2;
        }
        async init() {
          this.state = PD.INITING;
          try {
            await this.updateDevicesInfo(), this.state = PD.INITEND;
          } catch (e2) {
            throw BN.warning("Device Detection functionality cannot start properly.", e2.toString()), this.state = PD.IDLE, ("boolean" == typeof isSecureContext ? isSecureContext : "https:" === location.protocol || "file:" === location.protocol || "localhost" === location.hostname || "127.0.0.1" === location.hostname || "::1" === location.hostname) || new Ew(_w.WEB_SECURITY_RESTRICT, "Your context is limited by web security, please try using https protocol or localhost.").throw(), e2;
          }
        }
        async updateDevicesInfo() {
          const e2 = await this.enumerateDevices(true, true, true), t2 = Date.now(), i3 = [];
          if (e2[0] && e2[0].label && false === this.checkdeviceMatched) {
            this.checkdeviceMatched = true;
            const t3 = e2.find((e3) => "audioinput" === e3.kind && "default" === e3.deviceId), i4 = e2.find((e3) => "audiooutput" === e3.kind && "default" === e3.deviceId);
            t3 && i4 ? i4.groupId === t3.groupId ? BN.debug("[device-check] default input ".concat(t3.label, " and output ").concat(i4.label, " is the same group")) : BN.debug("[device-check] default input ".concat(t3.label, " and output ").concat(i4.label, " is not the same group")) : BN.debug("[device-check] default input or output not found");
          }
          const n2 = this.checkMediaDeviceInfoIsOk(e2);
          if (e2.forEach((e3) => {
            if (!e3.deviceId)
              return;
            const n3 = this.deviceInfoMap.get("".concat(e3.kind, "_").concat(e3.deviceId));
            if ("ACTIVE" !== (n3 ? n3.state : "INACTIVE")) {
              const n4 = { initAt: t2, updateAt: t2, device: e3, state: "ACTIVE" };
              this.deviceInfoMap.set("".concat(e3.kind, "_").concat(e3.deviceId), n4), i3.push(n4);
            }
            n3 && (n3.updateAt = t2);
          }), this.deviceInfoMap.forEach((e3, n3) => {
            "ACTIVE" === e3.state && e3.updateAt !== t2 && (e3.state = "INACTIVE", i3.push(e3));
          }), this.state !== PD.INITEND)
            return n2.audio && (this.lastAccessMicrophonePermission = true, this.isAccessMicrophonePermission = true), void (n2.video && (this.lastAccessCameraPermission = true, this.isAccessCameraPermission = true));
          i3.forEach((e3) => {
            switch (e3.device.kind) {
              case "audioinput":
                this.lastAccessMicrophonePermission && this.isAccessMicrophonePermission && this.emit(LD.RECORDING_DEVICE_CHANGED, e3);
                break;
              case "videoinput":
                this.lastAccessCameraPermission && this.isAccessCameraPermission && this.emit(LD.CAMERA_DEVICE_CHANGED, e3);
                break;
              case "audiooutput":
                this.lastAccessMicrophonePermission && this.isAccessMicrophonePermission && this.emit(LD.PLAYOUT_DEVICE_CHANGED, e3);
            }
          }), n2.audio && (this.lastAccessMicrophonePermission = true, this.isAccessMicrophonePermission = true), n2.video && (this.lastAccessCameraPermission = true, this.isAccessCameraPermission = true);
        }
        checkMediaDeviceInfoIsOk(e2) {
          const t2 = e2.filter((e3) => "audioinput" === e3.kind), i3 = e2.filter((e3) => "videoinput" === e3.kind), n2 = { audio: false, video: false };
          for (const e3 of t2)
            if (e3.label && e3.deviceId) {
              n2.audio = true;
              break;
            }
          for (const e3 of i3)
            if (e3.label && e3.deviceId) {
              n2.video = true;
              break;
            }
          return n2;
        }
      }();
      let uP = false;
      const hP = new class extends Nw {
        constructor() {
          super(...arguments), FD(this, "onAutoplayFailed", void 0), FD(this, "onAudioAutoplayFailed", void 0);
        }
      }();
      function pP() {
        if (xb(), !uP) {
          const e2 = (t2) => {
            t2.preventDefault(), uP = false, lw() ? document.body.removeEventListener("click", e2, true) : (document.body.removeEventListener("touchstart", e2, true), document.body.removeEventListener("mousedown", e2, true));
          };
          uP = true, lw() ? document.body.addEventListener("click", e2, true) : (document.body.addEventListener("touchstart", e2, true), document.body.addEventListener("mousedown", e2, true)), BN.info("detect media autoplay failed, document: https://docs.agora.io/cn/Voice/autoplay_policy_web_ng?platform=Web"), hP.onAutoplayFailed ? hP.onAutoplayFailed() : hP.onAudioAutoplayFailed ? BN.warning("AgoraRTC.onAudioAutoplayFailed has been deprecated in favor of AgoraRTC.onAutoplayFailed.\n\n  Please refer to the Agora document to migrate the newer API, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web .") : BN.warning("We have detected a media autoplay failed event, and found out that you haven't implemented AgoraRTC.onAutoplayFailed callback yet.\n\n  It will cause audio/video element not playing automatically on some browsers without user interaction, possibly hurting user experiences.\n\n  Please refer to the Agora document to properly handle autoplay failed event, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web ."), hP.emit("autoplay-failed");
        }
      }
      function _P(e2, t2, i3, n2) {
        if (!e2)
          return;
        const r2 = zN.getBaseInfoBySessionId(e2);
        if (!r2)
          return;
        const o2 = r2.info, s2 = Date.now(), a2 = jD(jD({}, o2), {}, { vid: void 0 === o2.vid ? 0 : Number(o2.vid), lts: s2, elapse: s2 - r2.startTime, cbRegistered: hP.onAutoplayFailed || hP.onAudioAutoplayFailed ? 1 : -1, errorMsg: i3, mediaType: t2, trackId: n2, extend: void 0 });
        zN.send({ type: KN.AUTOPLAY_FAILED, data: a2 }, true);
      }
      const EP = ["play", "playing", "loadeddata", "canplay", "pause", "stalled", "suspend", "waiting", "abort", "emptied", "ended", "error"], fP = new class {
        constructor() {
          FD(this, "onAutoplayFailed", void 0), FD(this, "elementMap", /* @__PURE__ */ new Map()), FD(this, "elementStateMap", /* @__PURE__ */ new Map()), FD(this, "elementsNeedToResume", []), FD(this, "sinkIdMap", /* @__PURE__ */ new Map()), FD(this, "autoResumeAfterInterruption", (e2) => {
            Array.from(this.elementMap.entries()).forEach((t2) => {
              let [i3, n2] = t2;
              const r2 = this.elementStateMap.get(i3), o2 = n2.srcObject.getAudioTracks()[0], s2 = o2 && o2.readyState;
              if (BN.debug("resume after interrupted, ele: ".concat(r2, " audio: ").concat(s2, " ").concat(e2)), "live" === s2) {
                if (e2)
                  return n2.pause(), void n2.play();
                if ("running" === YD.curState)
                  return tw() ? (n2.pause(), void n2.play()) : void (r2 && "paused" === r2 && n2.play());
              }
            });
          }), FD(this, "autoResumeAfterInterruptionOnIOS15_16", () => {
            Array.from(this.elementMap.entries()).forEach((e2) => {
              let [t2, i3] = e2;
              const n2 = i3.srcObject.getAudioTracks()[0];
              n2 && "live" === n2.readyState && (BN.debug("auto resume after interruption inside autoResumeAfterInterruptionOnIOS15"), i3.pause(), i3.play());
            });
          }), this.autoResumeAudioElement(), YD.on(eD.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), YD.on(eD.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16), YD.on(eD.STATE_CHANGE, () => {
            Yb() && "suspended" === YD.prevState && "running" === YD.curState && this.autoResumeAfterInterruption();
          });
        }
        async setSinkID(e2, t2) {
          const i3 = this.elementMap.get(e2);
          if (this.sinkIdMap.set(e2, t2), i3)
            try {
              await i3.setSinkId(t2);
            } catch (e3) {
              throw new Ew(_w.PERMISSION_DENIED, "can not set sink id: " + e3.toString());
            }
        }
        play(e2, t2, i3, n2) {
          if (this.elementMap.has(t2))
            return;
          const r2 = document.createElement("audio");
          r2.autoplay = true, r2.srcObject = new MediaStream([e2]), this.bindAudioElementEvents(t2, r2), this.elementMap.set(t2, r2), this.elementStateMap.set(t2, kD.INIT), this.setVolume(t2, i3);
          const o2 = this.sinkIdMap.get(t2);
          if (o2)
            try {
              r2.setSinkId(o2).catch((e3) => {
                BN.warning("[".concat(t2, "] set sink id failed"), e3.toString());
              });
            } catch (e3) {
              BN.warning("[".concat(t2, "] set sink id failed"), e3.toString());
            }
          const s2 = r2.play();
          s2 && s2.then && s2.catch((e3) => {
            n2 && _P(n2, "audio", e3.message, t2), BN.warning("audio element play warning", e3.toString()), this.elementMap.has(t2) && "NotAllowedError" === e3.name && (BN.warning("detected audio element autoplay failed"), this.elementsNeedToResume.push(r2), Zw(() => {
              this.onAutoplayFailed && this.onAutoplayFailed(), pP();
            }));
          });
        }
        updateTrack(e2, t2) {
          const i3 = this.elementMap.get(e2);
          i3 && (i3.srcObject = new MediaStream([t2]));
        }
        isPlaying(e2) {
          return this.elementMap.has(e2) && "playing" === this.elementStateMap.get(e2);
        }
        setVolume(e2, t2) {
          const i3 = this.elementMap.get(e2);
          i3 && (t2 = Math.max(0, Math.min(100, t2)), i3.volume = t2 / 100);
        }
        stop(e2) {
          const t2 = this.elementMap.get(e2);
          if (this.sinkIdMap.delete(e2), !t2)
            return;
          const i3 = this.elementsNeedToResume.indexOf(t2);
          this.elementsNeedToResume.splice(i3, 1), t2.srcObject = null, t2.remove(), this.elementMap.delete(e2), this.elementStateMap.delete(e2);
        }
        bindAudioElementEvents(e2, t2) {
          EP.forEach((i3) => {
            t2.addEventListener(i3, (i4) => {
              const n2 = this.elementStateMap.get(e2), r2 = "pause" === i4.type ? "paused" : i4.type;
              if (BN.debug("[".concat(e2, "] audio-element-status change ").concat(n2, " => ").concat(r2)), "error" === i4.type) {
                const i5 = null == t2 ? void 0 : t2.error;
                i5 && BN.error("[".concat(e2, "] media error, code: ").concat(i5.code, ", message: ").concat(i5.message));
              }
              this.elementStateMap.set(e2, r2);
            });
          });
        }
        getPlayerState(e2) {
          return this.elementStateMap.get(e2) || "uninit";
        }
        autoResumeAudioElement() {
          const e2 = () => {
            this.elementsNeedToResume.forEach((e3) => {
              e3.play().then((e4) => {
                BN.debug("Auto resume audio element success");
              }).catch((e4) => {
                BN.warning("Auto resume audio element failed!", e4);
              });
            }), this.elementsNeedToResume = [];
          };
          new Wh((e3) => {
            document.body ? e3() : window.addEventListener("load", () => e3());
          }).then(() => {
            lw() ? document.body.addEventListener("click", e2, true) : (document.body.addEventListener("touchstart", e2, true), document.body.addEventListener("mousedown", e2, true));
          });
        }
      }();
      function mP() {
        return function(e2, t2, i3) {
          const n2 = i3.value;
          return "function" == typeof n2 && (i3.value = function() {
            this._isClosed && new Ew(_w.INVALID_OPERATION, "[".concat(this.getTrackId(), "] cannot operate a closed track")).print("warning", BN);
            for (var e3 = arguments.length, t3 = new Array(e3), i4 = 0; i4 < e3; i4++)
              t3[i4] = arguments[i4];
            const r2 = n2.apply(this, t3);
            return r2 instanceof Wh ? new Wh((e4, t4) => {
              r2.then(e4).catch(t4);
            }) : r2;
          }), i3;
        };
      }
      class TP extends Nw {
        constructor(e2) {
          super(), FD(this, "name", "VideoProcessorDestination"), FD(this, "ID", "0"), FD(this, "_source", void 0), FD(this, "videoContext", void 0), FD(this, "inputTrack", void 0), this.videoContext = e2;
        }
        get kind() {
          return "video";
        }
        get enabled() {
          return true;
        }
        pipe() {
          throw new Ew(_w.NOT_SUPPORTED, "VideoProcessor cannot pipe to any other Processor");
        }
        unpipe() {
          throw new Ew(_w.NOT_SUPPORTED, "VideoProcessor cannot unpipe to any other Processor");
        }
        enable() {
        }
        disable() {
        }
        updateInput(e2) {
          if (e2.context !== this.videoContext)
            throw new Error("ProcessorContext passed to VideoTrack.processorDestination doesn't match it's belonging VideoTrack's context.\nProbably you are making pipeline like this:\nvideoTrack1.pipe(processor).pipe(videoTrack2.processorDestination).");
          e2.track && e2.track !== this.inputTrack && (this.videoContext.chained = true, this.inputTrack = e2.track, this.emit(ND.ON_TRACK, e2.track));
        }
        reset() {
          this.inputTrack = void 0, this.videoContext.chained = false, this.emit(ND.ON_TRACK, void 0);
        }
      }
      class SP extends Nw {
        set chained(e2) {
          this._chained = e2;
        }
        get chained() {
          return this._chained;
        }
        constructor(e2, t2) {
          super(), FD(this, "constraintsMap", /* @__PURE__ */ new Map()), FD(this, "statsRegistry", []), FD(this, "usageRegistry", []), FD(this, "trackId", void 0), FD(this, "direction", void 0), FD(this, "_chained", false), this.trackId = e2, this.direction = t2;
        }
        async getConstraints() {
          return await Kw(this, DD.REQUEST_CONSTRAINTS);
        }
        async requestApplyConstraints(e2, t2) {
          var i3;
          return BN.info("processor ".concat(t2.name, " requestApplyConstraints for ").concat(this.trackId)), e2 && this.constraintsMap.set(t2, e2), Yw(this, DD.REQUEST_UPDATE_CONSTRAINTS, Array.from(Zh(i3 = this.constraintsMap).call(i3)));
        }
        async requestRevertConstraints(e2) {
          var t2;
          if (this.constraintsMap.has(e2))
            return BN.info("processor ".concat(e2.name, " requestRevertConstraints for ").concat(this.trackId)), this.constraintsMap.delete(e2), Yw(this, DD.REQUEST_UPDATE_CONSTRAINTS, Array.from(Zh(t2 = this.constraintsMap).call(t2)));
        }
        registerStats(e2, t2, i3) {
          this.statsRegistry.find((i4) => i4.processorID === e2.ID && i4.processorName === e2.name && i4.type === t2) || this.statsRegistry.push({ processorName: e2.name, processorID: e2.ID, type: t2, cb: i3 });
        }
        unregisterStats(e2, t2) {
          const i3 = this.statsRegistry.findIndex((i4) => i4.processorID === e2.ID && i4.processorName === e2.name && i4.type === t2);
          -1 !== i3 && this.statsRegistry.splice(i3, 1);
        }
        gatherStats() {
          const e2 = [];
          for (const { processorID: t2, processorName: i3, type: n2, cb: r2 } of this.statsRegistry)
            try {
              const o2 = r2();
              e2.push({ processorID: t2, processorName: i3, type: n2, stats: o2 });
            } catch (e3) {
              BN.error(new Ew(_w.UNEXPECTED_ERROR, e3.message));
            }
          return e2;
        }
        registerUsage(e2, t2) {
          this.usageRegistry.find((t3) => t3.processorID === e2.ID && t3.processorName === e2.name) || this.usageRegistry.push({ processorID: e2.ID, processorName: e2.name, cb: t2 });
        }
        unregisterUsage(e2) {
          const t2 = this.usageRegistry.findIndex((t3) => t3.processorID === e2.ID && t3.processorName === e2.name);
          -1 !== t2 && this.usageRegistry.splice(t2, 1);
        }
        async gatherUsage() {
          const e2 = [];
          if (!this.chained)
            return [];
          for (const { cb: t2 } of this.usageRegistry)
            try {
              let i3 = t2();
              i3 instanceof Wh && (i3 = await i3), e2.push(jD(jD({}, i3), {}, { direction: this.direction }));
            } catch (e3) {
              BN.error("gather extension usage error", e3);
            }
          return e2;
        }
        getDirection() {
          return this.direction;
        }
      }
      class gP extends Nw {
        constructor(e2) {
          super(), FD(this, "name", "AudioProcessorDestination"), FD(this, "ID", "0"), FD(this, "inputTrack", void 0), FD(this, "inputNode", void 0), FD(this, "audioProcessorContext", void 0), FD(this, "_source", void 0), this.audioProcessorContext = e2;
        }
        get kind() {
          return "audio";
        }
        get enabled() {
          return true;
        }
        pipe() {
          throw new Ew(_w.NOT_SUPPORTED, "AudioProcessorDestination cannot pipe to any other Processor");
        }
        unpipe() {
          throw new Ew(_w.NOT_SUPPORTED, "AudioProcessor cannot unpipe to any other Processor");
        }
        enable() {
        }
        disable() {
        }
        reset() {
          this.inputTrack = void 0, this.inputNode = void 0, this.audioProcessorContext.chained = false, this.emit(ND.ON_TRACK, void 0), this.emit(ND.ON_NODE, void 0);
        }
        updateInput(e2) {
          if (e2.context !== this.audioProcessorContext)
            throw new Error("ProcessorContext passed to AudioTrack.processorDestination doesn't match it's belonging AudioTrack's context.\n        Probably you are making pipeline like this: audioTrack1.pipe(processor).pipe(audioTrack2.processorDestination).");
          e2.track && this.inputTrack !== e2.track && (this.audioProcessorContext.chained = true, this.inputTrack = e2.track, this.emit(ND.ON_TRACK, this.inputTrack)), e2.node && this.inputNode !== e2.node && (this.audioProcessorContext.chained = true, this.inputNode = e2.node, this.emit(ND.ON_NODE, this.inputNode));
        }
      }
      class RP extends Nw {
        set chained(e2) {
          this._chained = e2;
        }
        get chained() {
          return this._chained;
        }
        constructor(e2, t2, i3) {
          super(), FD(this, "constraintsMap", /* @__PURE__ */ new Map()), FD(this, "statsRegistry", []), FD(this, "audioContext", void 0), FD(this, "trackId", void 0), FD(this, "direction", void 0), FD(this, "usageRegistry", []), FD(this, "_chained", false), this.audioContext = e2, this.trackId = t2, this.direction = i3;
        }
        async getConstraints() {
          return Kw(this, DD.REQUEST_CONSTRAINTS);
        }
        getAudioContext() {
          return this.audioContext;
        }
        async requestApplyConstraints(e2, t2) {
          var i3;
          return BN.info("processor ".concat(t2.name, " requestApplyConstraints for ").concat(this.trackId)), e2 && this.constraintsMap.set(t2, e2), Yw(this, DD.REQUEST_UPDATE_CONSTRAINTS, Array.from(Zh(i3 = this.constraintsMap).call(i3)));
        }
        async requestRevertConstraints(e2) {
          var t2;
          if (this.constraintsMap.has(e2))
            return this.constraintsMap.delete(e2), Yw(this, DD.REQUEST_UPDATE_CONSTRAINTS, Array.from(Zh(t2 = this.constraintsMap).call(t2)));
        }
        registerStats(e2, t2, i3) {
          this.statsRegistry.find((i4) => i4.processorID === e2.ID && i4.processorName === e2.name && i4.type === t2) || this.statsRegistry.push({ processorName: e2.name, processorID: e2.ID, type: t2, cb: i3 });
        }
        unregisterStats(e2, t2) {
          const i3 = this.statsRegistry.findIndex((i4) => i4.processorID === e2.ID && i4.processorName === e2.name && i4.type === t2);
          -1 !== i3 && this.statsRegistry.splice(i3, 1);
        }
        gatherStats() {
          const e2 = [];
          for (const { processorID: t2, processorName: i3, type: n2, cb: r2 } of this.statsRegistry)
            try {
              const o2 = r2();
              e2.push({ processorID: t2, processorName: i3, type: n2, stats: o2 });
            } catch (e3) {
              BN.error(new Ew(_w.UNEXPECTED_ERROR, e3.message));
            }
          return e2;
        }
        registerUsage(e2, t2) {
          this.usageRegistry.find((t3) => t3.processorID === e2.ID && t3.processorName === e2.name) || this.usageRegistry.push({ processorID: e2.ID, processorName: e2.name, cb: t2 });
        }
        unregisterUsage(e2) {
          const t2 = this.usageRegistry.findIndex((t3) => t3.processorID === e2.ID && t3.processorName === e2.name);
          -1 !== t2 && this.usageRegistry.splice(t2, 1);
        }
        async gatherUsage() {
          const e2 = [];
          if (!this.chained)
            return [];
          for (const { cb: t2 } of this.usageRegistry)
            try {
              let i3 = t2();
              i3 instanceof Wh && (i3 = await i3), e2.push(jD(jD({}, i3), {}, { direction: this.direction }));
            } catch (e3) {
              BN.error("gather extension usage error", e3);
            }
          return e2;
        }
        getDirection() {
          return this.direction;
        }
      }
      class CP extends Nw {
        get isPlayed() {
          return true;
        }
        get isFreeze() {
          return false;
        }
        constructor() {
          super(), FD(this, "context", void 0), FD(this, "processSourceNode", void 0), FD(this, "outputTrack", void 0), FD(this, "processedNode", void 0), FD(this, "clonedTrack", void 0), FD(this, "outputNode", void 0), this.outputNode = new vP();
        }
        setVolume() {
        }
        createOutputTrack() {
          throw new Ew(_w.NOT_SUPPORTED, "can not create output MediaStreamTrack when WebAudio disabled");
        }
        getOriginVolumeLevel() {
          return 0;
        }
        getAccurateVolumeLevel() {
          return 0;
        }
        stopGetAudioBuffer() {
        }
        startGetAudioBuffer() {
        }
        play() {
        }
        stop() {
        }
        destroy() {
        }
        updateTrack() {
        }
        updateOriginTrack() {
        }
        createMediaStreamSourceNode() {
        }
      }
      class vP {
        disconnect() {
        }
        connect() {
        }
      }
      function IP(e2) {
        return new Wh((t2, i3) => {
          let n2 = false;
          const r2 = document.createElement("video");
          r2.setAttribute("autoplay", ""), r2.setAttribute("muted", ""), r2.muted = true, r2.autoplay = true, r2.setAttribute("playsinline", ""), r2.setAttribute("style", "position: fixed; top: 0; left: 0; width: 1px; height: 1px"), document.body.appendChild(r2);
          const o2 = Yb() ? "canplay" : "playing";
          r2.addEventListener(o2, () => {
            const e3 = r2.videoWidth, i4 = r2.videoHeight;
            !e3 && Kb() || (n2 = true, r2.srcObject = null, r2.remove(), t2([e3, i4]));
          }), r2.srcObject = new MediaStream([e2]), r2.play().catch(pO), setTimeout(() => {
            n2 || (r2.srcObject = null, r2.remove(), t2([r2.videoWidth, r2.videoHeight]));
          }, 4e3);
        });
      }
      function yP(e2) {
        const t2 = {};
        e2.facingMode && (t2.facingMode = e2.facingMode), e2.cameraId && (t2.deviceId = { exact: e2.cameraId });
        const i3 = cD(e2.encoderConfig);
        return null != i3.width && (t2.width = i3.width), null != i3.height && (t2.height = i3.height), !sw() && i3.frameRate && (t2.frameRate = i3.frameRate), Hb() && "object" == typeof t2.frameRate && (t2.frameRate.max = 60), Kb() && (t2.frameRate = { ideal: 30, max: 30 }), t2;
      }
      function AP(e2) {
        const t2 = {};
        return sw() || (void 0 !== e2.AGC && (t2.autoGainControl = e2.AGC), void 0 !== e2.AEC && (t2.echoCancellation = e2.AEC), void 0 !== e2.ANS && (t2.noiseSuppression = e2.ANS, Gb() && e2.ANS && (t2.googHighpassFilter = e2.ANS))), t2;
      }
      function bP(e2) {
        const t2 = AP(e2);
        if (e2.encoderConfig) {
          const i3 = hD(e2.encoderConfig);
          t2.channelCount = i3.stereo ? 2 : 1, t2.sampleRate = i3.sampleRate, t2.sampleSize = i3.sampleSize;
        }
        return e2.microphoneId && (t2.deviceId = { exact: e2.microphoneId }), dw() && (t2.sampleRate = void 0), t2;
      }
      const wP = (e2) => {
        const t2 = e2._encoderConfig;
        if (!t2)
          return;
        const { frameRate: i3, width: n2, height: r2 } = e2.getMediaStreamTrackSettings();
        let { frameRate: o2 = i3, width: s2 = n2, height: a2 = r2 } = t2;
        if (!o2 || !s2 || !a2)
          return;
        s2 = SO(s2), a2 = SO(a2), o2 = SO(o2);
        const { max: c2, min: d2 } = function(e3, t3, i4) {
          const n3 = 200 * Math.pow(i4 / 15, 0.6) * Math.pow(e3 * t3 / 640 / 360, 0.75);
          return { min: Math.floor(n3), max: Math.floor(4 * n3) };
        }(s2, a2, o2), { bitrateMax: l2, bitrateMin: u2 } = t2 || {};
        l2 || BN.debug("calculate bitrate: [w: ".concat(s2, ", h: ").concat(a2, ", fps: ").concat(o2, "] => [brMax: ").concat(l2, ", brMin: ").concat(u2, "]"));
        const { maxFramerate: h2 } = dN("ENCODER_CONFIG_LIMIT");
        return h2 && "number" == typeof h2 && (o2 = Math.min(o2, h2)), { frameRate: o2, bitrateMax: l2 || c2, bitrateMin: u2 || d2, scaleResolutionDownBy: 1, scale: 0 };
      }, OP = async (e2, t2, i3) => await (async (e3, t3, i4) => {
        const n2 = function(e4) {
          const t4 = [];
          for (let i5 = 0; i5 < e4.length; i5 += 2)
            t4.push(parseInt(e4.slice(i5, i5 + 2), 16));
          return Uint8Array.from(t4);
        }(gO("" + t3 + i4)).slice(0, 16), r2 = n2.slice(0, 12), o2 = await window.crypto.subtle.importKey("raw", n2, "AES-GCM", true, ["encrypt"]);
        return new Uint8Array(await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: r2 }, o2, e3));
      })(e2.buffer, t2, i3), NP = (e2) => {
        const t2 = document.createElement("canvas");
        return t2.width = 2, t2.height = 2, new Wh((i3, n2) => {
          t2.toBlob(async (e3) => {
            if (t2.remove(), e3) {
              const n3 = await DP(e3);
              i3({ buffer: n3, width: t2.width, height: t2.height });
            } else
              n2(new Ew(_w.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED));
          }, e2, 1);
        });
      }, DP = async (e2) => {
        const t2 = await e2.arrayBuffer();
        return new Uint8Array(t2);
      };
      var PP, LP, kP, MP, UP, xP, VP, FP, BP, jP, GP, WP, HP, KP, YP, qP, zP, XP, JP, QP, ZP, $P, eL, tL, iL, nL, rL, oL, sL, aL, cL, dL, lL, uL, hL, pL, _L, EL, fL, mL;
      let TL = (PP = qN({ argsMap: (e2, t2) => [e2.getTrackId(), t2], throttleTime: 300 }), LP = qN({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), kP = mP(), MP = IO("LocalAudioTrack", "_enabledMutex"), UP = qN({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), xP = mP(), VP = IO("LocalAudioTrack", "_enabledMutex"), FP = qN({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), BP = mP(), jP = mP(), GP = mP(), WP = qN({ argsMap: (e2) => [e2.getTrackId()] }), HP = mP(), KP = qN({ argsMap: (e2) => [e2.getTrackId()] }), YP = mP(), qP = qN({ argsMap: (e2) => [e2.getTrackId()] }), zP = qN({ argsMap: (e2, t2) => [e2.getTrackId(), t2.name] }), XP = qN({ argsMap: (e2) => [e2.getTrackId()] }), VD((JP = class extends WD {
        get _source() {
          return this.initWebAudio();
        }
        set _source(e2) {
          this._trackSource = e2;
        }
        get processorContext() {
          return this._processorContext || (this._processorContext = this.initProcessor().processorContext), this._processorContext;
        }
        get processorDestination() {
          return this._processorDestination || (this._processorDestination = this.initProcessor().processorDestination), this._processorDestination;
        }
        get isPlaying() {
          return this._useAudioElement ? fP.isPlaying(this.getTrackId()) : this._source.isPlayed;
        }
        get __className__() {
          return "LocalAudioTrack";
        }
        constructor(e2, t2, i3, n2) {
          super(e2, i3), FD(this, "trackMediaType", vD.AUDIO), FD(this, "_encoderConfig", void 0), FD(this, "_trackSource", void 0), FD(this, "_enabled", true), FD(this, "_volume", 100), FD(this, "_useAudioElement", true), FD(this, "_bypassWebAudio", false), FD(this, "processor", void 0), FD(this, "_processorContext", void 0), FD(this, "_processorDestination", void 0), FD(this, "_getOriginVolumeLevel", void 0), this._encoderConfig = t2, this._getOriginVolumeLevel = !!n2, this._trackSource = new CP(), dN("DISABLE_WEBAUDIO") && (this._bypassWebAudio = true), dN("LOCAL_AUDIO_TRACK_USES_WEB_AUDIO") && (this._useAudioElement = false), Wb() && !KD ? setTimeout(() => this.initWebAudio()) : this.initWebAudio();
        }
        setVolume(e2) {
          Tw(e2, "volume", 0, 1e3), this._volume = e2, this._source.setVolume(e2 / 100), this._useAudioElement && fP.setVolume(this.getTrackId(), e2);
          try {
            if (this._bypassWebAudio)
              return void BN.debug("[".concat(this.getTrackId(), "] setVolume returned because no pass through WebAudio."));
            const e3 = this._source.createOutputTrack();
            this._mediaStreamTrack !== e3 && (this._mediaStreamTrack = e3, Yw(this, ED.NEED_REPLACE_TRACK, this).then(() => {
              BN.debug("[".concat(this.getTrackId(), "] replace web audio track success"));
            }).catch((e4) => {
              BN.warning("[".concat(this.getTrackId(), "] replace web audio track failed"), e4);
            }));
          } catch (e3) {
          }
        }
        getVolumeLevel() {
          return this._muted && this.enabled && this._getOriginVolumeLevel ? this._source.getOriginVolumeLevel() : this._source.getAccurateVolumeLevel();
        }
        async setPlaybackDevice(e2) {
          if (!this._useAudioElement || !ZN())
            throw new Ew(_w.NOT_SUPPORTED, "your browser does not support setting the audio output device");
          await fP.setSinkID(this.getTrackId(), e2);
        }
        async setEnabled(e2, t2, i3) {
          return this._setEnabled(e2, t2, i3);
        }
        async _setEnabled(e2, t2, i3) {
          if (!i3) {
            if (e2 === this._enabled)
              return;
            this.stateCheck("enabled", e2);
          }
          if (BN.info("[".concat(this.getTrackId(), "] start setEnabled"), e2), e2) {
            this._originMediaStreamTrack.enabled = true;
            try {
              i3 || (this._enabled = true), await Yw(this, ED.NEED_ENABLE_TRACK, this), BN.info("[".concat(this.getTrackId(), "] setEnabled to ").concat(e2, " success"));
            } catch (e3) {
              throw i3 || (this._enabled = false), BN.error("[".concat(this.getTrackId(), "] setEnabled to true error"), e3.toString()), e3;
            }
          } else {
            this._originMediaStreamTrack.enabled = false, i3 || (this._enabled = false);
            try {
              await Yw(this, ED.NEED_DISABLE_TRACK, this);
            } catch (e3) {
              throw i3 || (this._enabled = true), BN.error("[".concat(this.getTrackId(), "] setEnabled to false error"), e3.toString()), e3;
            }
          }
        }
        async setMuted(e2) {
          e2 !== this._muted && (this.stateCheck("muted", e2), this._muted = e2, this._originMediaStreamTrack.enabled = !e2, BN.debug("[".concat(this.getTrackId(), "] start set muted: ").concat(e2)), e2 ? await Yw(this, ED.NEED_MUTE_TRACK, this) : await Yw(this, ED.NEED_UNMUTE_TRACK, this));
        }
        getStats() {
          iO(() => {
            BN.warning("[deprecated] LocalAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalAudioStats instead");
          }, "localAudioTrackGetStatsWarning");
          return qw(this, ED.GET_STATS) || jD({}, yD);
        }
        setAudioFrameCallback(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4096;
          if (!e2)
            return this._source.removeAllListeners(ID.ON_AUDIO_BUFFER), void this._source.stopGetAudioBuffer();
          this._source.startGetAudioBuffer(t2), this._source.removeAllListeners(ID.ON_AUDIO_BUFFER), this._source.on(ID.ON_AUDIO_BUFFER, (t3) => e2(t3));
        }
        play() {
          BN.debug("[".concat(this.getTrackId(), "] start audio playback")), this._useAudioElement ? (BN.debug("[".concat(this.getTrackId(), "] start audio playback in element")), fP.play(this._mediaStreamTrack, this.getTrackId(), this._volume)) : this._source.play();
        }
        stop() {
          BN.debug("[".concat(this.getTrackId(), "] stop audio playback")), this._useAudioElement ? fP.stop(this.getTrackId()) : this._source.stop();
        }
        close() {
          super.close(), this._processorDestination && this.unbindProcessorDestinationEvents(this._processorDestination), this._processorContext && this.unbindProcessorContextEvents(this._processorContext), this.unpipe(), this._processorDestination && this._processorDestination._source && this._processorDestination._source.unpipe(), this._source.destroy();
        }
        _updatePlayerSource() {
          let e2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
          BN.debug("[".concat(this.getTrackId(), "] update player source track")), e2 && this._source.updateTrack(this._mediaStreamTrack), this._useAudioElement && fP.updateTrack(this.getTrackId(), this._mediaStreamTrack);
        }
        async _updateOriginMediaStreamTrack(e2, t2) {
          this._originMediaStreamTrack !== e2 && (this._originMediaStreamTrack && (this._originMediaStreamTrack.removeEventListener("ended", this._handleTrackEnded), t2 && this._originMediaStreamTrack.stop()), e2.addEventListener("ended", this._handleTrackEnded), this._originMediaStreamTrack = e2, this._muted && (this._originMediaStreamTrack.enabled = false), this.processor && this._processorContext && this.processor.updateInput({ track: e2, context: this._processorContext }), this._mediaStreamTrack !== this._source.outputTrack ? (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await Yw(this, ED.NEED_REPLACE_TRACK, this)) : this._source.updateTrack(this._originMediaStreamTrack), this._getOriginVolumeLevel && this._source.updateOriginTrack(e2));
        }
        renewMediaStreamTrack(e2) {
          return Wh.resolve(void 0);
        }
        pipe(e2) {
          if (this._bypassWebAudio)
            throw new Ew(_w.INVALID_OPERATION, "Can not process AudioTrack when bypassWebAudio set to true.");
          if (this.processor === e2)
            return e2;
          if (e2._source)
            throw new Ew(_w.INVALID_OPERATION, "Processor ".concat(e2.name, " already piped, please call unpipe beforehand."));
          return this.unpipe(), this.processor = e2, this.processor._source = this, e2.updateInput({ track: this._originMediaStreamTrack, node: this._source.processSourceNode, context: this.processorContext }), e2;
        }
        unpipe() {
          var e2;
          if (!this.processor)
            return;
          const t2 = this.processor;
          null === (e2 = this._source.processSourceNode) || void 0 === e2 || e2.disconnect(), this.processor._source = false, this.processor = void 0, t2.reset();
        }
        bindProcessorDestinationEvents(e2) {
          e2.on(ND.ON_TRACK, async (e3) => {
            e3 ? e3 !== this._mediaStreamTrack && (this._mediaStreamTrack = e3, this._updatePlayerSource(false), this._source.processedNode = this._source.createMediaStreamSourceNode(e3), await Yw(this, ED.NEED_REPLACE_TRACK, this)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await Yw(this, ED.NEED_REPLACE_TRACK, this));
          }), e2.on(ND.ON_NODE, (e3) => {
            this._source.processedNode = e3;
          });
        }
        unbindProcessorDestinationEvents(e2) {
          e2.removeAllListeners(ND.ON_TRACK), e2.removeAllListeners(ND.ON_NODE);
        }
        bindProcessorContextEvents(e2) {
          e2.on(DD.REQUEST_CONSTRAINTS, async (e3) => {
            e3(this._originMediaStreamTrack.getSettings());
          });
        }
        unbindProcessorContextEvents(e2) {
          e2.removeAllListeners(DD.REQUEST_CONSTRAINTS);
        }
        initWebAudio() {
          return this._trackSource instanceof CP && (this._trackSource = new $D(this._mediaStreamTrack, false, this._getOriginVolumeLevel ? this._mediaStreamTrack : void 0)), this._trackSource;
        }
        initProcessor() {
          const e2 = new RP(this._source.context, this.getTrackId(), "local"), t2 = new gP(e2);
          return this._processorContext = e2, this._processorDestination = t2, this.bindProcessorContextEvents(e2), this.bindProcessorDestinationEvents(t2), this._source.on(ID.UPDATE_SOURCE, () => {
            this.processor && this.processor.updateInput({ node: this._source.processSourceNode, context: e2 });
          }), this._useAudioElement && (this._useAudioElement = false, this.isPlaying && (fP.stop(this.getTrackId()), this._source.play()), Yw(this, ED.NEED_REPLACE_MIXING_TRACK, this).then(() => {
            BN.debug("[".concat(this.getTrackId(), "] replace from origin track to web audio track success"));
          }).catch((e3) => {
            BN.warning("[".concat(this.getTrackId(), "] replace from origin track to web audio track failed"), e3);
          })), { processorContext: e2, processorDestination: t2 };
        }
      }).prototype, "setVolume", [PP], Object.getOwnPropertyDescriptor(JP.prototype, "setVolume"), JP.prototype), VD(JP.prototype, "setPlaybackDevice", [LP, kP], Object.getOwnPropertyDescriptor(JP.prototype, "setPlaybackDevice"), JP.prototype), VD(JP.prototype, "setEnabled", [MP, UP, xP], Object.getOwnPropertyDescriptor(JP.prototype, "setEnabled"), JP.prototype), VD(JP.prototype, "setMuted", [VP, FP, BP], Object.getOwnPropertyDescriptor(JP.prototype, "setMuted"), JP.prototype), VD(JP.prototype, "getStats", [jP], Object.getOwnPropertyDescriptor(JP.prototype, "getStats"), JP.prototype), VD(JP.prototype, "setAudioFrameCallback", [GP], Object.getOwnPropertyDescriptor(JP.prototype, "setAudioFrameCallback"), JP.prototype), VD(JP.prototype, "play", [WP, HP], Object.getOwnPropertyDescriptor(JP.prototype, "play"), JP.prototype), VD(JP.prototype, "stop", [KP, YP], Object.getOwnPropertyDescriptor(JP.prototype, "stop"), JP.prototype), VD(JP.prototype, "close", [qP], Object.getOwnPropertyDescriptor(JP.prototype, "close"), JP.prototype), VD(JP.prototype, "pipe", [zP], Object.getOwnPropertyDescriptor(JP.prototype, "pipe"), JP.prototype), VD(JP.prototype, "unpipe", [XP], Object.getOwnPropertyDescriptor(JP.prototype, "unpipe"), JP.prototype), JP), SL = (QP = qN({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), ZP = mP(), $P = IO("MicrophoneAudioTrack", "_enabledMutex"), eL = qN({ argsMap: (e2, t2, i3) => [e2.getTrackId(), t2, i3] }), tL = mP(), iL = qN({ argsMap: (e2) => [e2.getTrackId()] }), VD((nL = class extends TL {
        get __className__() {
          return "MicrophoneAudioTrack";
        }
        constructor(e2, t2, i3, n2) {
          super(e2, t2.encoderConfig ? hD(t2.encoderConfig) : {}, n2, dN("GET_VOLUME_OF_MUTED_AUDIO_TRACK")), FD(this, "_config", void 0), FD(this, "_deviceName", "default"), FD(this, "_constraints", void 0), FD(this, "_originalConstraints", void 0), FD(this, "_enabled", true), this._config = t2, this._constraints = i3, this._originalConstraints = i3, this._deviceName = e2.label, "boolean" == typeof t2.bypassWebAudio && (this._bypassWebAudio = t2.bypassWebAudio), (tw() || iw()) && YD.bindInterruptDetectorTrack(this);
        }
        async setDevice(e2) {
          if (BN.info("[".concat(this.getTrackId(), "] start set device to ").concat(e2)), this._enabled)
            try {
              const t2 = await lP.getDeviceById(e2), i3 = {};
              i3.audio = jD({}, this._constraints), i3.audio.deviceId = { exact: e2 }, this._originMediaStreamTrack.stop();
              let n2 = null;
              try {
                n2 = await sP(i3, this.getTrackId());
              } catch (e3) {
                throw BN.error("[".concat(this.getTrackId(), "] setDevice failed"), e3.toString()), n2 = await sP({ audio: this._constraints }, this.getTrackId()), await this._updateOriginMediaStreamTrack(n2.getAudioTracks()[0], false), e3;
              }
              await this._updateOriginMediaStreamTrack(n2.getAudioTracks()[0], false), this._deviceName = t2.label, this._config.microphoneId = e2, this._constraints.deviceId = { exact: e2 };
            } catch (e3) {
              throw BN.error("[".concat(this.getTrackId(), "] setDevice error"), e3.toString()), e3;
            }
          else
            try {
              const t2 = await lP.getDeviceById(e2);
              this._deviceName = t2.label, this._config.microphoneId = e2, this._constraints.deviceId = { exact: e2 };
            } catch (e3) {
              throw BN.error("[".concat(this.getTrackId(), "] setDevice error"), e3.toString()), e3;
            }
          BN.info("[".concat(this.getTrackId(), "] set device to ").concat(e2, " success"));
        }
        async setEnabled(e2, t2, i3) {
          if (t2)
            return BN.debug("[".concat(this.getTrackId(), "] setEnabled false (do not close microphone)")), await super._setEnabled(e2);
          if (!i3) {
            if (e2 === this._enabled)
              return;
            this.stateCheck("enabled", e2);
          }
          if (BN.info("[".concat(this.getTrackId(), "] start setEnabled"), e2), dN("AUTO_RESET_AUDIO_ROUTE") && (Yb() || rw())) {
            const t3 = navigator.audioSession;
            t3 && (e2 || (t3.type = "playback"), t3.type = "auto");
          }
          if (!e2) {
            var n2;
            this._originMediaStreamTrack.onended = null, this._originMediaStreamTrack.stop(), null === (n2 = this._source.clonedTrack) || void 0 === n2 || n2.stop(), i3 || (this._enabled = false);
            try {
              await Yw(this, ED.NEED_DISABLE_TRACK, this);
            } catch (e3) {
              throw BN.error("[".concat(this.getTrackId(), "] setEnabled false failed"), e3.toString()), e3;
            }
            return;
          }
          const r2 = jD({}, this._constraints), o2 = lP.searchDeviceIdByName(this._deviceName);
          o2 && !r2.deviceId && (r2.deviceId = o2);
          try {
            i3 || (this._enabled = true);
            const e3 = await sP({ audio: this._constraints }, this.getTrackId());
            await this._updateOriginMediaStreamTrack(e3.getAudioTracks()[0], false), await Yw(this, ED.NEED_ENABLE_TRACK, this);
          } catch (e3) {
            throw i3 || (this._enabled = false), BN.error("[".concat(this.getTrackId(), "] setEnabled true failed"), e3.toString()), e3;
          }
          BN.info("[".concat(this.getTrackId(), "] setEnabled success"));
        }
        close() {
          super.close(), (tw() || iw()) && YD.unbindInterruptDetectorTrack(this);
        }
        onTrackEnded() {
          if ((Yb() || rw()) && this._enabled && !this._isClosed && YD.duringInterruption) {
            const e2 = async () => {
              YD.off(eD.IOS_INTERRUPTION_END, e2), this._enabled && !this._isClosed && (BN.debug("[".concat(this.getTrackId(), "] try capture microphone media device for interrupted iOS device.")), await this.setEnabled(false), await this.setEnabled(true));
            };
            YD.on(eD.IOS_INTERRUPTION_END, e2);
          } else
            BN.debug("[".concat(this.getTrackId(), "] track ended")), this.safeEmit(RD.TRACK_ENDED);
        }
        async renewMediaStreamTrack(e2) {
          const t2 = e2 || this._constraints, i3 = lP.searchDeviceIdByName(this._deviceName);
          if (i3 && !t2.deviceId && (t2.deviceId = i3), this._constraints = t2, this._enabled) {
            this._originMediaStreamTrack.stop();
            const e3 = await sP({ audio: this._constraints }, this.getTrackId());
            await this._updateOriginMediaStreamTrack(e3.getAudioTracks()[0], true);
          }
        }
        bindProcessorContextEvents(e2) {
          super.bindProcessorContextEvents(e2), e2.on(DD.REQUEST_UPDATE_CONSTRAINTS, async (e3, t2, i3) => {
            try {
              const i4 = Object.assign({}, this._originalConstraints, ...e3);
              await this.renewMediaStreamTrack(i4), t2();
            } catch (e4) {
              i3(e4);
            }
          });
        }
        unbindProcessorContextEvents(e2) {
          super.unbindProcessorContextEvents(e2), e2.removeAllListeners(DD.REQUEST_UPDATE_CONSTRAINTS);
        }
      }).prototype, "setDevice", [QP, ZP], Object.getOwnPropertyDescriptor(nL.prototype, "setDevice"), nL.prototype), VD(nL.prototype, "setEnabled", [$P, eL, tL], Object.getOwnPropertyDescriptor(nL.prototype, "setEnabled"), nL.prototype), VD(nL.prototype, "close", [iL], Object.getOwnPropertyDescriptor(nL.prototype, "close"), nL.prototype), nL), gL = (rL = qN({ argsMap: (e2, t2) => [e2.getTrackId(), t2, e2.duration] }), oL = mP(), sL = qN({ argsMap: (e2) => [e2.getTrackId()] }), aL = mP(), cL = qN({ argsMap: (e2) => [e2.getTrackId()] }), dL = mP(), lL = qN({ argsMap: (e2) => [e2.getTrackId()] }), uL = mP(), hL = qN({ argsMap: (e2) => [e2.getTrackId()] }), pL = mP(), _L = qN({ argsMap: (e2) => [e2.getTrackId()] }), EL = qN({ argsMap: (e2) => [e2.getTrackId()] }), fL = mP(), VD((mL = class extends TL {
        get __className__() {
          return "BufferSourceAudioTrack";
        }
        constructor(e2, t2, i3, n2) {
          super(t2.createOutputTrack(), i3, n2), FD(this, "source", void 0), FD(this, "_bufferSource", void 0), this._useAudioElement = false, this.source = e2, this._bufferSource = t2, this._bufferSource.on(ID.AUDIO_SOURCE_STATE_CHANGE, (e3) => {
            this.safeEmit(RD.SOURCE_STATE_CHANGE, e3);
          });
          try {
            this._mediaStreamTrack = this._source.createOutputTrack();
          } catch (e3) {
          }
        }
        get currentState() {
          return this._bufferSource.currentState;
        }
        get duration() {
          return this._bufferSource.duration;
        }
        get playbackSpeed() {
          return this._bufferSource.playbackSpeed;
        }
        getCurrentTime() {
          return this._bufferSource.currentTime;
        }
        startProcessAudioBuffer(e2) {
          e2 && this._bufferSource.updateOptions(e2), this._bufferSource.startProcessAudioBuffer();
        }
        pauseProcessAudioBuffer() {
          this._bufferSource.pauseProcessAudioBuffer();
        }
        seekAudioBuffer(e2) {
          this._bufferSource.seekAudioBuffer(e2);
        }
        resumeProcessAudioBuffer() {
          this._bufferSource.resumeProcessAudioBuffer();
        }
        stopProcessAudioBuffer() {
          this._bufferSource.stopProcessAudioBuffer();
        }
        close() {
          this.source = null, this._bufferSource.destroy(), super.close();
        }
        setAudioBufferPlaybackSpeed(e2) {
          Tw(e2, "speed", 0), this._bufferSource.setAudioBufferPlaybackSpeed(e2);
        }
      }).prototype, "startProcessAudioBuffer", [rL, oL], Object.getOwnPropertyDescriptor(mL.prototype, "startProcessAudioBuffer"), mL.prototype), VD(mL.prototype, "pauseProcessAudioBuffer", [sL, aL], Object.getOwnPropertyDescriptor(mL.prototype, "pauseProcessAudioBuffer"), mL.prototype), VD(mL.prototype, "seekAudioBuffer", [cL, dL], Object.getOwnPropertyDescriptor(mL.prototype, "seekAudioBuffer"), mL.prototype), VD(mL.prototype, "resumeProcessAudioBuffer", [lL, uL], Object.getOwnPropertyDescriptor(mL.prototype, "resumeProcessAudioBuffer"), mL.prototype), VD(mL.prototype, "stopProcessAudioBuffer", [hL, pL], Object.getOwnPropertyDescriptor(mL.prototype, "stopProcessAudioBuffer"), mL.prototype), VD(mL.prototype, "close", [_L], Object.getOwnPropertyDescriptor(mL.prototype, "close"), mL.prototype), VD(mL.prototype, "setAudioBufferPlaybackSpeed", [EL, fL], Object.getOwnPropertyDescriptor(mL.prototype, "setAudioBufferPlaybackSpeed"), mL.prototype), mL);
      class RL extends TL {
        get __className__() {
          return "MixingAudioTrack";
        }
        get isActive() {
          for (const e2 of this.trackList)
            if (e2._enabled && !e2._isClosed && !e2.muted)
              return true;
          return false;
        }
        constructor() {
          const e2 = qD().createMediaStreamDestination();
          super(e2.stream.getAudioTracks()[0], void 0, uO(8, "track-mix-")), FD(this, "trackList", void 0), FD(this, "destNode", void 0), this._useAudioElement = false;
          try {
            this._mediaStreamTrack = this._source.createOutputTrack();
          } catch (e3) {
          }
          this.destNode = e2, this.trackList = [];
        }
        hasAudioTrack(e2) {
          return -1 !== this.trackList.indexOf(e2);
        }
        addAudioTrack(e2) {
          -1 === this.trackList.indexOf(e2) ? (BN.debug("add ".concat(e2.getTrackId(), " to mixing track")), e2._source.outputNode.connect(this.destNode), this.trackList.push(e2), this.updateEncoderConfig()) : BN.debug("track ".concat(e2.getTrackId(), " is already added"));
        }
        removeAudioTrack(e2) {
          if (-1 !== this.trackList.indexOf(e2)) {
            BN.debug("remove ".concat(e2.getTrackId(), " from mixing track"));
            try {
              e2._source.outputNode.disconnect(this.destNode);
            } catch (e3) {
            }
            Jw(this.trackList, e2), this.updateEncoderConfig();
          }
        }
        updateEncoderConfig() {
          const e2 = {};
          this.trackList.forEach((t2) => {
            t2._encoderConfig && ((t2._encoderConfig.bitrate || 0) > (e2.bitrate || 0) && (e2.bitrate = t2._encoderConfig.bitrate), (t2._encoderConfig.sampleRate || 0) > (e2.sampleRate || 0) && (e2.sampleRate = t2._encoderConfig.sampleRate), (t2._encoderConfig.sampleSize || 0) > (e2.sampleSize || 0) && (e2.sampleSize = t2._encoderConfig.sampleSize), t2._encoderConfig.stereo && (e2.stereo = true));
          }), this._encoderConfig = e2;
        }
        _updateRtpTransceiver(e2) {
          this._rtpTransceiver !== e2 && (this._rtpTransceiver = e2, this.trackList.forEach((t2) => {
            t2 instanceof RL ? t2.emit(gD.TRANSCEIVER_UPDATED, e2) : t2._updateRtpTransceiver(e2);
          }));
        }
      }
      class CL extends ZD {
        set currentState(e2) {
          e2 !== this._currentState && (this._currentState = e2, this.safeEmit(ID.AUDIO_SOURCE_STATE_CHANGE, this._currentState));
        }
        get currentState() {
          return this._currentState;
        }
        constructor(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          super(), FD(this, "audioBuffer", void 0), FD(this, "sourceNode", void 0), FD(this, "startPlayTime", 0), FD(this, "startPlayOffset", 0), FD(this, "pausePlayTime", 0), FD(this, "options", void 0), FD(this, "currentLoopCount", 0), FD(this, "currentPlaybackSpeed", 100), FD(this, "_currentState", "stopped"), this.audioBuffer = e2, this.options = t2, this.startPlayOffset = this.options.startPlayTime || 0;
        }
        createWebAudioDiagram() {
          return this.context.createGain();
        }
        get duration() {
          return this.audioBuffer ? this.audioBuffer.duration : 0;
        }
        get playbackSpeed() {
          return this.currentPlaybackSpeed;
        }
        get currentTime() {
          return this.audioBuffer ? "stopped" === this.currentState ? 0 : "paused" === this.currentState ? this.pausePlayTime : ((this.context.currentTime - this.startPlayTime) * (this.playbackSpeed / 100) + this.startPlayOffset) % this.audioBuffer.duration : 0;
        }
        updateOptions(e2) {
          "stopped" === this.currentState ? (this.options = e2, this.startPlayOffset = this.options.startPlayTime || 0) : BN.warning("can not set audio source options");
        }
        startProcessAudioBuffer() {
          this.sourceNode && this.stopProcessAudioBuffer(), this.sourceNode = this.createSourceNode(), this.startSourceNode(), this.currentState = "playing";
        }
        pauseProcessAudioBuffer() {
          this.sourceNode && "playing" === this.currentState && (this.pausePlayTime = this.currentTime, this.sourceNode.onended = null, this.sourceNode.stop(), this.sourceNode.buffer = null, this.sourceNode = this.createSourceNode(), this.currentState = "paused");
        }
        seekAudioBuffer(e2) {
          this.sourceNode && (this.sourceNode.onended = null, "playing" === this.currentState && this.sourceNode.stop(), this.sourceNode = this.createSourceNode(), "playing" === this.currentState ? (this.startPlayOffset = e2, this.startSourceNode()) : "paused" === this.currentState && (this.pausePlayTime = e2));
        }
        resumeProcessAudioBuffer() {
          "paused" === this.currentState && this.sourceNode && (this.startPlayOffset = this.pausePlayTime, this.pausePlayTime = 0, this.startSourceNode(), this.currentState = "playing");
        }
        stopProcessAudioBuffer() {
          if (this.sourceNode) {
            this.sourceNode.onended = null;
            try {
              this.sourceNode.stop();
            } catch (e2) {
            }
            this.reset();
          }
        }
        destroy() {
          this.audioBuffer = null, super.destroy();
        }
        setAudioBufferPlaybackSpeed(e2) {
          this.sourceNode && ("playing" === this.currentState && (this.startPlayOffset = this.currentTime, this.startPlayTime = this.context.currentTime), this.sourceNode.playbackRate.value = e2 / 100), this.currentPlaybackSpeed = e2;
        }
        startSourceNode() {
          this.sourceNode && this.sourceNode.buffer && (this.sourceNode.start(0, this.startPlayOffset), this.startPlayTime = this.context.currentTime, this.sourceNode.onended = this.handleSourceNodeEnded.bind(this));
        }
        createSourceNode() {
          const e2 = this.context.createBufferSource();
          return e2.buffer = this.audioBuffer, e2.loop = !!this.options.loop, e2.connect(this.outputNode), e2.playbackRate.value = this.currentPlaybackSpeed / 100, e2;
        }
        handleSourceNodeEnded() {
          if (this.currentLoopCount += 1, this.options.cycle && this.options.cycle > this.currentLoopCount)
            return this.startPlayOffset = 0, this.sourceNode = void 0, void this.startProcessAudioBuffer();
          this.reset();
        }
        reset() {
          this.startPlayOffset = this.options.startPlayTime || 0, this.currentState = "stopped", this.sourceNode && (this.sourceNode.disconnect(), this.sourceNode = void 0), this.currentLoopCount = 0;
        }
      }
      const vL = /* @__PURE__ */ new Map();
      class IL {
        get rendFrameRate() {
          if (this.renderStats && this.renderStats.curTs !== this.renderStats.lastTs) {
            const e2 = this.renderStats.curTs - this.renderStats.lastTs, t2 = (this.renderStats.renderNum - this.renderStats.lastRenderNum) / e2;
            return this.renderStats.lastRenderNum = this.renderStats.renderNum, this.renderStats.lastTs = this.renderStats.curTs, t2;
          }
          return 0;
        }
        get videoElementStatus() {
          return this._videoElementStatus;
        }
        set videoElementStatus(e2) {
          e2 !== this._videoElementStatus && (BN.debug("[".concat(this.trackId, "] video-element-status change ").concat(this._videoElementStatus, " => ").concat(e2)), this._videoElementStatus = e2);
        }
        get videoState() {
          return this._videoState;
        }
        set videoState(e2) {
          var t2;
          e2 !== this._videoState && (this._videoState = e2, null === (t2 = this.onVideoStateChanged) || void 0 === t2 || t2.call(this, this.videoState));
        }
        constructor(e2) {
          FD(this, "trackId", void 0), FD(this, "config", void 0), FD(this, "onFirstVideoFrameDecoded", void 0), FD(this, "onVideoStateChanged", void 0), FD(this, "freezeTimeCounterList", []), FD(this, "renderFreezeAccTime", 0), FD(this, "isKeepLastFrame", false), FD(this, "timeUpdatedCount", 0), FD(this, "freezeTime", 0), FD(this, "playbackTime", 0), FD(this, "lastTimeUpdatedTime", 0), FD(this, "autoplayFailed", false), FD(this, "videoTrack", void 0), FD(this, "videoElement", void 0), FD(this, "cacheVideoElement", void 0), FD(this, "renderStats", void 0), FD(this, "_videoState", MD.VideoStateStopped), FD(this, "videoElementCheckInterval", void 0), FD(this, "videoElementFreezeTimeout", void 0), FD(this, "_videoElementStatus", kD.NONE), FD(this, "isGettingVideoDimensions", false), FD(this, "startGetVideoDimensions", () => {
            const e3 = () => {
              if (this.isGettingVideoDimensions = true, this.videoElement.videoWidth * this.videoElement.videoHeight > 4)
                return BN.debug("[".concat(this.trackId, "] current video dimensions:"), this.videoElement.videoWidth, this.videoElement.videoHeight), void (this.isGettingVideoDimensions = false);
              setTimeout(e3, 500);
            };
            !this.isGettingVideoDimensions && e3();
          }), FD(this, "autoResumeAfterInterruption", () => {
            this.videoTrack && "live" === this.videoTrack.readyState && "running" === YD.curState && (BN.debug("[track-".concat(this.trackId, "] video element paused, auto resume for ").concat(Bb())), nw() ? (this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : (this.videoElement.pause(), this.videoElement.play()));
          }), FD(this, "handleVideoEvents", (e3) => {
            switch (e3.type) {
              case "play":
              case "playing":
                this.startGetVideoDimensions(), this.videoElementStatus = kD.PLAYING;
                break;
              case "loadeddata":
                if (this.videoState = MD.VideoStateStarting, this.onFirstVideoFrameDecoded && this.onFirstVideoFrameDecoded(), this.cacheVideoElement) {
                  try {
                    this.cacheVideoElement.srcObject = null, this.cacheVideoElement.remove();
                  } catch (e4) {
                  }
                  this.cacheVideoElement = void 0;
                }
                break;
              case "canplay":
                this.videoElementStatus = kD.CANPLAY;
                break;
              case "stalled":
                this.videoElementStatus = kD.STALLED;
                break;
              case "suspend":
                this.videoElementStatus = kD.SUSPEND;
                break;
              case "pause":
                this.videoElementStatus = kD.PAUSED, Yb() || rw() || Wb() && this.autoplayFailed || !this.videoTrack || "live" !== this.videoTrack.readyState || (BN.debug("[track-".concat(this.trackId, "] video element paused, auto resume")), this.videoElement.play());
                break;
              case "waiting":
                this.videoElementStatus = kD.WAITING;
                break;
              case "abort":
                this.videoElementStatus = kD.ABORT;
                break;
              case "ended":
                this.videoElementStatus = kD.ENDED;
                break;
              case "emptied":
                this.videoElementStatus = kD.EMPTIED;
                break;
              case "error": {
                const e4 = this.videoElement.error;
                e4 && (this.videoElementStatus = kD.ERROR, BN.error("[".concat(this.trackId, "] media error: ").concat(e4.message, " (").concat(e4.code, ")")));
                break;
              }
              case "timeupdate": {
                const e4 = performance.now();
                if (this.timeUpdatedCount += 1, this.timeUpdatedCount < 10)
                  return void (this.lastTimeUpdatedTime = e4);
                const t2 = e4 - this.lastTimeUpdatedTime, i3 = this.lastTimeUpdatedTime;
                if (this.lastTimeUpdatedTime = e4, yk.lastVisibleTime < yk.lastHiddenTime || i3 < yk.lastHiddenTime || i3 < yk.lastVisibleTime)
                  return;
                for (t2 > dN("VIDEO_FREEZE_DURATION") && (this.freezeTime += t2), this.playbackTime += t2; this.playbackTime >= 6e3; ) {
                  this.playbackTime -= 6e3;
                  const e5 = Math.min(6e3, this.freezeTime);
                  this.freezeTimeCounterList.push(e5), this.freezeTime = Math.max(0, this.freezeTime - 6e3);
                }
                break;
              }
            }
          }), FD(this, "autoResumeAfterInterruptionOnIOS15_16", () => {
            this.videoTrack && "live" === this.videoTrack.readyState && (BN.debug("[track-".concat(this.trackId, "] video element paused, auto resume for ").concat(Bb())), nw() ? (this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : (this.videoElement.pause(), this.videoElement.play()));
          }), this.trackId = e2.trackId, this.config = e2, e2.element instanceof HTMLVideoElement ? this.videoElement = e2.element : this.videoElement = document.createElement("video"), YD.on(eD.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), YD.on(eD.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16);
        }
        getVideoElement() {
          return this.videoElement;
        }
        getContainerElement() {
          var e2;
          return null !== (e2 = this.videoElement.parentElement) && void 0 !== e2 ? e2 : void 0;
        }
        updateConfig(e2) {
          this.config = e2, this.trackId = e2.trackId, e2.element !== this.videoElement && (this.destroy(), this.videoElement = e2.element), this.videoTrack && this.initVideoElement();
        }
        updateVideoTrack(e2) {
          this.videoTrack !== e2 && (this.videoTrack = e2, this.initVideoElement());
        }
        play(e2) {
          const t2 = this.videoElement.play();
          t2 && t2.catch && t2.catch((t3) => {
            e2 && _P(e2, "video", t3.message, this.trackId), "NotAllowedError" === t3.name ? (BN.warning("detected video element autoplay failed", t3), this.autoplayFailed = true, this.handleAutoPlayFailed()) : BN.warning("[".concat(this.trackId, "] play warning: "), t3);
          });
          const i3 = xb();
          if (("Safari" === i3.name && 15 === Number(i3.version) || tw()) && t2 && t2.then) {
            const e3 = () => {
              this.config.mirror && (this.videoElement.style.transform = "rotateY(180deg)");
            };
            t2.then(e3).catch(e3);
          }
        }
        getCurrentFrame() {
          const e2 = document.createElement("canvas");
          e2.width = this.videoElement.videoWidth, e2.height = this.videoElement.videoHeight;
          const t2 = e2.getContext("2d");
          if (!t2)
            return BN.error("create canvas context failed!"), new ImageData(2, 2);
          t2.drawImage(this.videoElement, 0, 0, e2.width, e2.height);
          const i3 = t2.getImageData(0, 0, e2.width, e2.height);
          return e2.remove(), i3;
        }
        async getCurrentFrameToUint8Array(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
          const i3 = document.createElement("canvas");
          i3.width = this.videoElement.videoWidth, i3.height = this.videoElement.videoHeight;
          const n2 = i3.getContext("2d");
          return n2 ? (n2.drawImage(this.videoElement, 0, 0, i3.width, i3.height), new Wh((n3, r2) => {
            i3.toBlob(async (e3) => {
              if (i3.remove(), e3) {
                const t3 = await DP(e3);
                n3({ buffer: t3, width: i3.width, height: i3.height });
              } else
                r2(new Ew(_w.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED));
            }, e2, t2 < 0 ? 0.1 : t2 > 1 ? 1 : t2);
          })) : await NP(e2);
        }
        destroy() {
          this.renderStats = void 0, YD.off(eD.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), YD.off(eD.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16), this.videoElement.srcObject = null, this.resetVideoElement(), this.freezeTimeCounterList = [], this.videoState = MD.VideoStateStopped;
        }
        initVideoElement() {
          if (this.videoElementStatus = kD.INIT, !this.videoElementCheckInterval && (yL.forEach((e3) => {
            this.videoElement.addEventListener(e3, this.handleVideoEvents);
          }), this.videoElementCheckInterval = window.setInterval(() => {
            (function(e3) {
              return e3 !== document.body && document.body.contains(e3);
            })(this.videoElement) || (this.videoElementStatus = kD.DESTROYED);
          }, 1e3), dN("ENABLE_VIDEO_FRAME_CALLBACK"))) {
            var e2, t2;
            let i4;
            const n3 = () => {
              "visible" === document.visibilityState && (document.removeEventListener("visibilitychange", n3), this.videoElementFreezeTimeout = window.setTimeout(r2, dN("VIDEO_FREEZE_DURATION")));
            }, r2 = () => {
              this.videoElementFreezeTimeout = void 0, this.videoState === MD.VideoStateDecoding && ("visible" === document.visibilityState ? this.videoState = MD.VideoStateFrozen : document.addEventListener("visibilitychange", n3));
            }, o2 = (e3, t3) => {
              if (this.videoElementStatus === kD.PLAYING) {
                if (this.renderStats ? (this.renderStats.renderNum++, this.renderStats.curTs = t3.mediaTime) : this.renderStats = { lastTs: t3.mediaTime, curTs: t3.mediaTime, lastRenderNum: 0, renderNum: 0 }, i4) {
                  const e4 = t3.presentationTime - i4.presentationTime;
                  this.videoState === MD.VideoStateStarting && (this.videoState = MD.VideoStateDecoding), this.videoState === MD.VideoStateDecoding && this.onVideoStateChanged && (this.videoElementFreezeTimeout && window.clearTimeout(this.videoElementFreezeTimeout), this.videoElementFreezeTimeout = window.setTimeout(r2, dN("VIDEO_FREEZE_DURATION"))), e4 < dN("VIDEO_FREEZE_DURATION") && this.videoState === MD.VideoStateFrozen && (this.videoState = MD.VideoStateDecoding), e4 > dN("VIDEO_FREEZE_DURATION") && yk.lastVisibleTime >= yk.lastHiddenTime && i4.timestamp > yk.lastVisibleTime && i4.timestamp > yk.lastHiddenTime && (this.renderFreezeAccTime += e4);
                }
                i4 = jD(jD({}, t3), {}, { timestamp: e3 });
              }
              var n4, s2;
              dN("ENABLE_VIDEO_FRAME_CALLBACK") && (null === (n4 = (s2 = this.videoElement).requestVideoFrameCallback) || void 0 === n4 || n4.call(s2, o2));
            };
            null === (e2 = (t2 = this.videoElement).requestVideoFrameCallback) || void 0 === e2 || e2.call(t2, o2);
          }
          this.videoElement.controls = false, this.videoElement.setAttribute("playsinline", ""), dw() && !dN("HIDE_NO_POSTER") && (this.videoElement.poster = "noposter");
          const i3 = xb();
          "Safari" === i3.name && 15 === Number(i3.version) || tw() || !this.config.mirror || (this.videoElement.style.transform = "rotateY(180deg)"), this.config.fit ? this.videoElement.style.objectFit = this.config.fit : this.videoElement.style.objectFit = "cover", this.videoElement.setAttribute("muted", ""), this.videoElement.muted = true, this.videoElement.srcObject && this.videoElement.srcObject instanceof MediaStream ? this.videoElement.srcObject.getVideoTracks()[0] !== this.videoTrack && (this.videoElement.srcObject = this.videoTrack ? new MediaStream([this.videoTrack]) : null, Kb() && this.videoElement.load()) : (this.videoElement.srcObject = this.videoTrack ? new MediaStream([this.videoTrack]) : null, Kb() && this.videoElement.load());
          const n2 = this.videoElement.play();
          void 0 !== n2 && n2.catch((e3) => {
            BN.debug("[".concat(this.trackId, "] playback interrupted"), e3.toString());
          });
        }
        resetVideoElement() {
          yL.forEach((e2) => {
            this.videoElement && this.videoElement.removeEventListener(e2, this.handleVideoEvents);
          }), this.videoElementCheckInterval && (window.clearInterval(this.videoElementCheckInterval), this.videoElementCheckInterval = void 0), this.videoElementStatus = kD.NONE;
        }
        handleAutoPlayFailed() {
          const e2 = (t2) => {
            t2.preventDefault(), this.videoElement.play().then(() => {
              BN.debug("[".concat(this.trackId, "] Video element for trackId:").concat(this.trackId, " autoplay resumed."));
            }).catch((e3) => {
              BN.error(e3);
            }), this.autoplayFailed = false, lw() ? document.body.removeEventListener("click", e2, true) : (document.body.removeEventListener("touchstart", e2, true), document.body.removeEventListener("mousedown", e2, true));
          };
          lw() ? document.body.addEventListener("click", e2, true) : (document.body.addEventListener("touchstart", e2, true), document.body.addEventListener("mousedown", e2, true)), pP();
        }
      }
      const yL = ["play", "playing", "loadeddata", "canplay", "pause", "stalled", "suspend", "waiting", "abort", "emptied", "ended", "timeupdate", "error"];
      class AL extends IL {
        constructor(e2) {
          super(e2), FD(this, "container", void 0), FD(this, "slot", void 0), this.slot = e2.element, this.updateConfig(e2);
        }
        updateConfig(e2) {
          this.config = e2, this.trackId = e2.trackId;
          const t2 = e2.element;
          t2 !== this.slot && (this.destroy(), this.slot = t2), this.createElements();
        }
        updateVideoTrack(e2) {
          this.videoTrack !== e2 && (this.videoTrack = e2, this.createElements());
        }
        play(e2) {
          var t2;
          null !== (t2 = this.container) && void 0 !== t2 && t2.contains(this.videoElement) && super.play(e2);
        }
        getCurrentFrame() {
          var e2;
          return null !== (e2 = this.container) && void 0 !== e2 && e2.contains(this.videoElement) ? super.getCurrentFrame() : new ImageData(2, 2);
        }
        async getCurrentFrameToUint8Array(e2) {
          var t2;
          let i3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
          return null !== (t2 = this.container) && void 0 !== t2 && t2.contains(this.videoElement) ? await super.getCurrentFrameToUint8Array(e2, i3) : await NP(e2);
        }
        destroy() {
          if (super.destroy(), this.videoElement.remove(), this.videoElement = document.createElement("video"), this.container) {
            try {
              this.container.remove(), this.slot.removeChild(this.container);
            } catch (e2) {
            }
            this.container = void 0;
          }
        }
        createElements() {
          this.container || (this.container = document.createElement("div")), this.container.id = "agora-video-player-".concat(this.trackId), this.container.style.width = "100%", this.container.style.height = "100%", this.container.style.position = "relative", this.container.style.overflow = "hidden", this.videoTrack ? (this.container.style.backgroundColor = "black", dN("KEEP_LAST_FRAME") && this.isKeepLastFrame && this.videoElement.paused && this.resetVideoElement(), this.mountedVideoElement()) : this.unmountedVideoElement(), this.slot.appendChild(this.container);
        }
        mountedVideoElement() {
          var e2;
          !this.container || null !== (e2 = this.container) && void 0 !== e2 && e2.contains(this.videoElement) || this.container.appendChild(this.videoElement), super.initVideoElement(), this.videoElement.id = "video_".concat(this.trackId), this.videoElement.className = "agora_video_player", this.videoElement.style.width = "100%", this.videoElement.style.height = "100%", this.videoElement.style.position = "absolute", this.videoElement.style.left = "0", this.videoElement.style.top = "0";
        }
        unmountedVideoElement() {
          var e2;
          if (null !== (e2 = this.container) && void 0 !== e2 && e2.contains(this.videoElement)) {
            super.resetVideoElement();
            try {
              this.container && this.container.removeChild(this.videoElement);
            } catch (e3) {
            }
            this.videoElement = document.createElement("video");
          }
        }
        resetVideoElement() {
          var e2;
          null !== (e2 = this.container) && void 0 !== e2 && e2.contains(this.videoElement) && (super.resetVideoElement(), this.cacheVideoElement = this.videoElement, this.videoElement = document.createElement("video"));
        }
        getContainerElement() {
          return this.container;
        }
      }
      var bL, wL, OL, NL, DL, PL, LL, kL, ML, UL, xL, VL, FL, BL, jL, GL, WL, HL, KL, YL, qL, zL, XL, JL, QL, ZL, $L, ek, tk, ik, nk, rk, ok2, sk;
      let ak = (bL = qN({ argsMap: (e2, t2, i3) => [e2.getTrackId(), "string" == typeof t2 ? t2 : t2 instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement", i3] }), wL = mP(), OL = qN({ argsMap: (e2) => [e2.getTrackId()] }), NL = IO("LocalVideoTrack", "_enabledMutex"), DL = qN({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), PL = mP(), LL = IO("LocalVideoTrack", "_enabledMutex"), kL = qN({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), ML = mP(), UL = qN({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), xL = mP(), VL = mP(), FL = qN({ argsMap: (e2, t2, i3) => [e2.getTrackId(), t2, i3] }), BL = mP(), jL = mP(), GL = mP(), WL = mP(), HL = mP(), KL = mP(), YL = mP(), qL = qN({ argsMap: (e2, t2) => [e2.getTrackId(), t2.name] }), zL = qN({ argsMap: (e2) => [e2.getTrackId()] }), XL = qN({ argsMap: (e2) => [e2.getTrackId()] }), JL = qN({ argsMap: (e2, t2, i3) => [e2.getTrackId(), t2.label, i3] }), QL = class e2 extends WD {
        get videoHeight() {
          if (Wb()) {
            const { height: e3 } = this._mediaStreamTrack.getSettings();
            return this._videoHeight = e3, this._videoHeight;
          }
          return this._videoHeight;
        }
        get videoWidth() {
          if (Wb()) {
            const { width: e3 } = this._mediaStreamTrack.getSettings();
            return this._videoWidth = e3, this._videoWidth;
          }
          return this._videoWidth;
        }
        get isPlaying() {
          return !(!this._player || this._player.videoElementStatus !== kD.PLAYING);
        }
        get processorDestination() {
          return this._processorDestination;
        }
        get processorContext() {
          return this._processorContext;
        }
        set processorContext(e3) {
          this._processorContext = e3;
        }
        get __className__() {
          return "LocalVideoTrack";
        }
        constructor(e3, t2, i3, n2, r2, o2) {
          if (super(e3, r2), FD(this, "trackMediaType", vD.VIDEO), FD(this, "_player", void 0), FD(this, "isUseScaleResolutionDownBy", false), FD(this, "_videoVisibleTimer", null), FD(this, "_previousVideoVisibleStatus", void 0), FD(this, "_clearPreviousVideoVisibleStatus", () => this._previousVideoVisibleStatus = void 0), FD(this, "_encoderConfig", void 0), FD(this, "_scalabilityMode", { numSpatialLayers: 1, numTemporalLayers: 1 }), FD(this, "_optimizationMode", void 0), FD(this, "_videoHeight", void 0), FD(this, "_videoWidth", void 0), FD(this, "_forceBitrateLimit", void 0), FD(this, "_enabled", true), FD(this, "_processorDestination", void 0), FD(this, "_processorContext", void 0), Wb()) {
            const { width: t3, height: i4 } = e3.getSettings();
            this._videoWidth = t3, this._videoHeight = i4;
          } else
            this.updateMediaStreamTrackResolution();
          if (this._encoderConfig = t2, this._scalabilityMode = i3, this._optimizationMode = n2, this._hints = o2 || [], -1 === this._hints.indexOf(fD.SCREEN_TRACK))
            this.updateBitrateFromProfile();
          else if (function(e4, t3, i4) {
            const n3 = xb();
            return !(n3.name !== e4 || !n3.osVersion) && (i4 ? Number(n3.version) >= t3 && Number(n3.version) <= i4 : Number(n3.version) === t3);
          }(Lb.CHROME, 115) && -1 !== Fb().indexOf("Windows")) {
            const t3 = function(e4, t4) {
              if ("VideoFrame" in window && "TransformStream" in window && QN().supportWebRTCInsertableStream) {
                const i4 = new MediaStreamTrackProcessor(e4), n3 = new MediaStreamTrackGenerator({ kind: "video" });
                let r3, o3, s2 = Date.now();
                const a2 = () => {
                  c2 && (clearInterval(c2), c2 = void 0), r3 && (r3.close(), r3 = void 0), e4.stop(), o3 = void 0, n3.removeEventListener("ended", a2);
                };
                let c2 = window.setInterval(() => {
                  if (o3 && r3 && Date.now() - s2 > (null != t4 ? t4 : 1e3))
                    try {
                      "live" === n3.readyState ? o3.enqueue(r3.clone()) : a2();
                    } catch (e5) {
                      a2();
                    }
                }, null != t4 ? t4 : 1e3);
                const d2 = new TransformStream({ transform: (e5, t5) => {
                  "live" === n3.readyState ? (o3 = t5, s2 = Date.now(), void 0 === r3 ? (r3 = e5, t5.enqueue(e5.clone())) : (t5.enqueue(r3), r3 = e5)) : e5.close();
                } });
                return n3.addEventListener("ended", a2), i4.readable.pipeThrough(d2).pipeTo(n3.writable), n3;
              }
            }(e3);
            t3 && (BN.info("local screen video track begin to inject frame"), this._mediaStreamTrack = t3);
          }
          t2 && -1 !== this._hints.indexOf(fD.CUSTOM_TRACK) && this.setEncoderConfiguration(t2), this._processorContext = new SP(this.getTrackId(), "local"), this._processorDestination = new TP(this.processorContext), this.bindProcessorDestinationEvents();
        }
        play(e3) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          if ("string" == typeof e3) {
            const t3 = document.getElementById(e3);
            t3 ? e3 = t3 : (BN.warning("[".concat(this.getTrackId(), '] can not find "#').concat(e3, '" element, use document.body')), e3 = document.body);
          }
          BN.debug("[".concat(this.getTrackId(), "] start video playback in ").concat(e3 instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement"), JSON.stringify(t2));
          const i3 = jD(jD(jD({}, this._getDefaultPlayerConfig()), t2), {}, { trackId: this.getTrackId(), element: e3 });
          this._player ? this._player.updateConfig(i3) : (e3 instanceof HTMLVideoElement ? this._player = new IL(i3) : this._player = new AL(i3), this._player.updateVideoTrack(this._mediaStreamTrack)), this._player.play(), this._videoVisibleTimer && window.clearInterval(this._videoVisibleTimer), this._clearPreviousVideoVisibleStatus(), this._videoVisibleTimer = window.setInterval(() => {
            try {
              const e4 = this.getVideoElementVisibleStatus();
              this.safeEmit(RD.VIDEO_ELEMENT_VISIBLE_STATUS, e4);
            } catch (e4) {
            }
          }, dN("CHECK_VIDEO_VISIBLE_INTERVAL"));
        }
        stop() {
          this._player && (this._videoVisibleTimer && (window.clearInterval(this._videoVisibleTimer), this._videoVisibleTimer = null), this._clearPreviousVideoVisibleStatus(), this._player.destroy(), this._player = void 0, BN.debug("[".concat(this.getTrackId(), "] stop video playback")));
        }
        async setEnabled(e3, t2) {
          if (!t2) {
            if (e3 === this._enabled)
              return;
            this.stateCheck("enabled", e3);
          }
          if (BN.info("[".concat(this.getTrackId(), "] start setEnabled"), e3), !e3) {
            this._originMediaStreamTrack.enabled = false;
            try {
              await Yw(this, ED.NEED_DISABLE_TRACK, this);
            } catch (e4) {
              throw BN.error("[".concat(this.getTrackId(), "] setEnabled to false error"), e4.toString()), e4;
            }
            return t2 || (this._enabled = false), void BN.info("[".concat(this.getTrackId(), "] setEnabled to false success"));
          }
          this._originMediaStreamTrack.enabled = true;
          try {
            await Yw(this, ED.NEED_ENABLE_TRACK, this);
          } catch (e4) {
            throw BN.error("[".concat(this.getTrackId(), "] setEnabled to true error"), e4.toString()), e4;
          }
          BN.info("[".concat(this.getTrackId(), "] setEnabled to true success")), t2 || (this._enabled = true);
        }
        async setMuted(e3) {
          e3 !== this._muted && (this.stateCheck("muted", e3), this._muted = e3, this._originMediaStreamTrack.enabled = !e3, BN.debug("[".concat(this.getTrackId(), "] start set muted: ").concat(e3)), e3 ? await Yw(this, ED.NEED_MUTE_TRACK, this) : await Yw(this, ED.NEED_UNMUTE_TRACK, this));
        }
        async setEncoderConfiguration(e3, t2) {
          if (!this._enabled)
            throw new Ew(_w.TRACK_IS_DISABLED, "can not set encoder configuration when track is disabled");
          if (e3 = cD(e3), this._forceBitrateLimit && (e3.bitrateMax = this._forceBitrateLimit.max_bitrate ? this._forceBitrateLimit.max_bitrate : e3.bitrateMax, e3.bitrateMin = this._forceBitrateLimit.min_bitrate ? this._forceBitrateLimit.min_bitrate : e3.bitrateMin), e3.width || e3.height || e3.frameRate) {
            const t3 = yP({ encoderConfig: e3 });
            (Wb() || Yb() || rw()) && (t3.deviceId = void 0), BN.debug("[".concat(this.getTrackId(), "] setEncoderConfiguration applyConstraints"), JSON.stringify(e3), JSON.stringify(t3));
            try {
              await this._originMediaStreamTrack.applyConstraints(t3), this.updateMediaStreamTrackResolution();
            } catch (e4) {
              const t4 = new Ew(_w.UNEXPECTED_ERROR, e4.toString());
              throw BN.error("[".concat(this.getTrackId(), "] applyConstraints error"), t4.toString()), t4;
            }
          }
          this._encoderConfig = e3, -1 === this._hints.indexOf(fD.SCREEN_TRACK) && this.updateBitrateFromProfile();
          try {
            await Yw(this, ED.NEED_UPDATE_VIDEO_ENCODER, this);
          } catch (e4) {
            return e4.throw(BN);
          }
        }
        getStats() {
          iO(() => {
            BN.warning("[deprecated] LocalVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalVideoStats instead");
          }, "localVideoTrackGetStatsWarning");
          return qw(this, ED.GET_STATS) || jD({}, AD);
        }
        async setBeautyEffect(e3) {
          BN.error("LocalVideoTrack.setBeautyEffect was deprecated, please migrate to agora-extension-beauty-effect");
        }
        getCurrentFrameData() {
          return this._player ? this._player.getCurrentFrame() : new ImageData(2, 2);
        }
        async getCurrentFrameImage(e3) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
          return this._player ? this._player.getCurrentFrameToUint8Array(e3, t2) : await NP(e3);
        }
        async setBitrateLimit(e3) {
          BN.debug("[".concat(this.getTrackId(), "] set bitrate limit, ").concat(JSON.stringify(e3))), e3 && (this._forceBitrateLimit = e3, this._encoderConfig && (this._encoderConfig.bitrateMax ? this._encoderConfig.bitrateMax = this._encoderConfig.bitrateMax < e3.max_bitrate ? this._encoderConfig.bitrateMax : e3.max_bitrate : this._encoderConfig.bitrateMax = e3.max_bitrate, this._encoderConfig.bitrateMin, this._encoderConfig.bitrateMin = e3.min_bitrate));
        }
        async setOptimizationMode(e3) {
          if ("motion" !== e3 && "detail" !== e3 && "balanced" !== e3)
            return void BN.error(_w.INVALID_PARAMS, "optimization mode must be motion, detail or balanced");
          const t2 = this._optimizationMode;
          try {
            this._optimizationMode = e3, await Yw(this, ED.NEED_UPDATE_VIDEO_SEND_PARAMETERS, this);
          } catch (e4) {
            throw this._optimizationMode = t2, BN.error("[".concat(this.getTrackId(), "] set optimization mode failed"), e4.toString()), e4;
          }
          BN.info("[".concat(this.getTrackId(), "] set optimization mode success (").concat(e3, ")"));
        }
        setScalabiltyMode(e3) {
          if (1 === e3.numSpatialLayers && 1 !== e3.numTemporalLayers)
            return BN.error(_w.INVALID_PARAMS, "scalability mode currently not supported, no SVC."), void (this._scalabilityMode = { numSpatialLayers: 1, numTemporalLayers: 1 });
          this._scalabilityMode = e3, BN.info("[".concat(this.getTrackId(), "] set scalability mode success (").concat(e3, ")"));
        }
        updateMediaStreamTrackResolution() {
          IP(this._originMediaStreamTrack).then((e3) => {
            let [t2, i3] = e3;
            this._videoHeight = i3, this._videoWidth = t2;
          }).catch(pO);
        }
        _updatePlayerSource() {
          this._player && this._player.updateVideoTrack(this._mediaStreamTrack);
        }
        _getDefaultPlayerConfig() {
          return { fit: "contain" };
        }
        async setSenderConfiguration(e3) {
          if (!this._enabled)
            throw new Ew(_w.TRACK_IS_DISABLED, "can not set encoder configuration when track is disabled");
          BN.debug("[".concat(this.getTrackId(), "] setSenderConfiguration applyConstraints"), JSON.stringify(e3)), e3 = cD(e3), this._forceBitrateLimit && (e3.bitrateMax = this._forceBitrateLimit.max_bitrate ? this._forceBitrateLimit.max_bitrate : e3.bitrateMax, e3.bitrateMin = this._forceBitrateLimit.min_bitrate ? this._forceBitrateLimit.min_bitrate : e3.bitrateMin), this._encoderConfig = e3, -1 === this._hints.indexOf(fD.SCREEN_TRACK) && this.updateBitrateFromProfile();
          try {
            await Yw(this, ED.NEED_UPDATE_VIDEO_ENCODER, this);
          } catch (e4) {
            return e4.throw(BN);
          }
        }
        updateBitrateFromProfile() {
          if (!this._encoderConfig)
            return;
          const { width: e3, height: t2, frameRate: i3 } = this.getMediaStreamTrackSettings();
          if (!e3 || !t2 || !i3)
            return;
          const { bitrateMax: n2, bitrateMin: r2 } = this._encoderConfig;
          if (null == r2 || null == n2) {
            const { max: o2, min: s2 } = function(e4, t3, i4, n3, r3) {
              const o3 = dN("BITRATE_ADAPTER_TYPE");
              if ("DEFAULT_BITRATE" === o3)
                return { min: n3, max: r3 };
              if (void 0 === r3) {
                var s3;
                const a3 = Math.floor(200 * Math.pow(i4 / 15, 0.6) * Math.pow(e4 * t3 / 640 / 360, 0.75));
                r3 = "STANDARD_BITRATE" === o3 ? 4 * a3 : 2 * a3, n3 = null !== (s3 = n3) && void 0 !== s3 ? s3 : a3;
              } else {
                var a2;
                n3 = null !== (a2 = n3) && void 0 !== a2 ? a2 : Math.floor(r3 / 10);
              }
              return { min: n3, max: r3 };
            }(e3, t2, i3, r2, n2);
            this._encoderConfig.bitrateMin = s2, this._encoderConfig.bitrateMax = o2, BN.debug("[".concat(this.getTrackId(), "] update bitrate from profile, [w: ").concat(e3, ", h: ").concat(t2, ", fps: ").concat(i3, "] => [brMax: ").concat(o2, ", brMin: ").concat(s2, "]"));
          }
        }
        getVideoElementVisibleStatus() {
          try {
            var e3, t2;
            const i3 = null == this || null === (e3 = this._player) || void 0 === e3 ? void 0 : e3.getContainerElement(), n2 = { track: this, element: null == this || null === (t2 = this._player) || void 0 === t2 ? void 0 : t2.getVideoElement(), slot: null == i3 ? void 0 : i3.parentElement }, { element: r2, slot: o2 } = n2;
            if (this.isPlaying && r2 instanceof HTMLVideoElement && o2 instanceof HTMLElement) {
              const e4 = Aw.checkOneElementVisible(r2), t3 = Object.assign({}, e4);
              if (t3.visible !== this._previousVideoVisibleStatus) {
                this._previousVideoVisibleStatus = t3.visible;
                const e5 = zN.reportApiInvoke(null, { tag: kw.TRACER, name: Lw.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE, options: [this.getTrackId()] });
                t3.visible ? e5.onSuccess("Video is visible") : e5.onSuccess("Invisible because of ".concat(t3.reason));
              }
              return t3;
            }
            return;
          } catch (e4) {
            throw new Ew(_w.GET_VIDEO_ELEMENT_VISIBLE_ERROR, e4.message);
          }
        }
        async renewMediaStreamTrack(e3) {
        }
        pipe(e3) {
          if (this.processor === e3)
            return e3;
          if (e3._source)
            throw new Ew(_w.INVALID_OPERATION, "Processor ".concat(e3.name, " already piped, please call unpipe beforehand."));
          return this.unpipe(), this.processor = e3, this.processor._source = this, e3.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext }), e3;
        }
        unpipe() {
          if (!this.processor)
            return;
          const e3 = this.processor;
          this.processor._source = void 0, this.processor = void 0, e3.reset();
        }
        close() {
          super.close(), this.unbindProcessorDestinationEvents(), this.unbindProcessorContextEvents(), this.unpipe(), this.processorDestination._source && this.processorDestination._source.unpipe();
        }
        clone(t2) {
          let i3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], n2 = this._encoderConfig;
          t2 && (n2 = jD(jD({}, n2), cD(t2))), n2 = eO(n2);
          const r2 = uO(8, "track-video-cloned-"), o2 = new e2(i3 ? this._mediaStreamTrack.clone() : this._mediaStreamTrack, n2, eO(this._scalabilityMode), this._optimizationMode, r2, eO(this._hints));
          return t2 && n2 && o2.setEncoderConfiguration(n2), BN.debug("clone video track from ".concat(this.getTrackId(), " to ").concat(r2, ", clone ").concat(i3)), o2;
        }
        async replaceTrack(e3, t2) {
          if (!(e3 instanceof MediaStreamTrack))
            throw new Ew(_w.INVALID_PARAMS, "track should be an instance of MediaStreamTrack");
          if ("video" !== e3.kind)
            throw new Ew(_w.INVALID_PARAMS, "track should be a video MediaStreamTrack");
          await this._updateOriginMediaStreamTrack(e3, t2, true), this.updateMediaStreamTrackResolution();
        }
        sendSeiData(e3) {
          if (iO(() => {
            zN.reportApiInvoke(null, { name: Lw.LOCAL_VIDEO_SEND_SEI_DATA, options: [], tag: kw.TRACER }).onSuccess("");
          }, this._mediaStreamTrack.id || this.getTrackId()), !dN("ENABLE_VIDEO_SEI") || !dN("ENABLE_ENCODED_TRANSFORM"))
            return void BN.warning('To send/receive SEI, please call AgoraRTC.setParameter("ENABLE_VIDEO_SEI", true) before instantiate IAgoraRtcClient');
          if (e3 instanceof Uint8Array == 0)
            return new Ew(_w.INVALID_PARAMS, "Invalid argument type, ILocalVideoTrack.sendSeiData() only accept Uint8Array argument.").throw();
          const t2 = this.getRTCRtpTransceiver();
          if (!t2)
            return void BN.warning("Video track is not published, SEI can not be send");
          const i3 = t2.sender.getParameters();
          if (0 === i3.codecs.length)
            return;
          const n2 = i3.codecs[0].mimeType.toLocaleLowerCase();
          "video/h264" === n2 ? this.safeEmit("sei-to-send", e3) : BN.warning("SEI is not supported by ".concat(n2));
        }
        bindProcessorDestinationEvents() {
          this.processorDestination.on(ND.ON_TRACK, async (e3) => {
            e3 ? e3 !== this._mediaStreamTrack && (this._mediaStreamTrack = e3, this._updatePlayerSource(), await Yw(this, ED.NEED_REPLACE_TRACK, this)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await Yw(this, ED.NEED_REPLACE_TRACK, this));
          });
        }
        unbindProcessorDestinationEvents() {
          this.processorDestination.removeAllListeners(ND.ON_TRACK);
        }
        unbindProcessorContextEvents() {
          this.processorContext.removeAllListeners(DD.REQUEST_UPDATE_CONSTRAINTS), this.processorContext.removeAllListeners(DD.REQUEST_CONSTRAINTS);
        }
      }, VD(QL.prototype, "play", [bL, wL], Object.getOwnPropertyDescriptor(QL.prototype, "play"), QL.prototype), VD(QL.prototype, "stop", [OL], Object.getOwnPropertyDescriptor(QL.prototype, "stop"), QL.prototype), VD(QL.prototype, "setEnabled", [NL, DL, PL], Object.getOwnPropertyDescriptor(QL.prototype, "setEnabled"), QL.prototype), VD(QL.prototype, "setMuted", [LL, kL, ML], Object.getOwnPropertyDescriptor(QL.prototype, "setMuted"), QL.prototype), VD(QL.prototype, "setEncoderConfiguration", [UL, xL], Object.getOwnPropertyDescriptor(QL.prototype, "setEncoderConfiguration"), QL.prototype), VD(QL.prototype, "getStats", [VL], Object.getOwnPropertyDescriptor(QL.prototype, "getStats"), QL.prototype), VD(QL.prototype, "setBeautyEffect", [FL, BL], Object.getOwnPropertyDescriptor(QL.prototype, "setBeautyEffect"), QL.prototype), VD(QL.prototype, "getCurrentFrameData", [jL], Object.getOwnPropertyDescriptor(QL.prototype, "getCurrentFrameData"), QL.prototype), VD(QL.prototype, "getCurrentFrameImage", [GL], Object.getOwnPropertyDescriptor(QL.prototype, "getCurrentFrameImage"), QL.prototype), VD(QL.prototype, "setBitrateLimit", [WL], Object.getOwnPropertyDescriptor(QL.prototype, "setBitrateLimit"), QL.prototype), VD(QL.prototype, "setOptimizationMode", [HL], Object.getOwnPropertyDescriptor(QL.prototype, "setOptimizationMode"), QL.prototype), VD(QL.prototype, "setScalabiltyMode", [KL], Object.getOwnPropertyDescriptor(QL.prototype, "setScalabiltyMode"), QL.prototype), VD(QL.prototype, "updateMediaStreamTrackResolution", [YL], Object.getOwnPropertyDescriptor(QL.prototype, "updateMediaStreamTrackResolution"), QL.prototype), VD(QL.prototype, "pipe", [qL], Object.getOwnPropertyDescriptor(QL.prototype, "pipe"), QL.prototype), VD(QL.prototype, "unpipe", [zL], Object.getOwnPropertyDescriptor(QL.prototype, "unpipe"), QL.prototype), VD(QL.prototype, "close", [XL], Object.getOwnPropertyDescriptor(QL.prototype, "close"), QL.prototype), VD(QL.prototype, "replaceTrack", [JL], Object.getOwnPropertyDescriptor(QL.prototype, "replaceTrack"), QL.prototype), QL), ck = (ZL = qN({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), $L = mP(), ek = IO("CameraVideoTrack", "_enabledMutex"), tk = qN({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), ik = mP(), nk = qN({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), rk = mP(), ok2 = qN({ argsMap: (e2) => [e2.getTrackId()] }), sk = class e2 extends ak {
        get __className__() {
          return "CameraVideoTrack";
        }
        constructor(e3, t2, i3, n2, r2, o2) {
          super(e3, cD(t2.encoderConfig), n2, r2, o2), FD(this, "_config", void 0), FD(this, "_originalConstraints", void 0), FD(this, "_constraints", void 0), FD(this, "_enabled", true), FD(this, "_deviceName", "default"), FD(this, "tryResumeVideoForIOS15_16WeChat", async () => {
            (tw() || iw()) && !function() {
              const e4 = xb();
              if (e4.os !== Pb.IOS || !e4.osVersion)
                return false;
              const t3 = e4.osVersion.split(".");
              return 15 === Number(t3[0]) && Number(t3[1]) >= 2;
            }() && ow() && this._enabled && !this._isClosed && (BN.debug("[".concat(this.getTrackId(), "] try capture camera media device for interrupted iOS 15 device on WeChat.")), await this.renewMediaStreamTrack());
          }), this._config = t2, this._originalConstraints = i3, this._constraints = i3, this._deviceName = e3.label, this._encoderConfig = cD(this._config.encoderConfig), YD.on(eD.IOS_15_16_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), YD.on(eD.IOS_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), this.bindProcessorContextEvents();
        }
        async setDevice(e3) {
          return "string" == typeof e3 ? this._setDeviceById(e3) : e3.deviceId ? this._setDeviceById(e3.deviceId) : e3.facingMode ? this._setDeviceByFacingModel(e3.facingMode) : void 0;
        }
        async _setDeviceById(e3) {
          if (BN.info("[".concat(this.getTrackId(), "] set device to ").concat(e3)), this._enabled)
            try {
              const t2 = await lP.getDeviceById(e3), i3 = {};
              i3.video = jD({}, this._constraints), i3.video.deviceId = { exact: e3 }, i3.video.facingMode = void 0, this._originMediaStreamTrack.stop();
              let n2 = null;
              try {
                n2 = await sP(i3, this.getTrackId());
              } catch (e4) {
                throw BN.error("[".concat(this.getTrackId(), "] setDevice failed"), e4.toString()), n2 = await sP({ video: this._constraints }, this.getTrackId()), await this._updateOriginMediaStreamTrack(n2.getVideoTracks()[0], false), e4;
              }
              await this._updateOriginMediaStreamTrack(n2.getVideoTracks()[0], false), this.updateMediaStreamTrackResolution(), this._deviceName = t2.label, this._config.cameraId = e3, this._constraints.deviceId = { exact: e3 };
            } catch (e4) {
              throw BN.error("[".concat(this.getTrackId(), "] setDevice error"), e4.toString()), e4;
            }
          else
            try {
              const t2 = await lP.getDeviceById(e3);
              this._deviceName = t2.label, this._config.cameraId = e3, this._constraints.deviceId = { exact: e3 };
            } catch (e4) {
              throw BN.error("[".concat(this.getTrackId(), "] setDevice error"), e4.toString()), e4;
            }
          BN.info("[".concat(this.getTrackId(), "] setDevice success"));
        }
        async _setDeviceByFacingModel(e3) {
          BN.info("[".concat(this.getTrackId(), "] set facingMode ").concat(e3));
          const t2 = { video: jD(jD({}, this._constraints), {}, { deviceId: void 0, facingMode: { exact: e3 } }) };
          if (this._enabled) {
            this._originMediaStreamTrack.stop();
            let e4 = null;
            try {
              e4 = await sP(t2, this.getTrackId());
            } catch (t3) {
              throw BN.error("[".concat(this.getTrackId(), "] setDeviceByFacingModel failed"), t3.toString()), e4 = await sP({ video: this._constraints }, this.getTrackId()), await this._updateOriginMediaStreamTrack(e4.getVideoTracks()[0], false), t3;
            }
            await this._updateOriginMediaStreamTrack(e4.getVideoTracks()[0], false), this.updateMediaStreamTrackResolution();
          }
          this._deviceName = "", this._config.facingMode = e3, this._config.cameraId = void 0, this._constraints = jD({}, t2.video), BN.info("[".concat(this.getTrackId(), "] setDeviceByFacingModel success"));
        }
        async setEnabled(e3, t2) {
          if (!t2) {
            if (e3 === this._enabled)
              return;
            this.stateCheck("enabled", e3);
          }
          if (BN.info("[".concat(this.getTrackId(), "] start setEnabled"), e3), e3) {
            try {
              if (this.isExternalTrack)
                this._originMediaStreamTrack.enabled = true;
              else {
                const e4 = await sP({ video: this._constraints }, this.getTrackId());
                await this._updateOriginMediaStreamTrack(e4.getVideoTracks()[0], false);
              }
              await Yw(this, ED.NEED_ENABLE_TRACK, this);
            } catch (e4) {
              throw BN.error("[".concat(this.getTrackId(), "] setEnabled true error"), e4.toString()), e4;
            }
            this.updateMediaStreamTrackResolution(), BN.info("[".concat(this.getTrackId(), "] setEnabled to true success")), t2 || (this._enabled = true);
          } else {
            this.isExternalTrack ? this._originMediaStreamTrack.enabled = false : (this._originMediaStreamTrack.onended = null, this._originMediaStreamTrack.stop()), t2 || (this._enabled = false);
            try {
              await Yw(this, ED.NEED_DISABLE_TRACK, this);
            } catch (e4) {
              throw BN.error("[".concat(this.getTrackId(), "] setEnabled to false error"), e4.toString()), e4;
            }
            BN.info("[".concat(this.getTrackId(), "] setEnabled to false success"));
          }
        }
        async setEncoderConfiguration(e3, t2) {
          if (!this._enabled)
            throw new Ew(_w.TRACK_IS_DISABLED, "can not set encoder configuration when track is disabled");
          e3 = cD(e3), this._forceBitrateLimit && (e3.bitrateMax = this._forceBitrateLimit.max_bitrate || e3.bitrateMax, e3.bitrateMin = this._forceBitrateLimit.min_bitrate || e3.bitrateMin);
          const i3 = $w(this._config);
          i3.encoderConfig = e3;
          const n2 = yP(i3);
          (Wb() || Yb() || rw()) && (n2.deviceId = void 0), BN.debug("[".concat(this.getTrackId(), "] setEncoderConfiguration applyConstraints"), JSON.stringify(e3), JSON.stringify(n2));
          try {
            await this._originMediaStreamTrack.applyConstraints(n2), this.updateMediaStreamTrackResolution();
          } catch (e4) {
            const t3 = new Ew(_w.UNEXPECTED_ERROR, e4.toString());
            throw BN.error("[".concat(this.getTrackId(), "] applyConstraints error"), t3.toString()), t3;
          }
          this._config = i3, this._constraints = n2, this._originalConstraints = n2, this._encoderConfig = e3, -1 === this._hints.indexOf(fD.SCREEN_TRACK) && this.updateBitrateFromProfile();
          try {
            await Yw(this, ED.NEED_UPDATE_VIDEO_ENCODER, this);
          } catch (e4) {
            return e4.throw(BN);
          }
        }
        _getDefaultPlayerConfig() {
          return { mirror: true, fit: "cover" };
        }
        onTrackEnded() {
          if ((Yb() || rw()) && this._enabled && !this._isClosed && YD.duringInterruption) {
            const e3 = async () => {
              YD.off(eD.IOS_INTERRUPTION_END, e3), this._enabled && !this._isClosed && (BN.debug("[".concat(this.getTrackId(), "] try capture camera media device for interrupted iOS device.")), await this.setEnabled(false), await this.setEnabled(true));
            };
            YD.on(eD.IOS_INTERRUPTION_END, e3);
          } else
            BN.debug("[".concat(this.getTrackId(), "] track ended")), this.safeEmit(RD.TRACK_ENDED);
        }
        async renewMediaStreamTrack(e3) {
          const t2 = e3 || this._constraints, i3 = lP.searchDeviceIdByName(this._deviceName);
          if (i3 && !t2.deviceId && (t2.deviceId = { exact: i3 }), this._enabled) {
            const e4 = await sP({ video: t2 }, this.getTrackId());
            this._constraints = t2, await this._updateOriginMediaStreamTrack(e4.getVideoTracks()[0], true), this.updateMediaStreamTrackResolution();
          }
        }
        close() {
          super.close(), YD.off(eD.IOS_15_16_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), YD.off(eD.IOS_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat);
        }
        clone(t2) {
          let i3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], n2 = this._encoderConfig;
          t2 && (n2 = jD(jD({}, n2), cD(t2))), n2 = eO(n2);
          const r2 = uO(8, "track-cam-cloned-"), o2 = new e2(i3 ? this._mediaStreamTrack.clone() : this._mediaStreamTrack, eO(jD(jD({}, this._config), {}, { encoderConfig: n2 })), eO(this._constraints), eO(this._scalabilityMode), this._optimizationMode, r2);
          return t2 && n2 && o2.setEncoderConfiguration(n2), BN.debug("clone track from ".concat(this.getTrackId(), " to ").concat(r2, ", clone ").concat(i3)), o2;
        }
        bindProcessorContextEvents() {
          this.processorContext.on(DD.REQUEST_UPDATE_CONSTRAINTS, async (e3, t2, i3) => {
            try {
              const i4 = Object.assign({}, this._originalConstraints, ...e3);
              await this.renewMediaStreamTrack(i4), t2();
            } catch (e4) {
              i3(e4);
            }
          }), this.processorContext.on(DD.REQUEST_CONSTRAINTS, async (e3) => {
            e3(this._originMediaStreamTrack.getSettings());
          });
        }
      }, VD(sk.prototype, "setDevice", [ZL, $L], Object.getOwnPropertyDescriptor(sk.prototype, "setDevice"), sk.prototype), VD(sk.prototype, "setEnabled", [ek, tk, ik], Object.getOwnPropertyDescriptor(sk.prototype, "setEnabled"), sk.prototype), VD(sk.prototype, "setEncoderConfiguration", [nk, rk], Object.getOwnPropertyDescriptor(sk.prototype, "setEncoderConfiguration"), sk.prototype), VD(sk.prototype, "close", [ok2], Object.getOwnPropertyDescriptor(sk.prototype, "close"), sk.prototype), sk);
      function dk(e2, t2, i3, n2) {
        i3.optimizationMode && (n2 && n2.width && n2.height ? (i3.encoderConfig = jD(jD({}, n2), {}, { bitrateMin: n2.bitrateMin, bitrateMax: n2.bitrateMax }), "motion" !== i3.optimizationMode && "detail" !== i3.optimizationMode || (t2.contentHint = i3.optimizationMode, t2.contentHint === i3.optimizationMode ? BN.debug("[".concat(e2, "] set content hint to"), i3.optimizationMode) : BN.debug("[".concat(e2, "] set content hint failed")))) : BN.warning("[".concat(e2, "] can not apply optimization mode bitrate config, no encoderConfig")));
      }
      var lk, uk, hk, pk, _k2, Ek, fk, mk, Tk, Sk, gk, Rk;
      class Ck extends GD {
        getUserId() {
          return this._userId;
        }
        constructor(e2, t2, i3, n2) {
          super(e2, "track-".concat(e2.kind, "-").concat(t2, "-").concat(n2.clientId, "_").concat(uO(5, ""))), FD(this, "_userId", void 0), FD(this, "_uintId", void 0), FD(this, "_isDestroyed", false), FD(this, "store", void 0), FD(this, "processor", void 0), FD(this, "processorContext", void 0), this._userId = t2, this._uintId = i3, this.store = n2;
        }
        _updateOriginMediaStreamTrack(e2) {
          this._originMediaStreamTrack = e2, this._mediaStreamTrack = e2, this._updatePlayerSource(), this.processor && this.processor.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext });
        }
        _destroy() {
          this._isDestroyed = true, BN.info("[".concat(this.getTrackId(), "] is destroyed")), this.stop(), super.close();
        }
        getProcessorStats() {
          return this.processorContext.gatherStats();
        }
        getProcessorUsage() {
          return this.processorContext.gatherUsage();
        }
      }
      let vk = (lk = qN({ argsMap: (e2, t2, i3) => [e2.getTrackId(), "string" == typeof t2 ? t2 : t2 instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement", i3] }), uk = qN({ argsMap: (e2) => [e2.getTrackId()] }), hk = qN({ argsMap: (e2, t2) => [e2.getTrackId(), t2.name] }), pk = qN({ argsMap: (e2) => [e2.getTrackId()] }), VD((_k2 = class extends Ck {
        get isPlaying() {
          return !(!this._player || this._player.videoElementStatus !== kD.PLAYING);
        }
        get __className__() {
          return "RemoteVideoTrack";
        }
        constructor(e2, t2, i3, n2) {
          super(e2, t2, i3, n2), FD(this, "_videoVisibleTimer", null), FD(this, "_previousVideoVisibleStatus", void 0), FD(this, "_clearPreviousVideoVisibleStatus", () => this._previousVideoVisibleStatus = void 0), FD(this, "trackMediaType", vD.VIDEO), FD(this, "_videoWidth", void 0), FD(this, "_videoHeight", void 0), FD(this, "_player", void 0), FD(this, "processorDestination", void 0), FD(this, "processorContext", void 0), this.updateMediaStreamTrackResolution(), this.processorContext = new SP(this.getTrackId(), "remote"), this.processorDestination = new TP(this.processorContext), this.bindProcessorDestinationEvents();
        }
        getStats() {
          return iO(() => {
            BN.warning("[deprecated] RemoteVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteVideoStats instead");
          }, "remoteVideoTrackGetStatsWarning"), qw(this, ED.GET_STATS) || jD({}, OD);
        }
        play(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          if ("string" == typeof e2) {
            const t3 = document.getElementById(e2);
            t3 ? e2 = t3 : (BN.warning("[".concat(this.getTrackId(), '] can not find "#').concat(e2, '" element, use document.body')), e2 = document.body);
          }
          BN.debug("[".concat(this.getTrackId(), "] start video playback in ").concat(e2 instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement"), JSON.stringify(t2));
          const i3 = jD(jD({ fit: "cover" }, t2), {}, { trackId: this.getTrackId(), element: e2 });
          this._player ? this._player.updateConfig(i3) : (e2 instanceof HTMLVideoElement ? this._player = new IL(i3) : this._player = new AL(i3), this._player.updateVideoTrack(this._mediaStreamTrack), this._player.onFirstVideoFrameDecoded = () => {
            this.store.subscribe(this.getUserId(), "video", void 0, void 0, Date.now()), this.safeEmit(CD.FIRST_FRAME_DECODED);
          }, this._player.onVideoStateChanged = (e3) => {
            this.safeEmit(CD.VIDEO_STATE_CHANGED, e3);
          }), this._player.play(this.store.sessionId || void 0), this._videoVisibleTimer && window.clearInterval(this._videoVisibleTimer), this._clearPreviousVideoVisibleStatus(), this._videoVisibleTimer = window.setInterval(() => {
            try {
              const e3 = this.getVideoElementVisibleStatus();
              this.safeEmit(CD.VIDEO_ELEMENT_VISIBLE_STATUS, e3);
            } catch (e3) {
            }
          }, dN("CHECK_VIDEO_VISIBLE_INTERVAL"));
        }
        stop() {
          this._player && (this._videoVisibleTimer && (window.clearInterval(this._videoVisibleTimer), this._videoVisibleTimer = null), this._clearPreviousVideoVisibleStatus(), this._player.destroy(), this._player = void 0, BN.debug("[".concat(this.getTrackId(), "] stop video playback")));
        }
        getCurrentFrameData() {
          return this._player ? this._player.getCurrentFrame() : new ImageData(2, 2);
        }
        updateMediaStreamTrackResolution() {
          IP(this._originMediaStreamTrack).then((e2) => {
            let [t2, i3] = e2;
            this._videoHeight = i3, this._videoWidth = t2;
          }).catch(pO);
        }
        _updatePlayerSource() {
          BN.debug("[".concat(this.getTrackId(), "] update player source track")), this._player && this._player.updateVideoTrack(this._mediaStreamTrack);
        }
        getVideoElementVisibleStatus() {
          try {
            var e2, t2;
            const i3 = null == this || null === (e2 = this._player) || void 0 === e2 ? void 0 : e2.getContainerElement(), n2 = { track: this, element: null == this || null === (t2 = this._player) || void 0 === t2 ? void 0 : t2.getVideoElement(), slot: null == i3 ? void 0 : i3.parentElement }, { element: r2, slot: o2 } = n2;
            if (this.isPlaying && r2 instanceof HTMLVideoElement && o2 instanceof HTMLElement) {
              const e3 = Aw.checkOneElementVisible(r2), t3 = Object.assign({}, e3);
              if (t3.visible !== this._previousVideoVisibleStatus) {
                this._previousVideoVisibleStatus = t3.visible;
                const e4 = zN.reportApiInvoke(null, { tag: kw.TRACER, name: Lw.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE, options: [this.getTrackId()] });
                t3.visible ? e4.onSuccess("Video is visible") : e4.onSuccess("Invisible because of ".concat(t3.reason));
              }
              return t3;
            }
            return;
          } catch (e3) {
            throw new Ew(_w.GET_VIDEO_ELEMENT_VISIBLE_ERROR, e3.message);
          }
        }
        pipe(e2) {
          if (this.processor === e2)
            return e2;
          if (e2._source)
            throw new Ew(_w.INVALID_OPERATION, "Processor ".concat(e2.name, " already piped, please call unpipe beforehand."));
          return this.unpipe(), this.processor = e2, this.processor._source = this, e2.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext }), e2;
        }
        unpipe() {
          if (!this.processor)
            return;
          const e2 = this.processor;
          this.processor._source = void 0, this.processor = void 0, e2.reset();
        }
        bindProcessorDestinationEvents() {
          this.processorDestination.on(ND.ON_TRACK, async (e2) => {
            e2 ? e2 !== this._mediaStreamTrack && (this._mediaStreamTrack = e2, this._updatePlayerSource()) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource());
          });
        }
        unbindProcessorDestinationEvents() {
          this.processorDestination.removeAllListeners(ND.ON_TRACK);
        }
        _destroy() {
          super._destroy(), this.unbindProcessorDestinationEvents();
        }
        _onSei(e2) {
          this.emit(gD.SEI_RECEIVED, e2);
        }
      }).prototype, "play", [lk], Object.getOwnPropertyDescriptor(_k2.prototype, "play"), _k2.prototype), VD(_k2.prototype, "stop", [uk], Object.getOwnPropertyDescriptor(_k2.prototype, "stop"), _k2.prototype), VD(_k2.prototype, "pipe", [hk], Object.getOwnPropertyDescriptor(_k2.prototype, "pipe"), _k2.prototype), VD(_k2.prototype, "unpipe", [pk], Object.getOwnPropertyDescriptor(_k2.prototype, "unpipe"), _k2.prototype), _k2), Ik = (Ek = qN({ argsMap: (e2, t2) => [e2.getTrackId(), t2], throttleTime: 300 }), fk = qN({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), mk = qN({ argsMap: (e2) => [e2.getTrackId()] }), Tk = qN({ argsMap: (e2) => [e2.getTrackId()] }), Sk = qN({ argsMap: (e2, t2) => [e2.getTrackId(), t2.name] }), gk = qN({ argsMap: (e2) => [e2.getTrackId()] }), VD((Rk = class extends Ck {
        get isPlaying() {
          return this._useAudioElement ? fP.isPlaying(this.getTrackId()) : this._source.isPlayed;
        }
        get __className__() {
          return "RemoteAudioTrack";
        }
        constructor(e2, t2, i3, n2) {
          super(e2, t2, i3, n2), FD(this, "trackMediaType", vD.AUDIO), FD(this, "_source", void 0), FD(this, "_useAudioElement", true), FD(this, "_volume", 100), FD(this, "processorContext", void 0), FD(this, "processorDestination", void 0), FD(this, "_played", false), FD(this, "_bypassWebAudio", false), dN("DISABLE_WEBAUDIO") ? (this._source = new CP(), this._bypassWebAudio = true, this._useAudioElement = true) : (this._source = new $D(e2, true), dN("REMOTE_AUDIO_TRACK_USES_WEB_AUDIO") && (this._useAudioElement = false)), this._source.once(ID.RECEIVE_TRACK_BUFFER, () => {
            this.safeEmit(CD.FIRST_FRAME_DECODED);
          }), this.processorContext = new RP(this._source.context, this.getTrackId(), "remote"), this.processorDestination = new gP(this.processorContext), this.bindProcessorDestinationEvents(), this._source.on(ID.UPDATE_SOURCE, () => {
            this.processor && this.processor.updateInput({ node: this._source.processSourceNode, context: this.processorContext });
          });
        }
        setAudioFrameCallback(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4096;
          if (!e2)
            return this._source.removeAllListeners(ID.ON_AUDIO_BUFFER), void this._source.stopGetAudioBuffer();
          this._source.startGetAudioBuffer(t2), this._source.removeAllListeners(ID.ON_AUDIO_BUFFER), this._source.on(ID.ON_AUDIO_BUFFER, (t3) => e2(t3));
        }
        setVolume(e2) {
          this._volume = e2, this._useAudioElement ? fP.setVolume(this.getTrackId(), e2) : this._source.setVolume(e2 / 100);
        }
        async setPlaybackDevice(e2) {
          if (!this._useAudioElement || !ZN())
            throw new Ew(_w.NOT_SUPPORTED, "your browser does not support setting the audio output device");
          await fP.setSinkID(this.getTrackId(), e2);
        }
        getVolumeLevel() {
          return this._source.getAccurateVolumeLevel();
        }
        getStats() {
          return iO(() => {
            BN.warning("[deprecated] RemoteAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteAudioStats instead");
          }, "remoteAudioTrackGetStatsWarning"), qw(this, ED.GET_STATS) || jD({}, bD);
        }
        play() {
          BN.debug("[".concat(this.getTrackId(), "] start audio playback")), this._played = true, this._useAudioElement ? (BN.debug("[".concat(this.getTrackId(), "] use audio element to play")), fP.play(this._mediaStreamTrack, this.getTrackId(), this._volume, this.store.sessionId || void 0)) : this._source.play();
        }
        stop() {
          BN.debug("[".concat(this.getTrackId(), "] stop audio playback")), this._played = false, this._useAudioElement ? fP.stop(this.getTrackId()) : this._source.stop();
        }
        _destroy() {
          super._destroy(), this._played = false, this.unbindProcessorDestinationEvents(), this._source.destroy();
        }
        _isFreeze() {
          return this._source.isFreeze;
        }
        _updatePlayerSource() {
          let e2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
          BN.debug("[".concat(this.getTrackId(), "] update player source track")), e2 && this._source.updateTrack(this._mediaStreamTrack), this._useAudioElement && fP.updateTrack(this.getTrackId(), this._mediaStreamTrack);
        }
        pipe(e2) {
          if (this._bypassWebAudio)
            throw new Ew(_w.NOT_SUPPORTED, "can not pipe extension when WebAudio disabled");
          if (this.processor === e2)
            return e2;
          if (e2._source)
            throw new Ew(_w.INVALID_OPERATION, "Processor ".concat(e2.name, " already piped, please call unpipe beforehand."));
          return this.unpipe(), this.processor = e2, this.processor._source = this, e2.updateInput({ track: this._originMediaStreamTrack, node: this._source.processSourceNode, context: this.processorContext }), e2;
        }
        unpipe() {
          var e2;
          if (this._bypassWebAudio)
            throw new Ew(_w.NOT_SUPPORTED, "can not unpipe extension when WebAudio disabled");
          if (!this.processor)
            return;
          const t2 = this.processor;
          null === (e2 = this._source.processSourceNode) || void 0 === e2 || e2.disconnect(), this.processor._source = false, this.processor = void 0, t2.reset();
        }
        bindProcessorDestinationEvents() {
          this.processorDestination.on(ND.ON_TRACK, async (e2) => {
            e2 ? e2 !== this._mediaStreamTrack && (this._mediaStreamTrack = e2, this._updatePlayerSource(false), this._source.processedNode = this._source.createMediaStreamSourceNode(e2)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource());
          }), this.processorDestination.on(ND.ON_NODE, (e2) => {
            this._source.processedNode = e2;
            const t2 = !e2;
            this._useAudioElement !== t2 && (this._played ? (this.stop(), this._useAudioElement = t2, this.play()) : this._useAudioElement = t2);
          });
        }
        unbindProcessorDestinationEvents() {
          this.processorDestination.removeAllListeners(ND.ON_TRACK), this.processorDestination.removeAllListeners(ND.ON_NODE);
        }
      }).prototype, "setVolume", [Ek], Object.getOwnPropertyDescriptor(Rk.prototype, "setVolume"), Rk.prototype), VD(Rk.prototype, "setPlaybackDevice", [fk], Object.getOwnPropertyDescriptor(Rk.prototype, "setPlaybackDevice"), Rk.prototype), VD(Rk.prototype, "play", [mk], Object.getOwnPropertyDescriptor(Rk.prototype, "play"), Rk.prototype), VD(Rk.prototype, "stop", [Tk], Object.getOwnPropertyDescriptor(Rk.prototype, "stop"), Rk.prototype), VD(Rk.prototype, "pipe", [Sk], Object.getOwnPropertyDescriptor(Rk.prototype, "pipe"), Rk.prototype), VD(Rk.prototype, "unpipe", [gk], Object.getOwnPropertyDescriptor(Rk.prototype, "unpipe"), Rk.prototype), Rk);
      const yk = new class extends Nw {
        get visibility() {
          return document.visibilityState;
        }
        get lastHiddenTime() {
          return this._lastHiddenTime;
        }
        get lastVisibleTime() {
          return this._lastVisibleTime;
        }
        constructor() {
          super(), FD(this, "_lastHiddenTime", 0), FD(this, "_lastVisibleTime", 0), document.addEventListener("visibilitychange", () => {
            "hidden" === document.visibilityState ? this._lastHiddenTime = performance.now() : this._lastVisibleTime = performance.now(), BN.debug("current web page is ".concat(document.visibilityState)), this.emit("VISIBILITY_CHANGE", document.visibilityState);
          });
        }
      }();
      class Ak extends Nw {
        constructor(e2, t2) {
          super(), FD(this, "trackMediaType", vD.DATA), FD(this, "_version", 1), FD(this, "_type", 3), FD(this, "_config", void 0), FD(this, "_originDataChannel", void 0), FD(this, "_dataStreamPacketHeader", new ArrayBuffer(4)), FD(this, "_dataStreamPacketHandler", { serialize: (e3) => e3, deserialize: (e3) => e3 }), FD(this, "_datachannelEventMap", /* @__PURE__ */ new Map()), this._config = e2, t2 && (this._originDataChannel = t2, this._bandDataChannelEvents(t2)), this._initPacketHeader();
        }
        useDataStream(e2) {
          this._dataStreamPacketHandler = e2;
        }
        get id() {
          return this._config.id;
        }
        get ordered() {
          return this._config.ordered;
        }
        get maxRetransmits() {
          return dN("DATASTREAM_MAX_RETRANSMITS");
        }
        get metadata() {
          return this._config.metadata;
        }
        get readyState() {
          var e2, t2;
          return null !== (e2 = null === (t2 = this._originDataChannel) || void 0 === t2 ? void 0 : t2.readyState) && void 0 !== e2 ? e2 : "connecting";
        }
        get _originDataChannelId() {
          var e2, t2;
          return null !== (e2 = null === (t2 = this._originDataChannel) || void 0 === t2 ? void 0 : t2.id) && void 0 !== e2 ? e2 : null;
        }
        getChannelId() {
          return this.id;
        }
        getConfig() {
          return this._config;
        }
        _close() {
          this._originDataChannel && (this._unbindDataChannelEvents(this._originDataChannel), this._originDataChannel = void 0);
        }
        async _waitTillOpen() {
          return new Wh((e2, t2) => {
            if (this._originDataChannel) {
              "open" === this._originDataChannel.readyState && e2();
              const i3 = setTimeout(() => {
                var e3;
                t2(new Ew(_w.DATACHANNEL_CONNECTION_TIMEOUT, "Cannot create datachannel, id: ".concat(null === (e3 = this._originDataChannel) || void 0 === e3 ? void 0 : e3.id)));
              }, 1e4);
              this._originDataChannel.onopen = () => {
                clearTimeout(i3), this._originDataChannel && this._bandDataChannelEvents(this._originDataChannel), e2();
              }, this._originDataChannel.onerror = () => {
                throw clearTimeout(i3), new Ew(_w.DATACHANNEL_CONNECTION_TIMEOUT);
              };
            } else
              t2(new Ew(_w.DATACHANNEL_CONNECTION_TIMEOUT, "cannot find dataChannel"));
          });
        }
        _updateOriginDataChannel(e2) {
          this._originDataChannel = e2, this._bandDataChannelEvents(e2);
        }
        _initPacketHeader() {
          const e2 = new DataView(this._dataStreamPacketHeader);
          e2.setUint16(0, this._version), e2.setUint8(2, this._type), e2.setUint8(3, this._config.id);
        }
        _bandDataChannelEvents(e2) {
          this._unbindDataChannelEvents(e2), [xD.OPEN, xD.CLOSE, xD.ERROR].forEach((t2) => {
            const i3 = () => {
              this.emit(t2);
            };
            this._datachannelEventMap.set(t2, i3), e2.addEventListener(t2, i3);
          });
        }
        _unbindDataChannelEvents(e2) {
          Array.from(this._datachannelEventMap.entries()).forEach((t2) => {
            let [i3, n2] = t2;
            e2.removeEventListener(i3, n2);
          }), this._datachannelEventMap.clear();
        }
      }
      class bk extends Ak {
        constructor(e2) {
          super(e2), FD(this, "_messageListener", void 0), this._messageListener = (e3) => {
            if (e3.data.byteLength < this._dataStreamPacketHeader.byteLength)
              throw Error("invalid byteLength: the byte length must exceed " + this._dataStreamPacketHeader.byteLength);
            const t2 = e3.data.slice(0, this._dataStreamPacketHeader.byteLength), i3 = new DataView(t2).getUint8(3);
            if (i3 !== this.id)
              return void (dN("SHOW_DATASTREAM2_LOG") && BN.debug("invalid datachannel id: ".concat(i3, " !== ").concat(this.id)));
            let n2 = e3.data.slice(this._dataStreamPacketHeader.byteLength);
            n2 = this._dataStreamPacketHandler.deserialize(n2), this.emit(xD.MESSAGE, n2);
          };
        }
        _updateOriginDataChannel(e2) {
          super._updateOriginDataChannel(e2), this._bandRemoteDataChannelEvents();
        }
        _close() {
          this._originDataChannel && (this._originDataChannel.removeEventListener("message", this._messageListener), super._close());
        }
        _bandRemoteDataChannelEvents() {
          this._originDataChannel && this._originDataChannel.addEventListener("message", this._messageListener);
        }
      }
      class wk extends Ak {
        send(e2) {
          if (this._originDataChannel) {
            let t2 = e2;
            t2 = this._dataStreamPacketHandler.serialize(e2);
            const i3 = new Uint8Array(this._dataStreamPacketHeader.byteLength + t2.byteLength);
            i3.set(new Uint8Array(this._dataStreamPacketHeader), 0), i3.set(new Uint8Array(t2), this._dataStreamPacketHeader.byteLength), this._originDataChannel.send(i3.buffer);
          }
        }
      }
      function Ok2() {
        const e2 = new Blob([atob("ZnVuY3Rpb24gZShlLHQsbil7bGV0IHI9bmV3IFVpbnQ4QXJyYXkoZSx0LG4pLGE9W10sbz0wO2Zvcig7YS5sZW5ndGg8bjspbyszPG4mJjA9PT1yW29dJiYwPT09cltvKzFdJiYzPT09cltvKzJdJiYoMD09PXJbbyszXXx8MT09PXJbbyszXXx8Mj09PXJbbyszXXx8Mz09PXJbbyszXSk/KGEucHVzaChyW29dLHJbbysxXSxyW28rM10pLG8rPTQpOihhLnB1c2gocltvXSksbysrKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYSl9ZnVuY3Rpb24gdChlLHQpe2NvbnN0IG49ZnVuY3Rpb24oZSl7Y29uc3QgdD1lLmxlbmd0aDtsZXQgbj1bXSxyPTA7Zm9yKDtyPHQ7KXIrMjx0JiYwPT09ZVtyXSYmMD09PWVbcisxXSYmKDA9PT1lW3IrMl18fDE9PT1lW3IrMl18fDI9PT1lW3IrMl18fDM9PT1lW3IrMl0pPyhuLnB1c2goZVtyXSxlW3IrMV0sMyxlW3IrMl0pLHIrPTMpOihuLnB1c2goZVtyXSkscisrKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkobil9KHQpLHI9bi5sZW5ndGgsYT1NYXRoLmZsb29yKHIvMjU1KSxvPXIlMjU1LHM9bmV3IFVpbnQ4QXJyYXkoNithKzErcitlLmJ5dGVMZW5ndGgpO3NbMF09MCxzWzFdPTAsc1syXT0wLHNbM109MSxzWzRdPTYsc1s1XT0xMDE7bGV0IGk9MDtmb3IoO2k8YTspc1s2K2ldPTI1NSxpKys7cmV0dXJuIHNbNitpXT1vLGkrKyxzLnNldChuLDYraSkscy5zZXQobmV3IFVpbnQ4QXJyYXkoZSksNitpK3IpLHMuYnVmZmVyfW5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZigiU2FmYXJpIik+LTEmJi0xPT09bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCJDaHJvbWUiKSYmKHNlbGYub25ydGN0cmFuc2Zvcm09bj0+e2NvbnN0IHI9bi50cmFuc2Zvcm1lcjtsZXQgYT1bXTtyLm9wdGlvbnMucG9ydC5vbm1lc3NhZ2U9ZT0+e2UuZGF0YS5zZWkmJmEucHVzaChlLmRhdGEuc2VpKX0sc2VsZi5wb3N0TWVzc2FnZSgic3RhcnRlZCIpO2NvbnN0IG89ci5yZWFkYWJsZS5nZXRSZWFkZXIoKSxzPXIud3JpdGFibGUuZ2V0V3JpdGVyKCk7InJ4Ij09PXIub3B0aW9ucy5uYW1lP2Z1bmN0aW9uIHQobil7by5yZWFkKCkudGhlbigocj0+e2lmKCFyLmRvbmUpe2lmKHIudmFsdWUgaW5zdGFuY2VvZiBSVENFbmNvZGVkVmlkZW9GcmFtZSl7Y29uc3QgdD1mdW5jdGlvbih0KXtjb25zdCBuPW5ldyBEYXRhVmlldyh0LmRhdGEpO2xldCByPTA7Zm9yKDtyKzQ8dC5kYXRhLmJ5dGVMZW5ndGg7KXtpZigwPT09bi5nZXRVaW50OChyKzApJiYwPT09bi5nZXRVaW50OChyKzEpJiYwPT09bi5nZXRVaW50OChyKzIpJiYxPT09bi5nZXRVaW50OChyKzMpJiY2PT09bi5nZXRVaW50OChyKzQpKXtsZXQgYT1yKzYsbz0wLHM9MDtmb3IoOzI1NT09PShzPW4uZ2V0VWludDgoYSsrKSk7KW8rPTI1NTtvKz1zO2NvbnN0IGk9ZSh0LmRhdGEsYSxvKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaSl9cisrfXJldHVybiBudWxsfShyLnZhbHVlKTt0JiZuLm9wdGlvbnMucG9ydC5wb3N0TWVzc2FnZSh7c2VpOnR9KX1zLndyaXRlKHIudmFsdWUpLG4ub3B0aW9ucy5wb3J0LnBvc3RNZXNzYWdlKHt0cmFuc2Zvcm1lZDohMH0pLHQobil9fSkpfShyKToidHgiPT09ci5vcHRpb25zLm5hbWUmJmZ1bmN0aW9uIGUobil7by5yZWFkKCkudGhlbigocj0+e2lmKCFyLmRvbmUpe2lmKHIudmFsdWUgaW5zdGFuY2VvZiBSVENFbmNvZGVkVmlkZW9GcmFtZSl7Y29uc3QgZT1hLnNoaWZ0KCk7ZSYmKHIudmFsdWUuZGF0YT10KHIudmFsdWUuZGF0YSxlKSl9cy53cml0ZShyLnZhbHVlKSxuLm9wdGlvbnMucG9ydC5wb3N0TWVzc2FnZSh7dHJhbnNmb3JtZWQ6ITB9KSxlKG4pfX0pKX0ocil9LHNlbGYucG9zdE1lc3NhZ2UoInJlZ2lzdGVyZWQiKSk7Cg==")], { type: "text/javascript" });
        return setTimeout(() => Tm.revokeObjectURL(e2), 0), new Worker(Tm.createObjectURL(e2));
      }
      const Nk = /* @__PURE__ */ new Map();
      const Dk = /* @__PURE__ */ new Map();
      async function Pk(e2) {
        if (!QN().supportWebRTCEncodedTransform)
          return void BN.warning("browser not support audio encoded transform");
        if (Dk.has(e2))
          return;
        const t2 = { track: e2.track };
        if (Gb()) {
          if (!e2.createEncodedStreams)
            return void BN.warning("browser not support createEncodedStreams() API");
          let n2 = null;
          try {
            n2 = e2.createEncodedStreams();
          } catch (e3) {
            return void BN.error("create audio-encoded-streams error", e3 && e3.message);
          }
          const r2 = new TransformStream({ transform(n3, r3) {
            t2.controller || (t2.controller = r3), e2.track && e2.track.id !== t2.track.id && (BN.debug("audio track changed: ".concat(t2.track.id, " => ").concat(e2.track.id)), t2.track.removeEventListener("ended", i3), t2.track = e2.track, t2.track.addEventListener("ended", i3)), r3.enqueue(n3);
          } });
          n2.readable.pipeThrough(r2).pipeTo(n2.writable);
        } else if (Wb()) {
          if ("undefined" == typeof RTCRtpScriptTransform)
            return void BN.warning("browser not support RTCRtpScriptTransform");
          const n2 = Ok2(), r2 = new MessageChannel();
          await new Wh((e3) => n2.onmessage = (t3) => {
            "registered" === t3.data && e3(void 0);
          });
          const o2 = new RTCRtpScriptTransform(n2, { name: "rx", port: r2.port2 }, [r2.port2]);
          e2.transform = o2, await new Wh((e3) => n2.onmessage = (t3) => {
            "started" === t3.data && e3(void 0);
          }), r2.port1.onmessage = (n3) => {
            var r3;
            n3.data.transformed && e2.track && (null === (r3 = e2.track) || void 0 === r3 ? void 0 : r3.id) !== t2.track.id && (BN.debug("audio track changed: ".concat(t2.track.id, " => ").concat(e2.track.id)), t2.track.removeEventListener("ended", i3), t2.track = e2.track, t2.track.addEventListener("ended", i3));
          }, t2.worker = n2;
        }
        function i3() {
          e2.track.removeEventListener("ended", i3), function(e3) {
            const t3 = Dk.get(e3);
            if (t3) {
              Dk.delete(e3);
              try {
                var i4, n2;
                null === (i4 = t3.controller) || void 0 === i4 || i4.terminate(), null === (n2 = t3.worker) || void 0 === n2 || n2.terminate();
              } catch (e4) {
                BN.warning(e4 && e4.message);
              }
            }
          }(e2);
        }
        Dk.set(e2, t2), e2.track.addEventListener("ended", i3);
      }
      function Lk(e2, t2, i3) {
        let n2 = new Uint8Array(e2, t2, i3), r2 = [], o2 = 0;
        for (; r2.length < i3; )
          o2 + 3 < i3 && 0 === n2[o2] && 0 === n2[o2 + 1] && 3 === n2[o2 + 2] && (0 === n2[o2 + 3] || 1 === n2[o2 + 3] || 2 === n2[o2 + 3] || 3 === n2[o2 + 3]) ? (r2.push(n2[o2], n2[o2 + 1], n2[o2 + 3]), o2 += 4) : (r2.push(n2[o2]), o2++);
        return new Uint8Array(r2);
      }
      const kk = /* @__PURE__ */ new Map();
      async function Mk(e2, t2) {
        if (!QN().supportWebRTCEncodedTransform)
          return void BN.warning("browser not support video encoded transform");
        if (kk.has(e2))
          return;
        if (!e2.track)
          return;
        const i3 = { track: e2.track };
        if (Gb()) {
          if (!e2.createEncodedStreams)
            return void BN.warning("browser not support createEncodedStreams() API");
          let r2 = null;
          try {
            r2 = e2.createEncodedStreams();
          } catch (e3) {
            return void BN.error("create video-encoded-streams error", e3 && e3.message);
          }
          let o2 = [];
          t2.on("sei-to-send", (e3) => {
            o2.push(e3);
          });
          const s2 = new TransformStream({ transform(t3, r3) {
            i3.controller || (i3.controller = r3), e2.track && e2.track.id !== i3.track.id && (BN.debug("video track changed: ".concat(i3.track.id, " => ").concat(e2.track.id)), i3.track.removeEventListener("ended", n2), i3.track = e2.track, i3.track.addEventListener("ended", n2));
            const s3 = o2.shift();
            s3 && (t3.data = function(e3, t4) {
              const i4 = function(e4) {
                const t5 = e4.length;
                let i5 = [], n4 = 0;
                for (; n4 < t5; )
                  n4 + 2 < t5 && 0 === e4[n4] && 0 === e4[n4 + 1] && (0 === e4[n4 + 2] || 1 === e4[n4 + 2] || 2 === e4[n4 + 2] || 3 === e4[n4 + 2]) ? (i5.push(e4[n4], e4[n4 + 1], 3, e4[n4 + 2]), n4 += 3) : (i5.push(e4[n4]), n4++);
                return new Uint8Array(i5);
              }(t4), n3 = i4.length, r4 = Math.floor(n3 / 255), o3 = n3 % 255, s4 = new Uint8Array(6 + r4 + 1 + n3 + e3.byteLength);
              s4[0] = 0, s4[1] = 0, s4[2] = 0, s4[3] = 1, s4[4] = 6, s4[5] = 101;
              let a2 = 0;
              for (; a2 < r4; )
                s4[6 + a2] = 255, a2++;
              return s4[6 + a2] = o3, a2++, s4.set(i4, 6 + a2), s4.set(new Uint8Array(e3), 6 + a2 + n3), s4.buffer;
            }(t3.data, s3)), r3.enqueue(t3);
          } });
          r2.readable.pipeThrough(s2).pipeTo(r2.writable);
        } else {
          if (!Wb())
            return;
          {
            if ("undefined" == typeof RTCRtpScriptTransform)
              return void BN.warning("browser not support RTCRtpScriptTransform");
            const r2 = Ok2(), o2 = new MessageChannel();
            await new Wh((e3) => r2.onmessage = (t3) => {
              "registered" === t3.data && e3(void 0);
            });
            const s2 = new RTCRtpScriptTransform(r2, { name: "tx", port: o2.port2 }, [o2.port2]);
            e2.transform = s2, await new Wh((e3) => r2.onmessage = (t3) => {
              "started" === t3.data && e3(void 0);
            }), t2.on("sei-to-send", (e3) => {
              o2.port1.postMessage({ sei: e3 });
            }), o2.port1.onmessage = (t3) => {
              var r3;
              t3.data.transformed && e2.track && (null === (r3 = e2.track) || void 0 === r3 ? void 0 : r3.id) !== i3.track.id && (BN.debug("video track changed: ".concat(i3.track.id, " => ").concat(e2.track.id)), i3.track.removeEventListener("ended", n2), i3.track = e2.track, i3.track.addEventListener("ended", n2));
            }, i3.worker = r2;
          }
        }
        function n2() {
          if (e2.track) {
            if (this.id !== e2.track.id)
              return;
            e2.track.removeEventListener("ended", n2);
          }
          const t3 = kk.get(e2);
          if (t3) {
            kk.delete(e2);
            try {
              var i4, r2;
              null === (i4 = t3.controller) || void 0 === i4 || i4.terminate(), null === (r2 = t3.worker) || void 0 === r2 || r2.terminate();
            } catch (e3) {
              BN.warning(e3 && e3.message);
            }
          }
        }
        kk.set(e2, i3), e2.track.addEventListener("ended", n2);
      }
      const Uk = /* @__PURE__ */ new Map();
      async function xk(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (!QN().supportWebRTCEncodedTransform)
          return void BN.warning("browser not support video encoded transform");
        if (!e2.track)
          return;
        if (Uk.has(e2)) {
          const i4 = Uk.get(e2);
          return void (i4 && (i4.onSei = t2.onSei));
        }
        const i3 = { track: e2.track, onSei: t2.onSei };
        if (Gb()) {
          if (!e2.createEncodedStreams)
            return void BN.warning("browser not support createEncodedStreams() API");
          let t3 = null;
          try {
            t3 = e2.createEncodedStreams();
          } catch (e3) {
            return void BN.error("create video-encoded-streams error", e3 && e3.message);
          }
          const r2 = new TransformStream({ transform(t4, r3) {
            i3.controller || (i3.controller = r3), e2.track && e2.track.id !== i3.track.id && (BN.debug("video track changed: ".concat(i3.track.id, " => ").concat(e2.track.id)), i3.track.removeEventListener("ended", n2), i3.track = e2.track, i3.track.addEventListener("ended", n2));
            const o2 = function(e3) {
              const t5 = new DataView(e3.data);
              let i4 = 0;
              for (; i4 + 4 < e3.data.byteLength; ) {
                if (0 === t5.getUint8(i4 + 0) && 0 === t5.getUint8(i4 + 1) && 0 === t5.getUint8(i4 + 2) && 1 === t5.getUint8(i4 + 3) && 6 === t5.getUint8(i4 + 4)) {
                  let n3 = i4 + 6, r4 = 0, o3 = 0;
                  for (; 255 === (o3 = t5.getUint8(n3++)); )
                    r4 += 255;
                  r4 += o3;
                  const s2 = Lk(e3.data, n3, r4);
                  return new Uint8Array(s2);
                }
                i4++;
              }
              return null;
            }(t4);
            o2 && i3.onSei && i3.onSei(o2), r3.enqueue(t4);
          } });
          t3.readable.pipeThrough(r2).pipeTo(t3.writable);
        } else if (Wb()) {
          if ("undefined" == typeof RTCRtpScriptTransform)
            return void BN.warning("browser not support RTCRtpScriptTransform");
          const t3 = Ok2(), r2 = new MessageChannel();
          await new Wh((e3) => t3.onmessage = (t4) => {
            "registered" === t4.data && e3(void 0);
          });
          const o2 = new RTCRtpScriptTransform(t3, { name: "rx", port: r2.port2 }, [r2.port2]);
          e2.transform = o2, await new Wh((e3) => t3.onmessage = (t4) => {
            "started" === t4.data && e3(void 0);
          }), r2.port1.onmessage = (t4) => {
            var r3;
            t4.data.transformed && e2.track && (null === (r3 = e2.track) || void 0 === r3 ? void 0 : r3.id) !== i3.track.id ? (BN.debug("video track changed: ".concat(i3.track.id, " => ").concat(e2.track.id)), i3.track.removeEventListener("ended", n2), i3.track = e2.track, i3.track.addEventListener("ended", n2)) : t4.data.sei && i3.onSei && i3.onSei(t4.data.sei);
          }, i3.worker = t3;
        }
        function n2() {
          if (e2.track) {
            if (this.id !== e2.track.id)
              return;
            e2.track.removeEventListener("ended", n2);
          }
          !function(e3) {
            const t3 = Uk.get(e3);
            if (t3) {
              Uk.delete(e3);
              try {
                var i4, n3;
                null === (i4 = t3.controller) || void 0 === i4 || i4.terminate(), null === (n3 = t3.worker) || void 0 === n3 || n3.terminate();
              } catch (e4) {
                BN.warning(e4 && e4.message);
              }
            }
          }(e2);
        }
        Uk.set(e2, i3), e2.track.addEventListener("ended", n2);
      }
      !function() {
        const e2 = xb();
        JN.getDisplayMedia = !(!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia), JN.getStreamFromExtension = e2.name === Lb.CHROME && Number(e2.version) > 34, JN.supportUnifiedPlan = function() {
          if (!window.RTCRtpTransceiver)
            return false;
          if (!("currentDirection" in RTCRtpTransceiver.prototype))
            return false;
          const e3 = new RTCPeerConnection();
          let t2 = false;
          try {
            e3.addTransceiver("audio"), t2 = true;
          } catch (e4) {
          }
          return e3.close(), t2;
        }(), JN.supportMinBitrate = e2.name === Lb.CHROME || e2.name === Lb.EDGE, JN.supportSetRtpSenderParameters = function() {
          const e3 = xb();
          return !!(window.RTCRtpSender && window.RTCRtpSender.prototype.setParameters && window.RTCRtpSender.prototype.getParameters) && (!!cw() || !(!Wb() && !jb()) || e3.name === Lb.FIREFOX && Number(e3.version) >= 64);
        }(), e2.name === Lb.SAFARI && (Number(e2.version) >= 14 ? JN.supportDualStream = true : JN.supportDualStream = false), JN.webAudioMediaStreamDest = function() {
          const e3 = xb();
          return !(e3.name === Lb.SAFARI && Number(e3.version) < 12);
        }(), JN.supportReplaceTrack = !!window.RTCRtpSender && "function" == typeof RTCRtpSender.prototype.replaceTrack, JN.supportWebGL = "undefined" != typeof WebGLRenderingContext, JN.supportRequestFrame = !!window.CanvasCaptureMediaStreamTrack, cw() || (JN.webAudioWithAEC = true), JN.supportShareAudio = function() {
          const e3 = xb();
          return (e3.os === Pb.WIN_10 || e3.os === Pb.WIN_81 || e3.os === Pb.WIN_7 || e3.os === Pb.LINUX || e3.os === Pb.MAC_OS || e3.os === Pb.CHROMIUM_OS) && e3.name === Lb.CHROME && Number(e3.version) >= 74;
        }(), JN.supportDataChannel = !!(qb(76) || function(e3) {
          const t2 = xb();
          return !(t2.name !== Lb.FIREFOX || !t2.osVersion) && Number(t2.version) >= e3;
        }(68) || Jb(14)), JN.supportPCSetConfiguration = function() {
          const e3 = window.RTCPeerConnection;
          return !Kb() && !!e3 && e3.prototype.setConfiguration instanceof Function;
        }(), JN.supportWebRTCEncodedTransform = function() {
          const e3 = xb();
          return "Chrome" === e3.name && Number(e3.version) >= 86 || "Safari" === e3.name && Number(e3.version) >= 15;
        }(), JN.supportWebRTCInsertableStream = function() {
          const e3 = xb();
          return (e3.name === Lb.CHROME || e3.name === Lb.EDGE) && Number(e3.version) >= 94 && "MediaStreamTrackGenerator" in window && "MediaStreamTrackProcessor" in window;
        }(), JN.supportRequestVideoFrameCallback = "requestVideoFrameCallback" in HTMLVideoElement.prototype, JN.supportWebCrypto = "undefined" != typeof window && void 0 !== window.crypto && void 0 !== window.crypto.subtle, Zw(() => {
          JN.supportDualStreamEncoding = function() {
            const e3 = xb();
            return !!dN("DISABLE_WEBAUDIO") || ("Safari" === e3.name && Number(e3.version) >= 14 || !!("Chrome" === e3.name && /Windows/i.test(e3.os || "") && Number(e3.version) >= 100 && dN("CHROME_DUAL_STREAM_USE_ENCODING")));
          }(), BN.debug("browser ua: ", navigator.userAgent), BN.info("browser info: ", e2), BN.info("browser compatibility: ", JN);
        });
      }();
      const Vk = ["CHINA", "GLOBAL"];
      const Fk = [[0, 1, 2, 3, 4, 5, 5], [0, 2, 2, 3, 4, 5, 5], [0, 3, 3, 3, 4, 5, 5], [0, 4, 4, 4, 4, 5, 5], [0, 5, 5, 5, 5, 5, 5]], Bk = [];
      function jk(e2, t2) {
        return !!t2 && Bk.some((i3) => i3.uid === e2 && i3.channelName === t2);
      }
      var Gk = EC.forEach, Wk = Bn("forEach") ? [].forEach : function(e2) {
        return Gk(this, e2, arguments.length > 1 ? arguments[1] : void 0);
      };
      wi({ target: "Array", proto: true, forced: [].forEach != Wk }, { forEach: Wk });
      var Hk = Ji("Array").forEach, Kk = pn, Yk = Ze, qk = l, zk = Hk, Xk = Array.prototype, Jk = { DOMTokenList: true, NodeList: true }, Qk = function(e2) {
        var t2 = e2.forEach;
        return e2 === Xk || qk(Xk, e2) && t2 === Xk.forEach || Yk(Jk, Kk(e2)) ? zk : t2;
      }, Zk = i2(Qk), $k = Xe, eM = to;
      wi({ target: "Object", stat: true, forced: n(function() {
        eM(1);
      }) }, { keys: function(e2) {
        return eM($k(e2));
      } });
      var tM = i2(ie.Object.keys), iM = i2(zn), nM = i2(ar), rM = wi, oM = Qn, sM = Gc, aM = te, cM = xi, dM = Gi, lM = Z, uM = sp, hM = ht, pM = Qc, _M = OR("slice"), EM = hM("species"), fM = Array, mM = Math.max;
      rM({ target: "Array", proto: true, forced: !_M }, { slice: function(e2, t2) {
        var i3, n2, r2, o2 = lM(this), s2 = dM(o2), a2 = cM(e2, s2), c2 = cM(void 0 === t2 ? s2 : t2, s2);
        if (oM(o2) && (i3 = o2.constructor, (sM(i3) && (i3 === fM || oM(i3.prototype)) || aM(i3) && null === (i3 = i3[EM])) && (i3 = void 0), i3 === fM || void 0 === i3))
          return pM(o2, a2, c2);
        for (n2 = new (void 0 === i3 ? fM : i3)(mM(c2 - a2, 0)), r2 = 0; a2 < c2; a2++, r2++)
          a2 in o2 && uM(n2, r2, o2[a2]);
        return n2.length = r2, n2;
      } });
      var TM = Ji("Array").slice, SM = l, gM = TM, RM = Array.prototype, CM = function(e2) {
        var t2 = e2.slice;
        return e2 === RM || SM(RM, e2) && t2 === RM.slice ? gM : t2;
      }, vM = i2(CM);
      function IM(e2, t2, i3, n2, r2) {
        var o2, s2, a2, c2 = {};
        return Zk(o2 = tM(n2)).call(o2, function(e3) {
          c2[e3] = n2[e3];
        }), c2.enumerable = !!c2.enumerable, c2.configurable = !!c2.configurable, ("value" in c2 || c2.initializer) && (c2.writable = true), c2 = iM(s2 = nM(a2 = vM(i3).call(i3)).call(a2)).call(s2, function(i4, n3) {
          return n3(e2, t2, i4) || i4;
        }, c2), r2 && void 0 !== c2.initializer && (c2.value = c2.initializer ? c2.initializer.call(r2) : void 0, c2.initializer = void 0), void 0 === c2.initializer && (mR(e2, t2, c2), c2 = null), c2;
      }
      let yM = function(e2) {
        return e2[e2.ACCESS_POINT = 101] = "ACCESS_POINT", e2[e2.UNILBS = 201] = "UNILBS", e2[e2.STRING_UID_ALLOCATOR = 901] = "STRING_UID_ALLOCATOR", e2;
      }({}), AM = function(e2) {
        return e2[e2.IIIEGAL_APPID = 1] = "IIIEGAL_APPID", e2[e2.IIIEGAL_UID = 2] = "IIIEGAL_UID", e2[e2.INTERNAL_ERROR = 3] = "INTERNAL_ERROR", e2;
      }({}), bM = function(e2) {
        return e2[e2.INVALID_VENDOR_KEY = 5] = "INVALID_VENDOR_KEY", e2[e2.INVALID_CHANNEL_NAME = 7] = "INVALID_CHANNEL_NAME", e2[e2.INTERNAL_ERROR = 8] = "INTERNAL_ERROR", e2[e2.NO_AUTHORIZED = 9] = "NO_AUTHORIZED", e2[e2.DYNAMIC_KEY_TIMEOUT = 10] = "DYNAMIC_KEY_TIMEOUT", e2[e2.NO_ACTIVE_STATUS = 11] = "NO_ACTIVE_STATUS", e2[e2.DYNAMIC_KEY_EXPIRED = 13] = "DYNAMIC_KEY_EXPIRED", e2[e2.STATIC_USE_DYNAMIC_KEY = 14] = "STATIC_USE_DYNAMIC_KEY", e2[e2.DYNAMIC_USE_STATIC_KEY = 15] = "DYNAMIC_USE_STATIC_KEY", e2[e2.USER_OVERLOAD = 16] = "USER_OVERLOAD", e2[e2.FORBIDDEN_REGION = 18] = "FORBIDDEN_REGION", e2[e2.CANNOT_MEET_AREA_DEMAND = 19] = "CANNOT_MEET_AREA_DEMAND", e2;
      }({}), wM = function(e2) {
        return e2[e2.NO_FLAG_SET = 100] = "NO_FLAG_SET", e2[e2.FLAG_SET_BUT_EMPTY = 101] = "FLAG_SET_BUT_EMPTY", e2[e2.INVALID_FALG_SET = 102] = "INVALID_FALG_SET", e2[e2.FLAG_SET_BUT_NO_RE = 103] = "FLAG_SET_BUT_NO_RE", e2[e2.INVALID_SERVICE_ID = 104] = "INVALID_SERVICE_ID", e2[e2.NO_SERVICE_AVAILABLE = 200] = "NO_SERVICE_AVAILABLE", e2[e2.NO_SERVICE_AVAILABLE_P2P = 201] = "NO_SERVICE_AVAILABLE_P2P", e2[e2.NO_SERVICE_AVAILABLE_VOICE = 202] = "NO_SERVICE_AVAILABLE_VOICE", e2[e2.NO_SERVICE_AVAILABLE_WEBRTC = 203] = "NO_SERVICE_AVAILABLE_WEBRTC", e2[e2.NO_SERVICE_AVAILABLE_CDS = 204] = "NO_SERVICE_AVAILABLE_CDS", e2[e2.NO_SERVICE_AVAILABLE_CDN = 205] = "NO_SERVICE_AVAILABLE_CDN", e2[e2.NO_SERVICE_AVAILABLE_TDS = 206] = "NO_SERVICE_AVAILABLE_TDS", e2[e2.NO_SERVICE_AVAILABLE_REPORT = 207] = "NO_SERVICE_AVAILABLE_REPORT", e2[e2.NO_SERVICE_AVAILABLE_APP_CENTER = 208] = "NO_SERVICE_AVAILABLE_APP_CENTER", e2[e2.NO_SERVICE_AVAILABLE_ENV0 = 209] = "NO_SERVICE_AVAILABLE_ENV0", e2[e2.NO_SERVICE_AVAILABLE_VOET = 210] = "NO_SERVICE_AVAILABLE_VOET", e2[e2.NO_SERVICE_AVAILABLE_STRING_UID = 211] = "NO_SERVICE_AVAILABLE_STRING_UID", e2[e2.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS = 212] = "NO_SERVICE_AVAILABLE_WEBRTC_UNILBS", e2[e2.NO_SERVICE_AVAILABLE_UNILBS_FLV = 213] = "NO_SERVICE_AVAILABLE_UNILBS_FLV", e2;
      }({}), OM = function(e2) {
        return e2[e2.K_TIMESTAMP_EXPIRED = 2] = "K_TIMESTAMP_EXPIRED", e2[e2.K_CHANNEL_PERMISSION_INVALID = 3] = "K_CHANNEL_PERMISSION_INVALID", e2[e2.K_CERTIFICATE_INVALID = 4] = "K_CERTIFICATE_INVALID", e2[e2.K_CHANNEL_NAME_EMPTY = 5] = "K_CHANNEL_NAME_EMPTY", e2[e2.K_CHANNEL_NOT_FOUND = 6] = "K_CHANNEL_NOT_FOUND", e2[e2.K_TICKET_INVALID = 7] = "K_TICKET_INVALID", e2[e2.K_CHANNEL_CONFLICTED = 8] = "K_CHANNEL_CONFLICTED", e2[e2.K_SERVICE_NOT_READY = 9] = "K_SERVICE_NOT_READY", e2[e2.K_SERVICE_TOO_HEAVY = 10] = "K_SERVICE_TOO_HEAVY", e2[e2.K_UID_BANNED = 14] = "K_UID_BANNED", e2[e2.K_IP_BANNED = 15] = "K_IP_BANNED", e2[e2.K_CHANNEL_BANNED = 16] = "K_CHANNEL_BANNED", e2[e2.DATASTREAM2_NOT_AVAILABLE = 27] = "DATASTREAM2_NOT_AVAILABLE", e2[e2.K_AUTO_REBALANCE = 28] = "K_AUTO_REBALANCE", e2[e2.WARN_NO_AVAILABLE_CHANNEL = 103] = "WARN_NO_AVAILABLE_CHANNEL", e2[e2.WARN_LOOKUP_CHANNEL_TIMEOUT = 104] = "WARN_LOOKUP_CHANNEL_TIMEOUT", e2[e2.WARN_LOOKUP_CHANNEL_REJECTED = 105] = "WARN_LOOKUP_CHANNEL_REJECTED", e2[e2.WARN_OPEN_CHANNEL_TIMEOUT = 106] = "WARN_OPEN_CHANNEL_TIMEOUT", e2[e2.WARN_OPEN_CHANNEL_REJECTED = 107] = "WARN_OPEN_CHANNEL_REJECTED", e2[e2.WARN_REQUEST_DEFERRED = 108] = "WARN_REQUEST_DEFERRED", e2[e2.ERR_DYNAMIC_KEY_TIMEOUT = 109] = "ERR_DYNAMIC_KEY_TIMEOUT", e2[e2.ERR_NO_AUTHORIZED = 110] = "ERR_NO_AUTHORIZED", e2[e2.ERR_VOM_SERVICE_UNAVAILABLE = 111] = "ERR_VOM_SERVICE_UNAVAILABLE", e2[e2.ERR_NO_CHANNEL_AVAILABLE_CODE = 112] = "ERR_NO_CHANNEL_AVAILABLE_CODE", e2[e2.ERR_MASTER_VOCS_UNAVAILABLE = 114] = "ERR_MASTER_VOCS_UNAVAILABLE", e2[e2.ERR_INTERNAL_ERROR = 115] = "ERR_INTERNAL_ERROR", e2[e2.ERR_NO_ACTIVE_STATUS = 116] = "ERR_NO_ACTIVE_STATUS", e2[e2.ERR_INVALID_UID = 117] = "ERR_INVALID_UID", e2[e2.ERR_DYNAMIC_KEY_EXPIRED = 118] = "ERR_DYNAMIC_KEY_EXPIRED", e2[e2.ERR_STATIC_USE_DYANMIC_KE = 119] = "ERR_STATIC_USE_DYANMIC_KE", e2[e2.ERR_DYNAMIC_USE_STATIC_KE = 120] = "ERR_DYNAMIC_USE_STATIC_KE", e2[e2.ERR_NO_VOCS_AVAILABLE = 2e3] = "ERR_NO_VOCS_AVAILABLE", e2[e2.ERR_NO_VOS_AVAILABLE = 2001] = "ERR_NO_VOS_AVAILABLE", e2[e2.ERR_JOIN_CHANNEL_TIMEOUT = 2002] = "ERR_JOIN_CHANNEL_TIMEOUT", e2[e2.ERR_REPEAT_JOIN_CHANNEL = 2003] = "ERR_REPEAT_JOIN_CHANNEL", e2[e2.ERR_JOIN_BY_MULTI_IP = 2004] = "ERR_JOIN_BY_MULTI_IP", e2[e2.ERR_NOT_JOINED = 2011] = "ERR_NOT_JOINED", e2[e2.ERR_REPEAT_JOIN_REQUEST = 2012] = "ERR_REPEAT_JOIN_REQUEST", e2[e2.ERR_INVALID_VENDOR_KEY = 2013] = "ERR_INVALID_VENDOR_KEY", e2[e2.ERR_INVALID_CHANNEL_NAME = 2014] = "ERR_INVALID_CHANNEL_NAME", e2[e2.ERR_INVALID_STRINGUID = 2015] = "ERR_INVALID_STRINGUID", e2[e2.ERR_TOO_MANY_USERS = 2016] = "ERR_TOO_MANY_USERS", e2[e2.ERR_SET_CLIENT_ROLE_TIMEOUT = 2017] = "ERR_SET_CLIENT_ROLE_TIMEOUT", e2[e2.ERR_SET_CLIENT_ROLE_NO_PERMISSION = 2018] = "ERR_SET_CLIENT_ROLE_NO_PERMISSION", e2[e2.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE = 2019] = "ERR_SET_CLIENT_ROLE_ALREADY_IN_USE", e2[e2.ERR_PUBLISH_REQUEST_INVALID = 2020] = "ERR_PUBLISH_REQUEST_INVALID", e2[e2.ERR_SUBSCRIBE_REQUEST_INVALID = 2021] = "ERR_SUBSCRIBE_REQUEST_INVALID", e2[e2.ERR_NOT_SUPPORTED_MESSAGE = 2022] = "ERR_NOT_SUPPORTED_MESSAGE", e2[e2.ERR_ILLEAGAL_PLUGIN = 2023] = "ERR_ILLEAGAL_PLUGIN", e2[e2.ERR_REJOIN_TOKEN_INVALID = 2024] = "ERR_REJOIN_TOKEN_INVALID", e2[e2.ERR_REJOIN_USER_NOT_JOINED = 2025] = "ERR_REJOIN_USER_NOT_JOINED", e2[e2.ERR_INVALID_OPTIONAL_INFO = 2027] = "ERR_INVALID_OPTIONAL_INFO", e2[e2.ILLEGAL_AES_PASSWORD = 2028] = "ILLEGAL_AES_PASSWORD", e2[e2.ILLEGAL_CLIENT_ROLE_LEVEL = 2029] = "ILLEGAL_CLIENT_ROLE_LEVEL", e2[e2.ERR_TOO_MANY_BROADCASTERS = 2031] = "ERR_TOO_MANY_BROADCASTERS", e2[e2.ERR_TOO_MANY_SUBSCRIBERS = 2032] = "ERR_TOO_MANY_SUBSCRIBERS", e2[e2.ERR_LICENSE_MISSING = 32769] = "ERR_LICENSE_MISSING", e2[e2.ERR_LICENSE_EXPIRED = 32771] = "ERR_LICENSE_EXPIRED", e2[e2.ERR_LICENSE_MINUTES_EXCEEDED = 32773] = "ERR_LICENSE_MINUTES_EXCEEDED", e2[e2.ERR_LICENSE_PERIOD_INVALID = 32774] = "ERR_LICENSE_PERIOD_INVALID", e2[e2.ERR_LICENSE_MULTIPLE_SDK_SERVICE = 32778] = "ERR_LICENSE_MULTIPLE_SDK_SERVICE", e2[e2.ERR_LICENSE_ILLEGAL = 32783] = "ERR_LICENSE_ILLEGAL", e2[e2.ERR_TEST_RECOVER = 9e3] = "ERR_TEST_RECOVER", e2[e2.ERR_TEST_TRYNEXT = 9001] = "ERR_TEST_TRYNEXT", e2[e2.ERR_TEST_RETRY = 9002] = "ERR_TEST_RETRY", e2;
      }({}), NM = function(e2) {
        return e2.CONNECTING = "connecting", e2.CONNECTED = "connected", e2.RECONNECTING = "reconnecting", e2.CLOSED = "closed", e2;
      }({}), DM = function(e2) {
        return e2.WS_CONNECTED = "ws_connected", e2.WS_RECONNECTING = "ws_reconnecting", e2.WS_CLOSED = "ws_closed", e2.WS_RECONNECT_CREATE_CONNECTION = "ws_reconnect_create_connection", e2.ON_BINARY_DATA = "on_binary_data", e2.REQUEST_RECOVER = "request_recover", e2.REQUEST_JOIN_INFO = "request_join_info", e2.REQUEST_REJOIN_INFO = "req_rejoin_info", e2.IS_P2P_DISCONNECTED = "is_p2p_dis", e2.DISCONNECT_P2P = "dis_p2p", e2.ABORT_P2P_EXECUTION = "abort_p2p_execution", e2.NEED_RENEW_SESSION = "need-sid", e2.REPORT_JOIN_GATEWAY = "report_join_gateway", e2.REQUEST_TIMEOUT = "request_timeout", e2.REQUEST_SUCCESS = "request_success", e2.JOIN_RESPONSE = "join_response", e2.PRE_CONNECT_PC = "pre_connect_pc", e2.P2P_CONNECTION = "p2p_connection", e2.P2P_REMOTE_CANDIDATE_UPDATE = "p2p_remote_candidate_update", e2.P2P_SUBSCRIBE = "p2p_subscribe", e2.P2P_UNSUBSCRIBE = "p2p_unsubscribe", e2.P2P_EXCHANGE_SDP = "p2p_exchange_sdp", e2.P2P_ON_ADD_VIDEO_STREAM = "p2p_on_add_video_stream", e2.P2P_ON_ADD_AUDIO_STREAM = "p2p_on_add_audio_stream", e2.RECOVER_NOTIFICATION = "recover_notification", e2;
      }({}), PM = function(e2) {
        return e2.PING = "ping", e2.PING_BACK = "ping_back", e2.JOIN = "join_v3", e2.REJOIN = "rejoin_v3", e2.LEAVE = "leave", e2.SET_CLIENT_ROLE = "set_client_role", e2.PUBLISH = "publish", e2.PUBLISH_DATASTREAM = "publish_datastream", e2.UNPUBLISH = "unpublish", e2.UNPUBLISH_DATASTREAM = "unpublish_datastream", e2.SUBSCRIBE = "subscribe", e2.PRE_SUBSCRIBE = "pre_subscribe", e2.SUBSCRIBE_DATASTREAM = "subscribe_datastream", e2.SUBSCRIBE_STREAMS = "subscribe_streams", e2.UNSUBSCRIBE = "unsubscribe", e2.UNSUBSCRIBE_DATASTREAM = "unsubscribe_datastream", e2.UNSUBSCRIBE_STREAMS = "unsubscribe_streams", e2.SUBSCRIBE_CHANGE = "subscribe_change", e2.TRAFFIC_STATS = "traffic_stats", e2.RENEW_TOKEN = "renew_token", e2.SWITCH_VIDEO_STREAM = "switch_video_stream", e2.DEFAULT_VIDEO_STREAM = "default_video_stream", e2.SET_FALLBACK_OPTION = "set_fallback_option", e2.GATEWAY_INFO = "gateway_info", e2.CONTROL = "control", e2.SEND_METADATA = "send_metadata", e2.DATA_STREAM = "data_stream", e2.PICK_SVC_LAYER = "pick_svc_layer", e2.RESTART_ICE = "restart_ice", e2.CONNECT_PC = "connect_pc", e2.SET_VIDEO_PROFILE = "set_video_profile", e2.SET_PARAMETER = "set_parameter", e2.SET_RTM2_FLAG = "set_rtm2_flag", e2;
      }({}), LM = function(e2) {
        return e2.WRTC_STATS = "wrtc_stats", e2.WS_INFLATE_DATA_LENGTH = "ws_inflate_data_length", e2.DENOISER_STATS = "denoiser_stats", e2.EXTENSION_USAGE_STATS = "extension_usage_stats", e2;
      }({}), kM = function(e2) {
        return e2.ON_USER_ONLINE = "on_user_online", e2.ON_USER_OFFLINE = "on_user_offline", e2.ON_STREAM_FALLBACK_UPDATE = "on_stream_fallback_update", e2.ON_PUBLISH_STREAM = "on_publish_stream", e2.ON_UPLINK_STATS = "on_uplink_stats", e2.ON_P2P_LOST = "on_p2p_lost", e2.ON_REMOVE_STREAM = "on_remove_stream", e2.ON_ADD_AUDIO_STREAM = "on_add_audio_stream", e2.ON_ADD_VIDEO_STREAM = "on_add_video_stream", e2.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = "on_token_privilege_will_expire", e2.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "on_token_privilege_did_expire", e2.ON_USER_BANNED = "on_user_banned", e2.ON_USER_LICENSE_BANNED = "on_user_license_banned", e2.ON_NOTIFICATION = "on_notification", e2.ON_CRYPT_ERROR = "on_crypt_error", e2.MUTE_AUDIO = "mute_audio", e2.MUTE_VIDEO = "mute_video", e2.UNMUTE_AUDIO = "unmute_audio", e2.UNMUTE_VIDEO = "unmute_video", e2.ON_P2P_OK = "on_p2p_ok", e2.RECEIVE_METADATA = "receive_metadata", e2.ON_DATA_STREAM = "on_data_stream", e2.ON_RTP_CAPABILITY_CHANGE = "on_rtp_capability_change", e2.ON_REMOTE_DATASTREAM_UPDATE = "on_remote_datastream_update", e2.ON_REMOTE_FULL_DATASTREAM_INFO = "on_remote_full_datastream_info", e2.ENABLE_LOCAL_VIDEO = "enable_local_video", e2.DISABLE_LOCAL_VIDEO = "disable_local_video", e2.ENABLE_LOCAL_AUDIO = "enable_local_audio", e2.DISABLE_LOCAL_AUDIO = "disable_local_audio", e2.ON_PUBLISHED_USER_LIST = "on_published_user_list", e2;
      }({}), MM = function(e2) {
        return e2.SEND_ONLY = "SEND_ONLY", e2.RECEIVE_ONLY = "RECEIVE_ONLY", e2;
      }({}), UM = function(e2) {
        return e2.CONNECTED = "websocket:connected", e2.RECONNECTING = "websocket:reconnecting", e2.WILL_RECONNECT = "websocket:will_reconnect", e2.CLOSED = "websocket:closed", e2.FAILED = "websocket:failed", e2.ON_MESSAGE = "websocket:on_message", e2.REQUEST_NEW_URLS = "websocket:request_new_urls", e2.RECONNECT_CREATE_CONNECTION = "websocket:reconnect_create_connection", e2.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "websocket:on_token_privilege_did_expire", e2;
      }({});
      function xM(e2) {
        if ("string" != typeof e2 || !/^[a-zA-Z0-9 \!\#\$\%\&\(\)\+\-\:\;\<\=\.\>\?\@\[\]\^\_\{\}\|\~\,]{1,64}$/.test(e2))
          throw BN.error("Invalid Channel Name ".concat(e2)), new XN(_w.INVALID_PARAMS, "The length must be within 64 bytes. The supported characters: a-z,A-Z,0-9,space,!, #, $, %, &, (, ), +, -, :, ;, <, =, ., >, ?, @, [, ], ^, _,  {, }, |, ~, ,");
      }
      function VM(e2) {
        if (!(t2 = e2, "number" == typeof t2 && Math.floor(t2) === t2 && 0 <= t2 && t2 <= 4294967295 || vw(e2, 1, 255)))
          throw new XN(_w.INVALID_PARAMS, "[String uid] Length of the string: [1,255]. ASCII characters only. [Number uid] The value range is [0,10000]");
        var t2;
        "string" == typeof e2 && BN.warn("You input a string as the user ID, to ensure better end-user experience, Agora highly suggests not using a string as the user ID.");
      }
      let FM = function(e2) {
        return e2.TRANSCODE = "mix_streaming", e2.RAW = "raw_streaming", e2;
      }({});
      const BM = { alpha: 1, height: 640, width: 360, x: 0, y: 0, zOrder: 0, audioChannel: 0 }, jM = { x: 0, y: 0, width: 160, height: 160, zOrder: 255, alpha: 1 };
      function GM(e2, t2) {
        gw(e2.url, "".concat(t2, ".url"), 1, 1e3, false), Cw(e2.x) || Tw(e2.x, "".concat(t2, ".x"), 0, 1e4), Cw(e2.y) || Tw(e2.y, "".concat(t2, ".y"), 0, 1e4), Cw(e2.width) || Tw(e2.width, "".concat(t2, ".width"), 0, 1e4), Cw(e2.height) || Tw(e2.height, "".concat(t2, ".height"), 0, 1e4), Cw(e2.zOrder) || Tw(e2.zOrder, "".concat(t2, ".zOrder"), 0, 255), Cw(e2.alpha) || Tw(e2.alpha, "".concat(t2, ".alpha"), 0, 1, false);
      }
      const WM = { audioBitrate: 48, audioChannels: 1, audioSampleRate: 48e3, backgroundColor: 0, height: 360, lowLatency: false, videoBitrate: 400, videoCodecProfile: 100, videoCodecType: 1, videoFrameRate: 15, videoGop: 30, width: 640, images: [], userConfigs: [], userConfigExtraInfo: "" };
      let HM = function(e2) {
        return e2.WARNING = "@live_uap-warning", e2.ERROR = "@line_uap-error", e2.PUBLISH_STREAM_STATUS = "@live_uap-publish-status", e2.WORKER_STATUS = "@live_uap-worker-status", e2.REQUEST_NEW_ADDRESS = "@live_uap-request-address", e2;
      }({}), KM = function(e2) {
        return e2.REQUEST_WORKER_MANAGER_LIST = "@live_req_worker_manager", e2;
      }({}), YM = function(e2) {
        return e2[e2.LIVE_STREAM_RESPONSE_SUCCEED = 200] = "LIVE_STREAM_RESPONSE_SUCCEED", e2[e2.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM = 454] = "LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM", e2[e2.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR = 450] = "LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR", e2[e2.LIVE_STREAM_RESPONSE_BAD_STREAM = 451] = "LIVE_STREAM_RESPONSE_BAD_STREAM", e2[e2.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR = 400] = "LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR", e2[e2.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST = 404] = "LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST", e2[e2.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED = 456] = "LIVE_STREAM_RESPONSE_NOT_AUTHORIZED", e2[e2.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE = 457] = "LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE", e2[e2.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN = 429] = "LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN", e2[e2.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH = 452] = "LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH", e2[e2.LIVE_STREAM_RESPONSE_NOT_SUPPORTED = 453] = "LIVE_STREAM_RESPONSE_NOT_SUPPORTED", e2[e2.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM = 455] = "LIVE_STREAM_RESPONSE_MAX_STREAM_NUM", e2[e2.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR = 500] = "LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR", e2[e2.LIVE_STREAM_RESPONSE_WORKER_LOST = 501] = "LIVE_STREAM_RESPONSE_WORKER_LOST", e2[e2.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT = 502] = "LIVE_STREAM_RESPONSE_RESOURCE_LIMIT", e2[e2.LIVE_STREAM_RESPONSE_WORKER_QUIT = 503] = "LIVE_STREAM_RESPONSE_WORKER_QUIT", e2[e2.ERROR_FAIL_SEND_MESSAGE = 504] = "ERROR_FAIL_SEND_MESSAGE", e2[e2.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE = 30] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE", e2[e2.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT = 31] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT", e2[e2.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH = 32] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH", e2[e2.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN = 33] = "PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN", e2;
      }({});
      function qM(e2) {
        if (!e2.channelName)
          throw new XN(_w.INVALID_PARAMS, "invalid channelName in info");
        if ("number" != typeof e2.uid)
          throw new XN(_w.INVALID_PARAMS, "invalid uid in info, uid must be a number");
        return e2.token && gw(e2.token, "info.token", 1, 2047), VM(e2.uid), xM(e2.channelName), true;
      }
      let zM = function(e2) {
        return e2[e2.SetSdkProfile = 0] = "SetSdkProfile", e2[e2.SetSourceChannel = 1] = "SetSourceChannel", e2[e2.SetSourceUserId = 2] = "SetSourceUserId", e2[e2.SetDestChannel = 3] = "SetDestChannel", e2[e2.StartPacketTransfer = 4] = "StartPacketTransfer", e2[e2.StopPacketTransfer = 5] = "StopPacketTransfer", e2[e2.UpdateDestChannel = 6] = "UpdateDestChannel", e2[e2.Reconnect = 7] = "Reconnect", e2[e2.SetVideoProfile = 8] = "SetVideoProfile", e2;
      }({}), XM = function(e2) {
        return e2.NETWORK_DISCONNECTED = "NETWORK_DISCONNECTED", e2.NETWORK_CONNECTED = "NETWORK_CONNECTED", e2.PACKET_JOINED_SRC_CHANNEL = "PACKET_JOINED_SRC_CHANNEL", e2.PACKET_JOINED_DEST_CHANNEL = "PACKET_JOINED_DEST_CHANNEL", e2.PACKET_SENT_TO_DEST_CHANNEL = "PACKET_SENT_TO_DEST_CHANNEL", e2.PACKET_RECEIVED_VIDEO_FROM_SRC = "PACKET_RECEIVED_VIDEO_FROM_SRC", e2.PACKET_RECEIVED_AUDIO_FROM_SRC = "PACKET_RECEIVED_AUDIO_FROM_SRC", e2.PACKET_UPDATE_DEST_CHANNEL = "PACKET_UPDATE_DEST_CHANNEL", e2.PACKET_UPDATE_DEST_CHANNEL_REFUSED = "PACKET_UPDATE_DEST_CHANNEL_REFUSED", e2.PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE = "PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE", e2;
      }({}), JM = function(e2) {
        return e2.RELAY_STATE_IDLE = "RELAY_STATE_IDLE", e2.RELAY_STATE_CONNECTING = "RELAY_STATE_CONNECTING", e2.RELAY_STATE_RUNNING = "RELAY_STATE_RUNNING", e2.RELAY_STATE_FAILURE = "RELAY_STATE_FAILURE", e2;
      }({}), QM = function(e2) {
        return e2.RELAY_OK = "RELAY_OK", e2.SERVER_CONNECTION_LOST = "SERVER_CONNECTION_LOST", e2.SRC_TOKEN_EXPIRED = "SRC_TOKEN_EXPIRED", e2.DEST_TOKEN_EXPIRED = "DEST_TOKEN_EXPIRED", e2;
      }({}), ZM = function(e2) {
        return e2.High = "high", e2.Low = "low", e2.Audio = "audio", e2.Screen = "screen", e2.ScreenLow = "screen_low", e2;
      }({}), $M = function(e2) {
        return e2.DISCONNECT = "disconnect", e2.CONNECTION_STATE_CHANGE = "connection-state-change", e2.NETWORK_QUALITY = "network-quality", e2.STREAM_TYPE_CHANGE = "stream-type-change", e2.IS_P2P_DISCONNECTED = "is-p2p-dis", e2.DISCONNECT_P2P = "dis-p2p", e2.REQUEST_NEW_GATEWAY_LIST = "req-gate-url", e2.NEED_RENEW_SESSION = "need-sid", e2.REQUEST_P2P_CONNECTION_PARAMS = "request-p2p-connection-params", e2.JOIN_RESPONSE = "join-response", e2.RESET_CONNECTION_EVENTS = "reset-connection-events", e2.PRE_CONNECT_PC = "pre-connect_pc", e2;
      }({}), eU = function(e2) {
        return e2.P2P_DISCONNECTED = "P2P_DISCONNECTED", e2.A_ROUND_WS_FAILED = "A_ROUND_WS_FAILED", e2.TIMEOUT = "TIMEOUT", e2.UNKNOWN_REASON = "UNKNOWN_REASON", e2;
      }({}), tU = function(e2) {
        return e2[e2.Nothing = 0] = "Nothing", e2[e2.Audio = 1] = "Audio", e2[e2.LwoVideo = 2] = "LwoVideo", e2[e2.Video = 4] = "Video", e2[e2.Data = 8] = "Data", e2[e2.DataStream0 = 256] = "DataStream0", e2[e2.DataStream1 = 512] = "DataStream1", e2[e2.DataStream2 = 1024] = "DataStream2", e2[e2.DataStream3 = 2048] = "DataStream3", e2[e2.DataStream4 = 4096] = "DataStream4", e2[e2.DataStream5 = 8192] = "DataStream5", e2[e2.DataStream6 = 16384] = "DataStream6", e2[e2.DataStream7 = 32768] = "DataStream7", e2;
      }({}), iU = function(e2) {
        return e2.CHINA = "CHINA", e2.ASIA = "ASIA", e2.NORTH_AMERICA = "NORTH_AMERICA", e2.EUROPE = "EUROPE", e2.JAPAN = "JAPAN", e2.INDIA = "INDIA", e2.KOREA = "KOREA", e2.HKMC = "HKMC", e2.US = "US", e2.OCEANIA = "OCEANIA", e2.SOUTH_AMERICA = "SOUTH_AMERICA", e2.AFRICA = "AFRICA", e2.OVERSEA = "OVERSEA", e2.GLOBAL = "GLOBAL", e2.EXTENSIONS = "EXTENSIONS", e2;
      }({});
      const nU = [iU.AFRICA, iU.ASIA, iU.CHINA, iU.EUROPE, iU.GLOBAL, iU.INDIA, iU.JAPAN, iU.NORTH_AMERICA, iU.OCEANIA, iU.OVERSEA, iU.SOUTH_AMERICA];
      let rU = function(e2) {
        return e2.CHINA = "CN", e2.ASIA = "AS", e2.NORTH_AMERICA = "NA", e2.EUROPE = "EU", e2.JAPAN = "JP", e2.INDIA = "IN", e2.KOREA = "KR", e2.HKMC = "HK", e2.US = "US", e2.OCEANIA = "OC", e2.SOUTH_AMERICA = "SA", e2.AFRICA = "AF", e2.OVERSEA = "OVERSEA", e2.GLOBAL = "GLOBAL", e2.EXTENSIONS = "GLOBAL", e2;
      }({});
      const oU = { CHINA: {}, ASIA: { CODE: rU.ASIA, WEBCS_DOMAIN: ["ap-web-1-asia.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-asia.agora.io"], PROXY_CS: ["proxy-ap-web-asia.agora.io"], CDS_AP: ["cds-ap-web-asia.agora.io", "cds-ap-web-asia2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-asia.agora.io", "sua-ap-web-asia2.agora.io"], UAP_AP: ["uap-ap-web-asia.agora.io", "uap-ap-web-asia2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-asia.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-asia.agora.io"], LOG_UPLOAD_SERVER: ["logservice-asia.agora.io"], PROXY_SERVER_TYPE3: ["southeast-asia.webrtc-cloud-proxy.sd-rtn.com"] }, NORTH_AMERICA: { CODE: rU.NORTH_AMERICA, WEBCS_DOMAIN: ["ap-web-1-north-america.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-north-america.agora.io"], PROXY_CS: ["proxy-ap-web-america.agora.io"], CDS_AP: ["cds-ap-web-america.agora.io", "cds-ap-web-america2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-america.agora.io", "sua-ap-web-america2.agora.io"], UAP_AP: ["uap-ap-web-america.agora.io", "uap-ap-web-america2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-north-america.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-north-america.agora.io"], LOG_UPLOAD_SERVER: ["logservice-north-america.agora.io"], PROXY_SERVER_TYPE3: ["east-usa.webrtc-cloud-proxy.sd-rtn.com"] }, EUROPE: { CODE: rU.EUROPE, WEBCS_DOMAIN: ["ap-web-1-europe.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-europe.agora.io"], PROXY_CS: ["proxy-ap-web-europe.agora.io"], CDS_AP: ["cds-ap-web-europe.agora.io", "cds-ap-web-europe2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-europe.agora.io", "sua-ap-web-europe.agora.io"], UAP_AP: ["uap-ap-web-europe.agora.io", "uap-ap-web-europe2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-europe.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-europe.agora.io"], LOG_UPLOAD_SERVER: ["logservice-europe.agora.io"], PROXY_SERVER_TYPE3: ["europe.webrtc-cloud-proxy.sd-rtn.com"] }, JAPAN: { CODE: rU.JAPAN, WEBCS_DOMAIN: ["ap-web-1-japan.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-japan.agora.io"], PROXY_CS: ["proxy-ap-web-japan.agora.io"], CDS_AP: ["cds-ap-web-japan.agora.io", "cds-ap-web-japan2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-japan.agora.io", "sua-ap-web-japan2.agora.io"], UAP_AP: ["uap-ap-web-japan.agora.io", "uap-ap-web-japan2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-japan.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-japan.agora.io"], LOG_UPLOAD_SERVER: ["logservice-japan.agora.io"], PROXY_SERVER_TYPE3: ["japan.webrtc-cloud-proxy.sd-rtn.com"] }, INDIA: { CODE: rU.INDIA, WEBCS_DOMAIN: ["ap-web-1-india.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-india.agora.io"], PROXY_CS: ["proxy-ap-web-india.agora.io"], CDS_AP: ["cds-ap-web-india.agora.io", "cds-ap-web-india2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-india.agora.io", "sua-ap-web-india2.agora.io"], UAP_AP: ["uap-ap-web-india.agora.io", "uap-ap-web-india2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-india.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-india.agora.io"], LOG_UPLOAD_SERVER: ["logservice-india.agora.io"], PROXY_SERVER_TYPE3: ["india.webrtc-cloud-proxy.sd-rtn.com"] }, KOREA: { CODE: rU.KOREA, WEBCS_DOMAIN: ["ap-web-1-korea.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-korea.agora.io"], PROXY_CS: ["proxy-ap-web-korea.agora.io"], CDS_AP: ["cds-ap-web-korea.agora.io", "cds-ap-web-korea2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-korea.agora.io", "sua-ap-web-korea2.agora.io"], UAP_AP: ["uap-ap-web-korea.agora.io", "uap-ap-web-korea2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-korea.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-korea.agora.io"], LOG_UPLOAD_SERVER: ["logservice-korea.agora.io"], PROXY_SERVER_TYPE3: ["korea.webrtc-cloud-proxy.sd-rtn.com"] }, HKMC: { CODE: rU.HKMC, WEBCS_DOMAIN: ["ap-web-1-hkmc.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-hkmc.agora.io"], PROXY_CS: ["proxy-ap-web-hkmc.agora.io"], CDS_AP: ["cds-ap-web-hkmc.agora.io", "cds-ap-web-hkmc2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-hkmc.agora.io", "sua-ap-web-hkmc2.agora.io"], UAP_AP: ["uap-ap-web-hkmc.agora.io", "uap-ap-web-hkmc2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-hkmc.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-hkmc.agora.io"], LOG_UPLOAD_SERVER: ["logservice-hkmc.agora.io"], PROXY_SERVER_TYPE3: ["hkmc.webrtc-cloud-proxy.sd-rtn.com"] }, US: { CODE: rU.US, WEBCS_DOMAIN: ["ap-web-1-us.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-us.agora.io"], PROXY_CS: ["proxy-ap-web-us.agora.io"], CDS_AP: ["cds-ap-web-us.agora.io", "cds-ap-web-us2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-us.agora.io", "sua-ap-web-us2.agora.io"], UAP_AP: ["uap-ap-web-us.agora.io", "uap-ap-web-us2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-us.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-us.agora.io"], LOG_UPLOAD_SERVER: ["logservice-us.agora.io"], PROXY_SERVER_TYPE3: ["us.webrtc-cloud-proxy.sd-rtn.com"] }, OVERSEA: { CODE: rU.OVERSEA, WEBCS_DOMAIN: ["ap-web-1-oversea.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-oversea.agora.io"], PROXY_CS: ["proxy-ap-web-oversea.agora.io"], CDS_AP: ["cds-ap-web-oversea.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-oversea.agora.io"], UAP_AP: ["uap-ap-web-oversea.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-oversea.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-oversea.agora.io"], LOG_UPLOAD_SERVER: ["logservice-oversea.agora.io"], PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.agora.io"] }, GLOBAL: { CODE: rU.GLOBAL, WEBCS_DOMAIN: ["webrtc2-ap-web-1.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-ap-web-3.agora.io"], PROXY_CS: ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"], CDS_AP: ["cds-ap-web-1.agora.io", "cds-ap-web-3.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-1.agora.io", "sua-ap-web-3.agora.io"], UAP_AP: ["uap-ap-web-1.agora.io", "uap-ap-web-3.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2.agora.io"], LOG_UPLOAD_SERVER: ["logservice.agora.io"], PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.sd-rtn.com"] }, OCEANIA: { CODE: rU.OCEANIA, WEBCS_DOMAIN: ["ap-web-1-oceania.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-oceania.agora.io"], PROXY_CS: ["proxy-ap-web-oceania.agora.io"], CDS_AP: ["cds-ap-web-oceania.agora.io", "cds-ap-web-oceania2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-oceania.agora.io", "sua-ap-web-oceania2.agora.io"], UAP_AP: ["uap-ap-web-oceania.agora.io", "uap-ap-web-oceania2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-oceania.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-oceania.agora.io"], LOG_UPLOAD_SERVER: ["logservice-oceania.agora.io"], PROXY_SERVER_TYPE3: ["oceania.webrtc-cloud-proxy.sd-rtn.com"] }, SOUTH_AMERICA: { CODE: rU.SOUTH_AMERICA, WEBCS_DOMAIN: ["ap-web-1-south-america.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-south-america.agora.io"], PROXY_CS: ["proxy-ap-web-south-america.agora.io"], CDS_AP: ["cds-ap-web-south-america.agora.io", "cds-ap-web-south-america2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-south-america.agora.io", "sua-ap-web-south-america2.agora.io"], UAP_AP: ["uap-ap-web-south-america.agora.io", "uap-ap-web-south-america2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-south-america.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-south-america.agora.io"], LOG_UPLOAD_SERVER: ["logservice-south-america.agora.io"], PROXY_SERVER_TYPE3: ["south-america.webrtc-cloud-proxy.sd-rtn.com"] }, AFRICA: { CODE: rU.AFRICA, WEBCS_DOMAIN: ["ap-web-1-africa.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-africa.agora.io"], PROXY_CS: ["proxy-ap-web-africa.agora.io"], CDS_AP: ["cds-ap-web-africa.agora.io", "cds-ap-web-africa2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-africa.agora.io", "sua-ap-web-africa2.agora.io"], UAP_AP: ["uap-ap-web-africa.agora.io", "uap-ap-web-africa2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-africa.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-africa.agora.io"], LOG_UPLOAD_SERVER: ["logservice-south-africa.agora.io"], PROXY_SERVER_TYPE3: ["africa.webrtc-cloud-proxy.sd-rtn.com"] }, EXTENSIONS: {} };
      iN && (oU.CHINA = { CODE: rU.CHINA, WEBCS_DOMAIN: ["webrtc2-2.ap.sd-rtn.com"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-4.ap.sd-rtn.com"], PROXY_CS: ["proxy-web.ap.sd-rtn.com"], CDS_AP: ["cds-web-2.ap.sd-rtn.com", "cds-web-4.ap.sd-rtn.com"], ACCOUNT_REGISTER: ["sua-web-2.ap.sd-rtn.com", "sua-web-4.ap.sd-rtn.com"], UAP_AP: ["uap-web-2.ap.sd-rtn.com", "uap-web-4.ap.sd-rtn.com"], EVENT_REPORT_DOMAIN: ["web-3.statscollector.sd-rtn.com"], EVENT_REPORT_BACKUP_DOMAIN: ["web-4.statscollector.sd-rtn.com"], LOG_UPLOAD_SERVER: ["logservice-china.agora.io"], PROXY_SERVER_TYPE3: ["east-cn.webrtc-cloud-proxy.sd-rtn.com"] });
      let sU = function(e2) {
        return e2.UPDATE_BITRATE_LIMIT = "update_bitrate_limit", e2.UPDATE_CLIENT_ROLE_OPTIONS = "update_client_role_options", e2;
      }({});
      function aU(e2) {
        return !!e2 && (!(!e2.uplink || !e2.id) && (void 0 !== e2.uplink.max_bitrate && void 0 !== e2.uplink.min_bitrate));
      }
      class cU extends Nw {
        constructor(e2, t2) {
          super(), QI(this, "onICEConnectionStateChange", void 0), QI(this, "onConnectionStateChange", void 0), QI(this, "onDTLSTransportStateChange", void 0), QI(this, "onDTLSTransportError", void 0), QI(this, "onICETransportStateChange", void 0), QI(this, "onFirstAudioReceived", void 0), QI(this, "onFirstVideoReceived", void 0), QI(this, "onFirstAudioDecoded", void 0), QI(this, "onFirstVideoDecoded", void 0), QI(this, "onFirstVideoDecodedTimeout", void 0), QI(this, "onSelectedLocalCandidateChanged", void 0), QI(this, "onSelectedRemoteCandidateChanged", void 0), QI(this, "onICECandidateError", void 0), QI(this, "getLocalVideoStats", void 0);
        }
      }
      class dU extends cU {
        constructor(e2, t2) {
          super(e2, t2), QI(this, "establishPromise", void 0);
        }
      }
      let lU = function(e2) {
        return e2.VIDEO = "video", e2.AUDIO = "audio", e2;
      }({}), uU = function(e2) {
        return e2.UDP_RELAY = "udp_relay", e2.UDP_TCP_RELAY = "udp_tcp_relay", e2.TCP_RELAY = "tcp_relay", e2.RELAY = "relay", e2;
      }({}), hU = function(e2) {
        return e2[e2.FIRST_CONNECTION = 0] = "FIRST_CONNECTION", e2[e2.UDP_TCP_RESTART = 1] = "UDP_TCP_RESTART", e2[e2.RELAY_RESTART = 2] = "RELAY_RESTART", e2[e2.TCP_RESTART = 3] = "TCP_RESTART", e2[e2.OLD_FIRST_CONNECTION = 10] = "OLD_FIRST_CONNECTION", e2[e2.OLD_RESTART = 11] = "OLD_RESTART", e2[e2.DISCONNECTED_OR_FAILED = 20] = "DISCONNECTED_OR_FAILED", e2;
      }({});
      const pU = ["disconnected", "failed"];
      let _U = function(e2) {
        return e2.LocalVideoTrack = "videoTrack", e2.LocalAudioTrack = "audioTrack", e2.LocalVideoLowTrack = "videoLowTrack", e2;
      }({}), EU = function(e2) {
        return e2.New = "new", e2.Connected = "connected", e2.Reconnecting = "reconnecting", e2.Disconnected = "disconnected", e2;
      }({}), fU = function(e2) {
        return e2.StateChange = "stateChange", e2.IceConnectionStateChange = "iceConnectionStateChange", e2.RequestMuteLocal = "requestMuteLocal", e2.RequestUnmuteLocal = "requestUnmuteLocal", e2.RequestRePublish = "requestRePublish", e2.RequestRePublishDataChannel = "requestRePublishDataChannel", e2.RequestReSubscribe = "requestReSubscribe", e2.RequestUploadStats = "requestUploadStats", e2.RequestUpload = "requestUpload", e2.MediaReconnectStart = "MediaReconnectStart", e2.MediaReconnectEnd = "MediaReconnectEnd", e2.NeedSignalRTT = "NeedSignalRTT", e2.RequestRestartICE = "RequestRestartIce", e2.PeerConnectionStateChange = "PeerConnectionStateChange", e2.RequestReconnect = "RequestReconnect", e2.RequestReconnectPC = "RequestReconnectPC", e2.RequestUnpublishForReconnectPC = "RequestUnpublishForReconnectPC", e2.P2PLost = "P2PLost", e2.UpdateVideoEncoder = "UpdateVideoEncoder", e2.ConnectionTypeChange = "ConnectionTypeChange", e2.RequestLowStreamParameter = "RequestLowStreamParameter", e2.QueryClientConnectionState = "QueryClientConnectionState", e2.LocalCandidate = "LocalCandidate", e2.RequestP2PMuteLocal = "requestP2PMuteLocal", e2.RequestP2PUnPublish = "RequestP2PUnPublish", e2.RequestP2PUnmuteRemote = "RequestP2PUnmuteRemote", e2.RequestP2PMuteRemote = "RequestP2PMuteRemote", e2.RequestP2PRestartICE = "RequestP2PRestartICE", e2;
      }({}), mU = function(e2) {
        return e2.CONNECTING = "CONNECTING", e2.RECONNECTING = "RECONNECTING", e2.CONNECTED = "CONNECTED", e2.CLOSED = "CLOSED", e2;
      }({}), TU = function(e2) {
        return e2[e2.CONNECT_AP = 0] = "CONNECT_AP", e2[e2.AP_CONNECTED = 1] = "AP_CONNECTED", e2[e2.CONNECT_WORKER_MANAGER = 2] = "CONNECT_WORKER_MANAGER", e2[e2.WORKER_MANAGER_CONNECTED = 3] = "WORKER_MANAGER_CONNECTED", e2[e2.GET_WORKER_MANAGER_RESPONSE = 4] = "GET_WORKER_MANAGER_RESPONSE", e2[e2.CONNECT_WORKER = 5] = "CONNECT_WORKER", e2[e2.WORKER_CONNECTED = 6] = "WORKER_CONNECTED", e2[e2.CLOSED = 7] = "CLOSED", e2;
      }({}), SU = function(e2) {
        return e2.CONNECTION_STATE_CHANGE = "connection-state-change", e2.STATE_CHANGE = "state-change", e2.INSPECT_RESULT = "inspect-result", e2.CLIENT_LOCAL_VIDEO_TRACK = "client-local-video-track", e2.REQUEST_NEW_WORKER_URL = "request-new-worker-url", e2;
      }({}), gU = function(e2) {
        return e2.CONNECTED = "transmitter:connected", e2.RECONNECTING = "transmitter:reconnecting", e2.WILL_RECONNECT = "transmitter:will_reconnect", e2.CLOSED = "transmitter:closed", e2.FAILED = "transmitter:failed", e2.ON_MESSAGE = "transmitter:on_message", e2.REQUEST_NEW_URLS = "transmitter:request_new_urls", e2.RECONNECT_CREATE_CONNECTION = "transmitter:reconnect_create_connection", e2.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "transmitter:on_token_privilege_did_expire", e2.TO_CONNECT_DATACHANNEL = "transmitter:to_connect_datachannel", e2.FAILBACK = "transmitter:failback", e2.PRE_CONNECT_PC = "transmitter:pre_connect_pc", e2;
      }({}), RU = function(e2) {
        return e2.CAMERA_CHANGED = "camera-changed", e2.MICROPHONE_CHANGED = "microphone-changed", e2.PLAYBACK_DEVICE_CHANGED = "playback-device-changed", e2.AUDIO_AUTOPLAY_FAILED = "audio-autoplay-failed", e2.AUTOPLAY_FAILED = "autoplay-failed", e2.AUDIO_CONTEXT_STATE_CHANGED = "audio-context-state-changed", e2.SECURITY_POLICY_VIOLATION = "security-policy-violation", e2;
      }({}), CU = function(e2) {
        return e2.CONNECTING = "CONNECTING", e2.RECONNECTING = "RECONNECTING", e2.CONNECTED = "CONNECTED", e2.CLOSED = "CLOSED", e2;
      }({}), vU = function(e2) {
        return e2.CONNECTION_STATE_CHANGE = "connection-state-change", e2.STATE_CHANGE = "state-change", e2.INSPECT_RESULT = "inspect-result", e2.CLIENT_LOCAL_VIDEO_TRACK = "client-local-video-track", e2.REQUEST_NEW_WORKER_URL = "request-new-worker-url", e2;
      }({}), IU = function(e2) {
        return e2[e2.CONNECT_AP = 0] = "CONNECT_AP", e2[e2.AP_CONNECTED = 1] = "AP_CONNECTED", e2[e2.CONNECT_WORKER_MANAGER = 2] = "CONNECT_WORKER_MANAGER", e2[e2.WORKER_MANAGER_CONNECTED = 3] = "WORKER_MANAGER_CONNECTED", e2[e2.GET_WORKER_MANAGER_RESPONSE = 4] = "GET_WORKER_MANAGER_RESPONSE", e2[e2.CONNECT_WORKER = 5] = "CONNECT_WORKER", e2[e2.WORKER_CONNECTED = 6] = "WORKER_CONNECTED", e2[e2.CLOSED = 7] = "CLOSED", e2;
      }({}), yU = function(e2) {
        return e2.CALL = "call", e2.CANDIDATE = "candidate", e2.PUBLISH = "publish", e2.UNPUBLISH = "unpublish", e2.CONTROL = "control", e2.RESTART_ICE = "restart_ice", e2.ACK = "ack", e2.RESPONSE = "response", e2.JOIN = "join", e2.CHECK = "check", e2;
      }({}), AU = function(e2) {
        return e2.ABORT = "abort", e2;
      }({}), bU = function(e2) {
        return e2.MUTE_LOCAL_AUDIO = "mute_local_audio", e2.MUTE_LOCAL_VIDEO = "mute_local_video", e2.UNMUTE_LOCAL_AUDIO = "unmute_local_audio", e2.UNMUTE_LOCAL_VIDEO = "unmute_local_video", e2;
      }({}), wU = function(e2) {
        return e2.P2P_TOKEN_TIMEOUT = "p2p_token_timeout", e2.P2P_TOKEN_CHANGED = "p2p_token_changed", e2;
      }({});
      const OU = { [yM.ACCESS_POINT]: { [wM.NO_FLAG_SET]: { desc: "flag is zero", retry: false }, [wM.FLAG_SET_BUT_EMPTY]: { desc: "flag is empty", retry: false }, [wM.INVALID_FALG_SET]: { desc: "invalid flag", retry: false }, [wM.FLAG_SET_BUT_NO_RE]: { desc: "flag set unilbs but no request", retry: false }, [wM.INVALID_SERVICE_ID]: { desc: "invalid service id", retry: false }, [wM.NO_SERVICE_AVAILABLE]: { desc: "no service available", retry: true }, [wM.NO_SERVICE_AVAILABLE_P2P]: { desc: "no unilbs p2p service available", retry: true }, [wM.NO_SERVICE_AVAILABLE_VOICE]: { desc: "no unilbs voice service available", retry: true }, [wM.NO_SERVICE_AVAILABLE_WEBRTC]: { desc: "no unilbs webrtc service available", retry: true }, [wM.NO_SERVICE_AVAILABLE_CDS]: { desc: "no cds service available", retry: true }, [wM.NO_SERVICE_AVAILABLE_CDN]: { desc: "no cdn dispatcher service available", retry: true }, [wM.NO_SERVICE_AVAILABLE_TDS]: { desc: "no tds service available", retry: true }, [wM.NO_SERVICE_AVAILABLE_REPORT]: { desc: "no unilbs report service available", retry: true }, [wM.NO_SERVICE_AVAILABLE_APP_CENTER]: { desc: "no app center service available", retry: true }, [wM.NO_SERVICE_AVAILABLE_ENV0]: { desc: "no unilbs sig env0 service available", retry: true }, [wM.NO_SERVICE_AVAILABLE_VOET]: { desc: "no unilbs voet service available", retry: true }, [wM.NO_SERVICE_AVAILABLE_STRING_UID]: { desc: "no string uid service available", retry: true }, [wM.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS]: { desc: "no webrtc unilbs service available", retry: true } }, [yM.UNILBS]: { [bM.INVALID_VENDOR_KEY]: { desc: "invalid vendor key, can not find appid", retry: false }, [bM.INVALID_CHANNEL_NAME]: { desc: "invalid channel name", retry: false }, [bM.INTERNAL_ERROR]: { desc: "unilbs internal error", retry: false }, [bM.NO_AUTHORIZED]: { desc: "invalid token, authorized failed", retry: false }, [bM.DYNAMIC_KEY_TIMEOUT]: { desc: "dynamic key or token timeout", retry: false }, [bM.NO_ACTIVE_STATUS]: { desc: "no active status", retry: false }, [bM.DYNAMIC_KEY_EXPIRED]: { desc: "dynamic key expired", retry: false }, [bM.STATIC_USE_DYNAMIC_KEY]: { desc: "static use dynamic key", retry: false }, [bM.DYNAMIC_USE_STATIC_KEY]: { desc: "dynamic use static key", retry: false }, [bM.USER_OVERLOAD]: { desc: "amount of users over load", retry: false }, [bM.FORBIDDEN_REGION]: { desc: "the request is forbidden in this area", retry: false }, [bM.CANNOT_MEET_AREA_DEMAND]: { desc: "unable to allocate services in this area", retry: false } }, [yM.STRING_UID_ALLOCATOR]: { [AM.IIIEGAL_APPID]: { desc: "invalid appid", retry: false }, [AM.IIIEGAL_UID]: { desc: "invalid string uid", retry: false }, [AM.INTERNAL_ERROR]: { desc: "string uid allocator internal error", retry: true } } };
      function NU(e2) {
        const t2 = OU[Math.floor(e2 / 1e4)];
        if (!t2)
          return { desc: "unknown error", retry: false };
        const i3 = t2[e2 % 1e4];
        if (!i3) {
          if (Math.floor(e2 / 1e4) === yM.ACCESS_POINT) {
            const t3 = e2 % 1e4;
            if ("1" === t3.toString()[0])
              return { desc: e2.toString(), retry: false };
            if ("2" === t3.toString()[0])
              return { desc: e2.toString(), retry: true };
          }
          return { desc: "unknown error", retry: false };
        }
        return i3;
      }
      const DU = { [OM.K_TIMESTAMP_EXPIRED]: { desc: "K_TIMESTAMP_EXPIRED", action: "failed" }, [OM.K_CHANNEL_PERMISSION_INVALID]: { desc: "K_CHANNEL_PERMISSION_INVALID", action: "failed" }, [OM.K_CERTIFICATE_INVALID]: { desc: "K_CERTIFICATE_INVALID", action: "failed" }, [OM.K_CHANNEL_NAME_EMPTY]: { desc: "K_CHANNEL_NAME_EMPTY", action: "failed" }, [OM.K_CHANNEL_NOT_FOUND]: { desc: "K_CHANNEL_NOT_FOUND", action: "failed" }, [OM.K_TICKET_INVALID]: { desc: "K_TICKET_INVALID", action: "failed" }, [OM.K_CHANNEL_CONFLICTED]: { desc: "K_CHANNEL_CONFLICTED", action: "failed" }, [OM.K_SERVICE_NOT_READY]: { desc: "K_SERVICE_NOT_READY", action: "tryNext" }, [OM.K_SERVICE_TOO_HEAVY]: { desc: "K_SERVICE_TOO_HEAVY", action: "tryNext" }, [OM.K_UID_BANNED]: { desc: "K_UID_BANNED", action: "failed" }, [OM.K_IP_BANNED]: { desc: "K_IP_BANNED", action: "failed" }, [OM.DATASTREAM2_NOT_AVAILABLE]: { desc: "DATASTREAM2_NOT_AVAILABLE", action: "quit" }, [OM.K_AUTO_REBALANCE]: { desc: "k_AUTO_REBALANCE", action: "recover" }, [OM.ERR_INVALID_VENDOR_KEY]: { desc: "ERR_INVALID_VENDOR_KEY", action: "failed" }, [OM.ERR_INVALID_CHANNEL_NAME]: { desc: "ERR_INVALID_CHANNEL_NAME", action: "failed" }, [OM.WARN_NO_AVAILABLE_CHANNEL]: { desc: "WARN_NO_AVAILABLE_CHANNEL", action: "failed" }, [OM.WARN_LOOKUP_CHANNEL_TIMEOUT]: { desc: "WARN_LOOKUP_CHANNEL_TIMEOUT", action: "tryNext" }, [OM.WARN_LOOKUP_CHANNEL_REJECTED]: { desc: "WARN_LOOKUP_CHANNEL_REJECTED", action: "failed" }, [OM.WARN_OPEN_CHANNEL_TIMEOUT]: { desc: "WARN_OPEN_CHANNEL_TIMEOUT", action: "tryNext" }, [OM.WARN_OPEN_CHANNEL_REJECTED]: { desc: "WARN_OPEN_CHANNEL_REJECTED", action: "failed" }, [OM.WARN_REQUEST_DEFERRED]: { desc: "WARN_REQUEST_DEFERRED", action: "failed" }, [OM.ERR_DYNAMIC_KEY_TIMEOUT]: { desc: "ERR_DYNAMIC_KEY_TIMEOUT", action: "failed" }, [OM.ERR_NO_AUTHORIZED]: { desc: "ERR_NO_AUTHORIZED", action: "failed" }, [OM.ERR_VOM_SERVICE_UNAVAILABLE]: { desc: "ERR_VOM_SERVICE_UNAVAILABLE", action: "tryNext" }, [OM.ERR_NO_CHANNEL_AVAILABLE_CODE]: { desc: "ERR_NO_CHANNEL_AVAILABLE_CODE", action: "failed" }, [OM.ERR_MASTER_VOCS_UNAVAILABLE]: { desc: "ERR_MASTER_VOCS_UNAVAILABLE", action: "tryNext" }, [OM.ERR_INTERNAL_ERROR]: { desc: "ERR_INTERNAL_ERROR", action: "tryNext" }, [OM.ERR_NO_ACTIVE_STATUS]: { desc: "ERR_NO_ACTIVE_STATUS", action: "failed" }, [OM.ERR_INVALID_UID]: { desc: "ERR_INVALID_UID", action: "failed" }, [OM.ERR_DYNAMIC_KEY_EXPIRED]: { desc: "ERR_DYNAMIC_KEY_EXPIRED", action: "failed" }, [OM.ERR_STATIC_USE_DYANMIC_KE]: { desc: "ERR_STATIC_USE_DYANMIC_KE", action: "failed" }, [OM.ERR_DYNAMIC_USE_STATIC_KE]: { desc: "ERR_DYNAMIC_USE_STATIC_KE", action: "failed" }, [OM.ERR_NO_VOCS_AVAILABLE]: { desc: "ERR_NO_VOCS_AVAILABLE", action: "tryNext" }, [OM.ERR_NO_VOS_AVAILABLE]: { desc: "ERR_NO_VOS_AVAILABLE", action: "tryNext" }, [OM.ERR_JOIN_CHANNEL_TIMEOUT]: { desc: "ERR_JOIN_CHANNEL_TIMEOUT", action: "tryNext" }, [OM.ERR_JOIN_BY_MULTI_IP]: { desc: "ERR_JOIN_BY_MULTI_IP", action: "recover" }, [OM.ERR_NOT_JOINED]: { desc: "ERR_NOT_JOINED", action: "failed" }, [OM.ERR_REPEAT_JOIN_REQUEST]: { desc: "ERR_REPEAT_JOIN_REQUEST", action: "quit" }, [OM.ERR_REPEAT_JOIN_CHANNEL]: { desc: "ERR_REPEAT_JOIN_CHANNEL", action: "quit" }, [OM.ERR_INVALID_STRINGUID]: { desc: "ERR_INVALID_STRINGUID", action: "failed" }, [OM.ERR_TOO_MANY_USERS]: { desc: "ERR_TOO_MANY_USERS", action: "tryNext" }, [OM.ERR_SET_CLIENT_ROLE_TIMEOUT]: { desc: "ERR_SET_CLIENT_ROLE_TIMEOUT", action: "failed" }, [OM.ERR_SET_CLIENT_ROLE_NO_PERMISSION]: { desc: "ERR_SET_CLIENT_ROLE_TIMEOUT", action: "failed" }, [OM.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE]: { desc: "ERR_SET_CLIENT_ROLE_ALREADY_IN_USE", action: "success" }, [OM.ERR_PUBLISH_REQUEST_INVALID]: { desc: "ERR_PUBLISH_REQUEST_INVALID", action: "failed" }, [OM.ERR_SUBSCRIBE_REQUEST_INVALID]: { desc: "ERR_SUBSCRIBE_REQUEST_INVALID", action: "failed" }, [OM.ERR_NOT_SUPPORTED_MESSAGE]: { desc: "ERR_NOT_SUPPORTED_MESSAGE", action: "failed" }, [OM.ERR_ILLEAGAL_PLUGIN]: { desc: "ERR_ILLEAGAL_PLUGIN", action: "failed" }, [OM.ILLEGAL_CLIENT_ROLE_LEVEL]: { desc: "ILLEGAL_CLIENT_ROLE_LEVEL", action: "failed" }, [OM.ERR_REJOIN_TOKEN_INVALID]: { desc: "ERR_REJOIN_TOKEN_INVALID", action: "failed" }, [OM.ERR_REJOIN_USER_NOT_JOINED]: { desc: "ERR_REJOIN_NOT_JOINED", action: "failed" }, [OM.ERR_INVALID_OPTIONAL_INFO]: { desc: "ERR_INVALID_OPTIONAL_INFO", action: "quit" }, [OM.ERR_TEST_RECOVER]: { desc: "ERR_TEST_RECOVER", action: "recover" }, [OM.ERR_TEST_TRYNEXT]: { desc: "ERR_TEST_TRYNEXT", action: "recover" }, [OM.ERR_TEST_RETRY]: { desc: "ERR_TEST_RETRY", action: "recover" }, [OM.ILLEGAL_AES_PASSWORD]: { desc: "ERR_TEST_RETRY", action: "failed" }, [OM.ERR_TOO_MANY_BROADCASTERS]: { desc: "ERR_TOO_MANY_BROADCASTERS", action: "failed" }, [OM.ERR_TOO_MANY_SUBSCRIBERS]: { desc: "ERR_TOO_MANY_SUBSCRIBERS", action: "failed" }, [OM.ERR_LICENSE_ILLEGAL]: { desc: "ERR_LICENSE_ILLEGAL", action: "quit" }, [OM.ERR_LICENSE_MISSING]: { desc: "ERR_LICENSE_MISSING", action: "quit" }, [OM.ERR_LICENSE_EXPIRED]: { desc: "ERR_LICENSE_EXPIRED", action: "quit" }, [OM.ERR_LICENSE_MINUTES_EXCEEDED]: { desc: "ERR_LICENSE_MINUTES_EXCEEDED", action: "quit" }, [OM.ERR_LICENSE_PERIOD_INVALID]: { desc: "ERR_LICENSE_PERIOD_INVALID", action: "quit" }, [OM.ERR_LICENSE_MULTIPLE_SDK_SERVICE]: { desc: "ERR_LICENSE_MULTIPLE_SDK_SERVICE", action: "quit" } };
      function PU(e2) {
        const t2 = DU[e2];
        return t2 || { desc: "UNKNOWN_ERROR_".concat(e2), action: "failed" };
      }
      function LU(e2, t2) {
        var i3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i3.push.apply(i3, n2);
        }
        return i3;
      }
      function kU(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i3 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? LU(Object(i3), true).forEach(function(t3) {
            QI(e2, t3, i3[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : LU(Object(i3)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
          });
        }
        return e2;
      }
      function MU(e2, t2) {
        if ("string" == typeof e2)
          return e2;
        const { proxy: i3, host: n2, port: r2 } = e2;
        if (t2) {
          const e3 = dN("JOIN_GATEWAY_FALLBACK_PORT") || 443;
          return 443 === e3 ? "wss://".concat(n2, "/ws/?p=").concat(Number(r2) + 150) : "wss://".concat(n2, ":").concat(e3, "/ws/?p=").concat(Number(r2) + 150);
        }
        return i3 ? "wss://".concat(i3, "/ws/?h=").concat(n2, "&p=").concat(r2) : "wss://".concat(n2, ":").concat(r2);
      }
      const UU = /wss:\/\/(.+)\/ws\/\?h=(.+)&p=([0-9]+)\/?/, xU = /wss:\/\/(.+)\/ws\/\?p=([0-9]+)\/?/, VU = /wss:\/\/(.+):([0-9]+)\/?/, FU = /wss:\/\/(.[^\/]+)\/?/;
      let BU = 0;
      class jU {
        constructor(e2, t2) {
          QI(this, "id", 0), QI(this, "store", void 0), QI(this, "recordIndex", void 0), QI(this, "websockets", []), QI(this, "try443PortDuration", 2e3), QI(this, "forceCloseWSDuration", 5e3), QI(this, "try443PortTimeout", null), QI(this, "forceCloseTimeout", null), QI(this, "isTry443PortFailed", false), QI(this, "isNormalPortFailed", false), QI(this, "useDoubleDomain", false), QI(this, "useProxy", false), QI(this, "startTime", Date.now()), this.id = ++BU, this.try443PortDuration = dN("JOIN_GATEWAY_TRY_443PORT_DURATION") || 2e3, this.forceCloseWSDuration = e2 || 5e3, this.store = t2;
        }
        closeAllWebsockets() {
          this.websockets.forEach((e2) => {
            e2.onopen = null, e2.onclose = null, e2.onmessage = null, e2.close();
          }), this.websockets.length = 0;
        }
        clearTimeout() {
          this.forceCloseTimeout && clearTimeout(this.forceCloseTimeout), this.try443PortTimeout && clearTimeout(this.try443PortTimeout), this.forceCloseTimeout = null, this.try443PortTimeout = null;
        }
        logger() {
          var e2;
          const t2 = Date.now() - this.startTime;
          for (var i3 = arguments.length, n2 = new Array(i3), r2 = 0; r2 < i3; r2++)
            n2[r2] = arguments[r2];
          BN.debug("[choose-best-ws ".concat(null === (e2 = this.store) || void 0 === e2 ? void 0 : e2.clientId, " ").concat(this.id, "] ").concat(t2, "ms:"), ...n2);
        }
        createWebSocket(e2, t2, i3) {
          this.logger("createWebSocket:", e2, { isTry443Port: t2, hasTimeoutDetection: i3 });
          const n2 = dN("GATEWAY_DOMAINS"), r2 = Date.now(), o2 = [], s2 = n2.find((t3) => {
            var i4;
            return Dn(i4 = e2.host).call(i4, t3);
          });
          s2 || (this.useDoubleDomain = false);
          const a2 = [];
          if (this.useDoubleDomain)
            n2.forEach((i4) => {
              a2.push(MU(kU(kU({}, e2), {}, { host: e2.host.replace(s2, i4) }), t2));
            });
          else {
            const i4 = kU({}, e2);
            if (t2 && s2) {
              const e3 = n2.find((e4) => e4 !== s2);
              e3 && (i4.host = i4.host.replace(s2, e3));
            }
            a2.push(MU(i4, t2));
          }
          try {
            a2.forEach((e3) => {
              const t3 = new WebSocket(e3);
              t3.binaryType = "arraybuffer", o2.push(t3), this.logger("ws is connecting:", t3.url);
            });
          } catch (n3) {
            if (this.logger("ws create failed"), o2.forEach((e3) => e3.close()), o2.length = 0, this.useDoubleDomain)
              return this.useDoubleDomain = false, this.createWebSocket(e2, t2, i3);
            if (!t2 && 443 !== Number(e2.port))
              return this.createWebSocket(e2, true, i3);
            throw new XN(_w.WS_ERR, "init websocket failed! Error: ".concat(n3.toString()));
          }
          const c2 = wb();
          this.store && this.store.recordJoinChannelService({ urls: o2.map((e3) => e3.url), service: "gateway" }, this.recordIndex), o2.forEach((e3) => {
            e3.onopen = () => {
              this.logger("onopen: ws ".concat(e3.url, " open cost ").concat(Date.now() - r2, "ms")), this.websockets.forEach((t3) => {
                t3 !== e3 && (t3.onopen = null, t3.onclose = null, t3.onmessage = null, t3.close(), this.logger("close backup websocket: ".concat(t3.url)));
              }), this.websockets.length = 0, c2.resolve(e3);
            }, e3.onclose = (i4) => {
              this.logger("onclose: ws ".concat(e3.url, " closed cost ").concat(Date.now() - r2, "ms state: ").concat(e3.readyState));
              const n3 = o2.every((e4) => e4.readyState === WebSocket.CLOSED || e4.readyState === WebSocket.CLOSING);
              this.logger("".concat(t2 ? "443" : "47xx", " websocket closed, all failed: ").concat(n3)), n3 && (t2 || this.isTry443PortFailed || this.useProxy) ? (this.logger("onclose: all websocket is closed, ".concat(i4.reason)), c2.reject({ code: i4.code, reason: eU.A_ROUND_WS_FAILED })) : !t2 && n3 && !this.isNormalPortFailed && this.try443PortTimeout && (this.logger("all 47xx websocket is closed, try 443 port"), this.clearTimeout(), l2()), t2 ? this.isTry443PortFailed = n3 : this.isNormalPortFailed = n3;
            }, e3.onmessage = (t3) => this.logger("".concat(e3.url, " onmessage: ").concat(t3.data));
          }), this.websockets.push(...o2);
          const d2 = () => {
            this.websockets.forEach((e3) => e3.readyState !== WebSocket.OPEN && e3.close());
          }, l2 = () => {
            if (c2.isResolved)
              return d2();
            xb().os === Pb.MAC_OS && Kb() && d2(), this.createWebSocket(e2, true, true).then((e3) => {
              c2.resolve(e3);
            }).catch((e3) => {
              this.isNormalPortFailed && c2.reject(e3), this.logger("try 443 port to create ws failed");
            }), this.forceCloseTimeout = window.setTimeout(() => {
              this.logger("5s timeout close un-opens, isWebsocket created: ", c2.isResolved), this.forceCloseTimeout = null, d2();
            }, this.forceCloseWSDuration);
          };
          return i3 || (() => {
            if (t2 || this.useProxy)
              return this.logger("add 5s timeout at ".concat(t2 ? "try-443" : "proxy", " condition")), this.forceCloseTimeout = window.setTimeout(() => {
                this.forceCloseTimeout = null, d2();
              }, this.forceCloseWSDuration);
            this.try443PortTimeout = window.setTimeout(() => {
              this.logger("2s timeout, isWebsocket created: ", c2.isResolved), this.try443PortTimeout = null, l2();
            }, this.try443PortDuration);
          })(), c2.promise;
        }
        chooseBestWebsocket(e2, t2, i3, n2) {
          return this.useDoubleDomain = !!t2, "string" == typeof e2 && (e2 = function(e3) {
            let t3, i4, n3;
            return [, t3, i4, n3] = e3.match(UU) || [], t3 || ([, i4, n3] = e3.match(xU) || []), i4 && n3 || ([, i4, n3] = e3.match(VU) || []), i4 && n3 || ([, i4] = e3.match(FU) || []), i4 || BN.warning("un-destructible url: ", e3), { proxy: t3, host: i4, port: n3 || "443" };
          }(e2)), this.recordIndex = n2, this.useProxy = !!e2.proxy, i3 && this.useProxy && (BN.warn("cannot use 443 only when use proxy"), i3 = false), this.createWebSocket(e2, !!i3, false).finally(() => this.clearTimeout());
        }
      }
      function GU(e2, t2) {
        var i3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i3.push.apply(i3, n2);
        }
        return i3;
      }
      class WU extends Nw {
        get url() {
          return this.websocket && this.websocket.url || null;
        }
        get reconnectMode() {
          return this._reconnectMode;
        }
        set reconnectMode(e2) {
          var t2;
          Dn(t2 = ["tryNext", "recover"]).call(t2, e2) && this.resetReconnectCount(e2), this._reconnectMode = e2;
        }
        get state() {
          return this._state;
        }
        set state(e2) {
          e2 !== this._state && (this._state = e2, "reconnecting" === this._state ? this.emit(UM.RECONNECTING, this.reconnectReason) : "connected" === this._state ? this.emit(UM.CONNECTED) : "closed" === this._state ? this.emit(UM.CLOSED) : "failed" === this._state && this.emit(UM.FAILED));
        }
        resetReconnectCount(e2) {
          BN.debug("websocket reset reconnect count, reason: " + e2), this.reconnectCount = 0;
        }
        constructor(e2, t2) {
          let i3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], n2 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], r2 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], o2 = arguments.length > 5 ? arguments[5] : void 0;
          super(), QI(this, "connectionID", 0), QI(this, "currentURLIndex", 0), QI(this, "urls", []), QI(this, "_reconnectMode", "tryNext"), QI(this, "reconnectReason", void 0), QI(this, "_initMutex", void 0), QI(this, "name", void 0), QI(this, "_state", "closed"), QI(this, "reconnectInterrupter", void 0), QI(this, "websocket", void 0), QI(this, "retryConfig", void 0), QI(this, "reconnectCount", 0), QI(this, "forceCloseTimeout", 5e3), QI(this, "onlineReconnectListener", void 0), QI(this, "useCompress", void 0), QI(this, "tryDoubleDomain", false), QI(this, "use443PortOnly", false), QI(this, "wsInflateLength", 0), QI(this, "wsDeflateLength", 0), QI(this, "closeEstablishingWs", () => {
          }), QI(this, "store", void 0), QI(this, "joinGatewayRecordIndex", void 0), this.store = o2, this.name = e2, this.retryConfig = function(e3) {
            for (var t3 = 1; t3 < arguments.length; t3++) {
              var i4 = null != arguments[t3] ? arguments[t3] : {};
              t3 % 2 ? GU(Object(i4), true).forEach(function(t4) {
                QI(e3, t4, i4[t4]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i4)) : GU(Object(i4)).forEach(function(t4) {
                Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i4, t4));
              });
            }
            return e3;
          }({}, t2), this.useCompress = i3, this.tryDoubleDomain = n2, this.use443PortOnly = r2, this._initMutex = new vO("websocket", o2 ? o2.clientId : void 0);
          const { timeout: s2, timeoutFactor: a2 } = t2, c2 = Math.max(300, Math.floor(3 * s2 / 5)), d2 = Math.max(1.2, Math.floor(8 * a2) / 10);
          Ww.ONLINE && (this.retryConfig.timeout = c2, this.retryConfig.timeoutFactor = d2), Xw.on(Hw.NETWORK_STATE_CHANGE, (e3, t3) => {
            e3 !== t3 && (this.resetReconnectCount("network state change: ".concat(t3, " -> ").concat(e3)), e3 === Ww.ONLINE ? (this.retryConfig.timeout = c2, this.retryConfig.timeoutFactor = d2) : (this.retryConfig.timeout = s2, this.retryConfig.timeoutFactor = a2));
          });
        }
        getConnection() {
          return this.websocket || void 0;
        }
        async init(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
          const i3 = await this._initMutex.lock();
          this._reconnectMode = "tryNext", this.forceCloseTimeout = t2, this.urls = e2, this.state = "connecting";
          try {
            const e3 = wb(), t3 = this.urls[this.currentURLIndex];
            dN("ENABLE_PREALLOC_PC") && this.emit(gU.PRE_CONNECT_PC), this.createWebSocketConnection(t3).then(e3.resolve).catch(e3.reject), this.once(UM.CLOSED, () => {
              e3.reject(new Ew(_w.WS_DISCONNECT));
            }), this.once(UM.CONNECTED, e3.resolve), await e3.promise;
          } catch (e3) {
          } finally {
            i3();
          }
        }
        close(e2, t2) {
          if (this.currentURLIndex = 0, this.resetReconnectCount("close"), this.reconnectInterrupter && this.reconnectInterrupter(), this.websocket) {
            this.websocket.onclose = null, this.websocket.onopen = null, this.websocket.onmessage = null;
            const e3 = this.websocket;
            t2 ? setTimeout(() => e3.close(), 500) : e3.close(), this.websocket = void 0;
          }
          this.state = e2 ? "failed" : "closed", this.closeEstablishingWs && this.closeEstablishingWs();
        }
        reconnect(e2, t2) {
          if (!this.websocket)
            return void BN.warning("[".concat(this.name, "] can not reconnect, no websocket"));
          void 0 !== e2 && (this.reconnectMode = e2), BN.debug("[".concat(this.name, "] reconnect is triggered initiative")), "number" == typeof this.joinGatewayRecordIndex && this.store && this.store.recordJoinChannelService({ status: "error", errors: [new Error(t2)] }, this.joinGatewayRecordIndex);
          const i3 = this.websocket.onclose;
          this.websocket.onclose = null, this.websocket.close(), i3 && i3.bind(this.websocket)({ code: 9999, reason: t2 });
        }
        sendMessage(e2) {
          let t2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN)
            throw new Ew(_w.WS_ABORT, "websocket is not ready");
          try {
            t2 || (e2 = JSON.stringify(e2)), this.websocket.send(e2);
          } catch (e3) {
            throw new Ew(_w.WS_ERR, "send websocket message error" + e3.toString());
          }
        }
        setWsInflateData(e2) {
          this.wsDeflateLength = this.wsDeflateLength + e2.originLength, this.wsInflateLength = this.wsInflateLength + e2.compressedLength;
        }
        getWsInflateData() {
          const e2 = this.wsInflateLength, t2 = this.wsDeflateLength;
          return this.clearWsInflateData(), { wsInflateLength: e2, wsDeflateLength: t2 };
        }
        clearWsInflateData() {
          this.wsInflateLength = 0, this.wsDeflateLength = 0;
        }
        async createWebSocketConnection(e2) {
          var t2;
          const i3 = wb();
          this.connectionID += 1, this.joinGatewayRecordIndex = void 0;
          const n2 = (e3) => {
            var t3;
            null === (t3 = this.store) || void 0 === t3 || t3.signalChannelOpen(), BN.debug("[".concat(this.name, "] websocket opened:"), e3), this.reconnectMode = "retry", this.state = "connected", this.resetReconnectCount("opened"), i3.resolve();
          }, r2 = async (e3) => {
            var t3;
            if (BN.debug("[".concat(this.name, "] websocket close ").concat(null === (t3 = this.websocket) || void 0 === t3 ? void 0 : t3.url, ", code: ").concat(e3.code, ", reason: ").concat(e3.reason, ", current mode: ").concat(this.reconnectMode)), this.reconnectCount >= this.retryConfig.maxRetryCount)
              i3.reject(new Ew(_w.WS_DISCONNECT, "websocket close: ".concat(e3.code))), this.close();
            else {
              "connected" === this.state && (this.reconnectReason = e3.reason, this.state = "reconnecting");
              const t4 = qw(this, UM.WILL_RECONNECT, this.reconnectMode, e3.reason) || this.reconnectMode, n3 = await this.reconnectWithAction(t4);
              if ("closed" === this.state)
                return void BN.debug("[".concat(this.connectionID, "] ws is closed, no need to reconnect"));
              if (!n3)
                return i3.reject(new Ew(_w.WS_DISCONNECT, "websocket reconnect failed: ".concat(e3.code))), this.close(true);
              i3.resolve();
            }
          }, o2 = (e3) => {
            this.emit(UM.ON_MESSAGE, e3);
          }, s2 = (e3) => {
            BN.warn("[".concat(this.connectionID, "] ws open error ").concat(e3));
          };
          this.websocket && (this.websocket.onclose = null, this.websocket.close()), dN("GATEWAY_WSS_ADDRESS") && this.name.startsWith("gateway") && (e2 = dN("GATEWAY_WSS_ADDRESS")), BN.debug("[".concat(this.name, "] start connect, url:"), e2);
          const a2 = null === (t2 = this.store) || void 0 === t2 ? void 0 : t2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "gateway" });
          try {
            var c2;
            const t3 = await this.chooseBestWebsocketConnection(e2);
            this.websocket = t3, n2 && n2(this.websocket.url), this.websocket.onclose = r2, this.websocket.onmessage = o2, this.websocket.onerror = s2, null === (c2 = this.store) || void 0 === c2 || c2.recordJoinChannelService({ endTs: Date.now(), status: "success" }, a2), this.joinGatewayRecordIndex = a2;
          } catch (e3) {
            const t3 = "closed" === this.state, n3 = e3 instanceof Ew, o3 = n3 && e3.code === _w.WS_ABORT, s3 = n3 && e3.code === _w.WS_ERR, c3 = n3 ? e3.message : e3 && (e3.reason || e3.toString());
            BN.warning("[choose-best-ws] chooseBestWebsocket error: ".concat(c3)), this.store && this.store.recordJoinChannelService({ endTs: Date.now(), status: o3 ? "aborted" : "error", errors: [e3] }, a2), t3 || s3 ? (i3.reject(t3 ? new Ew(_w.WS_DISCONNECT, "websocket is closed: ".concat(c3)) : new Ew(_w.WS_ERR, "init websocket failed: ".concat(c3))), s3 && BN.error("[".concat(this.name, "] init websocket failed: ").concat(c3))) : r2 && r2(e3);
          }
          return i3.promise;
        }
        async reconnectWithAction(e2) {
          let t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          if (this.reconnectCount >= this.retryConfig.maxRetryCount)
            return false;
          if (0 === this.urls.length)
            return false;
          if ("closed" === this.state)
            return false;
          BN.warning("[choose-best-ws] action: =>", e2), this.onlineReconnectListener || Xw.isOnline || !Xw.onlineWaiter || (this.onlineReconnectListener = Xw.onlineWaiter.then(() => {
            this.onlineReconnectListener = void 0;
          }));
          let i3 = true;
          if (this.reconnectInterrupter = () => i3 = false, t2) {
            const t3 = AO(this.reconnectCount, this.retryConfig);
            BN.debug("[".concat(this.name, "] wait ").concat(t3, "ms to reconnect websocket, mode: ").concat(e2)), await Wh.race([lO(t3), this.onlineReconnectListener || new Wh(() => {
            })]);
          }
          if ("closed" === this._state || !i3)
            return false;
          this.reconnectCount += 1;
          const n2 = async (e3, t3) => {
            this.emit(UM.RECONNECT_CREATE_CONNECTION, t3), await this.createWebSocketConnection(e3);
          };
          try {
            if ("retry" === e2)
              await n2(this.urls[this.currentURLIndex], e2);
            else if ("tryNext" === e2) {
              if (this.currentURLIndex += 1, this.currentURLIndex >= this.urls.length)
                return this.reconnectWithAction("recover", false);
              BN.debug("[".concat(this.name, "] websocket url length: ").concat(this.urls.length, " current index: ").concat(this.currentURLIndex)), await n2(this.urls[this.currentURLIndex], e2);
            } else
              "recover" === e2 && (BN.debug("[".concat(this.name, "] request new urls")), this.resetReconnectCount("recover mode"), this.urls = await Kw(this, UM.REQUEST_NEW_URLS), this.currentURLIndex = 0, await n2(this.urls[this.currentURLIndex], e2));
          } catch (i4) {
            var r2;
            BN.error("[".concat(this.name, "] reconnect failed ").concat(i4 && i4.toString()));
            const n3 = null == i4 || null === (r2 = i4.data) || void 0 === r2 ? void 0 : r2.desc;
            return Array.isArray(n3) && Dn(n3).call(n3, "dynamic key expired") ? (this.emit(UM.ON_TOKEN_PRIVILEGE_DID_EXPIRE), false) : this.reconnectWithAction(e2, t2);
          }
          return true;
        }
      }
      class HU extends WU {
        constructor(e2, t2) {
          super(e2, t2, arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 && void 0 !== arguments[3] && arguments[3], arguments.length > 4 && void 0 !== arguments[4] && arguments[4], arguments.length > 5 ? arguments[5] : void 0);
        }
        async chooseBestWebsocketConnection(e2, t2) {
          const i3 = wb(), n2 = function(e3, t3) {
            return new jU(e3, t3);
          }(this.forceCloseTimeout, this.store);
          this.closeEstablishingWs = () => {
            BN.debug("[choose-best-ws] close establishing websockets"), n2.closeAllWebsockets(), i3.reject(new Ew(_w.WS_ABORT, "choose best websocket aborted"));
          };
          const r2 = dN("GATEWAY_DOMAINS");
          return BN.debug("[choose-best-ws] currentDomain: ", e2, ", domains: ", r2, "total: ".concat(this.urls.length), "current: ".concat(this.currentURLIndex + 1)), n2.chooseBestWebsocket(e2, this.tryDoubleDomain, this.use443PortOnly, t2).then(i3.resolve).catch(i3.reject), i3.promise.finally(() => {
            this.closeEstablishingWs = void 0;
          });
        }
      }
      class KU extends WU {
        constructor(e2, t2) {
          super(e2, t2, arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 && void 0 !== arguments[3] && arguments[3], arguments.length > 4 && void 0 !== arguments[4] && arguments[4], arguments.length > 5 ? arguments[5] : void 0);
        }
        async chooseBestWebsocketConnection(e2, t2) {
          return new Wh((i3, n2) => {
            let r2 = false;
            const o2 = [];
            this.closeEstablishingWs = () => {
              BN.debug("[choose-best-ws] close establishing websockets"), o2.forEach((e3) => {
                e3.onclose = null, e3.onopen = null, e3.onmessage = null, e3.close();
              }), n2(new Ew(_w.WS_ABORT, "choose best websocket aborted"));
            };
            const s2 = dN("GATEWAY_DOMAINS");
            let a2;
            const c2 = e2.indexOf("?h="), d2 = s2.find((t3) => -1 !== c2 ? Dn(e2).call(e2, t3, c2) : Dn(e2).call(e2, t3));
            BN.debug("[choose-best-ws] currentDomain: ", d2, ", domains: ", s2);
            let l2 = !this.tryDoubleDomain || !d2;
            if (!l2 && d2) {
              var u2;
              const h3 = Date.now();
              try {
                s2.forEach((t3) => {
                  const i4 = -1 === c2 ? e2.replace(d2, t3) : e2.substr(0, c2) + e2.substr(c2).replace(d2, t3), n3 = new WebSocket(i4);
                  n3.binaryType = "arraybuffer", o2.push(n3), BN.debug("[choose-best-ws] ws is connecting:", n3.url);
                });
              } catch (e3) {
                for (BN.debug("[choose-best-ws] ws create failed, fallback to single url"), o2.forEach((e4) => e4.close()); o2.length; )
                  o2.pop();
                l2 = true;
              }
              null === (u2 = this.store) || void 0 === u2 || u2.recordJoinChannelService({ urls: o2.map((e3) => e3.url), service: "gateway" }, t2), o2.forEach((e3) => {
                e3.onopen = () => {
                  if (r2)
                    return;
                  const t3 = Date.now() - h3;
                  BN.debug("[choose-best-ws] ws open cost ".concat(t3, "ms")), o2.filter((t4) => t4 !== e3).forEach((e4) => {
                    BN.debug("[choose-best-ws]close backup websocket: ".concat(e4.url)), e4.close();
                  }), r2 = true, i3(e3);
                }, e3.onclose = (e4) => {
                  if (a2 = e4, r2)
                    return;
                  o2.find((e5) => !(e5.readyState === WebSocket.CLOSED || e5.readyState === WebSocket.CLOSING)) || (BN.debug("[choose-best-ws] all websocket is closed"), r2 = true, n2(a2));
                }, e3.onmessage = (t3) => {
                  BN.debug("[choose-best-ws]".concat(e3.url, " onmessage: ").concat(t3.data));
                };
              }), lO(this.forceCloseTimeout).then(() => {
                o2.forEach((e3) => {
                  e3.readyState !== WebSocket.OPEN && e3.close();
                });
              });
            }
            if (l2) {
              var h2;
              let r3;
              BN.debug("[choose-best-ws] use single url: ", e2), null === (h2 = this.store) || void 0 === h2 || h2.recordJoinChannelService({ urls: [e2], service: "gateway" }, t2);
              try {
                r3 = new WebSocket(e2), o2.push(r3), r3.binaryType = "arraybuffer";
              } catch (e3) {
                const t3 = new Ew(_w.WS_ERR, "init websocket failed! Error: ".concat(e3.toString()));
                return BN.error("[".concat(this.name, "]").concat(t3)), void n2(t3);
              }
              r3.onopen = () => {
                i3(r3);
              }, r3.onclose = (e3) => {
                n2(e3);
              }, r3.onmessage = (e3) => {
                BN.debug("[choose-best-ws]".concat(r3.url, " onmessage: ").concat(e3.data));
              }, lO(this.forceCloseTimeout).then(() => {
                r3 && r3.readyState !== WebSocket.OPEN && r3.close();
              });
            }
          }).then((e3) => (this.closeEstablishingWs = void 0, e3)).catch((e3) => {
            throw this.closeEstablishingWs = void 0, e3;
          });
        }
      }
      class YU extends Nw {
        get connectionState() {
          return this._connectionState;
        }
        set connectionState(e2) {
          e2 !== this._connectionState && (this._connectionState = e2, e2 === NM.CONNECTED ? this.emit(DM.WS_CONNECTED) : e2 === NM.RECONNECTING ? this.emit(DM.WS_RECONNECTING, this._websocketReconnectReason) : e2 === NM.CLOSED && this.emit(DM.WS_CLOSED, this._disconnectedReason));
        }
        get currentURLIndex() {
          return this.websocket.currentURLIndex;
        }
        get url() {
          return this.websocket && this.websocket.url || null;
        }
        get rtt() {
          return this.rttRolling.mean();
        }
        constructor(e2, t2) {
          super(), QI(this, "_disconnectedReason", void 0), QI(this, "_websocketReconnectReason", void 0), QI(this, "_connectionState", NM.CLOSED), QI(this, "reconnectToken", void 0), QI(this, "websocket", void 0), QI(this, "openConnectionTime", void 0), QI(this, "clientId", void 0), QI(this, "lastMsgTime", Date.now()), QI(this, "uploadCache", []), QI(this, "uploadCacheInterval", void 0), QI(this, "rttRolling", new OO(5)), QI(this, "pingpongTimer", void 0), QI(this, "wsInflateDataTimer", void 0), QI(this, "pingpongTimeoutCount", 0), QI(this, "joinResponse", void 0), QI(this, "multiIpOption", void 0), QI(this, "initError", void 0), QI(this, "spec", void 0), QI(this, "store", void 0), QI(this, "onWebsocketMessage", (e3) => {
            if (e3.data instanceof ArrayBuffer)
              return void this.emit(DM.ON_BINARY_DATA, e3.data);
            const t3 = JSON.parse(e3.data);
            if (this.lastMsgTime = Date.now(), Object.prototype.hasOwnProperty.call(t3, "_id")) {
              const e4 = "res-@".concat(t3._id);
              this.emit(e4, t3._result, t3._message);
            } else if (Object.prototype.hasOwnProperty.call(t3, "_type")) {
              if (this.emit(t3._type, t3._message), t3._type === kM.ON_NOTIFICATION && this.handleNotification(t3._message), t3._type === kM.ON_USER_BANNED)
                switch (t3._message.error_code) {
                  case 14:
                    this.close(xw.UID_BANNED);
                    break;
                  case 15:
                    this.close(xw.IP_BANNED);
                    break;
                  case 16:
                    this.close(xw.CHANNEL_BANNED);
                }
              if (t3._type === kM.ON_USER_LICENSE_BANNED)
                switch (t3._message.error_code) {
                  case OM.ERR_LICENSE_MISSING:
                    this.close(xw.LICENSE_MISSING);
                    break;
                  case OM.ERR_LICENSE_EXPIRED:
                    this.close(xw.LICENSE_EXPIRED);
                    break;
                  case OM.ERR_LICENSE_MINUTES_EXCEEDED:
                    this.close(xw.LICENSE_MINUTES_EXCEEDED);
                    break;
                  case OM.ERR_LICENSE_PERIOD_INVALID:
                    this.close(xw.LICENSE_PERIOD_INVALID);
                    break;
                  case OM.ERR_LICENSE_MULTIPLE_SDK_SERVICE:
                    this.close(xw.LICENSE_MULTIPLE_SDK_SERVICE);
                    break;
                  case OM.ERR_LICENSE_ILLEGAL:
                    this.close(xw.LICENSE_ILLEGAL);
                    break;
                  default:
                    this.close();
                }
            }
          }), this.clientId = e2.clientId, this.spec = e2, this.store = t2, this.websocket = new HU("gateway-".concat(this.clientId), this.spec.retryConfig, true, dN("JOIN_GATEWAY_USE_DUAL_DOMAIN"), dN("JOIN_GATEWAY_USE_443PORT_ONLY"), t2), this.handleWebsocketEvents(), window.addEventListener("offline", () => {
            this.connectionState === NM.CONNECTED && this.reconnect("retry", Gw.OFFLINE);
          });
        }
        async request(e2, t2, i3, n2) {
          const r2 = uO(6, ""), o2 = { _id: r2, _type: e2, _message: t2 }, s2 = this.websocket.connectionID, a2 = () => new Wh((t3, i4) => {
            if (this.connectionState === NM.CONNECTED)
              return t3();
            const n3 = () => {
              this.off(DM.WS_CLOSED, r3), t3();
            }, r3 = () => {
              this.off(DM.WS_CONNECTED, n3), i4(new XN(_w.WS_ABORT));
            };
            this.once(DM.WS_CONNECTED, n3), this.once(DM.WS_CLOSED, r3), e2 !== PM.PUBLISH && e2 !== PM.PUBLISH_DATASTREAM && e2 !== PM.SUBSCRIBE && e2 !== PM.SUBSCRIBE_DATASTREAM && e2 !== PM.UNSUBSCRIBE && e2 !== PM.UNSUBSCRIBE_DATASTREAM && e2 !== PM.UNPUBLISH && e2 !== PM.UNPUBLISH_DATASTREAM && e2 !== PM.CONTROL && e2 !== PM.RESTART_ICE || this.once(DM.DISCONNECT_P2P, () => {
              i4(new XN(_w.DISCONNECT_P2P));
            }), e2 !== PM.PUBLISH && e2 !== PM.RESTART_ICE || this.once(DM.ABORT_P2P_EXECUTION, () => {
              i4(new XN(_w.DISCONNECT_P2P));
            });
          });
          if (this.connectionState !== NM.CONNECTING && this.connectionState !== NM.RECONNECTING || e2 === PM.JOIN || e2 === PM.REJOIN || await a2(), this.websocket.sendMessage(o2, true), n2)
            return;
          const c2 = new Wh((i4, n3) => {
            let o3 = false;
            const a3 = (n4, r3) => {
              o3 = true, i4({ isSuccess: "success" === n4, message: r3 || {} }), this.off(DM.WS_CLOSED, c3), this.off(DM.WS_RECONNECTING, c3), this.emit(DM.REQUEST_SUCCESS, e2, t2);
            };
            this.once("res-@".concat(r2), a3);
            const c3 = () => {
              n3(new XN(_w.WS_ABORT, "type: ".concat(e2))), this.off(DM.WS_CLOSED, c3), this.off(DM.WS_RECONNECTING, c3), this.off("res-@".concat(r2), a3);
            };
            this.once(DM.WS_CLOSED, c3), this.once(DM.WS_RECONNECTING, c3), lO(dN("SIGNAL_REQUEST_TIMEOUT")).then(() => {
              this.websocket.connectionID !== s2 || o3 || (BN.warning("[".concat(this.clientId, "] ws request timeout, type: ").concat(e2)), this.emit(DM.REQUEST_TIMEOUT, e2, t2));
            });
          });
          let d2 = null;
          try {
            d2 = await c2;
          } catch (n3) {
            if (this.connectionState === NM.CLOSED || e2 === PM.LEAVE)
              throw new XN(_w.WS_ABORT);
            return !this.spec.forceWaitGatewayResponse || i3 ? n3.throw() : e2 === PM.JOIN || e2 === PM.REJOIN ? null : (await a2(), await this.request(e2, t2));
          }
          if (d2.isSuccess)
            return d2.message;
          const l2 = Number(d2.message.error_code || d2.message.code), u2 = PU(l2), h2 = new XN(_w.UNEXPECTED_RESPONSE, "".concat(u2.desc, ": ").concat(d2.message.error_str), { code: l2, data: d2.message, desc: u2.desc });
          return "success" === u2.action ? d2.message : (BN.warning("[".concat(this.clientId, "] [").concat(this.websocket.connectionID, "] unexpected response from type ").concat(e2, ", error_code: ").concat(l2, ", message: ").concat(u2.desc, ", action: ").concat(u2.action)), l2 === OM.ERR_TOO_MANY_BROADCASTERS ? e2 === PM.JOIN || e2 === PM.REJOIN ? (this.initError = h2, this.close(), h2.throw()) : h2.throw() : "failed" === u2.action ? h2.throw() : "quit" === u2.action ? (this.initError = h2, this.close(), h2.throw()) : (l2 === OM.ERR_JOIN_BY_MULTI_IP ? (this.multiIpOption = d2.message.option, BN.warning("[".concat(this.clientId, "] detect multi ip, recover")), this.reconnect("recover", Gw.MULTI_IP)) : this.reconnect(u2.action, Gw.SERVER_ERROR), e2 === PM.JOIN || e2 === PM.REJOIN ? null : await this.request(e2, t2)));
        }
        waitMessage(e2, t2) {
          return new Wh((i3) => {
            const n2 = (r2) => {
              (!t2 || t2(r2)) && (this.off(e2, n2), i3(r2));
            };
            this.on(e2, n2);
          });
        }
        uploadWRTCStats(e2) {
          if (!this.store.sessionId)
            return void BN.warn("[".concat(this.clientId, "] no session id when upload wrtc stats"));
          const t2 = { lts: Date.now(), sid: this.store.sessionId, uid: this.store.intUid, stats: e2 };
          this.upload(LM.WRTC_STATS, t2);
        }
        upload(e2, t2) {
          const i3 = { _type: e2, _message: t2 };
          try {
            this.websocket.sendMessage(i3);
          } catch (e3) {
            const t3 = dN("MAX_UPLOAD_CACHE") || 50;
            this.uploadCache.push(i3), this.uploadCache.length > t3 && this.uploadCache.splice(0, 1), this.uploadCache.length > 0 && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval(() => {
              if (this.connectionState !== NM.CONNECTED)
                return;
              const e4 = this.uploadCache.splice(0, 1)[0];
              0 === this.uploadCache.length && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0), this.upload(e4._type, e4._message);
            }, dN("UPLOAD_CACHE_INTERVAL") || 2e3));
          }
        }
        send(e2, t2) {
          const i3 = { _type: e2, _message: t2 };
          this.websocket.sendMessage(i3);
        }
        init(e2) {
          return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, this.openConnectionTime = void 0, new Wh((t2, i3) => {
            this.once(DM.WS_CONNECTED, () => t2(this.joinResponse)), this.once(DM.WS_CLOSED, (e3) => i3(this.initError || new XN(_w.WS_ABORT, e3))), this.connectionState = NM.CONNECTING, this.websocket.init(e2).catch(i3), this.wsInflateDataTimer && window.clearInterval(this.wsInflateDataTimer), this.wsInflateDataTimer = window.setInterval(() => {
              this.handleWsInflateData();
            }, 2e4);
          });
        }
        close(e2) {
          this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.wsInflateDataTimer && (this.handleWsInflateData(), window.clearInterval(this.wsInflateDataTimer), this.wsInflateDataTimer = void 0), this.reconnectToken = void 0, this.joinResponse = void 0, this._disconnectedReason = e2 || xw.LEAVE, this.connectionState = NM.CLOSED, BN.debug("[".concat(this.clientId, "] ") + "will close websocket in signal"), this.websocket.close();
        }
        async join() {
          if (!this.joinResponse) {
            this.emit(DM.ABORT_P2P_EXECUTION);
            const e2 = await Kw(this, DM.REQUEST_JOIN_INFO), t2 = await this.request(PM.JOIN, e2);
            if (!t2)
              return this.emit(DM.REPORT_JOIN_GATEWAY, eU.TIMEOUT, this.url || ""), false;
            this.joinResponse = t2, this.emit(DM.JOIN_RESPONSE, this.joinResponse), this.reconnectToken = this.joinResponse.rejoin_token;
          }
          return this.connectionState = NM.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), true;
        }
        async rejoin() {
          if (!this.reconnectToken)
            throw new XN(_w.UNEXPECTED_ERROR, "can not rejoin, no rejoin token");
          const e2 = zw(this, DM.REQUEST_REJOIN_INFO);
          e2.token = this.reconnectToken;
          const t2 = await this.request(PM.REJOIN, e2);
          return !!t2 && (this.connectionState = NM.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), t2.peers && t2.peers.forEach((e3) => {
            this.emit(kM.ON_USER_ONLINE, { uid: e3.uid }), e3.audio && this.emit(kM.ON_ADD_AUDIO_STREAM, { uid: e3.uid, uint_id: e3.uint_id, audio: true, ssrcId: e3.audio_ssrc }), e3.video && this.emit(kM.ON_ADD_VIDEO_STREAM, { uid: e3.uid, uint_id: e3.uint_id, video: true, ssrcId: e3.video_ssrc }), e3.audio_mute ? this.emit(kM.MUTE_AUDIO, { uid: e3.uid }) : this.emit(kM.UNMUTE_AUDIO, { uid: e3.uid }), e3.video_mute ? this.emit(kM.MUTE_VIDEO, { uid: e3.uid }) : this.emit(kM.UNMUTE_VIDEO, { uid: e3.uid }), e3.audio_enable_local ? this.emit(kM.ENABLE_LOCAL_AUDIO, { uid: e3.uid }) : this.emit(kM.DISABLE_LOCAL_AUDIO, { uid: e3.uid }), e3.video_enable_local ? this.emit(kM.ENABLE_LOCAL_VIDEO, { uid: e3.uid }) : this.emit(kM.DISABLE_LOCAL_VIDEO, { uid: e3.uid }), e3.audio || e3.video || this.emit(kM.ON_REMOVE_STREAM, { uid: e3.uid, uint_id: e3.uint_id });
          }), true);
        }
        reconnect(e2, t2) {
          this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.websocket.reconnect(e2, t2);
        }
        handleNotification(e2) {
          BN.debug("[".concat(this.clientId, "] receive notification: "), e2);
          const t2 = PU(e2.code);
          if (28 === e2.code && "detail" in e2 && (BN.info("[".concat(this.clientId, "] receive recover notification: "), e2.detail), this.emit(DM.RECOVER_NOTIFICATION, e2.detail)), "success" !== t2.action) {
            if ("failed" !== t2.action)
              return "quit" === t2.action ? ("ERR_REPEAT_JOIN_CHANNEL" === t2.desc && this.close(xw.UID_BANNED), void this.close()) : void this.reconnect(t2.action, Gw.SERVER_ERROR);
            BN.error("[".concat(this.clientId, "] ignore error: "), t2.desc);
          }
        }
        handlePingPong() {
          if (!this.websocket || "connected" !== this.websocket.state)
            return;
          this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3), this.pingpongTimeoutCount += 1;
          const e2 = dN("PING_PONG_TIME_OUT"), t2 = Date.now();
          this.pingpongTimeoutCount >= e2 && (BN.warning("[".concat(this.clientId, "] PING-PONG Timeout. Last Socket Message: ").concat(t2 - this.lastMsgTime, "ms")), t2 - this.lastMsgTime > dN("WEBSOCKET_TIMEOUT_MIN")) ? this.reconnect("retry", Gw.TIMEOUT) : this.request(PM.PING, void 0, true).then(() => {
            this.pingpongTimeoutCount = 0;
            const e3 = Date.now() - t2;
            this.rttRolling.add(e3), dN("REPORT_STATS") && this.send(PM.PING_BACK, { pingpongElapse: e3 });
          }).catch((e3) => {
          });
        }
        handleWsInflateData() {
          const { wsInflateLength: e2, wsDeflateLength: t2 } = this.websocket.getWsInflateData();
          0 !== e2 && 0 !== t2 && this.upload(LM.WS_INFLATE_DATA_LENGTH, { ws_deflate_length: t2, ws_inflate_length: e2 });
        }
        handleWebsocketEvents() {
          this.websocket.on(UM.RECONNECT_CREATE_CONNECTION, (e2) => {
            this.emit(DM.WS_RECONNECT_CREATE_CONNECTION, e2);
          }), this.websocket.on(UM.ON_MESSAGE, this.onWebsocketMessage), this.websocket.on(UM.CLOSED, () => {
            this.connectionState = NM.CLOSED;
          }), this.websocket.on(UM.FAILED, () => {
            this._disconnectedReason = xw.NETWORK_ERROR, this.connectionState = NM.CLOSED;
          }), this.websocket.on(UM.RECONNECTING, (e2) => {
            this._websocketReconnectReason = e2, this.joinResponse = void 0, this.connectionState === NM.CONNECTED ? this.connectionState = NM.RECONNECTING : this.connectionState = NM.CONNECTING;
          }), this.websocket.on(UM.WILL_RECONNECT, (e2, t2, i3) => {
            const n2 = zw(this, DM.IS_P2P_DISCONNECTED), r2 = n2 || "retry" !== e2;
            n2 && "retry" === e2 && (BN.debug("".concat(this.clientId, " reconnect mode is retry, but p2p lost, change to tryNext")), e2 = "tryNext", t2 = eU.P2P_DISCONNECTED), r2 && (BN.debug("".concat(this.clientId, " will renewSession, reconnect mode: ").concat(e2)), this.emit(DM.REPORT_JOIN_GATEWAY, t2 || eU.UNKNOWN_REASON, this.url || ""), this.reconnectToken = void 0, this.emit(DM.DISCONNECT_P2P)), i3(e2);
          }), this.websocket.on(UM.CONNECTED, () => {
            this.openConnectionTime = Date.now(), this.reconnectToken ? this.rejoin().catch((e2) => {
              BN.warning("[".concat(this.clientId, "] rejoin failed ").concat(e2)), this.reconnect("tryNext", Gw.SERVER_ERROR);
            }) : this.join().catch((e2) => {
              if (this.emit(DM.REPORT_JOIN_GATEWAY, e2, this.url || ""), e2 instanceof XN) {
                if (e2.code === _w.UNEXPECTED_RESPONSE && e2.data.code === OM.ERR_NO_AUTHORIZED)
                  return this.initError = new XN(_w.TOKEN_EXPIRE, "dynamic key expired"), void this.close(xw.TOKEN_EXPIRE);
                BN.error("[".concat(this.clientId, "] join gateway request failed"), e2.toString()), this.spec.forceWaitGatewayResponse ? this.reconnect("tryNext", Gw.SERVER_ERROR) : (this.initError = e2, this.close());
              }
            });
          }), this.websocket.on(UM.REQUEST_NEW_URLS, (e2, t2) => {
            Kw(this, DM.REQUEST_RECOVER, this.multiIpOption).then(e2).catch(t2);
          }), this.websocket.on(UM.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
            this.emit(kM.ON_TOKEN_PRIVILEGE_DID_EXPIRE);
          }), this.websocket.on(gU.PRE_CONNECT_PC, () => {
            this.emit(DM.PRE_CONNECT_PC);
          });
        }
      }
      let qU = function(e2) {
        return e2[e2.CHOOSE_SERVER = 11] = "CHOOSE_SERVER", e2[e2.CLOUD_PROXY = 18] = "CLOUD_PROXY", e2[e2.CLOUD_PROXY_5 = 20] = "CLOUD_PROXY_5", e2[e2.CLOUD_PROXY_FALLBACK = 26] = "CLOUD_PROXY_FALLBACK", e2;
      }({});
      function zU(e2, t2) {
        var i3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i3.push.apply(i3, n2);
        }
        return i3;
      }
      function XU(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i3 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? zU(Object(i3), true).forEach(function(t3) {
            QI(e2, t3, i3[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : zU(Object(i3)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
          });
        }
        return e2;
      }
      function JU(e2) {
        return e2.match(/^[\.\:\d]+$/) ? "".concat(e2.replace(/[^\d]/g, "-"), ".").concat(dN("TURN_DOMAIN")) : (BN.debug("Cannot recognized as ip address: ".concat(e2, ", use as host")), e2);
      }
      function QU(e2, t2) {
        e2.addresses || (e2.addresses = []);
        const i3 = function(e3, t3) {
          if (dN("CONNECT_GATEWAY_WITHOUT_DOMAIN"))
            return e3.map((e4) => {
              let { ip: t4, port: i5 } = e4;
              return { address: "".concat(t4, ":").concat(i5) };
            });
          const i4 = dN("GATEWAY_DOMAINS");
          let n3 = i4[1] && Dn(t3).call(t3, i4[1]) ? 1 : 0;
          return e3.map((e4) => {
            let { domain_prefix: t4, port: r3, ip: o3 } = e4;
            if (t4)
              return { address: "".concat(t4, ".").concat(i4[n3++ % i4.length], ":").concat(r3) };
            const s3 = /^[\.\:\d]+$/.test(o3), a2 = s3 ? "".concat(o3.replace(/[^\d]/g, "-"), ".").concat(i4[n3++ % i4.length], ":").concat(r3) : "".concat(o3, ":").concat(r3);
            return s3 || BN.debug("Cannot recognized as ip address: ".concat(o3, ", use as host")), { ip: o3, port: r3, address: a2 };
          });
        }(e2.addresses, t2), n2 = Array.isArray(e2.detail) && e2.detail[18];
        if (n2 && "string" == typeof n2) {
          const e3 = n2.split(";");
          for (let t3 = 0; t3 < e3.length; t3++) {
            var r2;
            const n3 = OT(r2 = e3[t3]).call(r2);
            i3[t3] && n3 && (i3[t3].ip6 = n3);
          }
        }
        const o2 = e2.detail && e2.detail.candidate;
        let s2;
        if (o2) {
          const [e3, t3] = o2.split(":");
          e3 && t3 && (s2 = { port: Number(t3), ip: e3, address: "".concat(e3, ":").concat(t3) });
        }
        return { gatewayAddrs: i3, apGatewayAddress: s2, uid: e2.uid, cid: e2.cid, cert: e2.cert, vid: e2.detail && e2.detail[8], uni_lbs_ip: e2.detail && e2.detail[1], res: e2, csIp: e2.detail && e2.detail[502] };
      }
      function ZU(e2) {
        return "number" == typeof e2 ? e2 : e2.exact || e2.ideal || e2.max || e2.min || 0;
      }
      function $U(e2) {
        const t2 = e2._encoderConfig;
        if (!t2)
          return {};
        const i3 = { resolution: t2.width && t2.height ? "".concat(ZU(t2.width), "x").concat(ZU(t2.height)) : void 0, maxVideoBW: t2.bitrateMax, minVideoBW: t2.bitrateMin };
        return "number" == typeof t2.frameRate ? (i3.maxFrameRate = t2.frameRate, i3.minFrameRate = t2.frameRate) : t2.frameRate && (i3.maxFrameRate = t2.frameRate.max || t2.frameRate.ideal || t2.frameRate.exact || t2.frameRate.min, i3.minFrameRate = t2.frameRate.min || t2.frameRate.ideal || t2.frameRate.exact || t2.frameRate.max), i3;
      }
      function ex(e2) {
        return e2 >= 0 && e2 < 0.17 ? 1 : e2 >= 0.17 && e2 < 0.36 ? 2 : e2 >= 0.36 && e2 < 0.59 ? 3 : e2 >= 0.59 && e2 <= 1 ? 4 : e2 > 1 ? 5 : 0;
      }
      function tx(e2, t2) {
        let i3, n2, r2;
        switch (t2) {
          case qU.CHOOSE_SERVER:
            n2 = 4096, r2 = "choose server";
            break;
          case qU.CLOUD_PROXY:
            n2 = 1048576, r2 = "proxy";
            break;
          case qU.CLOUD_PROXY_5:
            n2 = 4194304, r2 = "proxy5";
            break;
          case qU.CLOUD_PROXY_FALLBACK:
            n2 = 4194310, r2 = "proxy fallback";
            break;
          default:
            throw new XN(_w.UNEXPECTED_ERROR, "multi unlibs response transformer get unknown service id", { csIp: e2.detail && e2.detail[502], retry: false });
        }
        if (e2.response_body.forEach((t3) => {
          t3.buffer && t3.buffer.flag === n2 && (i3 = { code: t3.buffer.code, addresses: (t3.buffer.edges_services || []).map((e3) => XU(XU({}, e3), {}, { ticket: t3.buffer.cert })), server_ts: e2.enter_ts, uid: t3.buffer.uid, cid: t3.buffer.cid, cname: t3.buffer.cname, detail: XU(XU({}, t3.buffer.detail), e2.detail), flag: t3.buffer.flag, opid: e2.opid, cert: t3.buffer.cert });
        }), !i3)
          throw new XN(_w.MULTI_UNILBS_RESPONSE_ERROR, "cannot parse response ".concat(r2, " from multi unilbs response"), { csIp: e2.detail && e2.detail[502] });
        return i3;
      }
      async function ix(e2, t2) {
        return await Wh.all(e2.addresses.map(async (e3) => ({ address: JU(e3.ip), tcpport: e3.port, udpport: e3.port, username: t2 && dN("ENCRYPT_PROXY_USERNAME_AND_PSW") && window.isSecureContext ? t2.toString() : rN.username, password: t2 && dN("ENCRYPT_PROXY_USERNAME_AND_PSW") && window.isSecureContext ? await Ow(t2.toString()) : rN.password })));
      }
      function nx(e2, t2) {
        const i3 = t2.getMediaStreamTrack(true).getSettings(), n2 = t2.videoHeight || i3.height, r2 = t2.videoWidth || i3.width;
        return n2 && r2 ? Math.max(Math.min(n2, r2) / Math.min(ZU(e2.height), ZU(e2.width)), 1) : (BN.warning("can't get ori-track's height, default scale down 4 times for low stream"), 4);
      }
      function rx(e2) {
        let { candidateType: t2, relayProtocol: i3, type: n2, address: r2, port: o2, protocol: s2 } = e2;
        const a2 = { candidateType: t2, relayProtocol: i3, protocol: s2 };
        if ("local-candidate" !== n2) {
          const e3 = r2.split(".");
          e3.length >= 4 && (e3[1] = "*", e3[2] = "*"), a2.address = e3.join("."), a2.port = o2;
        }
        return a2;
      }
      function ox() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : dN("SVC_MODE");
        if (dN("ENABLE_SVC"))
          return function(e3) {
            return e3 in qO;
          }(e2) ? e2 : qO.L1T3;
      }
      const sx = { [lU.VIDEO]: [{ key: "abs-send-time", extensionName: "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" }, { key: "video-orientation", extensionName: "urn:3gpp:video-orientation" }, { key: "draft-holmer-rmcat-transport-wide-cc-extensions-01", extensionName: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" }, { key: "playout-delay", extensionName: "http://www.webrtc.org/experiments/rtp-hdrext/playout-delay" }, { key: "video-content-type", extensionName: "http://www.webrtc.org/experiments/rtp-hdrext/video-content-type" }, { key: "color-space", extensionName: "http://www.webrtc.org/experiments/rtp-hdrext/color-space" }, { key: "video-timing", extensionName: "http://www.webrtc.org/experiments/rtp-hdrext/video-timing" }], [lU.AUDIO]: [{ key: "ssrc-audio-level", extensionName: "urn:ietf:params:rtp-hdrext:ssrc-audio-level" }, { key: "draft-holmer-rmcat-transport-wide-cc-extensions-01", extensionName: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" }, { key: "abs-send-time", extensionName: "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" }] };
      function ax(e2, t2, i3) {
        t2.forEach((t3) => {
          var n2;
          const r2 = sx[e2].find((e3) => {
            var i4;
            let { key: n3 } = e3;
            return Dn(i4 = t3.extensionName).call(i4, n3);
          });
          if (!r2)
            return;
          const o2 = i3.find((e3) => {
            let { extensionName: t4 } = e3;
            return Dn(t4).call(t4, r2.key);
          });
          o2 && Dn(n2 = o2.extensionName).call(n2, "gdpr_forbidden") && (t3.extensionName = o2.extensionName);
        });
      }
      function cx(e2, t2) {
        t2.forEach((t3) => {
          var i3;
          const n2 = sx[e2].find((e3) => {
            var i4;
            let { key: n3 } = e3;
            return Dn(i4 = t3.extensionName).call(i4, n3);
          });
          Dn(i3 = t3.extensionName).call(i3, "gdpr_forbidden") && n2 && (t3.extensionName = n2.extensionName);
        });
      }
      function dx(e2) {
        return "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" === e2 || Dn(e2).call(e2, "abs-send-time");
      }
      function lx(e2) {
        return "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e2 || Dn(e2).call(e2, "draft-holmer-rmcat-transport-wide-cc-extensions-01");
      }
      function ux(e2, t2) {
        var i3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i3.push.apply(i3, n2);
        }
        return i3;
      }
      function hx(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i3 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? ux(Object(i3), true).forEach(function(t3) {
            QI(e2, t3, i3[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : ux(Object(i3)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
          });
        }
        return e2;
      }
      function px(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, n2 = arguments.length > 3 ? arguments[3] : void 0;
        const { filterRTX: r2, filterVideoFec: o2, filterAudioFec: s2, filterAudioCodec: a2, filterVideoCodec: c2 } = t2, { useXR: d2 } = i3;
        let l2 = [], u2 = [], h2 = [], p3 = [], _2 = false, E2 = false;
        if (SN(e2).mediaDescriptions.forEach((e3) => {
          n2 && n2 !== e3.attributes.direction || ("video" !== e3.media.mediaType || _2 || (u2 = e3.attributes.payloads, p3 = e3.attributes.extmaps, _2 = true), "audio" !== e3.media.mediaType || E2 || (l2 = e3.attributes.payloads, h2 = e3.attributes.extmaps, E2 = true));
        }), !p3 || 0 === u2.length)
          throw new Error("Cannot get video capabilities from SDP.");
        if (!h2 || 0 === l2.length)
          throw new Error("Cannot get audio capabilities from SDP.");
        if (u2.forEach((e3) => {
          var t3;
          null !== (t3 = e3.rtpMap) && void 0 !== t3 && t3.clockRate && (e3.rtpMap.clockRate = parseInt(e3.rtpMap.clockRate)), d2 && e3.rtcpFeedbacks.push({ type: "rrtr" });
        }), l2.forEach((e3) => {
          var t3;
          null !== (t3 = e3.rtpMap) && void 0 !== t3 && t3.clockRate && (e3.rtpMap.clockRate = parseInt(e3.rtpMap.clockRate)), d2 && e3.rtcpFeedbacks.push({ type: "rrtr" });
        }), r2 && (l2 = l2.filter((e3) => {
          var t3;
          return "rtx" !== (null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase());
        }), u2 = u2.filter((e3) => {
          var t3;
          return "rtx" !== (null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase());
        })), o2 && (u2 = u2.filter((e3) => {
          var t3;
          return !/(red)|(ulpfec)|(flexfec)/i.test((null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName) || "");
        })), s2 && (l2 = l2.filter((e3) => {
          var t3;
          return !/(red)|(ulpfec)|(flexfec)/i.test((null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName) || "");
        })), a2 && (null == a2 ? void 0 : a2.length) > 0 && (l2 = l2.filter((e3) => {
          var t3;
          return Dn(a2).call(a2, (null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) || "");
        })), c2 && (null == c2 ? void 0 : c2.length) > 0) {
          const e3 = u2.filter((e4) => {
            var t3;
            return Dn(c2).call(c2, (null === (t3 = e4.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) || "");
          });
          u2 = e3.concat(r2 ? [] : Dx(e3, u2));
        }
        const f2 = dN("UNSUPPORTED_VIDEO_CODEC");
        return f2 && f2.length > 0 && (u2 = u2.filter((e3) => !(e3.rtpMap && Dn(f2).call(f2, e3.rtpMap.encodingName.toLowerCase())))), { audioCodecs: l2, videoCodecs: u2, audioExtensions: h2, videoExtensions: p3 };
      }
      function _x(e2) {
        const t2 = SN(e2);
        let i3, n2;
        for (const e3 of t2.mediaDescriptions) {
          if (!i3) {
            const t3 = e3.attributes.iceUfrag, n3 = e3.attributes.icePwd;
            if (!t3 || !n3)
              throw new Error("Cannot get iceUfrag or icePwd from SDP.");
            i3 = { iceUfrag: t3, icePwd: n3 };
          }
          if (!n2) {
            const t3 = e3.attributes.fingerprints;
            t3.length > 0 && (n2 = { fingerprints: t3 });
          }
        }
        if (!n2 && t2.attributes.fingerprints.length > 0 && (n2 = { fingerprints: t2.attributes.fingerprints }), !n2 || !i3)
          throw new Error("Cannot get iceParameters or dtlsParameters from SDP.");
        return { iceParameters: i3, dtlsParameters: n2 };
      }
      function Ex(e2, t2) {
        const i3 = [], n2 = e2.attributes.ssrcGroups.filter((e3) => "FID" === e3.semantic), r2 = e2.attributes.ssrcGroups.find((e3) => "SIM" === e3.semantic), o2 = e2.attributes.ssrcs;
        if (r2)
          r2.ssrcIds.forEach((e3) => {
            var r3;
            const o3 = null === (r3 = n2.find((t3) => t3.ssrcIds[0] === e3)) || void 0 === r3 ? void 0 : r3.ssrcIds[1];
            i3.push({ ssrcId: e3, rtx: t2 ? o3 : void 0 });
          });
        else if (n2.length > 0) {
          const e3 = n2[0].ssrcIds[0], r3 = n2[0].ssrcIds[1];
          i3.push({ ssrcId: e3, rtx: t2 ? r3 : void 0 });
        } else {
          if (0 === o2.length)
            throw new Error("No ssrcs found on local media description.");
          i3.push({ ssrcId: o2[0].ssrcId });
        }
        return i3;
      }
      function fx(e2, t2, i3) {
        const { cname: n2 } = e2;
        let r2 = [];
        t2 && (r2 = mx(t2)), 0 === r2.length && (r2 = e2.iceParameters.candidates.map((e3) => ({ foundation: e3.foundation, componentId: "1", transport: e3.protocol, priority: e3.priority.toString(), connectionAddress: e3.ip, port: e3.port.toString(), type: e3.type, extension: {} })), BN.debug("Using candidates from gateway."));
        const o2 = { fingerprints: e2.dtlsParameters.fingerprints.map((e3) => ({ hashFunction: e3.algorithm, fingerprint: e3.fingerprint })) }, s2 = { iceUfrag: e2.iceParameters.iceUfrag, icePwd: e2.iceParameters.icePwd };
        let a2;
        switch (e2.dtlsParameters.role) {
          case "server":
            a2 = "passive";
            break;
          case "client":
            a2 = "active";
            break;
          case "auto":
            a2 = "actpass";
        }
        const c2 = wx(e2.rtpCapabilities), d2 = [];
        return Array.isArray(i3) && i3.length > 0 && i3.forEach((e3) => {
          d2.push({ kind: lU.VIDEO, ssrcId: e3.v, rtx: e3.v_rtx, mslabel: "".concat(e3.v, "_").concat(e3.a) }, { kind: lU.AUDIO, ssrcId: e3.a, mslabel: "".concat(e3.v, "_").concat(e3.a) });
        }), { dtlsParameters: o2, iceParameters: s2, candidates: r2, rtpCapabilities: c2, setup: a2, cname: n2, preSSRCs: d2 };
      }
      function mx(e2) {
        let t2 = [];
        return e2.ip && "number" == typeof e2.port && (t2 = [{ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: e2.ip, port: e2.port.toString(), type: "host", extension: {} }], BN.debug("Using remote candidate from AP ".concat(e2.ip, ":").concat(e2.port)), e2.ip6 && (t2.push({ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: e2.ip6, port: e2.port.toString(), type: "host", extension: {} }), BN.debug("Using IPV6 remote candidate from AP ".concat(e2.ip6, ":").concat(e2.port)))), t2;
      }
      function Tx(e2, t2, i3) {
        const n2 = [], r2 = [];
        return e2.forEach((e3) => {
          let { ssrcId: o2, rtx: s2 } = e3;
          const a2 = uO(8, "track-"), c2 = { ssrcId: o2, attributes: hx({ label: a2, mslabel: i3 = i3 || uO(10, ""), msid: "".concat(i3, " ").concat(a2) }, t2 && { cname: t2 }) };
          if (n2.push(c2), void 0 !== s2) {
            const e4 = { ssrcId: s2, attributes: hx({ label: a2, mslabel: i3, msid: "".concat(i3, " ").concat(a2) }, t2 && { cname: t2 }) };
            n2.push(e4), r2.push({ semantic: "FID", ssrcIds: [o2, s2] });
          }
        }), e2.length > 1 && r2.push({ semantic: "SIM", ssrcIds: e2.map((e3) => {
          let { ssrcId: t3 } = e3;
          return t3;
        }) }), { ssrcs: n2, ssrcGroups: r2 };
      }
      function Sx(e2, t2) {
        t2 instanceof TL && e2.attributes.payloads.forEach((e3) => {
          var i3;
          const n2 = null === (i3 = e3.rtpMap) || void 0 === i3 ? void 0 : i3.encodingName.toLowerCase();
          if (!n2 || -1 === ["opus", "pcmu", "pcma", "g722"].indexOf(n2))
            return;
          e3.fmtp || (e3.fmtp = { parameters: {} }), e3.fmtp.parameters.minptime = "10", e3.fmtp.parameters.useinbandfec = "1";
          const r2 = t2._encoderConfig;
          r2 && "pcmu" !== n2 && "pcma" !== n2 && "g722" !== n2 && (r2.bitrate && !Kb() && (e3.fmtp.parameters.maxaveragebitrate = "".concat(Math.floor(1e3 * r2.bitrate))), r2.sampleRate && (e3.fmtp.parameters.maxplaybackrate = "".concat(r2.sampleRate), e3.fmtp.parameters["sprop-maxcapturerate"] = "".concat(r2.sampleRate)), r2.stereo && (e3.fmtp.parameters.stereo = "1", e3.fmtp.parameters["sprop-stereo"] = "1"));
        });
      }
      function gx(e2) {
        const t2 = e2.attributes.unrecognized.findIndex((e3) => "x-google-flag" === e3.attField && "conference" === e3.attValue);
        -1 !== t2 && e2.attributes.unrecognized.splice(t2, 1);
      }
      function Rx(e2, t2) {
        var i3;
        if (!(t2 instanceof ak && t2._encoderConfig && -1 === t2._hints.indexOf(fD.SCREEN_TRACK)))
          return;
        const n2 = t2._encoderConfig;
        QN().supportMinBitrate && n2.bitrateMin && e2.attributes.payloads.forEach((e3) => {
          var t3, i4;
          Dn(t3 = ["h264", "h265", "vp8", "vp9", "av1"]).call(t3, (null === (i4 = e3.rtpMap) || void 0 === i4 ? void 0 : i4.encodingName.toLowerCase()) || "") && (e3.fmtp || (e3.fmtp = { parameters: {} }), e3.fmtp.parameters["x-google-min-bitrate"] = "".concat(n2.bitrateMin));
        }), QN().supportMinBitrate && !Dn(i3 = t2._hints).call(i3, fD.LOW_STREAM) && n2.bitrateMax && e2.attributes.payloads.forEach((e3) => {
          var t3, i4;
          Dn(t3 = ["h264", "h265", "vp8", "vp9", "av1"]).call(t3, (null === (i4 = e3.rtpMap) || void 0 === i4 ? void 0 : i4.encodingName.toLowerCase()) || "") && (e3.fmtp || (e3.fmtp = { parameters: {} }), e3.fmtp.parameters["x-google-start-bitrate"] = "".concat(dN("X_GOOGLE_START_BITRATE") || Math.floor(n2.bitrateMax)));
        });
      }
      function Cx(e2) {
        if ("video" !== e2.media.mediaType)
          return;
        const t2 = xb();
        if (t2.name !== Lb.SAFARI && t2.os !== Pb.IOS)
          return;
        const i3 = e2.attributes.extmaps.findIndex((e3) => /video-orientation/g.test(e3.extensionName));
        -1 !== i3 && e2.attributes.extmaps.splice(i3, 1);
      }
      function vx(e2, t2, i3) {
        if (!t2)
          return;
        let n2, r2;
        if ("video" === e2.media.mediaType ? (n2 = i3.videoExtensions, r2 = i3.videoCodecs) : (n2 = i3.audioExtensions, r2 = i3.audioCodecs), true === t2.twcc) {
          const t3 = n2.find((e3) => lx(e3.extensionName));
          if (t3) {
            const i4 = t3.extensionName;
            e2.attributes.extmaps.find((e3) => lx(e3.extensionName)) || e2.attributes.extmaps.push({ entry: t3.entry, extensionName: i4 });
            const n3 = function(e3, t4) {
              return t4.filter((t5) => !!e3.find((e4) => e4.payloadType === t5.payloadType && !!e4.rtcpFeedbacks.find((e5) => "transport-cc" === e5.type)));
            }(r2, e2.attributes.payloads);
            n3.forEach((e3) => {
              e3.rtcpFeedbacks.find((e4) => "transport-cc" === e4.type) || e3.rtcpFeedbacks.push({ type: "transport-cc" });
            });
          }
        } else if (false === t2.twcc) {
          const t3 = e2.attributes.extmaps.findIndex((e3) => lx(e3.extensionName));
          -1 !== t3 && e2.attributes.extmaps.splice(t3, 1), e2.attributes.payloads.forEach((e3) => {
            const t4 = e3.rtcpFeedbacks.findIndex((e4) => "transport-cc" === e4.type);
            -1 !== t4 && e3.rtcpFeedbacks.splice(t4, 1);
          });
        }
        if (true === t2.remb) {
          const t3 = n2.find((e3) => dx(e3.extensionName));
          if (t3) {
            const i4 = t3.extensionName;
            e2.attributes.extmaps.find((e3) => e3.extensionName === i4) || e2.attributes.extmaps.push({ entry: t3.entry, extensionName: i4 });
            const n3 = function(e3, t4) {
              return t4.filter((t5) => !!e3.find((e4) => e4.payloadType === t5.payloadType && !!e4.rtcpFeedbacks.find((e5) => "goog-remb" === e5.type)));
            }(r2, e2.attributes.payloads);
            n3.forEach((e3) => {
              e3.rtcpFeedbacks.find((e4) => "goog-remb" === e4.type) || e3.rtcpFeedbacks.push({ type: "goog-remb" });
            });
          }
        } else if (false === t2.remb) {
          const t3 = e2.attributes.extmaps.findIndex((e3) => dx(e3.extensionName));
          -1 !== t3 && e2.attributes.extmaps.splice(t3, 1), e2.attributes.payloads.forEach((e3) => {
            const t4 = e3.rtcpFeedbacks.findIndex((e4) => "goog-remb" === e4.type);
            -1 !== t4 && e3.rtcpFeedbacks.splice(t4, 1);
          });
        }
      }
      function Ix(e2, t2, i3) {
        if (Kb())
          return;
        if ("video" !== e2.media.mediaType)
          return;
        if (!(t2 instanceof ak))
          return;
        if ("vp9" !== i3 && "vp8" !== i3)
          return;
        if ("vp8" === i3 && !dN("SIMULCAST"))
          return;
        if ("vp9" === i3 && dN("ENABLE_SVC"))
          return;
        if (void 0 === t2._scalabilityMode || t2._scalabilityMode.numSpatialLayers <= 1)
          return;
        const n2 = "vp8" === i3 ? 2 : t2._scalabilityMode.numSpatialLayers, r2 = e2.attributes.ssrcs[0], o2 = e2.attributes.ssrcGroups.find((e3) => "FID" === e3.semantic && e3.ssrcIds[0] === r2.ssrcId), s2 = { semantic: "SIM", ssrcIds: [r2.ssrcId] };
        for (let t3 = 1; t3 < n2; t3++)
          e2.attributes.ssrcs.push({ ssrcId: r2.ssrcId + t3, attributes: $w(r2.attributes) }), s2.ssrcIds.push(r2.ssrcId + t3), o2 && (e2.attributes.ssrcs.push({ ssrcId: o2.ssrcIds[1] + t3, attributes: $w(r2.attributes) }), e2.attributes.ssrcGroups.push({ semantic: "FID", ssrcIds: [r2.ssrcId + t3, o2.ssrcIds[1] + t3] }));
        e2.attributes.ssrcGroups.unshift(s2);
      }
      async function yx() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        const i3 = new RTCPeerConnection();
        i3.addTransceiver("video", { direction: "sendonly" }), i3.addTransceiver("audio", { direction: "sendonly" }), i3.addTransceiver("video", { direction: "recvonly" }), i3.addTransceiver("audio", { direction: "recvonly" });
        const n2 = (await i3.createOffer()).sdp, { send: r2, recv: o2, sendrecv: s2 } = function() {
          let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i4 = arguments.length > 2 ? arguments[2] : void 0;
          const n3 = px(i4, e3, t3, "sendonly"), r3 = px(i4, e3, t3, "recvonly"), o3 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, s3 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, a2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] };
          if (bx(n3, r3, "videoExtensions", o3, s3, a2), bx(n3, r3, "videoCodecs", o3, s3, a2), bx(n3, r3, "audioExtensions", o3, s3, a2), bx(n3, r3, "audioCodecs", o3, s3, a2), dN("RAISE_H264_BASELINE_PRIORITY")) {
            const e4 = [], t4 = [];
            a2.videoCodecs.forEach((i5, n4) => {
              var r4;
              if ("h264" === (null === (r4 = i5.rtpMap) || void 0 === r4 ? void 0 : r4.encodingName.toLocaleLowerCase())) {
                var o4, s4;
                const r5 = a2.videoCodecs[n4 + 1], c2 = r5 && Ux(i5, r5), d2 = null === (o4 = i5.fmtp) || void 0 === o4 ? void 0 : o4.parameters["profile-level-id"], l2 = null === (s4 = i5.fmtp) || void 0 === s4 ? void 0 : s4.parameters["packetization-mode"];
                !d2 || d2 !== dN("FIRST_H264_PROFILE_LEVEL_ID") || dN("FIRST_PACKETIZATION_MODE") && l2 !== dN("FIRST_PACKETIZATION_MODE") ? c2 ? t4.push([i5, r5]) : t4.push([i5]) : c2 ? e4.push([i5, r5]) : e4.push([i5]);
              }
            }), e4.length > 0 && t4.length > 0 && (BN.debug("raising H264 baseline profile priority"), a2.videoCodecs.forEach((i5, n4) => {
              var r4;
              if ("h264" === (null === (r4 = i5.rtpMap) || void 0 === r4 ? void 0 : r4.encodingName.toLocaleLowerCase())) {
                const r5 = Ux(i5, a2.videoCodecs[n4 + 1]), o4 = e4.shift() || t4.shift() || [];
                o4.length > 0 && (r5 ? a2.videoCodecs.splice(n4, 2, ...o4) : a2.videoCodecs.splice(n4, 1, ...o4));
              }
            }), s3.videoCodecs = s3.videoCodecs.filter((e5) => {
              var t5, i5;
              return !("h264" === (null === (t5 = e5.rtpMap) || void 0 === t5 ? void 0 : t5.encodingName.toLocaleLowerCase()) && (null === (i5 = e5.fmtp) || void 0 === i5 ? void 0 : i5.parameters["profile-level-id"]) !== dN("FIRST_H264_PROFILE_LEVEL_ID"));
            }), dN("FILTER_SEND_H264_BASELINE") && (o3.videoCodecs = o3.videoCodecs.filter((e5) => {
              var t5, i5;
              return !("h264" === (null === (t5 = e5.rtpMap) || void 0 === t5 ? void 0 : t5.encodingName.toLocaleLowerCase()) && (null === (i5 = e5.fmtp) || void 0 === i5 ? void 0 : i5.parameters["profile-level-id"]) !== dN("FIRST_H264_PROFILE_LEVEL_ID"));
            })));
          }
          return { send: o3, recv: s3, sendrecv: a2 };
        }(e2, t2, n2);
        try {
          i3.close();
        } catch (e3) {
        }
        return { send: r2, recv: o2, sendrecv: s2 };
      }
      function Ax() {
        const e2 = { audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: [] }, t2 = px(arguments.length > 2 ? arguments[2] : void 0, arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, "recvonly"), i3 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, n2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, r2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] };
        if (bx(e2, t2, "videoExtensions", i3, n2, r2), bx(e2, t2, "videoCodecs", i3, n2, r2), bx(e2, t2, "audioExtensions", i3, n2, r2), bx(e2, t2, "audioCodecs", i3, n2, r2), dN("RAISE_H264_BASELINE_PRIORITY")) {
          const e3 = r2.videoCodecs.findIndex((e4) => e4.rtpMap && "h264" === e4.rtpMap.encodingName.toLocaleLowerCase() && e4.fmtp && "42001f" === e4.fmtp.parameters["profile-level-id"]);
          if (-1 !== e3) {
            const t3 = r2.videoCodecs.findIndex((e4) => e4.rtpMap && "h264" === e4.rtpMap.encodingName.toLocaleLowerCase());
            if (t3 < e3) {
              BN.debug("raising H264 baseline profile priority");
              const i4 = r2.videoCodecs[e3];
              r2.videoCodecs.splice(e3, 1), r2.videoCodecs.splice(t3, 0, i4);
            }
            -1 !== t3 && (n2.videoCodecs = n2.videoCodecs.filter((e4) => !(e4.rtpMap && "h264" === e4.rtpMap.encodingName.toLocaleLowerCase() && e4.fmtp && "42001f" !== e4.fmtp.parameters["profile-level-id"])));
          }
        }
        return { send: i3, recv: n2, sendrecv: r2 };
      }
      function bx(e2, t2, i3, n2, r2, o2) {
        if ("videoExtensions" === i3 || "audioExtensions" === i3) {
          const s2 = [];
          return e2[i3].forEach((e3) => {
            t2[i3].some((t3, i4) => {
              if (e3.entry === t3.entry && e3.extensionName === t3.extensionName)
                return s2.push(i4), true;
            }) ? o2[i3].push(e3) : n2[i3].push(e3);
          }), void t2[i3].forEach((e3, t3) => {
            -1 === s2.indexOf(t3) && r2[i3].push(e3);
          });
        }
        if ("videoCodecs" === i3 || "audioCodecs" === i3) {
          const s2 = [];
          return e2[i3].forEach((e3) => {
            t2[i3].some((t3, i4) => {
              if (e3.payloadType === t3.payloadType && JSON.stringify(e3) === JSON.stringify(t3))
                return s2.push(i4), true;
            }) ? o2[i3].push(e3) : n2[i3].push(e3);
          }), void t2[i3].forEach((e3, t3) => {
            -1 === s2.indexOf(t3) && r2[i3].push(e3);
          });
        }
      }
      function wx(e2) {
        const { send: t2, recv: i3, sendrecv: n2 } = e2;
        if (!n2) {
          if (!t2 || !i3)
            throw new Error("cannot merge rtp capabilities because one of send or recv is empty!");
          return { send: t2, recv: i3 };
        }
        let r2, o2;
        return t2 ? (r2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, r2.audioCodecs = [...t2.audioCodecs, ...n2.audioCodecs], r2.videoCodecs = [...t2.videoCodecs, ...n2.videoCodecs], r2.audioExtensions = [...t2.audioExtensions, ...n2.audioExtensions], r2.videoExtensions = [...t2.videoExtensions, ...n2.videoExtensions]) : r2 = n2, i3 ? (o2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, o2.audioCodecs = [...i3.audioCodecs, ...n2.audioCodecs], o2.videoCodecs = [...i3.videoCodecs, ...n2.videoCodecs], o2.audioExtensions = [...i3.audioExtensions, ...n2.audioExtensions], o2.videoExtensions = [...i3.videoExtensions, ...n2.videoExtensions]) : o2 = n2, { send: r2, recv: o2 };
      }
      function Ox(e2) {
        if ("audio" !== e2.media.mediaType)
          return;
        e2.attributes.payloads.filter((e3) => {
          var t2;
          return "opus" === (null === (t2 = e3.rtpMap) || void 0 === t2 ? void 0 : t2.encodingName.toLowerCase());
        }).forEach((e3) => {
          e3.fmtp || (e3.fmtp = { parameters: {} }), e3.fmtp.parameters.stereo = "1", e3.fmtp.parameters["sprop-stereo"] = "1";
        });
      }
      function Nx(e2, t2, i3, n2) {
        let r2 = [];
        if (e2 === lU.VIDEO) {
          if (dN("H264_PROFILE_LEVEL_ID") && "h264" === n2 && (r2 = t2.videoCodecs.filter((e3) => {
            var t3;
            return Dn(t3 = e3.rtpMap && e3.rtpMap.encodingName.toLowerCase() || "").call(t3, n2) && e3 && e3.fmtp && e3.fmtp.parameters["profile-level-id"] === dN("H264_PROFILE_LEVEL_ID");
          })), !Array.isArray(r2) || 0 === r2.length) {
            let e3 = [];
            const o2 = [], s2 = [], a2 = [];
            if (i3.videoCodecs.forEach((t3) => {
              const i4 = t3.rtpMap && t3.rtpMap.encodingName.toLowerCase() || "";
              Dn(i4).call(i4, n2) ? e3.push(t3) : Dn(i4).call(i4, "vp9") ? o2.push(t3) : Dn(i4).call(i4, "vp8") ? s2.push(t3) : Dn(i4).call(i4, "h264") && a2.push(t3);
            }), 0 === e3.length) {
              let t3 = "";
              0 !== o2.length ? (e3 = o2, t3 = "vp9") : 0 !== s2.length ? (e3 = s2, t3 = "vp8") : 0 !== a2.length && (e3 = a2, t3 = "h264"), BN.warning("codec ".concat(n2, " not included in rtpCapabilities, fallback to default payloads: ").concat(t3));
            }
            0 !== e3.length && (r2 = t2.videoCodecs.filter((t3) => e3.some((e4) => e4.payloadType === t3.payloadType)));
          }
          if (0 === r2.length && (BN.warning("codec ".concat(n2, " not included in rtpCapabilities, fallback to default payloads: ").concat(t2.videoCodecs[0].rtpMap && t2.videoCodecs[0].rtpMap.encodingName)), r2 = t2.videoCodecs), dN("USE_PUB_RTX") || dN("USE_SUB_RTX")) {
            const e3 = Dx(r2, t2.videoCodecs);
            r2 = [...r2, ...e3];
          }
        } else
          r2 = t2.audioCodecs.filter((e3) => {
            var t3;
            return Dn(t3 = e3.rtpMap && e3.rtpMap.encodingName.toLowerCase() || "").call(t3, n2);
          }), 0 === r2.length && (BN.warning("codec ".concat(n2, " not included in rtpCapabilities, fallback to opus")), r2 = t2.audioCodecs.filter((e3) => {
            var t3;
            return Dn(t3 = e3.rtpMap && e3.rtpMap.encodingName.toLowerCase() || "").call(t3, "opus");
          }));
        return r2;
      }
      function Dx(e2, t2) {
        const i3 = e2.map((e3) => e3.payloadType.toString());
        return t2.filter((e3) => e3.rtpMap && "rtx" === e3.rtpMap.encodingName && e3.fmtp && e3.fmtp.parameters.apt && Dn(i3).call(i3, e3.fmtp && e3.fmtp.parameters.apt));
      }
      async function Px(e2, t2, i3) {
        const n2 = t2.toString(), r2 = kx(n2, "offer", "remote", "exchangeSDP");
        await e2.setRemoteDescription({ type: "offer", sdp: n2 });
        const o2 = await e2.createAnswer();
        if (!o2.sdp)
          throw new Error("cannot get answer sdp");
        let s2 = o2.sdp;
        s2 = Lx(s2, i3 || {}), null == r2 || r2(s2 || ""), await e2.setLocalDescription({ type: "answer", sdp: s2 });
      }
      function Lx(e2, t2, i3) {
        const n2 = SN(e2), { useXR: r2 } = t2;
        return n2.mediaDescriptions.forEach((e3) => {
          var t3;
          e3.attributes.mid && (Array.isArray(i3) && !Dn(i3).call(i3, e3.attributes.mid) || ("audio" === e3.media.mediaType && Ox(e3), r2 && Dn(t3 = ["audio", "video"]).call(t3, e3.media.mediaType) && e3.attributes.payloads.forEach((e4) => {
            -1 === e4.rtcpFeedbacks.findIndex((e5) => "rrtr" === e5.type) && e4.rtcpFeedbacks.push({ type: "rrtr" });
          })));
        }), gN(n2);
      }
      function kx(e2, t2, i3, n2) {
        if (dN("SDP_LOGGING"))
          return BN.upload("exchanging ".concat(i3, " ").concat(t2, " SDP during P2PConnection.").concat(n2, "\n"), e2), "offer" === t2 ? (e3) => {
            kx(e3, "answer", "local" === i3 ? "remote" : "local", n2);
          } : void 0;
      }
      function Mx(e2) {
        const t2 = dN("COMPATIBLE_SDP_EXTENSION");
        return !!(Array.isArray(t2) && t2.length > 0) && t2.some((t3) => Dn(e2).call(e2, t3));
      }
      function Ux(e2, t2) {
        try {
          var i3;
          return (null === (i3 = e2.fmtp) || void 0 === i3 ? void 0 : i3.parameters.apt) === t2.payloadType.toString();
        } catch (e3) {
          return false;
        }
      }
      function xx(e2, t2) {
        var i3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i3.push.apply(i3, n2);
        }
        return i3;
      }
      function Vx(e2, t2) {
        return typeof dN(e2) === t2 ? dN(e2) : void 0;
      }
      function Fx() {
        try {
          const e2 = dN("EXPERIMENTS") || {};
          return "string" == typeof e2 || Array.isArray(e2) ? {} : function(e3) {
            for (var t2 = 1; t2 < arguments.length; t2++) {
              var i3 = null != arguments[t2] ? arguments[t2] : {};
              t2 % 2 ? xx(Object(i3), true).forEach(function(t3) {
                QI(e3, t3, i3[t3]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : xx(Object(i3)).forEach(function(t3) {
                Object.defineProperty(e3, t3, Object.getOwnPropertyDescriptor(i3, t3));
              });
            }
            return e3;
          }({}, e2);
        } catch (e2) {
          return BN.debug("handle gateway attributes failed: ", e2), {};
        }
      }
      const Bx = {};
      function jx(e2) {
        (!(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]) && BN.debug("install service ".concat(e2.name)), Bx[e2.name] = e2;
      }
      function Gx(e2) {
        const t2 = Bx[e2];
        if (!t2)
          throw new Ew(_w.INVALID_OPERATION, "".concat(e2, " not found, please use AgoraRTC.use(").concat(e2, "Service) to load it first"));
        return t2;
      }
      function Wx(e2, t2) {
        return Gx("DataStream").create(e2, t2);
      }
      function Hx(e2, t2) {
        var i3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i3.push.apply(i3, n2);
        }
        return i3;
      }
      function Kx(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i3 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? Hx(Object(i3), true).forEach(function(t3) {
            QI(e2, t3, i3[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : Hx(Object(i3)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
          });
        }
        return e2;
      }
      const Yx = /* @__PURE__ */ new Map();
      class qx extends Nw {
        get state() {
          return this._state;
        }
        set state(e2) {
          if (e2 === this._state)
            return;
          const t2 = this._state;
          this._state = e2, "DISCONNECTED" === e2 && this._disconnectedReason ? this.emit($M.CONNECTION_STATE_CHANGE, e2, t2, this._disconnectedReason) : this.emit($M.CONNECTION_STATE_CHANGE, e2, t2);
        }
        get joinGatewayStartTime() {
          return this._joinGatewayStartTime;
        }
        set joinGatewayStartTime(e2) {
          BN.debug("[".concat(this.store.clientId, "] set joinGatewayStartTime at ").concat(e2)), this._joinGatewayStartTime = e2;
        }
        constructor(e2, t2) {
          var i3, n2, r2;
          super(), QI(this, "store", void 0), QI(this, "joinInfo", void 0), QI(this, "key", void 0), QI(this, "ntpOffset", 0), QI(this, "signal", void 0), QI(this, "role", void 0), QI(this, "inChannelInfo", { joinAt: null, duration: 0 }), QI(this, "spec", void 0), QI(this, "_state", "DISCONNECTED"), QI(this, "_statsCollector", void 0), QI(this, "_disconnectedReason", void 0), QI(this, "isSignalRecover", false), QI(this, "hasChangeBGPAddress", false), QI(this, "trafficStatsInterval", void 0), QI(this, "networkQualityInterval", void 0), QI(this, "_joinGatewayStartTime", 0), QI(this, "_signalTimeout", false), QI(this, "_clientRoleOptions", void 0), QI(this, "_isProactiveJoin", false), this.store = e2, this.spec = t2, this.signal = this.store.useP2P ? (i3 = { spec: Kx(Kx({}, t2), {}, { retryConfig: t2.websocketRetryConfig }), store: e2 }, null === (n2 = (r2 = Gx("P2PChannel")).createSubmodule) || void 0 === n2 ? void 0 : n2.call(r2, i3)) : new YU(Kx(Kx({}, t2), {}, { retryConfig: t2.websocketRetryConfig }), e2), this._statsCollector = t2.statsCollector, this.role = t2.role || "audience", this._clientRoleOptions = t2.clientRoleOptions, this.handleSignalEvents();
        }
        async join(e2, t2, i3) {
          this.store.joinGatewayStart(), "disabled" !== e2.cloudProxyServer && (this.hasChangeBGPAddress = true);
          const n2 = Date.now();
          let r2 = Yx.get(e2.cname);
          if (r2 || (r2 = /* @__PURE__ */ new Map(), Yx.set(e2.cname, r2)), this._isProactiveJoin = true, r2.has(e2.uid)) {
            const t3 = new XN(_w.UID_CONFLICT);
            throw zN.joinGateway(e2.sid, { lts: n2, succ: false, ec: t3.code, addr: null, uid: e2.uid, cid: e2.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!e2.proxyServer, signalChannel: "0", preload: e2.preload }), t3;
          }
          r2.set(e2.uid, true), this.joinInfo = e2, this.key = t2;
          let o2 = 0;
          this.joinGatewayStartTime = n2;
          const s2 = e2.proxyServer;
          try {
            BN.debug("[".concat(this.store.clientId, "] use websocket join uid ").concat(o2));
            const t3 = e2.gatewayAddrs.map((t4) => {
              let { address: i4 } = t4;
              const [n3, r3] = i4.split(":"), o3 = { host: n3, port: r3 };
              return e2.proxyServer && (o3.proxy = e2.proxyServer), o3;
            });
            o2 = (await this.signal.init(t3)).uid, BN.debug("[".concat(this.store.clientId, "] websocket join uid ").concat(o2, " cost ").concat(Date.now() - this.joinGatewayStartTime));
          } catch (t3) {
            var a2;
            throw BN.error("[".concat(this.store.clientId, "] User join failed"), t3.toString()), zN.joinGateway(e2.sid, { lts: n2, succ: false, ec: (null === (a2 = t3.data) || void 0 === a2 ? void 0 : a2.desc) || t3.code, errorMsg: t3.message, addr: this.signal.url, uid: e2.uid, cid: e2.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!s2, signalChannel: "0", preload: e2.preload }), r2.delete(e2.uid), this.signal.close(), t3;
          }
          return this.state = "CONNECTED", this.inChannelInfo.joinAt = Date.now(), BN.debug("[".concat(this.store.clientId, "] Connected to gateway server")), this.trafficStatsInterval = window.setInterval(() => {
            this.updateTrafficStats().catch((e3) => {
              BN.warning("[".concat(this.store.clientId, "] get traffic stats error"), e3.toString());
            });
          }, 3e3), this.networkQualityInterval = window.setInterval(() => {
            navigator && void 0 !== navigator.onLine && !navigator.onLine ? this.emit($M.NETWORK_QUALITY, { downlinkNetworkQuality: 6, uplinkNetworkQuality: 6 }) : this._signalTimeout ? this.emit($M.NETWORK_QUALITY, { downlinkNetworkQuality: 5, uplinkNetworkQuality: 5 }) : "CONNECTED" === this.state && this._statsCollector.trafficStats ? this.emit($M.NETWORK_QUALITY, { uplinkNetworkQuality: ex(this._statsCollector.trafficStats.B_unq), downlinkNetworkQuality: ex(this._statsCollector.trafficStats.B_dnq) }) : this.emit($M.NETWORK_QUALITY, { uplinkNetworkQuality: 0, downlinkNetworkQuality: 0 });
          }, 2e3), this.store.joinGatewayEnd(), o2;
        }
        async leave() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], t2 = arguments.length > 1 ? arguments[1] : void 0;
          if ("DISCONNECTED" !== this.state) {
            t2 !== xw.FALLBACK && (this.state = "DISCONNECTING");
            try {
              e2 || this.signal.connectionState !== NM.CONNECTED || await function(e3, t3) {
                return t3 === 1 / 0 ? e3 : Wh.race([e3, dO(t3)]);
              }(this.signal.request(PM.LEAVE, void 0, true), 3e3);
            } catch (e3) {
              BN.warning("[".concat(this.store.clientId, "] leave request failed, ignore"), e3);
            }
            this.signal.close(t2), t2 !== xw.FALLBACK && (this.state = "DISCONNECTED"), this.reset();
          }
        }
        async publish(e2, t2, i3) {
          if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
            throw new XN(_w.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
          const n2 = { state: "offer", p2p_id: this.store.p2pId, ortc: t2, mode: this.spec.mode, extend: dN("PUB_EXTEND"), twcc: !!dN("PUBLISH_TWCC"), rtx: !!dN("USE_PUB_RTX") };
          try {
            return (await this.signal.request(PM.PUBLISH, n2, true))._message;
          } catch (n3) {
            if (i3 && n3.data && n3.data.code === OM.ERR_PUBLISH_REQUEST_INVALID)
              return BN.warning("[".concat(this.store.clientId, "] receive publish error code, retry"), n3.toString()), await this.tryUnpubBeforeRepub(e2, t2), this.publish(e2, t2, false);
            throw n3;
          }
        }
        async publishDataChannel(e2, t2, i3) {
          var n2;
          if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
            throw new XN(_w.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
          const r2 = { stream_id: t2.streamId, ordered: t2.ordered ? 1 : 0, max_retrans_times: null !== (n2 = t2.maxRetransmits) && void 0 !== n2 ? n2 : 10, channel_id: t2.channelId, metadata: t2.metadata };
          try {
            await this.signal.request(PM.PUBLISH_DATASTREAM, r2, true);
          } catch (n3) {
            if (i3 && n3.data && n3.data.code === OM.ERR_PUBLISH_REQUEST_INVALID)
              return BN.warning("[".concat(this.store.clientId, "] receive publish datachannels error code, retry"), n3.toString()), await this.tryUnpubDataChannelBeforeRepub(e2, t2), this.publishDataChannel(e2, t2, false);
            throw n3;
          }
        }
        async unpublish(e2, t2) {
          try {
            if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
              throw new XN(_w.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
            await this.signal.request(PM.UNPUBLISH, { stream_id: t2, ortc: e2 }, true);
          } catch (e3) {
            BN.warning("[".concat(this.store.clientId, "] unpublish warning: "), e3);
          }
        }
        async unpublishDataChannel(e2) {
          try {
            if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
              throw new XN(_w.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
            await Wh.all(e2.map((e3) => this.signal.request(PM.UNPUBLISH_DATASTREAM, { channel_id: e3 }, true)));
          } catch (e3) {
            BN.warning("unpublish datachannels warning: ", e3);
          }
        }
        async presubscribe(e2, t2, i3) {
          if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
            throw new XN(_w.INVALID_OPERATION, "can not presubscribe when connection state is ".concat(this.state));
          const n2 = { stream_id: e2, stream_type: t2, mode: this.spec.mode, codec: this.spec.codec, p2p_id: this.store.p2pId, twcc: !!dN("SUBSCRIBE_TWCC"), rtx: !!dN("USE_SUB_RTX") || void 0, extend: dN("SUB_EXTEND"), svc: Array.isArray(dN("SVC")) && 0 !== dN("SVC").length ? dN("SVC") : void 0 };
          try {
            return await this.signal.request(PM.PRE_SUBSCRIBE, n2, true);
          } catch (n3) {
            if (i3 && n3.data && n3.data.code === OM.ERR_SUBSCRIBE_REQUEST_INVALID)
              return BN.warning("[".concat(this.store.clientId, "] pre-subscribe error, retry"), n3.toString()), this.presubscribe(e2, t2, false);
            throw n3;
          }
        }
        async subscribe(e2, t2, i3) {
          if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
            throw new XN(_w.INVALID_OPERATION, "can not subscribe when connection state is ".concat(this.state));
          const n2 = { stream_id: e2, stream_type: t2.stream_type, mode: this.spec.mode, codec: this.spec.codec, p2p_id: this.store.p2pId, twcc: !!dN("SUBSCRIBE_TWCC"), rtx: !!dN("USE_SUB_RTX"), extend: dN("SUB_EXTEND"), ssrcId: t2.ssrcId, svc: Array.isArray(dN("SVC")) && 0 !== dN("SVC").length ? dN("SVC") : void 0 };
          try {
            return (await this.signal.request(PM.SUBSCRIBE, n2, true))._message;
          } catch (n3) {
            if (i3 && n3.data && n3.data.code === OM.ERR_SUBSCRIBE_REQUEST_INVALID)
              return BN.warning("[".concat(this.store.clientId, "] receiver subscribe error code, retry"), n3.toString()), await this.tryUnsubBeforeResub(e2, t2), await this.subscribe(e2, t2, false);
            throw n3;
          }
        }
        async subscribeDataChannel(e2, t2, i3) {
          if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
            throw new XN(_w.INVALID_OPERATION, "can not subscribe datachannel when connection state is ".concat(this.state));
          const n2 = { uid: e2, stream_id: t2.id, channel_id: t2.datachannelId };
          try {
            return void await this.signal.request(PM.SUBSCRIBE_DATASTREAM, n2, true);
          } catch (n3) {
            if (i3 && n3.data && n3.data.code === OM.ERR_SUBSCRIBE_REQUEST_INVALID)
              return BN.warning("[".concat(this.store.clientId, "] receiver subscribe datachannel error code, retry"), n3.toString()), await this.tryUnsubDataChannelBeforeResub(e2, t2), await this.subscribeDataChannel(e2, t2, false);
            throw n3;
          }
        }
        async subscribeAll(e2, t2) {
          if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
            throw new XN(_w.INVALID_OPERATION, "can not massSubscribe when connection state is ".concat(this.state));
          const i3 = { p2p_id: this.store.p2pId, users: e2, dtx: false, rtx: !!dN("USE_SUB_RTX"), twcc: !!dN("SUBSCRIBE_TWCC"), svc: Array.isArray(dN("SVC")) && 0 !== dN("SVC").length ? dN("SVC") : void 0 };
          try {
            return await this.signal.request(PM.SUBSCRIBE_STREAMS, i3, true);
          } catch (i4) {
            if (t2 && i4.data && i4.data.code === OM.ERR_SUBSCRIBE_REQUEST_INVALID)
              return BN.warning("[".concat(this.store.clientId, "] receiver massSubscribe error code, retry"), i4.toString()), await this.tryMassUnsubBeforeResub(e2), await this.subscribeAll(e2, false);
            throw i4;
          }
        }
        async setVideoProfile(e2) {
          const t2 = function(e3) {
            if (!(e3.bitrateMax && e3.bitrateMin && e3.frameRate && e3.height && e3.width))
              return;
            let t3 = e3.frameRate, i3 = e3.width, n2 = e3.height, r2 = true;
            return "number" != typeof t3 && (t3 = t3.exact || t3.ideal || t3.max || t3.min || 0, t3 || (r2 = false)), "number" != typeof i3 && (i3 = i3.exact || i3.ideal || i3.max || i3.min || 0, i3 || (r2 = false)), "number" != typeof n2 && (n2 = n2.exact || n2.ideal || n2.max || n2.min || 0, t3 || (r2 = false)), r2 ? { stream_type: 0, width: i3, height: n2, fps: t3, start_bps: 1e3 * e3.bitrateMax, min_bps: 1e3 * e3.bitrateMin, target_bps: 1e3 * e3.bitrateMax } : void 0;
          }(e2);
          if (t2)
            return this.signal.request(PM.SET_VIDEO_PROFILE, t2);
          BN.debug("[".concat(this.store.clientId, "] encoder config is not complete, do not report to gateway"));
        }
        async unsubscribe(e2, t2) {
          try {
            await this.signal.request(PM.UNSUBSCRIBE, { p2p_id: this.store.p2pId, ortc: e2, stream_id: t2 }, true);
          } catch (e3) {
            BN.warning("[".concat(this.store.clientId, "] unsubscribe warning: "), e3);
          }
        }
        async unsubscribeDataChannel(e2, t2) {
          try {
            if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
              throw new XN(_w.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
            await Wh.all(e2.map((e3) => this.signal.request(PM.UNSUBSCRIBE_DATASTREAM, { stream_id: e3, uid: t2 }, true)));
          } catch (e3) {
            BN.warning("unsubscribeDataChannel warning: ", e3);
          }
        }
        async massUnsubscribe(e2) {
          try {
            await this.signal.request(PM.UNSUBSCRIBE_STREAMS, e2, true);
          } catch (e3) {
            BN.warning("[".concat(this.store.clientId, "] massUnsubscribeAll warning: "), e3);
          }
        }
        async reconnectPC(e2) {
          const { iceParameters: t2, dtlsParameters: i3, rtpCapabilities: n2 } = e2;
          return { gatewayEstablishParams: await this.signal.request(PM.CONNECT_PC, { p2p_id: this.store.p2pId, stream_id: this.store.uid, ortc: { iceParameters: t2, dtlsParameters: i3, rtpCapabilities: n2 } }, true), gatewayAddress: this.getCurrentGatewayAddress() };
        }
        getGatewayInfo() {
          return this.signal.request(PM.GATEWAY_INFO);
        }
        async renewToken(e2) {
          await this.signal.request(PM.RENEW_TOKEN, e2), this.key = e2.token;
        }
        updateClientRole(e2, t2) {
          t2 && (this._clientRoleOptions = Object.assign({}, t2)), dN("CLIENT_ROLE_OPTIONS") && (BN.debug("[".concat(this.store.clientId, "] Set roleOptions for ").concat(JSON.stringify(dN("CLIENT_ROLE_OPTIONS")), " instead of ").concat(JSON.stringify(this._clientRoleOptions), " ")), this._clientRoleOptions = Object.assign({}, dN("CLIENT_ROLE_OPTIONS"))), this.role = e2;
        }
        async setClientRole(e2, t2) {
          if (t2 && (this._clientRoleOptions = Object.assign({}, t2)), dN("CLIENT_ROLE_OPTIONS") && (this._clientRoleOptions = Object.assign({}, dN("CLIENT_ROLE_OPTIONS")), BN.debug("[".concat(this.store.clientId, "] Set roleOptions for ").concat(JSON.stringify(dN("CLIENT_ROLE_OPTIONS")), " instead of ").concat(JSON.stringify(this._clientRoleOptions), " "))), "CONNECTED" !== this.state)
            return void (this.role = e2);
          let i3, n2 = 0;
          "audience" === e2 ? this._clientRoleOptions && this._clientRoleOptions.delay ? (i3 = this._clientRoleOptions.delay, n2 = 1) : n2 = this._clientRoleOptions && this._clientRoleOptions.level ? this._clientRoleOptions.level : 2 : n2 = 0, await this.signal.request(PM.SET_CLIENT_ROLE, { role: e2, level: n2, delay: i3, client_ts: Date.now() }), this.role = e2;
        }
        async setRemoteVideoStreamType(e2, t2) {
          await this.signal.request(PM.SWITCH_VIDEO_STREAM, { stream_id: e2, stream_type: t2 });
        }
        async setDefaultRemoteVideoStreamType(e2) {
          await this.signal.request(PM.DEFAULT_VIDEO_STREAM, { stream_type: e2 });
        }
        async setStreamFallbackOption(e2, t2) {
          await this.signal.request(PM.SET_FALLBACK_OPTION, { stream_id: e2, fallback_type: t2 });
        }
        async pickSVCLayer(e2, t2) {
          await this.signal.request(PM.PICK_SVC_LAYER, { stream_id: e2, spatial_layer: t2.spatialLayer, temporal_layer: t2.temporalLayer });
        }
        async setRTM2Flag(e2) {
          await this.signal.request(PM.SET_RTM2_FLAG, { rtm2_flag: e2 });
        }
        async sendExtensionMessage(e2, t2, i3) {
          if (this.store.useP2P)
            return this.signal.sendExtensionMessage(e2, t2, i3);
        }
        getInChannelInfo() {
          return this.inChannelInfo.joinAt && (this.inChannelInfo.duration = Date.now() - this.inChannelInfo.joinAt), Kx({}, this.inChannelInfo);
        }
        async getGatewayVersion() {
          return (await this.signal.request(PM.GATEWAY_INFO)).version;
        }
        reset() {
          if (this.inChannelInfo.joinAt && (this.inChannelInfo.duration = Date.now() - this.inChannelInfo.joinAt, this.inChannelInfo.joinAt = null), this.trafficStatsInterval && (window.clearInterval(this.trafficStatsInterval), this.trafficStatsInterval = void 0), this.joinInfo) {
            const e2 = Yx.get(this.joinInfo.cname);
            e2 && e2.delete(this.joinInfo.uid);
          }
          this.joinInfo = void 0, this.key = void 0, this.networkQualityInterval && (window.clearInterval(this.networkQualityInterval), this.networkQualityInterval = void 0);
        }
        updateTurnConfigFromSignal() {
          if (!this.joinInfo)
            return;
          const e2 = function(e3) {
            let t2;
            return t2 = e3.startsWith("dc") ? e3.match(/(dc\:\/\/)?([^:]+):(\d+)/) : e3.match(/(wss\:\/\/)?([^:]+):(\d+)/), t2 ? { username: rN.username, password: rN.password, turnServerURL: t2[2], tcpport: parseInt(t2[3]) + 30, udpport: parseInt(t2[3]) + 30, forceturn: false } : null;
          }(("disabled" === this.joinInfo.cloudProxyServer ? this.signal.url : this.joinInfo.gatewayAddrs[this.signal.currentURLIndex].address) || "");
          this.joinInfo.turnServer.serversFromGateway = [], e2 && "off" !== this.joinInfo.turnServer.mode && "disabled" === this.joinInfo.cloudProxyServer && this.joinInfo.turnServer.serversFromGateway.push(Kx(Kx({}, rN), {}, { turnServerURL: e2.turnServerURL, tcpport: e2.tcpport, udpport: e2.udpport, username: this.joinInfo.uid.toString(), password: this.joinInfo.token }));
        }
        async updateTrafficStats() {
          if ("CONNECTED" !== this.state)
            return;
          const e2 = await this.signal.request(PM.TRAFFIC_STATS, void 0, true);
          e2.timestamp = Date.now(), null != e2.ntp_offset && (this.ntpOffset = e2.ntp_offset), e2.peer_delay.forEach((e3) => {
            const t2 = this._statsCollector.trafficStats && this._statsCollector.trafficStats.peer_delay.find((t3) => t3.peer_uid === e3.peer_uid);
            t2 && t2.B_st !== e3.B_st && Zw(() => {
              this.emit($M.STREAM_TYPE_CHANGE, e3.peer_uid, e3.B_st);
            });
          }), this._statsCollector.updateTrafficStats(e2);
        }
        getJoinMessage(e2) {
          if (!this.joinInfo || !this.key)
            throw new XN(_w.UNEXPECTED_ERROR, "can not generate join message, no join info");
          const t2 = Object.assign({}, this.joinInfo.apResponse);
          let i3 = dN("REPORT_APP_SCENARIO");
          if ("string" != typeof i3)
            try {
              i3 = JSON.stringify(i3);
            } catch (e3) {
              i3 = void 0;
            }
          i3 && i3.length > 128 && (i3 = void 0);
          const n2 = !(Kb() || zb(87) || $N()) && ("boolean" == typeof dN("ENABLE_PRE_SUB") && dN("ENABLE_PRE_SUB")), r2 = !$N() && Vx("ENABLE_PREALLOC_PC", "boolean"), o2 = Fx(), s2 = Kx({ license: this.joinInfo.license, p2p_id: this.store.p2pId, session_id: this.joinInfo.sid, app_id: this.joinInfo.appId, channel_key: this.key, channel_name: this.joinInfo.cname, sdk_version: tN, browser: navigator.userAgent, process_id: dN("PROCESS_ID"), mode: this.store.useP2P ? "p2p" : this.spec.mode, codec: this.spec.codec, role: this.role, has_changed_gateway: this.hasChangeBGPAddress, ap_response: t2, extend: dN("JOIN_EXTEND"), details: { 6: this.joinInfo.stringUid, cservice_map: "proxy3" === this.joinInfo.cloudProxyServer ? "1" : "proxy5" === this.joinInfo.cloudProxyServer ? "2" : void 0 }, features: { rejoin: true }, optionalInfo: this.joinInfo.optionalInfo, appScenario: i3, attributes: { userAttributes: Kx({ enablePublishedUserList: dN("ENABLE_PUBLISHED_USER_LIST"), maxSubscription: dN("MAX_SUBSCRIPTION"), subscribeAudioFilterTopN: "number" == typeof dN("SUBSCRIBE_AUDIO_FILTER_TOPN") ? dN("SUBSCRIBE_AUDIO_FILTER_TOPN") : void 0, enablePublishAudioFilter: "boolean" == typeof dN("ENABLE_PUBLISH_AUDIO_FILTER") ? dN("ENABLE_PUBLISH_AUDIO_FILTER") : void 0, enableUserLicenseCheck: "boolean" == typeof dN("ENABLE_USER_LICENSE_CHECK") ? dN("ENABLE_USER_LICENSE_CHECK") : void 0, enableRTX: true === dN("USE_PUB_RTX") || true === dN("USE_SUB_RTX") || void 0, disableFEC: dN("DISABLE_FEC"), enableNTPReport: !!dN("ENABLE_NTP_REPORT") || void 0, enableInstantVideo: !!dN("ENABLE_INSTANT_VIDEO") || void 0, enableFulllinkAvSync: !!dN("ENABLE_FULL_LINK_AV_SYNC") || void 0, enableDataStream2: Vx("ENABLE_DATASTREAM_2", "boolean"), enableAutFeedback: !!dN("ENABLE_AUT_FEEDBACK") || void 0, rtm2Flag: "number" == typeof this.joinInfo.rtmFlag ? this.joinInfo.rtmFlag : void 0, enableUserAutoRebalanceCheck: !!dN("ENABLE_USER_AUTO_REBALANCE_CHECK"), enableXR: Vx("USE_XR", "boolean"), enableLossbasedBwe: Vx("ENABLE_LOSSBASED_BWE", "boolean"), enableAutCC: !!dN("ENABLE_AUT_CC") || void 0, enableCCFallback: Vx("ENABLE_CC_FALLBACK", "boolean"), enablePreallocPC: r2, preSubNum: n2 ? Vx("PRE_SUB_NUM", "number") : void 0, enablePubTWCC: Vx("PUBLISH_TWCC", "boolean"), enableSubTWCC: Vx("SUBSCRIBE_TWCC", "boolean"), enablePubRTX: Vx("USE_PUB_RTX", "boolean"), enableSubRTX: Vx("USE_SUB_RTX", "boolean"), enableSubSVC: dN("ENABLE_SVC") ? dN("ENABLE_SVC_DEFAULT_CODECS") : Array.isArray(dN("SVC")) && 0 !== dN("SVC").length ? dN("SVC") : void 0, enableSvcExtended: dN("ENABLE_SVC") && Array.isArray(dN("SVC_EXTENDED")) && 0 !== dN("SVC_EXTENDED").length ? dN("SVC_EXTENDED") : void 0 }, o2) }, join_ts: this.joinGatewayStartTime }, e2);
          return this.joinInfo.stringUid && (s2.string_uid = this.joinInfo.stringUid), this.joinInfo.aesmode && this.joinInfo.aespassword && (s2.aes_mode = this.joinInfo.aesmode, dN("ENCRYPT_AES") ? (s2.aes_secret = this.joinInfo.aespassword, s2.aes_encrypt = true) : s2.aes_secret = this.joinInfo.aespassword, this.joinInfo.aessalt && (s2.aes_salt = this.joinInfo.aessalt)), t2.addresses[this.signal.websocket.currentURLIndex] && (s2.ap_response.ticket = t2.addresses[this.signal.websocket.currentURLIndex].ticket, delete t2.addresses), void 0 !== this.joinInfo.defaultVideoStream && (s2.default_video_stream = this.joinInfo.defaultVideoStream), s2;
        }
        getRejoinMessage() {
          if (!this.joinInfo)
            throw new XN(_w.UNEXPECTED_ERROR, "can not generate rejoin message, no join info");
          return { session_id: this.joinInfo.sid, channel_name: this.joinInfo.cname, cid: this.joinInfo.cid, uid: this.joinInfo.uid, vid: Number(this.joinInfo.vid) };
        }
        handleSignalEvents() {
          this.signal.on(DM.WS_RECONNECT_CREATE_CONNECTION, (e2) => {
            this.joinGatewayStartTime = Date.now();
          }), this.signal.on(DM.WS_RECONNECTING, (e2) => {
            this.joinInfo && zN.WebSocketQuit(this.joinInfo.sid, { lts: Date.now(), succ: -1, cname: this.joinInfo.cname, uid: this.joinInfo.uid, cid: this.joinInfo.cid, errorCode: e2 || Gw.NETWORK_ERROR }), this.joinInfo && (this.state = "RECONNECTING", zN.sessionInit(this.joinInfo.sid, { lts: (/* @__PURE__ */ new Date()).getTime(), extend: this.isSignalRecover ? { recover: true } : { rejoin: true }, cname: this.joinInfo.cname, appid: this.joinInfo.appId, mode: this.spec.mode, stringUid: this.joinInfo.stringUid, channelProfile: "live" === this.spec.mode ? 1 : 0, channelMode: 0, lsid: this.joinInfo.sid, clientRole: "audience" === this.role ? 2 : 1, buildFormat: 1 }), this.isSignalRecover = false, this.joinGatewayStartTime = Date.now());
          }), this.signal.on(DM.WS_CLOSED, (e2) => {
            let t2;
            switch (e2) {
              case xw.LEAVE:
                t2 = Gw.LEAVE;
                break;
              case xw.UID_BANNED:
              case xw.IP_BANNED:
              case xw.CHANNEL_BANNED:
              case xw.SERVER_ERROR:
                t2 = Gw.SERVER_ERROR;
                break;
              case xw.FALLBACK:
                t2 = Gw.FALLBACK;
                break;
              case xw.LICENSE_MISSING:
              case xw.LICENSE_EXPIRED:
              case xw.LICENSE_MINUTES_EXCEEDED:
              case xw.LICENSE_PERIOD_INVALID:
              case xw.LICENSE_MULTIPLE_SDK_SERVICE:
              case xw.LICENSE_ILLEGAL:
              case xw.TOKEN_EXPIRE:
                t2 = e2;
                break;
              default:
                t2 = Gw.NETWORK_ERROR;
            }
            BN.debug("[".concat(this.store.clientId, "] [signal] websocket closed, reason: ").concat(t2 || "undefined -> " + Gw.NETWORK_ERROR)), this.joinInfo && zN.WebSocketQuit(this.joinInfo.sid, { lts: Date.now(), succ: e2 === xw.LEAVE ? 1 : -1, cname: this.joinInfo.cname, uid: this.joinInfo.uid, cid: this.joinInfo.cid, errorCode: t2 }), this._disconnectedReason = e2, e2 !== xw.FALLBACK && (this.state = "DISCONNECTED"), this.reset();
          }), this.signal.on(DM.WS_CONNECTED, () => {
            if (this.updateTurnConfigFromSignal(), this.state = "CONNECTED", this.joinInfo) {
              if ("audience" === this.role) {
                const e2 = dN("CLIENT_ROLE_OPTIONS") || this._clientRoleOptions;
                e2 && (e2.level || e2.delay) && (BN.debug("[".concat(this.store.clientId, "] patch to send set client role, role: ").concat(this.role, ", mode: ").concat(this.spec.mode, ", level: ").concat(e2.level, ", delay: ").concat(e2.delay)), this.setClientRole(this.role, e2));
              }
              if (zN.joinGateway(this.joinInfo.sid, { lts: this.joinGatewayStartTime, succ: true, ec: null, vid: this.joinInfo.vid, addr: this.signal.url, uid: this.joinInfo.uid, cid: this.joinInfo.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!this.joinInfo.proxyServer, signalChannel: "0", preload: this.joinInfo.preload }), this._isProactiveJoin = false, this.joinInfo.useLocalAccessPoint && 1 === this.joinInfo.setLocalAPVersion) {
                const e2 = this.signal.url && this.signal.url.match(/wss\:\/\/([^:]+):(\d+)/);
                if (!e2)
                  return void BN.error("[".concat(this.store.clientId, "] set local access point after joined failed: ").concat(e2));
                cN("EVENT_REPORT_DOMAIN", e2[1]), cN("EVENT_REPORT_BACKUP_DOMAIN", e2[1]), cN("LOG_UPLOAD_SERVER", "".concat(e2[1], ":6444"));
              }
            }
          }), this.signal.on(kM.ON_UPLINK_STATS, (e2) => {
            this._statsCollector.updateUplinkStats(e2);
          }), this.signal.on(DM.REQUEST_RECOVER, (e2, t2, i3) => {
            if (!this.joinInfo)
              return i3(new XN(_w.UNEXPECTED_ERROR, "gateway: can not recover, no join info"));
            e2 && (this.joinInfo.multiIP = e2, this.hasChangeBGPAddress = true), this.isSignalRecover = true, Kw(this, $M.REQUEST_NEW_GATEWAY_LIST).then(t2).catch(i3);
          }), this.signal.on(DM.REQUEST_JOIN_INFO, async (e2, t2, i3) => {
            var n2;
            if (this.updateTurnConfigFromSignal(), this.store.useP2P)
              return void e2(this.getJoinMessage({ ortc: {} }));
            const { iceParameters: r2, dtlsParameters: o2, rtpCapabilities: s2 } = await Kw(this, $M.REQUEST_P2P_CONNECTION_PARAMS, { turnServer: null === (n2 = this.joinInfo) || void 0 === n2 ? void 0 : n2.turnServer });
            try {
              e2(this.getJoinMessage({ ortc: { iceParameters: r2, dtlsParameters: o2, rtpCapabilities: s2, version: "2" } }));
            } catch (e3) {
              t2(e3);
            }
          }), this.signal.on(DM.REQUEST_REJOIN_INFO, (e2) => {
            e2(this.getRejoinMessage());
          }), this.signal.on(DM.REPORT_JOIN_GATEWAY, (e2, t2) => {
            if (!this.joinInfo)
              return;
            let i3, n2 = "";
            var r2;
            e2 instanceof XN ? (i3 = (null === (r2 = e2.data) || void 0 === r2 ? void 0 : r2.desc) || e2.code, n2 = e2.message) : i3 = e2;
            zN.joinGateway(this.joinInfo.sid, { lts: this.joinGatewayStartTime, succ: false, ec: i3, errorMsg: n2, addr: t2, uid: this.joinInfo.uid, cid: this.joinInfo.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!this.joinInfo.proxyServer, signalChannel: "0", preload: this.joinInfo.preload });
          }), this.signal.on(DM.IS_P2P_DISCONNECTED, (e2) => {
            e2(zw(this, $M.IS_P2P_DISCONNECTED));
          }), this.signal.on(DM.DISCONNECT_P2P, () => {
            this.emit($M.DISCONNECT_P2P);
          }), this.signal.on(DM.REQUEST_SUCCESS, () => {
            this._signalTimeout = false;
          }), this.signal.on(DM.REQUEST_TIMEOUT, () => {
            this._signalTimeout = true;
          }), this.signal.on(DM.JOIN_RESPONSE, (e2) => {
            const t2 = this.getCurrentGatewayAddress();
            this.emit($M.JOIN_RESPONSE, e2, t2);
          }), this.signal.on(DM.PRE_CONNECT_PC, async () => {
            if (this.joinInfo) {
              this.updateTurnConfigFromSignal();
              const e2 = this.getCurrentGatewayAddress(), t2 = dN("FINGERPRINT") || this.joinInfo.apResponse.addresses[this.signal.currentURLIndex].fingerprint;
              if (e2 && t2) {
                const i3 = mx(e2);
                this.emit($M.PRE_CONNECT_PC, { candidates: i3, fingerprint: t2 });
              }
            }
          }), this.signal.on(DM.RECOVER_NOTIFICATION, (e2) => {
            this.joinInfo && "string" == typeof dN("AP_REQUEST_DETAIL") && (this.joinInfo.apRequestDetail = "".concat(dN("AP_REQUEST_DETAIL"), ";").concat(e2));
          });
        }
        async tryUnsubBeforeResub(e2, t2) {
          try {
            await this.signal.request(PM.UNSUBSCRIBE, { p2p_id: this.store.p2pId, stream_id: e2, ortc: [t2] }, true);
          } catch (e3) {
            throw BN.warning("[".concat(this.store.clientId, "] tryUnsubBeforeResub warning"), e3), e3;
          }
        }
        async tryUnsubDataChannelBeforeResub(e2, t2) {
          try {
            await this.signal.request(PM.UNSUBSCRIBE, { stream_id: t2.id }, true);
          } catch (e3) {
            throw BN.warning("unsubscribe datachannel warning", e3), e3;
          }
        }
        async tryUnpubBeforeRepub(e2, t2) {
          try {
            await this.signal.request(PM.UNPUBLISH, { stream_id: e2, ortc: t2 }, true);
          } catch (e3) {
            throw BN.warning("[".concat(this.store.clientId, "] tryUnpubBeforeRepub warning: "), e3), e3;
          }
        }
        async tryUnpubDataChannelBeforeRepub(e2, t2) {
          try {
            await this.signal.request(PM.UNPUBLISH_DATASTREAM, { channnel_id: t2.channelId }, true);
          } catch (e3) {
            throw BN.warning("unpublish datastream warning: ", e3), e3;
          }
        }
        async tryMassUnsubBeforeResub(e2) {
          const t2 = { users: e2.map((e3) => ({ stream_id: e3.stream_id, stream_type: e3.stream_type })) };
          try {
            await this.signal.request(PM.UNSUBSCRIBE_STREAMS, t2, true);
          } catch (e3) {
            throw BN.warning("[".concat(this.store.clientId, "] tryMassUnsubBeforeResub warning"), e3), e3;
          }
        }
        async muteLocal(e2, t2) {
          const i3 = { action: e2.find((e3) => e3.stream_type === ZM.Audio) ? "mute_local_audio" : "mute_local_video", p2p_id: this.store.p2pId, ortc: e2, stream_id: t2 };
          try {
            await this.signal.request(PM.CONTROL, i3, true, true);
          } catch (e3) {
            throw BN.warning("[".concat(this.store.clientId, "] gateway muteLocal warning: "), e3), e3;
          }
        }
        async unmuteLocal(e2, t2) {
          const i3 = { action: e2.find((e3) => e3.stream_type === ZM.Audio) ? "unmute_local_audio" : "unmute_local_video", p2p_id: this.store.p2pId, ortc: e2, stream_id: t2 };
          try {
            await this.signal.request(PM.CONTROL, i3, true, true);
          } catch (e3) {
            throw BN.warning("[".concat(this.store.clientId, "] gateway unmuteLocal warning: "), e3), e3;
          }
        }
        async muteRemote(e2, t2) {
          const i3 = { action: e2 === lU.AUDIO ? "mute_remote_audio" : "mute_remote_video", p2p_id: this.store.p2pId, stream_id: t2 };
          try {
            await this.signal.request(PM.CONTROL, i3, true, true);
          } catch (e3) {
            throw BN.warning("[".concat(this.store.clientId, "] gateway muteRemote warning: "), e3), e3;
          }
        }
        async unmuteRemote(e2, t2) {
          const i3 = { action: e2 === lU.AUDIO ? "unmute_remote_audio" : "unmute_remote_video", p2p_id: this.store.p2pId, stream_id: t2 };
          try {
            await this.signal.request(PM.CONTROL, i3, true, true);
          } catch (e3) {
            throw BN.warning("[".concat(this.store.clientId, "] gateway unmuteRemote warning: "), e3), e3;
          }
        }
        uploadWRTCStats(e2) {
          this.signal.uploadWRTCStats(e2);
        }
        upload(e2, t2) {
          this.signal.upload(e2, t2);
        }
        getSignalRTT() {
          return this.signal.rtt;
        }
        async restartICE(e2) {
          const t2 = { p2p_id: this.store.p2pId, stream_id: this.store.uid, ortc: e2 };
          try {
            return await this.signal.request(PM.RESTART_ICE, t2, true);
          } catch (e3) {
            throw BN.warning("[".concat(this.store.clientId, "] P2PChannel.restartICE warning: "), e3), e3;
          }
        }
        reconnect(e2, t2) {
          "CONNECTED" === this.state && this.signal.reconnect(e2 || void 0, t2 || Gw.P2P_FAILED);
        }
        getCurrentGatewayAddress() {
          var e2, t2;
          if (!dN("GATEWAY_WSS_ADDRESS"))
            return dN("USE_CANDIDATE_FROM_AP_DETAIL") && null !== (e2 = this.joinInfo) && void 0 !== e2 && e2.apGatewayAddress ? (BN.debug("[".concat(this.store.clientId, "] use candidate from ap detail, ").concat(JSON.stringify(this.joinInfo.apGatewayAddress))), this.joinInfo.apGatewayAddress) : null !== (t2 = this.joinInfo) && void 0 !== t2 && t2.gatewayAddrs ? this.joinInfo.gatewayAddrs[this.signal.currentURLIndex] : void 0;
        }
        async setPublishAudioFilterEnabled(e2) {
          await this.signal.request(PM.SET_PARAMETER, { enablePublishAudioFilter: e2 });
        }
      }
      let zx = 0, Xx = 0;
      function Jx(e2, t2, i3, n2) {
        return new Wh((r2, o2) => {
          t2.timeout = t2.timeout || dN("HTTP_CONNECT_TIMEOUT"), t2.responseType = t2.responseType || "json", t2.data && !i3 ? (t2.data = JSON.stringify(t2.data), zx += aO(t2.data)) : i3 && (t2.data.size ? zx += t2.data.size : t2.data instanceof FormData ? zx += cO(t2.data) : zx += aO(JSON.stringify(t2.data))), t2.headers = t2.headers || {}, t2.headers["Content-Type"] = t2.headers["Content-Type"] || "application/json", t2.method = "POST", t2.url = e2, Ab.request(t2).then((e3) => {
            "string" == typeof e3.data ? Xx += aO(e3.data) : e3.data instanceof ArrayBuffer || e3.data instanceof Uint8Array ? Xx += e3.data.byteLength : Xx += aO(JSON.stringify(e3.data)), n2 && r2({ data: e3.data, headers: e3.headers }), r2(e3.data);
          }).catch((e3) => {
            Ab.isCancel(e3) ? o2(new XN(_w.OPERATION_ABORTED, "cancel token canceled")) : "ECONNABORTED" === e3.code ? o2(new XN(_w.NETWORK_TIMEOUT, e3.message)) : e3.response ? o2(new XN(_w.NETWORK_RESPONSE_ERROR, e3.response.status)) : o2(new XN(_w.NETWORK_ERROR, e3.message));
          });
        });
      }
      !function() {
        var e2;
        function i3(e3) {
          var t2 = 0;
          return function() {
            return t2 < e3.length ? { done: false, value: e3[t2++] } : { done: true };
          };
        }
        var n2 = "function" == typeof Object.defineProperties ? Object.defineProperty : function(e3, t2, i4) {
          return e3 == Array.prototype || e3 == Object.prototype || (e3[t2] = i4.value), e3;
        };
        var r2, o2 = function(e3) {
          e3 = ["object" == typeof globalThis && globalThis, e3, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof t && t];
          for (var i4 = 0; i4 < e3.length; ++i4) {
            var n3 = e3[i4];
            if (n3 && n3.Math == Math)
              return n3;
          }
          throw Error("Cannot find global object");
        }(this);
        function s2(e3, t2) {
          if (t2)
            e: {
              var i4 = o2;
              e3 = e3.split(".");
              for (var r3 = 0; r3 < e3.length - 1; r3++) {
                var s3 = e3[r3];
                if (!(s3 in i4))
                  break e;
                i4 = i4[s3];
              }
              (t2 = t2(r3 = i4[e3 = e3[e3.length - 1]])) != r3 && null != t2 && n2(i4, e3, { configurable: true, writable: true, value: t2 });
            }
        }
        function a2(e3) {
          return (e3 = { next: e3 })[Symbol.iterator] = function() {
            return this;
          }, e3;
        }
        function c2(e3) {
          var t2 = "undefined" != typeof Symbol && Symbol.iterator && e3[Symbol.iterator];
          return t2 ? t2.call(e3) : { next: i3(e3) };
        }
        if (s2("Symbol", function(e3) {
          function t2(e4, t3) {
            this.A = e4, n2(this, "description", { configurable: true, writable: true, value: t3 });
          }
          if (e3)
            return e3;
          t2.prototype.toString = function() {
            return this.A;
          };
          var i4 = "jscomp_symbol_" + (1e9 * Math.random() >>> 0) + "_", r3 = 0;
          return function e4(n3) {
            if (this instanceof e4)
              throw new TypeError("Symbol is not a constructor");
            return new t2(i4 + (n3 || "") + "_" + r3++, n3);
          };
        }), s2("Symbol.iterator", function(e3) {
          if (e3)
            return e3;
          e3 = Symbol("Symbol.iterator");
          for (var t2 = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), r3 = 0; r3 < t2.length; r3++) {
            var s3 = o2[t2[r3]];
            "function" == typeof s3 && "function" != typeof s3.prototype[e3] && n2(s3.prototype, e3, { configurable: true, writable: true, value: function() {
              return a2(i3(this));
            } });
          }
          return e3;
        }), "function" == typeof Object.setPrototypeOf)
          r2 = Object.setPrototypeOf;
        else {
          var d2;
          e: {
            var l2 = {};
            try {
              l2.__proto__ = { a: true }, d2 = l2.a;
              break e;
            } catch (e3) {
            }
            d2 = false;
          }
          r2 = d2 ? function(e3, t2) {
            if (e3.__proto__ = t2, e3.__proto__ !== t2)
              throw new TypeError(e3 + " is not extensible");
            return e3;
          } : null;
        }
        var u2 = r2;
        function h2() {
          this.m = false, this.j = null, this.v = void 0, this.h = 1, this.u = this.C = 0, this.l = null;
        }
        function p3(e3) {
          if (e3.m)
            throw new TypeError("Generator is already running");
          e3.m = true;
        }
        function _2(e3, t2) {
          return e3.h = 3, { value: t2 };
        }
        function E2(e3) {
          this.g = new h2(), this.G = e3;
        }
        function f2(e3, t2, i4, n3) {
          try {
            var r3 = t2.call(e3.g.j, i4);
            if (!(r3 instanceof Object))
              throw new TypeError("Iterator result " + r3 + " is not an object");
            if (!r3.done)
              return e3.g.m = false, r3;
            var o3 = r3.value;
          } catch (t3) {
            return e3.g.j = null, e3.g.s(t3), m2(e3);
          }
          return e3.g.j = null, n3.call(e3.g, o3), m2(e3);
        }
        function m2(e3) {
          for (; e3.g.h; )
            try {
              var t2 = e3.G(e3.g);
              if (t2)
                return e3.g.m = false, { value: t2.value, done: false };
            } catch (t3) {
              e3.g.v = void 0, e3.g.s(t3);
            }
          if (e3.g.m = false, e3.g.l) {
            if (t2 = e3.g.l, e3.g.l = null, t2.F)
              throw t2.D;
            return { value: t2.return, done: true };
          }
          return { value: void 0, done: true };
        }
        function T2(e3) {
          this.next = function(t2) {
            return e3.o(t2);
          }, this.throw = function(t2) {
            return e3.s(t2);
          }, this.return = function(t2) {
            return function(e4, t3) {
              p3(e4.g);
              var i4 = e4.g.j;
              return i4 ? f2(e4, "return" in i4 ? i4.return : function(e5) {
                return { value: e5, done: true };
              }, t3, e4.g.return) : (e4.g.return(t3), m2(e4));
            }(e3, t2);
          }, this[Symbol.iterator] = function() {
            return this;
          };
        }
        function S2(e3, t2) {
          return t2 = new T2(new E2(t2)), u2 && e3.prototype && u2(t2, e3.prototype), t2;
        }
        if (h2.prototype.o = function(e3) {
          this.v = e3;
        }, h2.prototype.s = function(e3) {
          this.l = { D: e3, F: true }, this.h = this.C || this.u;
        }, h2.prototype.return = function(e3) {
          this.l = { return: e3 }, this.h = this.u;
        }, E2.prototype.o = function(e3) {
          return p3(this.g), this.g.j ? f2(this, this.g.j.next, e3, this.g.o) : (this.g.o(e3), m2(this));
        }, E2.prototype.s = function(e3) {
          return p3(this.g), this.g.j ? f2(this, this.g.j.throw, e3, this.g.o) : (this.g.s(e3), m2(this));
        }, s2("Array.prototype.entries", function(e3) {
          return e3 || function() {
            return function(e4, t2) {
              e4 instanceof String && (e4 += "");
              var i4 = 0, n3 = false, r3 = { next: function() {
                if (!n3 && i4 < e4.length) {
                  var r4 = i4++;
                  return { value: t2(r4, e4[r4]), done: false };
                }
                return n3 = true, { done: true, value: void 0 };
              } };
              return r3[Symbol.iterator] = function() {
                return r3;
              }, r3;
            }(this, function(e4, t2) {
              return [e4, t2];
            });
          };
        }), "undefined" != typeof Blob && ("undefined" == typeof FormData || !FormData.prototype.keys)) {
          var g2 = function(e3, t2) {
            for (var i4 = 0; i4 < e3.length; i4++)
              t2(e3[i4]);
          }, R3 = function(e3) {
            return e3.replace(/\r?\n|\r/g, "\r\n");
          }, C2 = function(e3, t2, i4) {
            return t2 instanceof Blob ? (i4 = void 0 !== i4 ? String(i4 + "") : "string" == typeof t2.name ? t2.name : "blob", t2.name === i4 && "[object Blob]" !== Object.prototype.toString.call(t2) || (t2 = new File([t2], i4)), [String(e3), t2]) : [String(e3), String(t2)];
          }, v2 = function(e3, t2) {
            if (e3.length < t2)
              throw new TypeError(t2 + " argument required, but only " + e3.length + " present.");
          }, I2 = "object" == typeof globalThis ? globalThis : "object" == typeof window ? window : "object" == typeof self ? self : this, y2 = I2.FormData, A2 = I2.XMLHttpRequest && I2.XMLHttpRequest.prototype.send, b2 = I2.Request && I2.fetch, w2 = I2.navigator && I2.navigator.sendBeacon, O2 = I2.Element && I2.Element.prototype, N2 = I2.Symbol && Symbol.toStringTag;
          N2 && (Blob.prototype[N2] || (Blob.prototype[N2] = "Blob"), "File" in I2 && !File.prototype[N2] && (File.prototype[N2] = "File"));
          try {
            new File([], "");
          } catch (e3) {
            I2.File = function(e4, t2, i4) {
              return e4 = new Blob(e4, i4 || {}), Object.defineProperties(e4, { name: { value: t2 }, lastModified: { value: +(i4 && void 0 !== i4.lastModified ? new Date(i4.lastModified) : /* @__PURE__ */ new Date()) }, toString: { value: function() {
                return "[object File]";
              } } }), N2 && Object.defineProperty(e4, N2, { value: "File" }), e4;
            };
          }
          var D2 = function(e3) {
            return e3.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
          }, P2 = function(e3) {
            this.i = [];
            var t2 = this;
            e3 && g2(e3.elements, function(e4) {
              if (e4.name && !e4.disabled && "submit" !== e4.type && "button" !== e4.type && !e4.matches("form fieldset[disabled] *"))
                if ("file" === e4.type) {
                  var i4 = e4.files && e4.files.length ? e4.files : [new File([], "", { type: "application/octet-stream" })];
                  g2(i4, function(i5) {
                    t2.append(e4.name, i5);
                  });
                } else
                  "select-multiple" === e4.type || "select-one" === e4.type ? g2(e4.options, function(i5) {
                    !i5.disabled && i5.selected && t2.append(e4.name, i5.value);
                  }) : "checkbox" === e4.type || "radio" === e4.type ? e4.checked && t2.append(e4.name, e4.value) : (i4 = "textarea" === e4.type ? R3(e4.value) : e4.value, t2.append(e4.name, i4));
            });
          };
          if ((e2 = P2.prototype).append = function(e3, t2, i4) {
            v2(arguments, 2), this.i.push(C2(e3, t2, i4));
          }, e2.delete = function(e3) {
            v2(arguments, 1);
            var t2 = [];
            e3 = String(e3), g2(this.i, function(i4) {
              i4[0] !== e3 && t2.push(i4);
            }), this.i = t2;
          }, e2.entries = function e3() {
            var t2, i4 = this;
            return S2(e3, function(e4) {
              if (1 == e4.h && (t2 = 0), 3 != e4.h)
                return t2 < i4.i.length ? e4 = _2(e4, i4.i[t2]) : (e4.h = 0, e4 = void 0), e4;
              t2++, e4.h = 2;
            });
          }, e2.forEach = function(e3, t2) {
            v2(arguments, 1);
            for (var i4 = c2(this), n3 = i4.next(); !n3.done; n3 = i4.next()) {
              var r3 = c2(n3.value);
              n3 = r3.next().value, r3 = r3.next().value, e3.call(t2, r3, n3, this);
            }
          }, e2.get = function(e3) {
            v2(arguments, 1);
            var t2 = this.i;
            e3 = String(e3);
            for (var i4 = 0; i4 < t2.length; i4++)
              if (t2[i4][0] === e3)
                return t2[i4][1];
            return null;
          }, e2.getAll = function(e3) {
            v2(arguments, 1);
            var t2 = [];
            return e3 = String(e3), g2(this.i, function(i4) {
              i4[0] === e3 && t2.push(i4[1]);
            }), t2;
          }, e2.has = function(e3) {
            v2(arguments, 1), e3 = String(e3);
            for (var t2 = 0; t2 < this.i.length; t2++)
              if (this.i[t2][0] === e3)
                return true;
            return false;
          }, e2.keys = function e3() {
            var t2, i4, n3, r3, o3 = this;
            return S2(e3, function(e4) {
              if (1 == e4.h && (t2 = c2(o3), i4 = t2.next()), 3 != e4.h)
                return i4.done ? void (e4.h = 0) : (n3 = i4.value, r3 = c2(n3), _2(e4, r3.next().value));
              i4 = t2.next(), e4.h = 2;
            });
          }, e2.set = function(e3, t2, i4) {
            v2(arguments, 2), e3 = String(e3);
            var n3 = [], r3 = C2(e3, t2, i4), o3 = true;
            g2(this.i, function(t3) {
              t3[0] === e3 ? o3 && (o3 = !n3.push(r3)) : n3.push(t3);
            }), o3 && n3.push(r3), this.i = n3;
          }, e2.values = function e3() {
            var t2, i4, n3, r3, o3 = this;
            return S2(e3, function(e4) {
              if (1 == e4.h && (t2 = c2(o3), i4 = t2.next()), 3 != e4.h)
                return i4.done ? void (e4.h = 0) : (n3 = i4.value, (r3 = c2(n3)).next(), _2(e4, r3.next().value));
              i4 = t2.next(), e4.h = 2;
            });
          }, P2.prototype._asNative = function() {
            for (var e3 = new y2(), t2 = c2(this), i4 = t2.next(); !i4.done; i4 = t2.next()) {
              var n3 = c2(i4.value);
              i4 = n3.next().value, n3 = n3.next().value, e3.append(i4, n3);
            }
            return e3;
          }, P2.prototype._blob = function() {
            var e3 = "----formdata-polyfill-" + Math.random(), t2 = [], i4 = "--" + e3 + '\r\nContent-Disposition: form-data; name="';
            return this.forEach(function(e4, n3) {
              return "string" == typeof e4 ? t2.push(i4 + D2(R3(n3)) + '"\r\n\r\n' + R3(e4) + "\r\n") : t2.push(i4 + D2(R3(n3)) + '"; filename="' + D2(e4.name) + '"\r\nContent-Type: ' + (e4.type || "application/octet-stream") + "\r\n\r\n", e4, "\r\n");
            }), t2.push("--" + e3 + "--"), new Blob(t2, { type: "multipart/form-data; boundary=" + e3 });
          }, P2.prototype[Symbol.iterator] = function() {
            return this.entries();
          }, P2.prototype.toString = function() {
            return "[object FormData]";
          }, O2 && !O2.matches && (O2.matches = O2.matchesSelector || O2.mozMatchesSelector || O2.msMatchesSelector || O2.oMatchesSelector || O2.webkitMatchesSelector || function(e3) {
            for (var t2 = (e3 = (this.document || this.ownerDocument).querySelectorAll(e3)).length; 0 <= --t2 && e3.item(t2) !== this; )
              ;
            return -1 < t2;
          }), N2 && (P2.prototype[N2] = "FormData"), A2) {
            var L2 = I2.XMLHttpRequest.prototype.setRequestHeader;
            I2.XMLHttpRequest.prototype.setRequestHeader = function(e3, t2) {
              L2.call(this, e3, t2), "content-type" === e3.toLowerCase() && (this.B = true);
            }, I2.XMLHttpRequest.prototype.send = function(e3) {
              e3 instanceof P2 ? (e3 = e3._blob(), this.B || this.setRequestHeader("Content-Type", e3.type), A2.call(this, e3)) : A2.call(this, e3);
            };
          }
          b2 && (I2.fetch = function(e3, t2) {
            return t2 && t2.body && t2.body instanceof P2 && (t2.body = t2.body._blob()), b2.call(this, e3, t2);
          }), w2 && (I2.navigator.sendBeacon = function(e3, t2) {
            return t2 instanceof P2 && (t2 = t2._asNative()), w2.call(this, e3, t2);
          }), I2.FormData = P2;
        }
      }();
      const Qx = () => {
        const e2 = dN("AREAS");
        0 === e2.length && e2.push(iU.GLOBAL);
        return Xn(e2).call(e2, (e3, t2, i3) => {
          const n2 = Zx(t2);
          return n2 ? 0 === i3 ? n2 : "".concat(e3, ",").concat(n2) : e3;
        }, "");
      }, Zx = (e2) => e2 === iU.OVERSEA ? "".concat(rU.ASIA, ",").concat(rU.EUROPE, ",").concat(rU.AFRICA, ",").concat(rU.NORTH_AMERICA, ",").concat(rU.SOUTH_AMERICA, ",").concat(rU.OCEANIA) : rU[e2], $x = (e2) => {
        const t2 = { CODE: "", WEBCS_DOMAIN: [], WEBCS_DOMAIN_BACKUP_LIST: [], PROXY_CS: [], CDS_AP: [], ACCOUNT_REGISTER: [], UAP_AP: [], EVENT_REPORT_DOMAIN: [], EVENT_REPORT_BACKUP_DOMAIN: [], LOG_UPLOAD_SERVER: [], PROXY_SERVER_TYPE3: [] };
        return e2.map((e3) => {
          const i3 = oU[e3], n2 = Object.keys(i3);
          n2 && n2.map((e4) => {
            "CODE" !== e4 && (t2[e4] = t2[e4].concat(i3[e4]));
          });
        }), t2;
      }, eV = { GLOBAL: { ASIA: [iU.CHINA, iU.JAPAN, iU.INDIA, iU.KOREA, iU.HKMC], EUROPE: [], NORTH_AMERICA: [iU.US], SOUTH_AMERICA: [], OCEANIA: [], AFRICA: [] } }, tV = Object.keys(eV[iU.GLOBAL]), iV = [iU.CHINA, iU.NORTH_AMERICA, iU.EUROPE, iU.ASIA, iU.JAPAN, iU.INDIA, iU.OCEANIA, iU.SOUTH_AMERICA, iU.AFRICA, iU.KOREA, iU.HKMC, iU.US], nV = function(e2, t2) {
        let i3 = [];
        if (Dn(e2).call(e2, iU.GLOBAL)) {
          const o2 = [iU.GLOBAL, iU.OVERSEA], s2 = Object.keys(oU);
          if (t2 === iU.GLOBAL)
            throw new XN(_w.INVALID_PARAMS, "GLOBAL is an invalid excludedArea value");
          if (t2 === iU.CHINA)
            i3 = [iU.OVERSEA];
          else if (r2 = t2, Dn(tV).call(tV, r2)) {
            const e3 = (n2 = t2, eV[iU.GLOBAL][n2] || []), r3 = [...o2, t2, ...e3];
            i3 = s2.filter((e4) => !Dn(r3).call(r3, e4));
          } else if (function(e3) {
            let t3 = false;
            return tV.forEach((i4) => {
              var n3;
              Dn(n3 = eV[iU.GLOBAL][i4]).call(n3, e3) && (t3 = true);
            }), t3;
          }(t2)) {
            const e3 = function(e4) {
              let t3;
              return tV.forEach((i4) => {
                var n4;
                Dn(n4 = eV[iU.GLOBAL][i4]).call(n4, e4) && (t3 = i4);
              }), t3;
            }(t2), n3 = [...o2, e3, t2];
            i3 = s2.filter((e4) => !Dn(n3).call(n3, e4));
          } else
            i3 = e2;
          i3 = function(e3) {
            const t3 = [];
            return iV.forEach((i4) => {
              Dn(e3).call(e3, i4) && t3.push(i4);
            }), t3.concat(e3.filter((e4) => !Dn(iV).call(iV, e4)));
          }(i3);
        } else
          i3 = e2;
        var n2, r2;
        return i3;
      };
      function rV(e2) {
        var t2, i3;
        if (!e2 && Dn(t2 = dN("AREAS")).call(t2, iU.EXTENSIONS))
          return BN.debug("update area from ap : reset"), void oV(Vk, true);
        if (!Dn(i3 = dN("AREAS")).call(i3, iU.GLOBAL) || !e2)
          return;
        let n2 = oU.EXTENSIONS;
        n2 && (n2 = { CODE: Zx(iU.EXTENSIONS), WEBCS_DOMAIN: ["ap-web-1-".concat(e2, ".agora.io")], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-".concat(e2, ".ap.sd-rtn.com")], PROXY_CS: ["proxy-ap-web-".concat(e2, ".agora.io")], CDS_AP: ["cds-ap-web-1-".concat(e2, ".agora.io"), "cds-ap-web-2-".concat(e2, ".ap.sd-rtn.com")], ACCOUNT_REGISTER: ["sua-ap-web-1-".concat(e2, ".agora.io"), "sua-ap-web-2-".concat(e2, ".ap.sd-rtn.com")], UAP_AP: ["uap-ap-web-1-".concat(e2, ".agora.io"), "uap-ap-web-2-".concat(e2, ".ap.sd-rtn.com")], EVENT_REPORT_DOMAIN: ["statscollector-1-".concat(e2, ".agora.io")], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-".concat(e2, ".agora.io")], LOG_UPLOAD_SERVER: ["logservice-".concat(e2, ".agora.io")], PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy-".concat(e2, ".agora.io")] }, BN.debug("update area from ap success: ".concat(e2, ",config is "), n2), cN("AREAS", [iU.EXTENSIONS], true), Object.keys(n2).map((e3) => {
          if ("LOG_UPLOAD_SERVER" === e3 || "EVENT_REPORT_DOMAIN" === e3 || "EVENT_REPORT_BACKUP_DOMAIN" === e3 || "PROXY_SERVER_TYPE3" === e3) {
            cN(e3, n2[e3][0]);
          } else
            cN(e3, n2[e3]);
        }));
      }
      function oV(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        const i3 = zN.reportApiInvoke(null, { name: Lw.SET_AREA, options: e2, tag: kw.TRACER });
        try {
          let n2 = [];
          if ("string" == typeof e2 && (n2 = [e2]), Array.isArray(e2) && (e2.forEach((e3) => {
            if (!Dn(nU).call(nU, e3))
              throw new XN(_w.INVALID_PARAMS, "invalid area code");
          }), n2 = e2), "[object Object]" === Object.prototype.toString.call(e2)) {
            const { areaCode: t3, excludedArea: i4 } = e2;
            if (!t3)
              throw new XN(_w.INVALID_PARAMS, "area code is needed");
            let r3 = t3;
            "string" == typeof t3 && (r3 = [t3]), n2 = i4 ? nV(r3, i4) : r3;
          }
          if (!t2) {
            if (lN.AREAS) {
              const e3 = new XN(_w.PROHIBITED_OPERATION, "setArea is prohibited because of config-distribute");
              return i3.onError(e3), void BN.warning("setArea is prohibited because of config-distribute");
            }
            if (Dn(n2).call(n2, iU.GLOBAL) && dN("AREAS") === iU.EXTENSIONS) {
              const e3 = new XN(_w.PROHIBITED_OPERATION, "setArea is prohibited because of ap extensions");
              return i3.onError(e3), void BN.warning("setArea is prohibited because of ap extensions");
            }
          }
          cN("AREAS", n2, t2);
          const r2 = $x(n2);
          Object.keys(r2).map((e3) => {
            if ("LOG_UPLOAD_SERVER" === e3 || "EVENT_REPORT_DOMAIN" === e3 || "EVENT_REPORT_BACKUP_DOMAIN" === e3 || "PROXY_SERVER_TYPE3" === e3) {
              cN(e3, r2[e3][0]);
            } else
              cN(e3, r2[e3]);
          }), BN.debug("set area success:", n2.join(","));
        } catch (e3) {
          throw i3.onError(e3), e3;
        }
        i3.onSuccess();
      }
      function sV(e2, t2) {
        var i3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i3.push.apply(i3, n2);
        }
        return i3;
      }
      function aV(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i3 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? sV(Object(i3), true).forEach(function(t3) {
            QI(e2, t3, i3[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : sV(Object(i3)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
          });
        }
        return e2;
      }
      let cV = 1;
      function dV(e2, t2, i3, n2, r2) {
        cV += 1;
        const o2 = { sid: i3.sid, command: "convergeAllocateEdge", uid: "666", appId: i3.appId, ts: Math.floor(Date.now() / 1e3), seq: cV, requestId: cV, version: tN, cname: i3.cname }, s2 = { service_name: t2, json_body: JSON.stringify(o2) };
        let a2, c2, d2 = e2[0];
        return bO(async () => {
          a2 = Date.now();
          const e3 = await Jx(d2, { data: s2, cancelToken: n2, headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "61" } });
          if (c2 = Date.now() - a2, 0 !== e3.code) {
            const t3 = new XN(_w.UNEXPECTED_RESPONSE, "live streaming ap error, code" + e3.code, { retry: true, responseTime: c2 });
            throw BN.error(t3.toString()), t3;
          }
          const i4 = JSON.parse(e3.json_body);
          if (200 !== i4.code) {
            const e4 = new XN(_w.UNEXPECTED_RESPONSE, "live streaming app center error, code: ".concat(i4.code, ", reason: ").concat(i4.reason), { code: i4.code, responseTime: c2 });
            throw BN.error(e4.toString()), e4;
          }
          if (!i4.servers || 0 === i4.servers.length) {
            const e4 = new XN(_w.UNEXPECTED_RESPONSE, "live streaming app center empty server", { code: i4.code, responseTime: c2 });
            throw BN.error(e4.toString()), e4;
          }
          const r3 = function(e4, t3) {
            return { addressList: e4.servers.map((e5) => "wss://".concat(e5.address.replace(/\./g, "-"), ".").concat(dN("WORKER_DOMAIN"), ":").concat(e5.wss, "?serviceName=").concat(encodeURIComponent(t3))), workerToken: e4.workerToken, vid: e4.vid };
          }(i4, t2);
          return dN("LIVE_STREAMING_ADDRESS") && (r3.addressList = dN("LIVE_STREAMING_ADDRESS") instanceof Array ? dN("LIVE_STREAMING_ADDRESS") : [dN("LIVE_STREAMING_ADDRESS")]), aV(aV({}, r3), {}, { responseTime: c2 });
        }, (n3, r3) => (zN.apworkerEvent(i3.sid, { success: true, sc: 200, serviceName: t2, responseDetail: JSON.stringify(n3.addressList), firstSuccess: 0 === r3, responseTime: c2, serverIp: e2[r3 % e2.length] }), false), (n3, r3) => (zN.apworkerEvent(i3.sid, { success: false, sc: n3.data && n3.data.code || 200, serviceName: t2, responseTime: c2, serverIp: e2[r3 % e2.length] }), !!(n3.code !== _w.OPERATION_ABORTED && n3.code !== _w.UNEXPECTED_RESPONSE || n3.data && n3.data.retry) && (d2 = e2[(r3 + 1) % e2.length], true)), r2);
      }
      let lV = 1;
      function uV(e2, t2, i3, n2) {
        let { url: r2, areaCode: o2 } = e2;
        const { clientId: s2, sid: a2 } = t2, c2 = Date.now();
        let d2;
        const l2 = t2.role, [u2, h2] = fV(t2, o2, [qU.CHOOSE_SERVER]);
        let p3 = Xw.networkState;
        return bO(async () => {
          p3 && Xw.networkState === Ww.OFFLINE && Xw.onlineWaiter && await Wh.race([Xw.onlineWaiter, lO(n2 && n2.maxRetryTimeout || yO.maxRetryTimeout)]), p3 = Xw.networkState;
          const { data: e3, headers: o3 } = await Jx(r2, { data: u2, cancelToken: i3, headers: { "Content-Type": "multipart/form-data;" } }, true, true);
          d2 = "1" === o3.http3 ? 1 : -1, zN.reportResourceTiming(r2, a2), pV(e3, r2, t2, c2, [qU.CHOOSE_SERVER], d2);
          const s3 = tx(e3, qU.CHOOSE_SERVER);
          return _V(s3), QU(s3, r2);
        }, (e3) => (e3 && zN.joinChooseServer(a2, { role: l2, lts: c2, succ: true, csAddr: r2, opid: h2, serverList: e3.gatewayAddrs.map((e4) => e4.address), ec: null, cid: e3.cid.toString(), uid: e3.uid.toString(), csIp: e3.csIp, unilbsServerIds: [qU.CHOOSE_SERVER].toString(), isHttp3: d2, corssRegionTagReq: t2.apRequestDetail, corssRegionTagRes: e3.res.detail && e3.res.detail[38] }), false), (e3) => e3.code !== _w.OPERATION_ABORTED && (e3.code === _w.CAN_NOT_GET_GATEWAY_SERVER ? e3.data.retry : (zN.joinChooseServer(a2, { role: l2, lts: c2, succ: false, csAddr: r2, serverList: null, opid: h2, ec: e3.code, csIp: e3.data && e3.data.csIp, unilbsServerIds: [qU.CHOOSE_SERVER].toString(), extend: JSON.stringify({ networkState: p3 }), isHttp3: d2, corssRegionTagReq: t2.apRequestDetail }), BN.warning("[".concat(s2 || "sid-".concat(a2.slice(0, 6)), "] Choose server network error, retry"), e3), true)), n2);
      }
      function hV(e2, t2, i3, n2) {
        let r2, { url: o2, areaCode: s2, serviceIds: a2 } = e2;
        const c2 = Date.now(), d2 = t2.role, [l2, u2] = fV(t2, s2, a2);
        let h2;
        return bO(async () => {
          h2 && Xw.networkState === Ww.OFFLINE && Xw.onlineWaiter && await Wh.race([Xw.onlineWaiter, lO(n2 && n2.maxRetryTimeout || yO.maxRetryTimeout)]), h2 = Xw.networkState;
          const { data: e3, headers: s3 } = await Jx(o2, { data: l2, cancelToken: i3, headers: { "Content-Type": "multipart/form-data;" } }, true, true);
          r2 = "1" === s3.http3 ? 1 : -1, zN.reportResourceTiming(o2, t2.sid), pV(e3, o2, t2, c2, a2, r2);
          const d3 = tx(e3, qU.CHOOSE_SERVER), u3 = tx(e3, "proxy5" === t2.cloudProxyServer ? qU.CLOUD_PROXY_5 : "proxy3" === t2.cloudProxyServer || "proxy4" === t2.cloudProxyServer ? qU.CLOUD_PROXY : qU.CLOUD_PROXY_FALLBACK);
          return _V(d3), { gatewayInfo: QU(d3, o2), proxyInfo: u3, url: o2 };
        }, (e3) => (e3.gatewayInfo && zN.joinChooseServer(t2.sid, { role: d2, lts: c2, succ: true, csAddr: o2, serverList: e3.gatewayInfo.gatewayAddrs.map((e4) => e4.address), ec: null, opid: u2, cid: e3.gatewayInfo.cid.toString(), uid: e3.gatewayInfo.uid.toString(), csIp: e3.gatewayInfo.csIp, unilbsServerIds: a2.toString(), isHttp3: r2, corssRegionTagReq: t2.apRequestDetail, corssRegionTagRes: e3.gatewayInfo.res.detail && e3.gatewayInfo.res.detail[38] }), e3.proxyInfo && zN.joinWebProxyAP(t2.sid, { lts: c2, sucess: 1, apServerAddr: o2, turnServerAddrList: e3.proxyInfo.addresses.map((e4) => e4.ip).join(","), errorCode: null, eventType: t2.cloudProxyServer, unilbsServerIds: a2.toString() }), false), (e3) => e3.code !== _w.OPERATION_ABORTED && (e3.code === _w.CAN_NOT_GET_GATEWAY_SERVER ? e3.data.retry : (zN.joinWebProxyAP(t2.sid, { lts: c2, sucess: 0, apServerAddr: o2, turnServerAddrList: null, errorCode: e3.code, eventType: t2.cloudProxyServer, unilbsServerIds: a2.toString(), extend: JSON.stringify({ networkState: h2 }) }), BN.warning("[".concat(t2.clientId, "] multi unilbs network error, retry"), e3), true)), n2);
      }
      const pV = (e2, t2, i3, n2, r2, o2) => {
        const { sid: s2, clientId: a2, cloudProxyServer: c2 } = i3, d2 = [], l2 = (a3) => {
          4096 === a3.flag ? zN.joinChooseServer(s2, { role: i3.role, lts: n2, succ: false, csAddr: t2, opid: e2.opid, serverList: null, ec: a3.error.message, csIp: a3.error.data && a3.error.data.csIp, unilbsServerIds: r2.toString(), isHttp3: o2, corssRegionTagReq: i3.apRequestDetail }) : 1048576 !== a3.flag && 4194304 !== a3.flag && 4194310 !== a3.flag || zN.joinWebProxyAP(s2, { lts: n2, sucess: 0, apServerAddr: t2, turnServerAddrList: null, errorCode: a3.error.code, eventType: c2, unilbsServerIds: r2.toString() });
        };
        if (e2.response_body.forEach((t3) => {
          const i4 = t3.buffer.code;
          if (23 === t3.uri && 0 === i4 && !t3.buffer.edges_services)
            if (4194310 === t3.buffer.flag)
              BN.warning("no edge services in ap response of proxy fallback, will not set proxy in iceServers"), t3.buffer.edges_services = [];
            else {
              const i5 = { error: new XN(_w.CAN_NOT_GET_GATEWAY_SERVER, "no edge services in ap response", { retry: true, csIp: e2.detail[502] }), flag: t3.buffer.flag };
              d2.push(i5), l2(i5);
            }
          if (0 !== i4) {
            const n3 = NU(i4), r3 = { error: new XN(_w.CAN_NOT_GET_GATEWAY_SERVER, n3.desc, { desc: n3.desc, retry: n3.retry, csIp: e2.detail[502] }), flag: t3.buffer.flag };
            4194310 === t3.buffer.flag ? BN.warning(r3.error.toString()) : d2.push(r3), l2(r3);
          }
        }), d2.length)
          throw BN.warning("[".concat(a2 || "sid-".concat(s2.slice(0, 6)), "] multi unilbs ").concat(t2, " failed, ").concat(d2.map((e3) => "flag: ".concat(e3.flag, ", message: ").concat(e3.error.message, ", retry: ").concat(e3.error.data.retry)).join(" | "))), new XN(_w.CAN_NOT_GET_GATEWAY_SERVER, d2.map((e3) => "flag: ".concat(e3.flag, ", message: ").concat(e3.error.message)).join(" | "), { retry: !!d2.find((e3) => e3.error.data.retry), csIp: e2.detail[502], desc: [...new Set(d2.map((e3) => {
            var t3;
            return null == e3 || null === (t3 = e3.error) || void 0 === t3 || null === (t3 = t3.data) || void 0 === t3 ? void 0 : t3.desc;
          }).filter((e3) => !!e3))] });
      }, _V = (e2) => {
        var t2, i3, n2, r2;
        if (e2.addresses && 0 === e2.addresses.length && 0 === e2.code)
          throw new XN(_w.CAN_NOT_GET_GATEWAY_SERVER, "void gateway address", { retry: true, csIp: e2.detail && e2.detail[502] });
        dN("AP_AREA") && (null !== (n2 = e2.detail) && void 0 !== n2 && n2[23] && "string" == typeof (null === (r2 = e2.detail) || void 0 === r2 ? void 0 : r2[23]) ? rV(e2.detail[23].toLowerCase()) : rV());
        if (null !== (t2 = e2.detail) && void 0 !== t2 && t2[19] && "string" == typeof (null === (i3 = e2.detail) || void 0 === i3 ? void 0 : i3[19])) {
          const t3 = e2.detail[19], i4 = null == t3 ? void 0 : t3.split(";");
          for (let t4 = 0; t4 < i4.length; t4++) {
            var o2;
            const n3 = OT(o2 = i4[t4]).call(o2);
            e2.addresses[t4] && i4 && (e2.addresses[t4].fingerprint = n3);
          }
        }
        if (dN("GATEWAY_ADDRESS") && dN("GATEWAY_ADDRESS").length > 0) {
          BN.debug("assign gateway address to", dN("GATEWAY_ADDRESS"));
          const t3 = dN("GATEWAY_ADDRESS").map((t4) => {
            var i4, n3;
            const r3 = null !== (i4 = null === (n3 = e2.addresses.find((e3) => e3.ip === t4.ip && e3.port === t4.port)) || void 0 === n3 ? void 0 : n3.fingerprint) && void 0 !== i4 ? i4 : "";
            return { ip: t4.ip, port: t4.port, ticket: e2.addresses[0] && e2.addresses[0].ticket, fingerprint: r3 };
          });
          e2.addresses = t3;
        }
      }, EV = (e2, t2) => {
        if (e2.response_body && e2.response_body.length) {
          const t3 = e2.response_body[0];
          if (0 !== t3.buffer.code) {
            const e3 = NU(t3.buffer.code);
            throw new XN(_w.UPDATE_TICKET_FAILED, "[".concat(t3.buffer.code, "]: ").concat(e3.desc), { retry: e3.retry });
          }
          return t3.buffer.ticket;
        }
        throw BN.debug("update ticket request received ap response without response body:", t2), new XN(_w.UPDATE_TICKET_FAILED, "cannot find response body from ap response", { retry: false });
      }, fV = (e2, t2, i3) => {
        const n2 = Math.floor(Math.random() * 10 ** 12), r2 = "host" === e2.role ? "1" : "audience" === e2.role ? "2" : void 0, o2 = { appid: e2.appId, client_ts: Date.now(), opid: n2, sid: e2.sid, request_bodies: [{ uri: 22, buffer: { cname: e2.cname, detail: aV(aV(aV({ 6: e2.stringUid, 11: t2, 12: dN("USE_NEW_TOKEN") ? "1" : void 0 }, r2 ? { 17: r2 } : {}), {}, { 22: t2 }, e2.apRequestDetail ? { 33: e2.apRequestDetail } : {}), e2.apRTM ? { 26: "RTM2" } : {}), key: e2.token, service_ids: i3, uid: e2.uid || 0 } }] };
        o2.request_bodies.forEach((t3) => {
          e2.multiIP && e2.multiIP.gateway_ip && (t3.buffer.detail[5] = JSON.stringify({ vocs_ip: [e2.multiIP.uni_lbs_ip], vos_ip: [e2.multiIP.gateway_ip] }));
        });
        const s2 = new FormData();
        return s2.append("request", JSON.stringify(o2)), [s2, n2];
      }, mV = (e2, t2) => {
        const i3 = Math.floor(Math.random() * 10 ** 12), n2 = { appid: e2.appId, client_ts: Date.now(), opid: i3, sid: e2.sid, request_bodies: [{ uri: 28, buffer: { cname: e2.cname, detail: { 1: "", 6: e2.stringUid, 12: "1" }, token: e2.token, service_ids: t2, uid: e2.uid || 0, edges_services: e2.apResponse.addresses.map((e3) => ({ ip: e3.ip, port: e3.port })) } }] }, r2 = new FormData();
        return r2.append("request", JSON.stringify(n2)), [r2, i3];
      };
      let TV = 0;
      function SV(e2) {
        return Wh.all(e2.map((e3) => e3.then((e4) => {
          throw e4;
        }, (e4) => e4))).then((e3) => {
          throw e3;
        }, (e3) => e3);
      }
      const gV = async (e2) => {
        let { fragementLength: t2, referenceList: i3, asyncMapHandler: n2, allFailedhandler: r2, promisesCollector: o2 } = e2, s2 = 0;
        const a2 = t2;
        let c2, d2 = 0;
        const l2 = async () => {
          const e3 = (() => {
            const e4 = s2 * a2, t3 = e4 + a2;
            return i3.slice(e4, t3).map(n2);
          })();
          o2 && o2.push(...e3);
          try {
            c2 = await SV(e3);
          } catch (e4) {
            if (d2 += a2, s2++, !(d2 >= i3.length))
              return void await l2();
            r2(e4);
          }
          e3.forEach((e4) => e4.cancel());
        };
        return await l2(), c2;
      }, RV = async (e2) => {
        let { referenceList: t2, asyncMapHandler: i3, closeFn: n2 } = e2;
        const r2 = t2.length;
        let o2 = 0;
        const s2 = async () => {
          const e3 = i3(t2.shift());
          try {
            return await e3;
          } catch (e4) {
            if (o2++, o2 >= r2 || null != n2 && n2(e4))
              throw e4;
            return s2();
          }
        };
        return s2();
      };
      async function CV(e2, t2, i3, n2) {
        const r2 = async function(e3, t3, i4, n3) {
          let r3 = null;
          const o2 = [], s2 = async () => {
            const r4 = dN("WEBCS_DOMAIN").slice(0, dN("AJAX_REQUEST_CONCURRENT")).map((t4) => ({ url: e3.proxyServer ? "https://".concat(e3.proxyServer, "/ap/?url=").concat(t4 + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t4, "/api/v2/transpond/webrtc?v=2"), areaCode: Qx() })), s3 = n3.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: r4.map((e4) => e4.url) }), a3 = await gV({ fragementLength: dN("FRAGEMENT_LENGTH"), referenceList: r4, asyncMapHandler: (n4) => (BN.debug("[".concat(e3.clientId, "] Connect to choose_server:"), n4.url), uV(n4, e3, t3, i4)), allFailedhandler: (e4) => {
              throw n3.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e4 }, s3), e4[0];
            }, promisesCollector: o2 });
            return n3.recordJoinChannelService({ endTs: Date.now(), status: "success" }, s3), a3;
          }, a2 = async () => {
            if (await lO(1e3), null !== r3)
              return r3;
            const s3 = dN("WEBCS_DOMAIN_BACKUP_LIST").map((t4) => ({ url: e3.proxyServer ? "https://".concat(e3.proxyServer, "/ap/?url=").concat(t4 + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t4, "/api/v2/transpond/webrtc?v=2"), areaCode: Qx() })), a3 = n3.recordJoinChannelService({ endTs: void 0, startTs: Date.now(), status: "pending", service: "chooseServer", urls: s3.map((e4) => e4.url) }), c2 = await gV({ fragementLength: dN("FRAGEMENT_LENGTH"), referenceList: s3, asyncMapHandler: (n4) => (BN.debug("[".concat(e3.clientId, "] Connect to backup choose_server:"), n4.url), uV(n4, e3, t3, i4)), allFailedhandler: (e4) => {
              throw n3.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e4 }, a3), e4[0];
            }, promisesCollector: o2 });
            return n3.recordJoinChannelService({ endTs: Date.now(), status: "success" }, a3), c2;
          };
          try {
            return r3 = await SV([s2(), a2()]), o2.length && o2.forEach((e4) => e4.cancel && "function" == typeof e4.cancel && e4.cancel()), r3;
          } catch (e4) {
            throw e4[0];
          }
        }(e2, t2, i3, n2);
        return { gatewayInfo: await r2 };
      }
      async function vV(e2, t2, i3, n2, r2) {
        const o2 = e2.cloudProxyServer;
        if ("disabled" === o2) {
          if (!n2)
            return;
          if (e2.useLocalAccessPoint)
            return await CV(e2, t2, i3, r2);
          if (dN("JOIN_WITH_FALLBACK_MEDIA_PROXY")) {
            const { gatewayInfo: n3, proxyInfo: o3 } = await wV(e2, t2, i3, r2);
            if (e2.turnServer && "auto" !== e2.turnServer.mode)
              return { gatewayInfo: n3 };
            const a3 = o3.map((e3) => ({ turnServerURL: e3.address, tcpport: e3.tcpport || rN.tcpport, udpport: e3.udpport || rN.udpport, username: e3.username || rN.username, password: e3.password || rN.password, forceturn: false, security: true }));
            if (r2.useP2P) {
              var s2;
              const t3 = null !== (s2 = e2.uid) && void 0 !== s2 ? s2 : n3.uid, i4 = "glb:".concat(t3.toString()), r3 = await Ow(i4), c3 = o3.map((e3) => ({ turnServerURL: e3.address, tcpport: e3.tcpport || rN.tcpport, udpport: e3.udpport || rN.udpport, username: i4, password: r3, forceturn: false, security: true }));
              a3.push(...c3);
            }
            return e2.turnServer = { mode: "manual", servers: a3 }, { gatewayInfo: n3 };
          }
          return await CV(e2, t2, i3, r2);
        }
        const { proxyInfo: a2, gatewayInfo: c2 } = await wV(e2, t2, i3, r2), d2 = { gatewayInfo: c2 }, l2 = a2.map((e3) => ({ turnServerURL: e3.address, tcpport: "proxy3" === o2 ? void 0 : e3.tcpport ? e3.tcpport : rN.tcpport, udpport: "proxy4" === o2 ? void 0 : e3.udpport ? e3.udpport : rN.udpport, username: e3.username || rN.username, password: e3.password || rN.password, forceturn: "proxy4" !== o2, security: "proxy5" === o2 }));
        if (r2.useP2P) {
          var u2;
          const t3 = null !== (u2 = e2.uid) && void 0 !== u2 ? u2 : c2.uid, i4 = "glb:".concat(t3.toString()), n3 = await Ow(i4), r3 = a2.map((e3) => ({ turnServerURL: e3.address, tcpport: "proxy3" === o2 ? void 0 : e3.tcpport || rN.tcpport, udpport: "proxy4" === o2 ? void 0 : e3.udpport || rN.udpport, username: i4, password: n3, forceturn: "proxy4" !== o2, security: "proxy5" === o2 }));
          l2.push(...r3);
        }
        return e2.turnServer = { mode: "manual", servers: l2 }, BN.debug("[".concat(e2.clientId, "] set proxy server: ").concat(e2.proxyServer, ", mode: ").concat(o2)), d2;
      }
      async function IV(e2, t2, i3, n2, r2) {
        const o2 = dN("ACCOUNT_REGISTER").slice(0, dN("AJAX_REQUEST_CONCURRENT"));
        let s2 = [];
        s2 = t2.proxyServer ? o2.map((e3) => "https://".concat(t2.proxyServer, "/ap/?url=").concat(e3 + "/api/v1")) : o2.map((e3) => "https://".concat(e3, "/api/v1"));
        const a2 = null == r2 ? void 0 : r2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "stringUID", urls: s2 });
        try {
          const o3 = await async function(e3, t3, i4, n3, r3) {
            const o4 = Date.now(), s3 = { sid: i4.sid, opid: 10, appid: i4.appId, string_uid: t3 };
            let a3 = e3[0];
            const c2 = await bO(() => Jx(a3 + "".concat(-1 === a3.indexOf("?") ? "?" : "&", "action=stringuid"), { data: s3, cancelToken: n3, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 72 } }), (i5, n4) => {
              if (0 === i5.code) {
                if (i5.uid <= 0 || i5.uid >= Math.pow(2, 32))
                  throw BN.error("Invalid Uint Uid ".concat(t3, " => ").concat(i5.uid), i5), zN.reqUserAccount(s3.sid, { lts: o4, success: false, serverAddr: a3, stringUid: s3.string_uid, uid: i5.uid, errorCode: _w.INVALID_UINT_UID_FROM_STRING_UID, extend: s3 }), new XN(_w.INVALID_UINT_UID_FROM_STRING_UID);
                return zN.reqUserAccount(s3.sid, { lts: o4, success: true, serverAddr: a3, stringUid: s3.string_uid, uid: i5.uid, errorCode: null, extend: s3 }), false;
              }
              const r4 = NU(i5.code);
              return r4.retry && (a3 = e3[(n4 + 1) % e3.length]), zN.reqUserAccount(s3.sid, { lts: o4, success: false, serverAddr: a3, stringUid: s3.string_uid, uid: i5.uid, errorCode: r4.desc, extend: s3 }), r4.retry;
            }, (t4, i5) => t4.code !== _w.OPERATION_ABORTED && (zN.reqUserAccount(s3.sid, { lts: o4, success: false, serverAddr: a3, stringUid: s3.string_uid, uid: null, errorCode: t4.code, extend: s3 }), a3 = e3[(i5 + 1) % e3.length], true), r3);
            if (0 !== c2.code) {
              const e4 = NU(c2.code);
              throw new XN(_w.UNEXPECTED_RESPONSE, e4.desc);
            }
            return c2;
          }(s2, e2, t2, i3, n2);
          return null == r2 || r2.recordJoinChannelService({ status: "success", endTs: Date.now() }, a2), o3.uid;
        } catch (e3) {
          throw null == r2 || r2.recordJoinChannelService({ status: "error", endTs: Date.now(), errors: [e3] }, a2), e3;
        }
      }
      async function yV(e2, t2, i3) {
        const n2 = dN("ACCOUNT_REGISTER");
        let r2 = [];
        r2 = t2.proxyServer ? n2.map((e3) => "https://".concat(t2.proxyServer, "/ap/?url=").concat(e3 + "/api/v1")) : n2.map((e3) => "https://".concat(e3, "/api/v1"));
        try {
          const n3 = await RV({ referenceList: r2, asyncMapHandler: (n4) => async function(e3, t3, i4, n5) {
            const r3 = Date.now(), o2 = { sid: i4.sid, opid: 10, appid: i4.appId, string_uid: t3 };
            try {
              const t4 = await Jx(e3 + "".concat(-1 === e3.indexOf("?") ? "?" : "&", "action=stringuid"), { data: o2, cancelToken: n5, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 72 } });
              if (0 !== t4.code) {
                const e4 = NU(t4.code);
                throw new XN(_w.UNEXPECTED_RESPONSE, "preload sua error:".concat(e4.desc), e4);
              }
              if (t4.uid <= 0 || t4.uid >= Math.pow(2, 32))
                throw new XN(_w.INVALID_UINT_UID_FROM_STRING_UID);
              return { requestTime: r3, url: e3, req: o2, uid: t4.uid, elapse: Date.now() - r3 };
            } catch (e4) {
              throw e4;
            }
          }(n4, e2, t2, i3), closeFn: (e3) => e3.code === _w.OPERATION_ABORTED || e3.code === _w.UNEXPECTED_RESPONSE && !e3.data.retry });
          return n3;
        } catch (e3) {
          throw e3;
        }
      }
      async function AV(e2, t2, i3) {
        const n2 = dN("CDS_AP").slice(0, dN("AJAX_REQUEST_CONCURRENT")).map((t3) => e2.proxyServer ? "https://".concat(e2.proxyServer, "/ap/?url=").concat(t3 + "/api/v1") : "https://".concat(t3, "/api/v1?action=config")), r2 = n2.map((n3) => function(e3, t3, i4, n4) {
          const r3 = xb(), o3 = { flag: 64, cipher_method: 0, features: { device: r3.name, system: r3.os, system_general: navigator.userAgent, vendor: t3.appId, version: tN, cname: t3.cname, sid: t3.sid, session_id: t3.sid, detail: "", proxyServer: t3.proxyServer } };
          return bO(() => Jx(e3, { data: o3, timeout: 1e3, cancelToken: i4, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 54 } }), void 0, (e4) => e4.code !== _w.OPERATION_ABORTED, n4);
        }(n3, e2, t2, i3));
        let o2 = null, s2 = null, a2 = {};
        try {
          o2 = await SV(r2);
        } catch (e3) {
          if (e3.code === _w.OPERATION_ABORTED)
            throw e3;
          s2 = e3;
        }
        r2.forEach((e3) => e3.cancel());
        if (zN.reportApiInvoke(e2.sid, { name: Lw.REQUEST_CONFIG_DISTRIBUTE, options: { error: s2, res: o2 } }).onSuccess(), o2 && o2.test_tags)
          try {
            a2 = function(e3) {
              if (!e3.test_tags)
                return {};
              const t3 = e3.test_tags, i4 = Object.keys(t3), n3 = {};
              return i4.forEach((e4) => {
                var i5;
                const r3 = OT(i5 = e4.slice(4)).call(i5), o3 = JSON.parse(t3[e4])[1];
                n3[r3] = o3;
              }), n3;
            }(o2);
          } catch (e3) {
          }
        return a2;
      }
      async function bV(e2, t2) {
        const i3 = dN("WEBCS_DOMAIN").concat(dN("WEBCS_DOMAIN_BACKUP_LIST")).map((e3) => ({ url: "https://".concat(e3, "/api/v2/transpond/webrtc?v=2"), areaCode: Qx(), serviceIds: [qU.CHOOSE_SERVER, qU.CLOUD_PROXY_FALLBACK] }));
        try {
          const n2 = await RV({ referenceList: i3, asyncMapHandler: (i4) => async function(e3, t3, i5) {
            let n3, { url: r2, areaCode: o2, serviceIds: s2 } = e3;
            const a2 = Date.now(), [c2, d2] = fV(t3, o2, s2);
            let l2 = Xw.networkState;
            try {
              l2 && Xw.networkState === Ww.OFFLINE && Xw.onlineWaiter && await Wh.race([Xw.onlineWaiter, lO(yO.maxRetryTimeout)]), l2 = Xw.networkState;
              const { data: e4, headers: t4 } = await Jx(r2, { data: c2, cancelToken: i5, headers: { "Content-Type": "multipart/form-data;" } }, true, true);
              n3 = "1" === t4.http3 ? 1 : -1;
              const o3 = (e5) => {
                const t5 = [];
                if (e5.response_body.forEach((i6) => {
                  const n4 = i6.buffer.code;
                  if (23 === i6.uri && 0 === n4 && !i6.buffer.edges_services)
                    if (4194310 === i6.buffer.flag)
                      i6.buffer.edges_services = [];
                    else {
                      const n5 = { error: new XN(_w.CAN_NOT_GET_GATEWAY_SERVER, "no edge services in ap response", { retry: true, csIp: e5.detail[502] }), flag: i6.buffer.flag };
                      t5.push(n5);
                    }
                  if (0 !== n4) {
                    const r3 = NU(n4), o4 = { error: new XN(_w.CAN_NOT_GET_GATEWAY_SERVER, r3.desc, { desc: r3.desc, retry: r3.retry, csIp: e5.detail[502] }), flag: i6.buffer.flag };
                    4194310 === i6.buffer.flag ? BN.warning(o4.error.toString()) : t5.push(o4);
                  }
                }), t5.length)
                  throw new XN(_w.CAN_NOT_GET_GATEWAY_SERVER, t5.map((e6) => "flag: ".concat(e6.flag, ", message: ").concat(e6.error.message)).join(" | "), { retry: !!t5.find((e6) => e6.error.data.retry), csIp: e5.detail[502], desc: [...new Set(t5.map((e6) => {
                    var t6;
                    return null == e6 || null === (t6 = e6.error) || void 0 === t6 || null === (t6 = t6.data) || void 0 === t6 ? void 0 : t6.desc;
                  }).filter((e6) => !!e6))] });
              };
              o3(e4);
              const s3 = tx(e4, qU.CHOOSE_SERVER), u2 = tx(e4, qU.CLOUD_PROXY_FALLBACK);
              return _V(s3), { gatewayInfo: QU(s3, r2), proxyInfo: u2, opid: d2, requestTime: a2, url: r2, isHttp3: n3, elapse: Date.now() - a2 };
            } catch (e4) {
              throw e4;
            }
          }(i4, e2, t2), closeFn: (e3) => e3.code === _w.OPERATION_ABORTED || e3.code === _w.CAN_NOT_GET_GATEWAY_SERVER && !e3.data.retry });
          return n2;
        } catch (e3) {
          throw e3;
        }
      }
      async function wV(e2, t2, i3, n2) {
        const r2 = dN("PROXY_SERVER_TYPE3"), o2 = (e3, t3, i4) => {
          let n3 = i4 || r2;
          return Array.isArray(n3) && (n3 = t3 % 2 == 0 ? r2[1] : r2[0]), "https://".concat(n3, "/ap/?url=").concat(e3);
        };
        let s2 = null;
        const a2 = [], c2 = async () => {
          const r3 = dN("WEBCS_DOMAIN").slice(0, dN("AJAX_REQUEST_CONCURRENT")).map((t3, i4) => {
            let n3;
            return n3 = "disabled" === e2.cloudProxyServer && e2.proxyServer ? o2("".concat(t3, "/api/v2/transpond/webrtc?v=2"), i4, e2.proxyServer) : "disabled" === e2.cloudProxyServer || "fallback" === e2.cloudProxyServer ? "https://".concat(t3, "/api/v2/transpond/webrtc?v=2") : o2("".concat(t3, "/api/v2/transpond/webrtc?v=2"), i4), { url: n3, areaCode: Qx(), serviceIds: [qU.CHOOSE_SERVER, "proxy5" === e2.cloudProxyServer ? qU.CLOUD_PROXY_5 : "proxy3" === e2.cloudProxyServer || "proxy4" === e2.cloudProxyServer ? qU.CLOUD_PROXY : qU.CLOUD_PROXY_FALLBACK] };
          }), s3 = n2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: r3.map((e3) => e3.url) }), c3 = await gV({ fragementLength: dN("FRAGEMENT_LENGTH"), referenceList: r3, asyncMapHandler: (n3) => (BN.debug("[".concat(e2.clientId, "] Connect to choose_server:"), n3.url), hV(n3, e2, t2, i3)), allFailedhandler: (e3) => {
            throw n2.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e3 }, s3), e3[0];
          }, promisesCollector: a2 });
          return n2.recordJoinChannelService({ endTs: Date.now(), status: "success" }, s3), c3;
        }, d2 = async () => {
          if (await lO(1e3), null !== s2)
            return s2;
          const r3 = dN("WEBCS_DOMAIN_BACKUP_LIST").map((t3, i4) => {
            let n3;
            return n3 = "disabled" === e2.cloudProxyServer && e2.proxyServer ? o2("".concat(t3, "/api/v2/transpond/webrtc?v=2"), i4, e2.proxyServer) : "disabled" === e2.cloudProxyServer || "fallback" === e2.cloudProxyServer ? "https://".concat(t3, "/api/v2/transpond/webrtc?v=2") : o2("".concat(t3, "/api/v2/transpond/webrtc?v=2"), i4), { url: n3, areaCode: Qx(), serviceIds: [qU.CHOOSE_SERVER, "proxy5" === e2.cloudProxyServer ? qU.CLOUD_PROXY_5 : "proxy3" === e2.cloudProxyServer || "proxy4" === e2.cloudProxyServer ? qU.CLOUD_PROXY : qU.CLOUD_PROXY_FALLBACK] };
          }), c3 = n2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: r3.map((e3) => e3.url) }), d3 = await gV({ fragementLength: dN("FRAGEMENT_LENGTH"), referenceList: r3, asyncMapHandler: (n3) => (BN.debug("[".concat(e2.clientId, "] Connect to backup choose_server:"), n3.url), hV(n3, e2, t2, i3)), allFailedhandler: (e3) => {
            throw n2.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e3 }, c3), e3[0];
          }, promisesCollector: a2 });
          return n2.recordJoinChannelService({ endTs: Date.now(), status: "success" }, c3), d3;
        };
        let l2, u2, h2;
        try {
          ({ gatewayInfo: l2, proxyInfo: u2, url: h2 } = await SV([c2(), d2()]));
        } catch (e3) {
          throw e3[0];
        }
        if (a2.length && a2.forEach((e3) => e3.cancel && "function" == typeof e3.cancel && e3.cancel()), !l2 || !u2)
          throw new XN(_w.UNEXPECTED_ERROR, "missing gateway or proxy response").print();
        if (e2.apUrl = h2, "disabled" !== e2.cloudProxyServer && Array.isArray(r2) && h2) {
          const t3 = /^https?:\/\/(.+?)(\/.*)?$/.exec(h2)[1];
          Dn(r2).call(r2, t3) && (e2.proxyServer = t3, BN.setProxyServer(t3), zN.setProxyServer(t3));
        }
        return s2 = { gatewayInfo: l2, proxyInfo: await ix(u2, l2.uid) }, s2;
      }
      async function OV(e2, t2, i3) {
        const n2 = dN("UAP_AP").slice(0, dN("AJAX_REQUEST_CONCURRENT")).map((t3) => e2.proxyServer ? "https://".concat(e2.proxyServer, "/ap/?url=").concat(t3 + "/api/v1?action=uap") : "https://".concat(t3, "/api/v1?action=uap")), r2 = n2.map((n3) => function(e3, t3, i4, n4) {
          const r3 = { command: "convergeAllocateEdge", sid: t3.sid, appId: t3.appId, token: t3.token, ts: Date.now(), version: tN, cname: t3.cname, uid: t3.uid.toString(), requestId: lV, seq: lV };
          lV += 1;
          const o2 = { service_name: "tele_channel", json_body: JSON.stringify(r3) };
          return bO(async () => {
            const t4 = await Jx(e3, { data: o2, cancelToken: i4, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 61 } });
            if (0 !== t4.code) {
              const e4 = new XN(_w.UNEXPECTED_RESPONSE, "cross channel ap error, code" + t4.code, { retry: true });
              throw BN.error(e4.toString()), e4;
            }
            const n5 = JSON.parse(t4.json_body);
            if (200 !== n5.code) {
              const e4 = new XN(_w.UNEXPECTED_RESPONSE, "cross channel app center error, code: ".concat(n5.code, ", reason: ").concat(n5.reason));
              throw BN.error(e4.toString()), e4;
            }
            if (!n5.servers || 0 === n5.servers.length) {
              const e4 = new XN(_w.UNEXPECTED_RESPONSE, "cross channel app center empty server");
              throw BN.error(e4.toString()), e4;
            }
            return { vid: n5.vid, workerToken: n5.workerToken, addressList: (dN("CHANNEL_MEDIA_RELAY_SERVERS") || n5.servers).map((e4) => "wss://".concat(e4.address.replace(/\./g, "-"), ".").concat(dN("WORKER_DOMAIN"), ":").concat(e4.wss)) };
          }, void 0, (e4) => !!(e4.code !== _w.OPERATION_ABORTED && e4.code !== _w.UNEXPECTED_RESPONSE || e4.data && e4.data.retry), n4);
        }(n3, e2, t2, i3));
        try {
          const e3 = await SV(r2);
          return r2.forEach((e4) => e4.cancel()), e3;
        } catch (e3) {
          throw e3[0];
        }
      }
      async function NV(e2, t2, i3) {
        let n2 = null;
        const r2 = [], o2 = async (o3) => {
          const s2 = dN(o3 ? "WEBCS_DOMAIN_BACKUP_LIST" : "WEBCS_DOMAIN").map((t3) => e2.proxyServer ? "https://".concat(e2.proxyServer, "/ap/?url=").concat(t3 + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t3, "/api/v2/transpond/webrtc?v=2"));
          return o3 && (await lO(1e3), null !== n2) ? n2 : await gV({ fragementLength: dN("FRAGEMENT_LENGTH"), referenceList: s2, asyncMapHandler: (n3) => (BN.debug("[".concat(e2.clientId, "] update ticket, Connect to ").concat(o3 ? "backup" : "", " choose_server:"), n3), function(e3, t3, i4, n4) {
            const [r3] = mV(t3, [qU.CHOOSE_SERVER]);
            let o4 = Xw.networkState;
            return bO(async () => {
              o4 && Xw.networkState === Ww.OFFLINE && Xw.onlineWaiter && await Wh.race([Xw.onlineWaiter, lO(n4 && n4.maxRetryTimeout || yO.maxRetryTimeout)]), o4 = Xw.networkState;
              const t4 = await Jx(e3, { data: r3, cancelToken: i4, headers: { "Content-Type": "multipart/form-data;" } }, true);
              return EV(t4, e3);
            }, () => false, (e4) => e4.code !== _w.OPERATION_ABORTED && (e4.code === _w.UPDATE_TICKET_FAILED ? e4.data.retry : (BN.warning("[".concat(t3.clientId, "] update ticket network error, retry"), e4), true)), n4);
          }(n3, e2, t2, i3)), allFailedhandler: (e3) => {
            throw e3[0];
          }, promisesCollector: r2 });
        };
        try {
          return n2 = await SV([o2(false), o2(true)]), r2.length && r2.forEach((e3) => e3.cancel && "function" == typeof e3.cancel && e3.cancel()), n2;
        } catch (e3) {
          throw e3[0];
        }
      }
      function DV(e2, t2) {
        var i3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i3.push.apply(i3, n2);
        }
        return i3;
      }
      function PV(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i3 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? DV(Object(i3), true).forEach(function(t3) {
            QI(e2, t3, i3[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : DV(Object(i3)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
          });
        }
        return e2;
      }
      class LV extends Nw {
        get isSuccess() {
          return !!this.configs;
        }
        constructor(e2) {
          super(), QI(this, "configs", void 0), QI(this, "joinInfo", void 0), QI(this, "cancelToken", void 0), QI(this, "retryConfig", { timeout: 3e3, timeoutFactor: 1.5, maxRetryCount: 1, maxRetryTimeout: 1e4 }), QI(this, "interval", void 0), QI(this, "mutex", void 0), QI(this, "mutableParamsRead", false), this.mutex = new vO("config-distribute", e2);
        }
        startGetConfigDistribute(e2, t2) {
          this.joinInfo = e2, this.cancelToken = t2, this.interval && this.stopGetConfigDistribute(), dN("ENABLE_CONFIG_DISTRIBUTE") && (this.updateConfigDistribute(), this.interval = window.setInterval(() => {
            this.updateConfigDistribute();
          }, dN("CONFIG_DISTRIBUTE_INTERVAL")));
        }
        stopGetConfigDistribute() {
          this.interval && clearInterval(this.interval), this.interval = void 0, this.joinInfo = void 0, this.cancelToken = void 0;
        }
        async awaitConfigDistributeComplete() {
          if (!this.mutex.isLocked)
            return;
          (await this.mutex.lock())();
        }
        async updateConfigDistribute() {
          if (!this.mutableParamsRead) {
            this.mutableParamsRead = true;
            zN.reportApiInvoke(null, { options: void 0, name: Lw.LOAD_CONFIG_FROM_LOCALSTORAGE, tag: kw.TRACER }).onSuccess(JSON.stringify(lN));
          }
          if (!this.joinInfo || !this.cancelToken || !this.retryConfig)
            return void BN.debug("[config-distribute] get config distribute interrupted have no joininfo");
          let e2;
          const t2 = await this.mutex.lock();
          try {
            e2 = await AV(this.joinInfo, this.cancelToken, this.retryConfig), BN.debug("[config-distribute] get config distribute", JSON.stringify(e2)), e2.limit_bitrate && this.handleBitrateLimit(e2.limit_bitrate), this.cacheGlobalParameterConfig(e2), this.configs = e2;
          } catch (e3) {
            const t3 = new XN(_w.NETWORK_RESPONSE_ERROR, e3);
            BN.warning("[config-distribute] ".concat(t3.toString()));
          } finally {
            t2();
          }
        }
        getBitrateLimit() {
          return this.configs ? this.configs.limit_bitrate : void 0;
        }
        handleBitrateLimit(e2) {
          aU(e2) && (this.configs && this.configs.limit_bitrate ? this.configs && this.configs.limit_bitrate && this.configs.limit_bitrate.id !== e2.id && this.emit(sU.UPDATE_BITRATE_LIMIT, e2) : this.emit(sU.UPDATE_BITRATE_LIMIT, e2));
        }
        getLowStreamConfigDistribute() {
          return this.configs && this.configs.limit_bitrate && PV({}, this.configs.limit_bitrate.low_stream_uplink);
        }
        cacheGlobalParameterConfig(e2) {
          var t2;
          const i3 = CS(t2 = Object.keys(e2).filter((e3) => /^webrtc_ng_global_parameter/.test(e3))).call(t2);
          for (let t3 = 0; t3 < i3.length; t3++)
            for (let n3 = i3.length - 1; n3 > t3; n3--) {
              const t4 = i3[n3];
              if ("number" == typeof e2[t4].__priority) {
                const r3 = e2[t4].__priority, o2 = i3[n3 - 1];
                if ("number" == typeof e2[o2].__priority) {
                  if (!(r3 > e2[o2].__priority))
                    continue;
                  {
                    const e3 = t4;
                    i3[n3] = i3[n3 - 1], i3[n3 - 1] = e3;
                  }
                } else {
                  const e3 = t4;
                  i3[n3] = i3[n3 - 1], i3[n3 - 1] = e3;
                }
              }
            }
          const n2 = {};
          i3.forEach((t3) => {
            const i4 = e2[t3], r3 = i4.__expires;
            Object.keys(i4).forEach((e3) => {
              "__priority" === e3 || "__expires" === e3 || Object.prototype.hasOwnProperty.call(n2, e3) || (n2[e3] = PV({ value: i4[e3] }, r3 && { expires: r3 }));
            });
          });
          try {
            var r2;
            const t3 = null === (r2 = n2.LIMIT_BITRATE) || void 0 === r2 ? void 0 : r2.value;
            delete n2.LIMIT_BITRATE, this.handleGlobalParameterConfig(n2), function(e3) {
              try {
                const t4 = Date.now();
                Object.keys(e3).forEach((i5) => {
                  switch (i5) {
                    case "ENABLE_EVENT_REPORT":
                    case "UPLOAD_LOG":
                    case "ENABLE_AG_ADAPTATION":
                    case "FORCE_AG_HIGH_FRAMERATE":
                    case "FORCE_SUPPORT_AG_ADAPTATION":
                    case "ENCODER_CONFIG_LIMIT":
                    case "CAMERA_CAPTURE_CONFIG":
                    case "ENABLE_PRELOAD":
                    case "NEW_ICE_RESTART":
                    case "ICE_RESTART_INTERVAL":
                    case "RESTART_SEQUENCE":
                      if (Object.prototype.hasOwnProperty.call(aN, i5)) {
                        const { value: n3, expires: r3 } = e3[i5];
                        if (r3 && r3 <= t4)
                          return;
                        lN[i5] = n3, aN[i5] = n3, BN.debug("Update global parameters from config distribute", i5, n3);
                      }
                  }
                });
              } catch (t4) {
                BN.error("Error update config immediately: ".concat(e3), t4.message);
              }
            }(n2);
            const i4 = JSON.stringify(n2), o2 = window.btoa(i4);
            window.localStorage.setItem("websdk_ng_global_parameter", o2), BN.debug("Caching global parameters ".concat(i4)), t3 && aU(t3) && (this.handleBitrateLimit(t3), e2.limit_bitrate = t3);
          } catch (e3) {
            BN.error("Error caching global parameters:", e3.message);
          }
        }
        handleGlobalParameterConfig(e2) {
          try {
            const t2 = Date.now();
            Object.keys(e2).forEach((i3) => {
              if ("CLIENT_ROLE_OPTIONS" === i3) {
                if (Object.prototype.hasOwnProperty.call(aN, i3)) {
                  const { value: n2, expires: r2 } = e2[i3];
                  if (r2 && r2 <= t2)
                    return;
                  (function(e3, t3) {
                    try {
                      return "object" == typeof e3 && "object" == typeof t3 && JSON.stringify(e3) === JSON.stringify(t3);
                    } catch (e4) {
                      return false;
                    }
                  })(aN[i3], n2) || (lN[i3] = n2, aN[i3] = n2, this.emit(sU.UPDATE_CLIENT_ROLE_OPTIONS, n2), BN.debug("Updating client role options: ".concat(JSON.stringify(n2))));
                }
              }
            });
          } catch (e3) {
            BN.error("Error handling global parameter config:", e3.message);
          }
        }
      }
      class kV extends Nw {
        constructor() {
          super(...arguments), QI(this, "resultStorage", /* @__PURE__ */ new Map());
        }
        setLocalAudioStats(e2, t2, i3) {
          this.record("AUDIO_INPUT_LEVEL_TOO_LOW", e2, this.checkAudioInputLevel(i3, t2)), this.record("SEND_AUDIO_BITRATE_TOO_LOW", e2, this.checkSendAudioBitrate(i3, t2));
        }
        setLocalVideoStats(e2, t2, i3) {
          this.record("SEND_VIDEO_BITRATE_TOO_LOW", e2, this.checkSendVideoBitrate(i3, t2)), this.record("FRAMERATE_INPUT_TOO_LOW", e2, this.checkFramerateInput(i3, t2)), this.record("FRAMERATE_SENT_TOO_LOW", e2, this.checkFramerateSent(i3));
        }
        setRemoteAudioStats(e2, t2) {
          const i3 = e2.getUserId();
          this.record("AUDIO_OUTPUT_LEVEL_TOO_LOW", i3, this.checkAudioOutputLevel(t2));
        }
        setRemoteVideoStats(e2, t2) {
          const i3 = e2.getUserId();
          this.record("RECV_VIDEO_DECODE_FAILED", i3, this.checkVideoDecode(t2));
        }
        record(e2, t2, i3) {
          if (dN("STATS_UPDATE_INTERVAL") > 500)
            return;
          this.resultStorage.has(e2) || this.resultStorage.set(e2, { result: [], isPrevNormal: true });
          const n2 = this.resultStorage.get(e2);
          if (n2 && (n2.result.push(i3), n2.result.length >= 5)) {
            var r2;
            const i4 = Dn(r2 = n2.result).call(r2, true);
            n2.isPrevNormal && !i4 && this.emit("exception", MV[e2], e2, t2), !n2.isPrevNormal && i4 && this.emit("exception", MV[e2] + 2e3, e2 + "_RECOVER", t2), n2.isPrevNormal = i4, n2.result = [];
          }
        }
        checkAudioOutputLevel(e2) {
          return !(e2.receiveBitrate > 0 && 0 === e2.receiveLevel);
        }
        checkAudioInputLevel(e2, t2) {
          return t2 instanceof RL && !t2.isActive || (!!t2.muted || 0 !== e2.sendVolumeLevel);
        }
        checkFramerateInput(e2, t2) {
          let i3 = null;
          t2._encoderConfig && t2._encoderConfig.frameRate && (i3 = ZU(t2._encoderConfig.frameRate));
          const n2 = e2.captureFrameRate;
          return !i3 || !n2 || !(i3 > 10 && n2 < 5 || i3 < 10 && i3 >= 5 && n2 <= 1);
        }
        checkFramerateSent(e2) {
          return !(e2.captureFrameRate && e2.sendFrameRate && e2.captureFrameRate > 5 && e2.sendFrameRate <= 1);
        }
        checkSendVideoBitrate(e2, t2) {
          return !!t2.muted || 0 !== e2.sendBitrate;
        }
        checkSendAudioBitrate(e2, t2) {
          return t2 instanceof RL && !t2.isActive || (!!t2.muted || 0 !== e2.sendBitrate);
        }
        checkVideoDecode(e2) {
          return 0 === e2.receiveBitrate || 0 !== e2.decodeFrameRate;
        }
      }
      const MV = { FRAMERATE_INPUT_TOO_LOW: 1001, FRAMERATE_SENT_TOO_LOW: 1002, SEND_VIDEO_BITRATE_TOO_LOW: 1003, RECV_VIDEO_DECODE_FAILED: 1005, AUDIO_INPUT_LEVEL_TOO_LOW: 2001, AUDIO_OUTPUT_LEVEL_TOO_LOW: 2002, SEND_AUDIO_BITRATE_TOO_LOW: 2003 };
      const UV = new class {
        markSubscribeStart(e2, t2) {
          performance.mark("agora-web-sdk/".concat(e2, "/subscribe-").concat(t2));
        }
        markPublishStart(e2, t2) {
          performance.mark("agora-web-sdk/".concat(e2, "/publish-").concat(t2));
        }
        measureFromSubscribeStart(e2, t2) {
          const i3 = performance.getEntriesByName("agora-web-sdk/".concat(e2, "/subscribe-").concat(t2));
          if (i3.length > 0) {
            const e3 = i3[i3.length - 1];
            return Math.round(performance.now() - e3.startTime);
          }
          return 0;
        }
        measureFromPublishStart(e2, t2) {
          const i3 = performance.getEntriesByName("agora-web-sdk/".concat(e2, "/publish-").concat(t2));
          if (i3.length > 0) {
            const e3 = i3[i3.length - 1];
            return Math.round(performance.now() - e3.startTime);
          }
          return 0;
        }
      }();
      function xV(e2, t2) {
        var i3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i3.push.apply(i3, n2);
        }
        return i3;
      }
      function VV(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i3 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? xV(Object(i3), true).forEach(function(t3) {
            QI(e2, t3, i3[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : xV(Object(i3)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
          });
        }
        return e2;
      }
      class FV {
        constructor(e2) {
          QI(this, "store", void 0), QI(this, "onStatsException", void 0), QI(this, "onUploadPublishDuration", void 0), QI(this, "onStatsChanged", void 0), QI(this, "localStats", /* @__PURE__ */ new Map()), QI(this, "remoteStats", /* @__PURE__ */ new Map()), QI(this, "updateStatsInterval", void 0), QI(this, "trafficStats", void 0), QI(this, "trafficStatsPeerList", []), QI(this, "uplinkStats", void 0), QI(this, "exceptionMonitor", void 0), QI(this, "p2pChannel", void 0), QI(this, "scalabilityMode", qO.L1T1), QI(this, "updateStats", () => {
            this.p2pChannel && (this.updateRemoteStats(this.p2pChannel), this.updateLocalStats(this.p2pChannel));
          }), this.store = e2, this.exceptionMonitor = new kV(), this.exceptionMonitor.on("exception", (e3, t2, i3) => {
            this.onStatsException && this.onStatsException(e3, t2, i3);
          });
        }
        startUpdateStats() {
          this.updateStatsInterval || (this.updateStatsInterval = window.setInterval(this.updateStats, 1e3));
        }
        stopUpdateStats() {
          this.updateStatsInterval && (window.clearInterval(this.updateStatsInterval), this.updateStatsInterval = void 0);
        }
        reset() {
          this.localStats = /* @__PURE__ */ new Map(), this.remoteStats = /* @__PURE__ */ new Map(), this.trafficStats = void 0, this.trafficStatsPeerList = [], this.uplinkStats = void 0;
        }
        getLocalAudioTrackStats() {
          return this.localStats.get(_U.LocalAudioTrack) || VV({}, yD);
        }
        getLocalVideoTrackStats() {
          return this.localStats.get(_U.LocalVideoTrack) || VV({}, AD);
        }
        getRemoteAudioTrackStats(e2) {
          const t2 = (e3, t3) => {
            if (!this.trafficStats)
              return t3;
            const i4 = this.trafficStats.peer_delay.find((t4) => t4.peer_uid === e3);
            return i4 && (t3.publishDuration = i4.B_ppad + (Date.now() - this.trafficStats.timestamp)), t3;
          }, i3 = {};
          if (e2) {
            var n2;
            const r2 = null === (n2 = this.remoteStats.get(e2)) || void 0 === n2 ? void 0 : n2.audioStats;
            r2 && (i3[e2] = t2(e2, r2));
          } else
            Array.from(this.remoteStats.entries()).forEach((e3) => {
              let [n3, { audioStats: r2 }] = e3;
              r2 && (i3[n3] = t2(n3, r2));
            });
          return i3;
        }
        getRemoteNetworkQualityStats(e2) {
          const t2 = {};
          if (e2) {
            var i3;
            const n2 = null === (i3 = this.remoteStats.get(e2)) || void 0 === i3 ? void 0 : i3.networkStats;
            n2 && (t2[e2] = n2);
          } else
            Array.from(this.remoteStats.entries()).forEach((e3) => {
              let [i4, { networkStats: n2 }] = e3;
              n2 && (t2[i4] = n2);
            });
          return t2;
        }
        getRemoteVideoTrackStats(e2) {
          const t2 = (e3, t3) => {
            if (!this.trafficStats)
              return t3;
            const i4 = this.trafficStats.peer_delay.find((t4) => t4.peer_uid === e3);
            return i4 && (t3.publishDuration = i4.B_ppvd + (Date.now() - this.trafficStats.timestamp)), t3;
          }, i3 = {};
          if (e2) {
            var n2;
            const r2 = null === (n2 = this.remoteStats.get(e2)) || void 0 === n2 ? void 0 : n2.videoStats;
            r2 && (i3[e2] = t2(e2, r2));
          } else
            Array.from(this.remoteStats.entries()).forEach((e3) => {
              let [n3, { videoStats: r2 }] = e3;
              r2 && (i3[n3] = t2(n3, r2));
            });
          return i3;
        }
        getRTCStats() {
          let e2 = 0, t2 = 0, i3 = 0, n2 = 0;
          const r2 = this.localStats.get(_U.LocalAudioTrack);
          r2 && (e2 += r2.sendBytes, t2 += r2.sendBitrate);
          const o2 = this.localStats.get(_U.LocalVideoTrack);
          o2 && (e2 += o2.sendBytes, t2 += o2.sendBitrate);
          const s2 = this.localStats.get(_U.LocalVideoLowTrack);
          s2 && (e2 += s2.sendBytes, t2 += s2.sendBitrate), this.remoteStats.forEach((e3) => {
            let { audioStats: t3, videoStats: r3 } = e3;
            t3 && (i3 += t3.receiveBytes, n2 += t3.receiveBitrate), r3 && (i3 += r3.receiveBytes, n2 += r3.receiveBitrate);
          });
          let a2 = 1;
          return this.trafficStats && (a2 += this.trafficStats.peer_delay.length), { Duration: 0, UserCount: a2, SendBitrate: t2, SendBytes: e2, RecvBytes: i3, RecvBitrate: n2, OutgoingAvailableBandwidth: this.uplinkStats ? this.uplinkStats.B_uab / 1e3 : 0, RTT: this.trafficStats ? 2 * this.trafficStats.B_acd : 0 };
        }
        addLocalStats(e2) {
          this.localStats.set(e2, void 0);
        }
        removeLocalStats(e2) {
          e2 ? this.localStats.delete(e2) : this.localStats.clear();
        }
        addRemoteStats(e2) {
          this.remoteStats.set(e2, {});
        }
        removeRemoteStats(e2) {
          e2 ? this.remoteStats.delete(e2) : this.remoteStats.clear();
        }
        addP2PChannel(e2) {
          this.p2pChannel = e2;
        }
        updateTrafficStats(e2) {
          e2.peer_delay = e2.peer_delay.filter((e3) => void 0 !== e3.B_ppad || void 0 !== e3.B_ppvd);
          e2.peer_delay.filter((e3) => -1 === this.trafficStatsPeerList.indexOf(e3.peer_uid)).forEach((e3) => {
            var t2;
            const i3 = null === (t2 = this.p2pChannel) || void 0 === t2 ? void 0 : t2.getRemoteMedia(e3.peer_uid), n2 = null != i3 && i3.videoSSRC ? UV.measureFromSubscribeStart(this.store.clientId, i3.videoSSRC) : 0, r2 = null != i3 && i3.audioSSRC ? UV.measureFromSubscribeStart(this.store.clientId, i3.audioSSRC) : 0;
            void 0 !== e3.B_ppad && void 0 !== e3.B_ppvd && (this.onUploadPublishDuration && this.onUploadPublishDuration(e3.peer_uid, e3.B_ppad, e3.B_ppvd, n2 > r2 ? n2 : r2), this.trafficStatsPeerList.push(e3.peer_uid));
          }), this.trafficStats = e2;
        }
        updateUplinkStats(e2) {
          this.uplinkStats && this.uplinkStats.B_fir !== e2.B_fir && BN.debug("[".concat(this.store.clientId, "]: Period fir changes to ").concat(e2.B_fir)), this.uplinkStats = e2;
        }
        static isRemoteVideoFreeze(e2, t2, i3) {
          if (!e2)
            return false;
          const n2 = !!i3 && t2.framesDecodeFreezeTime > i3.framesDecodeFreezeTime, r2 = !i3 || t2.framesDecodeCount > i3.framesDecodeCount;
          return n2 || !r2;
        }
        static isRemoteAudioFreeze(e2) {
          return !!e2 && e2._isFreeze();
        }
        isLocalVideoFreeze(e2) {
          return !(!e2.inputFrame || !e2.sentFrame) && (e2.inputFrame.frameRate > 5 && e2.sentFrame.frameRate < 3);
        }
        updateLocalStats(e2) {
          Array.from(this.localStats.entries()).forEach((t2) => {
            let [i3, n2] = t2;
            switch (i3) {
              case _U.LocalVideoTrack:
              case _U.LocalVideoLowTrack: {
                const t3 = n2, o2 = VV({}, AD), s2 = e2.getStats(), a2 = e2.getLocalMedia(i3);
                if (s2) {
                  const i4 = s2.videoSend.find((e3) => e3.ssrc === (null == a2 ? void 0 : a2.ssrcs[0].ssrcId));
                  if (i4) {
                    const n3 = e2.getLocalVideoSize(), r3 = e2.getEncoderConfig(_U.LocalVideoTrack);
                    "H264" !== i4.codec && "H265" !== i4.codec && "VP8" !== i4.codec && "VP9" !== i4.codec && "AV1X" !== i4.codec && "AV1" !== i4.codec || (o2.codecType = i4.codec), o2.sendBytes = i4.bytes, o2.sendBitrate = t3 ? 8 * Math.max(0, o2.sendBytes - t3.sendBytes) : 0, i4.inputFrame ? (o2.captureFrameRate = i4.inputFrame.frameRate, o2.captureResolutionHeight = i4.inputFrame.height, o2.captureResolutionWidth = i4.inputFrame.width) : n3 && (o2.captureResolutionWidth = n3.width, o2.captureResolutionHeight = n3.height), i4.sentFrame ? (o2.sendFrameRate = i4.sentFrame.frameRate, o2.sendResolutionHeight = i4.sentFrame.height, o2.sendResolutionWidth = i4.sentFrame.width) : n3 && (o2.sendResolutionWidth = n3.width, o2.sendResolutionHeight = n3.height), i4.avgEncodeMs && (o2.encodeDelay = i4.avgEncodeMs), r3 && r3.bitrateMax && (o2.targetSendBitrate = 1e3 * r3.bitrateMax), o2.sendPackets = i4.packets, o2.sendPacketsLost = i4.packetsLost, o2.sendJitterMs = i4.jitterMs, o2.sendRttMs = i4.rttMs, o2.totalDuration = t3 ? t3.totalDuration + 1 : 1, o2.totalFreezeTime = t3 ? t3.totalFreezeTime : 0, this.isLocalVideoFreeze(i4) && (o2.totalFreezeTime += 1), i4.scalabilityMode && this.scalabilityMode !== i4.scalabilityMode && (BN.debug("[".concat(this.store.clientId, "]: The scalabilityMode of the video sending stream is ").concat(i4.scalabilityMode)), this.scalabilityMode = i4.scalabilityMode);
                  }
                  this.trafficStats && (o2.currentPacketLossRate = (this.trafficStats.B_pvlr4 || 0) / 100);
                }
                var r2;
                if (this.localStats.set(i3, o2), (null == t3 ? void 0 : t3.sendResolutionWidth) !== o2.sendResolutionWidth || (null == t3 ? void 0 : t3.sendResolutionHeight) !== o2.sendResolutionHeight)
                  null === (r2 = this.onStatsChanged) || void 0 === r2 || r2.call(this, "resolution", { width: o2.sendResolutionWidth, height: o2.sendResolutionHeight });
                o2 && a2 && this.exceptionMonitor.setLocalVideoStats(this.store.uid, a2.track, o2);
                break;
              }
              case _U.LocalAudioTrack: {
                const t3 = n2, r3 = VV({}, yD), o2 = e2.getStats(), s2 = e2.getLocalMedia(i3);
                if (o2) {
                  const i4 = o2.audioSend.find((e3) => e3.ssrc === (null == s2 ? void 0 : s2.ssrcs[0].ssrcId));
                  if (i4) {
                    if ("opus" !== i4.codec && "aac" !== i4.codec && "PCMU" !== i4.codec && "PCMA" !== i4.codec && "G722" !== i4.codec || (r3.codecType = i4.codec), i4.inputLevel)
                      r3.sendVolumeLevel = Math.round(32767 * i4.inputLevel);
                    else {
                      const t4 = e2.getLocalAudioVolume();
                      t4 && (r3.sendVolumeLevel = Math.round(32767 * t4));
                    }
                    r3.sendBytes = i4.bytes, r3.sendPackets = i4.packets, r3.sendPacketsLost = i4.packetsLost, r3.sendJitterMs = i4.jitterMs, r3.sendRttMs = i4.rttMs, r3.sendBitrate = t3 ? 8 * Math.max(0, r3.sendBytes - t3.sendBytes) : 0;
                  }
                }
                this.trafficStats && (r3.currentPacketLossRate = (this.trafficStats.B_palr4 || 0) / 100), this.localStats.set(_U.LocalAudioTrack, r3), r3 && s2 && this.exceptionMonitor.setLocalAudioStats(this.store.uid, s2.track, r3);
                break;
              }
            }
          });
        }
        updateRemoteStats(e2) {
          Array.from(this.remoteStats.entries()).forEach((t2) => {
            var i3, n2;
            let [r2, { videoStats: o2, audioStats: s2, videoPcStats: a2 }] = t2;
            const c2 = s2, d2 = o2, l2 = a2, u2 = VV({}, bD), h2 = VV({}, OD), p3 = VV({}, wD), { audioTrack: _2, videoTrack: E2, audioSSRC: f2, videoSSRC: m2 } = e2.getRemoteMedia(r2);
            let T2;
            T2 = this.store.useP2P ? e2.getStats(true) : e2.getStats();
            const S2 = null === (i3 = T2) || void 0 === i3 ? void 0 : i3.audioRecv.find((e3) => e3.ssrc === f2), g2 = null === (n2 = T2) || void 0 === n2 ? void 0 : n2.videoRecv.find((e3) => e3.ssrc === m2), R3 = this.trafficStats && this.trafficStats.peer_delay.find((e3) => e3.peer_uid === r2);
            if (S2 && ("opus" !== S2.codec && "aac" !== S2.codec && "PCMU" !== S2.codec && "PCMA" !== S2.codec && "G722" !== S2.codec || (u2.codecType = S2.codec), S2.outputLevel ? u2.receiveLevel = Math.round(32767 * S2.outputLevel) : _2 && (u2.receiveLevel = Math.round(32767 * _2.getVolumeLevel())), u2.receiveBytes = S2.bytes, u2.receivePackets = S2.packets, u2.receivePacketsLost = S2.packetsLost, u2.receivePacketsDiscarded = S2.packetsDiscarded, u2.packetLossRate = u2.receivePacketsLost / (u2.receivePackets + u2.receivePacketsLost), u2.receiveBitrate = c2 ? 8 * Math.max(0, u2.receiveBytes - c2.receiveBytes) : 0, u2.totalDuration = c2 ? c2.totalDuration + 1 : 1, u2.totalFreezeTime = c2 ? c2.totalFreezeTime : 0, u2.freezeRate = u2.totalFreezeTime / u2.totalDuration, u2.receiveDelay = S2.jitterBufferMs, u2.totalDuration > 10 && FV.isRemoteAudioFreeze(_2) && (u2.totalFreezeTime += 1)), g2) {
              var C2;
              "H264" !== g2.codec && "H265" !== g2.codec && "VP8" !== g2.codec && "VP9" !== g2.codec && "AV1X" !== g2.codec && "AV1" !== g2.codec || (h2.codecType = g2.codec), h2.receiveBytes = g2.bytes, h2.receiveBitrate = d2 ? 8 * Math.max(0, h2.receiveBytes - d2.receiveBytes) : 0, h2.decodeFrameRate = g2.decodeFrameRate < 0 ? 0 : g2.decodeFrameRate, h2.renderFrameRate = g2.decodeFrameRate < 0 ? 0 : g2.decodeFrameRate, g2.outputFrame && (h2.renderFrameRate = g2.outputFrame.frameRate), g2.receivedFrame ? (h2.receiveFrameRate = g2.receivedFrame.frameRate, h2.receiveResolutionHeight = g2.receivedFrame.height, h2.receiveResolutionWidth = g2.receivedFrame.width) : E2 && (h2.receiveResolutionHeight = E2._videoHeight || 0, h2.receiveResolutionWidth = E2._videoWidth || 0), void 0 !== g2.framesRateFirefox && (h2.receiveFrameRate = Math.round(g2.framesRateFirefox)), h2.receivePackets = g2.packets, h2.receivePacketsLost = g2.packetsLost, h2.packetLossRate = h2.receivePacketsLost / (h2.receivePackets + h2.receivePacketsLost);
              const t3 = d2 ? d2.totalFreezeTime : 0, i4 = d2 ? d2.totalDuration : 0;
              h2.totalDuration = d2 ? d2.totalDuration + 1 : 1, h2.totalFreezeTime = null !== (C2 = g2.totalFreezesDuration) && void 0 !== C2 ? C2 : t3 || 0, h2.receiveDelay = g2.jitterBufferMs || 0;
              const n3 = !!m2 && e2.getRemoteVideoIsReady(m2);
              void 0 === g2.totalFreezesDuration && E2 && n3 && FV.isRemoteVideoFreeze(E2, g2, l2) && (h2.totalFreezeTime += 1), h2.freezeRate = Math.max(0, Math.min((h2.totalFreezeTime - t3) / (h2.totalDuration - i4), 1));
            }
            R3 && (u2.end2EndDelay = R3.B_ad, h2.end2EndDelay = R3.B_vd, u2.transportDelay = R3.B_ed, h2.transportDelay = R3.B_ed, u2.currentPacketLossRate = R3.B_ealr4 / 100, h2.currentPacketLossRate = R3.B_evlr4 / 100, p3.uplinkNetworkQuality = R3.B_punq ? R3.B_punq : 0, p3.downlinkNetworkQuality = R3.B_pdnq ? R3.B_pdnq : 0), this.remoteStats.set(r2, { audioStats: u2, videoStats: h2, videoPcStats: g2, networkStats: p3 }), _2 && this.exceptionMonitor.setRemoteAudioStats(_2, u2), E2 && this.exceptionMonitor.setRemoteVideoStats(E2, h2);
          });
        }
      }
      class BV {
        constructor() {
          QI(this, "destChannelMediaInfos", /* @__PURE__ */ new Map()), QI(this, "srcChannelMediaInfo", void 0);
        }
        setSrcChannelInfo(e2) {
          qM(e2), this.srcChannelMediaInfo = e2;
        }
        addDestChannelInfo(e2) {
          qM(e2), this.destChannelMediaInfos.set(e2.channelName, e2);
        }
        removeDestChannelInfo(e2) {
          xM(e2), this.destChannelMediaInfos.delete(e2);
        }
        getSrcChannelMediaInfo() {
          return this.srcChannelMediaInfo;
        }
        getDestChannelMediaInfo() {
          return this.destChannelMediaInfos;
        }
      }
      function jV(e2) {
        if (!(e2 instanceof BV)) {
          return new XN(_w.INVALID_PARAMS, "Config should be instance of [ChannelMediaRelayConfiguration]").throw();
        }
        const t2 = e2.getSrcChannelMediaInfo(), i3 = e2.getDestChannelMediaInfo();
        if (!t2) {
          return new XN(_w.INVALID_PARAMS, "srcChannelMediaInfo should not be empty").throw();
        }
        if (0 === i3.size) {
          return new XN(_w.INVALID_PARAMS, "destChannelMediaInfo should not be empty").throw();
        }
      }
      class GV {
        get hasVideo() {
          return this._video_enabled_ && !this._video_muted_ && this._video_added_;
        }
        get hasAudio() {
          return this._audio_enabled_ && !this._audio_muted_ && this._audio_added_;
        }
        get audioTrack() {
          if (this.hasAudio || this._audio_pre_subscribed)
            return this._audioTrack;
        }
        get videoTrack() {
          if (this.hasVideo || this._video_pre_subscribed)
            return this._videoTrack;
        }
        get dataChannels() {
          return this._dataChannels;
        }
        constructor(e2, t2) {
          QI(this, "uid", void 0), QI(this, "_uintid", void 0), QI(this, "_trust_in_room_", true), QI(this, "_trust_audio_enabled_state_", true), QI(this, "_trust_video_enabled_state_", true), QI(this, "_trust_audio_mute_state_", true), QI(this, "_trust_video_mute_state_", true), QI(this, "_audio_muted_", false), QI(this, "_video_muted_", false), QI(this, "_audio_enabled_", true), QI(this, "_video_enabled_", true), QI(this, "_audio_added_", false), QI(this, "_video_added_", false), QI(this, "_is_pre_created", false), QI(this, "_video_pre_subscribed", false), QI(this, "_audio_pre_subscribed", false), QI(this, "_trust_video_stream_added_state_", true), QI(this, "_trust_audio_stream_added_state_", true), QI(this, "_audioTrack", void 0), QI(this, "_videoTrack", void 0), QI(this, "_dataChannels", []), QI(this, "_audioSSRC", void 0), QI(this, "_videoSSRC", void 0), QI(this, "_audioOrtc", void 0), QI(this, "_videoOrtc", void 0), QI(this, "_cname", void 0), QI(this, "_rtxSsrcId", void 0), QI(this, "_videoMid", void 0), QI(this, "_audioMid", void 0), this.uid = e2, this._uintid = t2;
        }
      }
      function WV(e2, t2) {
        var i3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i3.push.apply(i3, n2);
        }
        return i3;
      }
      function HV(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i3 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? WV(Object(i3), true).forEach(function(t3) {
            QI(e2, t3, i3[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : WV(Object(i3)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
          });
        }
        return e2;
      }
      const KV = "9", YV = 4e4;
      function qV(e2, t2) {
        var i3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i3.push.apply(i3, n2);
        }
        return i3;
      }
      function zV(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i3 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? qV(Object(i3), true).forEach(function(t3) {
            QI(e2, t3, i3[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : qV(Object(i3)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
          });
        }
        return e2;
      }
      var XV = function(e2) {
        return e2[e2.DOWN = 0] = "DOWN", e2[e2.UP = 1] = "UP", e2;
      }(XV || {});
      const JV = /* @__PURE__ */ new Map();
      function QV(e2, t2, i3, n2) {
        let { scale: r2 } = e2;
        if (0 === r2 && n2 === XV.UP || r2 >= t2.length - 1 && n2 === XV.DOWN)
          return e2;
        let o2 = zV(zV({}, e2), {}, { scale: n2 === XV.DOWN ? ++r2 : --r2 });
        switch (i3) {
          case "maintain-framerate":
            o2 = zV(zV({}, o2), t2[r2].motion);
            break;
          case "maintain-resolution":
            o2 = zV(zV({}, o2), t2[r2].detail);
            break;
          case "balanced":
            o2 = zV(zV({}, o2), t2[r2].balanced);
        }
        return o2;
      }
      function ZV(e2, t2) {
        if (t2) {
          const i3 = { overUse: 0, underUse: 0, adaptationList: $V(t2) };
          JV.set(e2, i3);
        } else
          JV.delete(e2);
      }
      function $V(e2) {
        const t2 = zV({}, e2), { bitrateMax: i3, frameRate: n2, scaleResolutionDownBy: r2, bitrateMin: o2 } = t2, { MIN_FRAME_RATE: s2, MAX_THRESHOLD_FRAMERATE: a2, MAX_SCALE: c2, BITRATE_MIN_THRESHOLD: d2, BITRATE_MAX_THRESHOLD: l2, BWE_SCALE_UP_THRESHOLD: u2, BWE_SCALE_DOWN_THRESHOLD: h2, PERF_SCALE_DOWN_THRESHOLD: p3, PERF_SCALE_UP_THRESHOLD: _2, BALANCE_BITRATE_FACTOR: E2, BALANCE_FRAMERATE_FACTOR: f2, BALANCE_RESOLUTION_FACTOR: m2, MOTION_RESOLUTION_FACTOR: T2, MOTION_BITRATE_FACTOR: S2, DETAIL_FRAMERATE_FACTOR: g2, DETAIL_BITRATE_FACTOR: R3 } = oN, C2 = Math.min(t2.frameRate, a2), v2 = [{ scale: 0, threshold: { bwe_down: Math.round(Math.pow(h2, 1) * i3), bwe_up: i3, fps_down: Math.round(Math.pow(p3, 1) * C2), fps_up: n2 }, balanced: { scaleResolutionDownBy: 1, frameRate: n2, bitrateMax: i3, bitrateMin: o2 }, motion: { scaleResolutionDownBy: 1, frameRate: n2, bitrateMax: i3, bitrateMin: o2 }, detail: { scaleResolutionDownBy: 1, frameRate: n2, bitrateMax: i3, bitrateMin: o2 } }];
        for (let e3 = 1; e3 <= c2; e3++) {
          const t3 = { bwe_up: Math.round(Math.pow(u2, e3) * i3), bwe_down: Math.round(Math.pow(h2, e3 + 1) * i3), fps_up: Math.round(Math.pow(_2, e3) * C2), fps_down: Math.round(Math.pow(p3, e3 + 1) * C2) }, a3 = { scaleResolutionDownBy: r2 / Math.pow(m2, e3), frameRate: Math.max(Math.round(Math.pow(f2, e3) * n2), s2), bitrateMax: Math.max(Math.round(Math.pow(E2, e3) * i3), l2), bitrateMin: Math.max(Math.round(Math.pow(E2, e3) * o2), d2) }, c3 = { scaleResolutionDownBy: r2 / Math.pow(T2, e3), frameRate: n2, bitrateMax: Math.max(Math.round(Math.pow(S2, e3) * i3), l2), bitrateMin: Math.max(Math.round(Math.pow(S2, e3) * o2), d2) }, I2 = { scaleResolutionDownBy: 1, frameRate: Math.max(Math.round(Math.pow(g2, e3) * n2), s2), bitrateMax: Math.max(Math.round(Math.pow(R3, e3) * i3), l2), bitrateMin: Math.max(Math.round(Math.pow(R3, e3) * o2), d2) };
          v2.push({ scale: e3, threshold: t3, balanced: a3, motion: c3, detail: I2 });
        }
        return v2;
      }
      function eF(e2, t2, i3, n2, r2, o2) {
        const s2 = JV.get(e2) || { overUse: 0, underUse: 0, adaptationList: $V(r2) }, { adaptationList: a2 } = s2;
        JV.set(e2, s2);
        const { OVERUSE_TIMES_THRESHOLD: c2, UNDERUSE_TIMES_THRESHOLD: d2 } = oN, { scale: l2 } = n2;
        let u2, h2;
        return "number" == typeof t2 && t2 > 0 && function(e3, t3, i4, n3) {
          if (t3 >= i4.length)
            return false;
          let { threshold: { fps_down: r3 } } = i4[t3];
          return dN("FORCE_AG_HIGH_FRAMERATE") && "maintain-framerate" === n3 && (r3 = i4[0].threshold.fps_down), e3 < r3;
        }(t2, l2, a2, o2) && (s2.overUse++, h2 = YO.CPU, s2.overUse > c2) || "number" == typeof i3 && i3 > 0 && function(e3, t3, i4) {
          if (t3 >= i4.length)
            return false;
          const { threshold: { bwe_down: n3 } } = i4[t3];
          return e3 < n3;
        }(i3, l2, a2) && (s2.overUse++, h2 = YO.BANDWIDTH, s2.overUse > c2) ? (s2.overUse = 0, s2.underUse = 0, u2 = QV(n2, a2, o2, XV.DOWN), [u2, h2]) : ("number" == typeof t2 && t2 > 0 && "number" == typeof i3 && i3 > 0 && function(e3, t3, i4, n3) {
          if (0 === t3)
            return;
          let { threshold: { fps_up: r3 } } = i4[t3];
          return dN("FORCE_AG_HIGH_FRAMERATE") && "maintain-framerate" === n3 && (r3 = i4[1].threshold.fps_up), e3 > r3;
        }(t2, l2, a2, o2) && function(e3, t3, i4) {
          if (0 === t3)
            return;
          const { threshold: { bwe_up: n3 } } = i4[t3];
          return e3 > n3;
        }(i3, l2, a2) && (s2.underUse++, s2.underUse > d2 && (s2.overUse = 0, s2.underUse = 0, u2 = QV(n2, a2, o2, XV.UP), 0 === u2.scale && (h2 = YO.NONE))), [u2, h2]);
      }
      function tF(e2, t2) {
        var i3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i3.push.apply(i3, n2);
        }
        return i3;
      }
      function iF(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i3 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? tF(Object(i3), true).forEach(function(t3) {
            QI(e2, t3, i3[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : tF(Object(i3)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
          });
        }
        return e2;
      }
      function nF(e2) {
        var t2;
        return !!dN("ENABLE_AG_ADAPTATION") && (!!(e2 instanceof ck || Dn(t2 = e2._hints).call(t2, fD.CUSTOM_TRACK)) && (!!dN("FORCE_SUPPORT_AG_ADAPTATION") || !!(function(e3) {
          const t3 = xb();
          if (t3.os !== Pb.IOS || !t3.osVersion)
            return false;
          const i3 = t3.osVersion.split(".");
          return Number(i3[0]) >= e3;
        }(14) && Qb(17, 4, true) || Jb(14) && Zb(17, 4, true))));
      }
      const rF = /* @__PURE__ */ new Map();
      function oF(e2, t2) {
        const i3 = rF.get(e2);
        if (i3) {
          const { timer: t3 } = i3;
          window.clearTimeout(t3), rF.delete(e2);
        }
        t2.qualityLimitationReason = YO.NONE, ZV(e2);
      }
      function sF(e2, t2) {
        var i3;
        let n2;
        switch (t2) {
          case _U.LocalAudioTrack:
            n2 = ZM.Audio;
            break;
          case _U.LocalVideoTrack:
            n2 = Dn(i3 = e2._hints).call(i3, fD.SCREEN_TRACK) ? ZM.Screen : ZM.High;
            break;
          case _U.LocalVideoLowTrack:
            n2 = ZM.Low;
        }
        return n2;
      }
      function aF(e2) {
        const t2 = QN();
        if (e2.some((e3) => e3._bypassWebAudio))
          throw new Ew(_w.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio");
        if (!t2.webAudioMediaStreamDest)
          throw new Ew(_w.NOT_SUPPORTED, "cannot publish multiple tracks because your browser does not support audio mixing");
      }
      function cF(e2, t2) {
        aF(e2);
        const i3 = t2 || new RL();
        return e2.forEach((e3) => i3.addAudioTrack(e3)), i3;
      }
      const dF = !QN().supportUnifiedPlan || dN("CHROME_FORCE_PLAN_B") && cw();
      function lF(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        var i3;
        return dF ? (i3 = { spec: t2, store: e2 }, Gx("PlanBConnection").create(i3)) : new fF(t2, e2);
      }
      function uF(e2) {
        return e2 && ("disconnected" === e2.iceConnectionState || "checking" === e2.iceConnectionState || "failed" === e2.iceConnectionState);
      }
      function hF(e2) {
        try {
          if (e2.iceServers)
            return false;
          if (e2.turnServer && "off" !== e2.turnServer.mode) {
            if (Vw(e2.turnServer.servers))
              return false;
            if (dN("FORCE_TURN_TCP") || e2.turnServer.servers.concat(e2.turnServer.serversFromGateway || []).some((e3) => e3.forceturn))
              return true;
          }
          return false;
        } catch (e3) {
          return false;
        }
      }
      var pF;
      function _F(e2, t2) {
        var i3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i3.push.apply(i3, n2);
        }
        return i3;
      }
      function EF(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i3 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? _F(Object(i3), true).forEach(function(t3) {
            QI(e2, t3, i3[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : _F(Object(i3)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
          });
        }
        return e2;
      }
      let fF = (pF = class e2 extends dU {
        get currentLocalDescription() {
          return this.peerConnection.currentLocalDescription;
        }
        get currentRemoteDescription() {
          return this.peerConnection.currentRemoteDescription;
        }
        get peerConnectionState() {
          return this.peerConnection.connectionState;
        }
        get iceConnectionState() {
          return this.peerConnection.iceConnectionState;
        }
        get dtlsTransportState() {
          var e3, t2;
          return null !== (e3 = null === (t2 = this.peerConnection.getReceivers()[0]) || void 0 === t2 || null === (t2 = t2.transport) || void 0 === t2 ? void 0 : t2.state) && void 0 !== e3 ? e3 : null;
        }
        get localCodecs() {
          return [...new Set(this.localCapabilities && this.localCapabilities.send.videoCodecs.map((e3) => e3.rtpMap && e3.rtpMap.encodingName.toLowerCase() || "").filter((e3) => {
            var t2;
            return Dn(t2 = Object.keys(hN)).call(t2, e3);
          }))];
        }
        constructor(t2, i3) {
          super(t2, i3), QI(this, "id", uO(5, "connection-")), QI(this, "store", void 0), QI(this, "peerConnection", void 0), QI(this, "forceTurn", false), QI(this, "remoteSDP", void 0), QI(this, "initialOffer", void 0), QI(this, "transportEventReceiver", void 0), QI(this, "statsFilter", void 0), QI(this, "extension", { useXR: dN("USE_XR") }), QI(this, "localCapabilities", void 0), QI(this, "remoteCodecs", void 0), QI(this, "localCandidateCount", 0), QI(this, "allCandidatesReceived", false), QI(this, "isPreallocation", false), QI(this, "preSSRCMap", /* @__PURE__ */ new Map()), QI(this, "dataStreamChannelMap", /* @__PURE__ */ new Map()), QI(this, "establishPromise", void 0), QI(this, "recoveredDataChannelIds", []), QI(this, "currentDataChannelId", 1), QI(this, "supportAV1RtpSpec", false), QI(this, "mutex", void 0), QI(this, "qualityLimitationReason", YO.NONE), this.store = i3, this.forceTurn = hF(t2), this.mutex = new vO("P2PConnection-mutex", i3.clientId), this.peerConnection = new RTCPeerConnection(e2.resolvePCConfiguration(t2), { optional: [{ googDscp: true }] }), this.statsFilter = eN(this.peerConnection, dN("STATS_UPDATE_INTERVAL"), void 0, Kb() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1, this.establishPromise = this.establish();
        }
        getPreMedia(e3) {
          const t2 = this.preSSRCMap.get(e3);
          if (void 0 !== t2) {
            const e4 = this.peerConnection.getTransceivers().find((e5) => e5.mid === t2);
            if (e4)
              return { transceiver: e4, track: e4.receiver.track, id: t2 };
          }
        }
        async updateRemoteRTPCapabilities(e3, t2) {
          if (this.remoteCodecs = t2, !this.remoteSDP)
            return void BN.debug("[P2PConnection] cannot updateRemoteRTPCapabilities before remote SDP created, local codecs: ".concat(this.localCodecs, ", codecs: ").concat(t2));
          if (this.remoteSDP.updateRemoteCodec(e3, t2, this.store.codec)) {
            const e4 = await this.peerConnection.createOffer(), t3 = this.logSDPExchange(e4.sdp || "", "offer", "local", "muteLocal");
            await this.peerConnection.setLocalDescription(e4);
            const i3 = this.remoteSDP.toString();
            null == t3 || t3(i3), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: i3 });
          } else
            BN.debug("[P2PConnection] updateRemoteRTPCapabilities no need to exchange SDP.");
        }
        async establish() {
          try {
            this.peerConnection.addTransceiver("video", { direction: "recvonly" }), this.peerConnection.addTransceiver("audio", { direction: "recvonly" });
            const i3 = await this.peerConnection.createOffer();
            if (!i3.sdp)
              throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
            const n2 = _x(i3.sdp), r2 = await yx({ filterRTX: !dN("USE_PUB_RTX") && !dN("USE_SUB_RTX"), filterVideoFec: dN("FILTER_VIDEO_FEC"), filterAudioFec: dN("FILTER_AUDIO_FEC"), filterVideoCodec: dN("FILTER_VIDEO_CODEC") }, this.extension);
            if (this.localCapabilities = wx(r2), this.initialOffer = i3, dN("ENABLE_SVC") && "av1" == this.store.codec) {
              const t3 = await async function() {
                try {
                  const e4 = new RTCPeerConnection();
                  e4.addTransceiver("video", { direction: "sendonly", sendEncodings: [{ scalabilityMode: qO.L1T3 }] });
                  const t4 = await e4.createOffer();
                  if (!t4.sdp)
                    return void e4.close();
                  const i4 = SN(t4.sdp).mediaDescriptions[0];
                  if (!i4)
                    return;
                  const n3 = i4.attributes.extmaps.find((e5) => "https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension" === e5.extensionName);
                  return e4.close(), n3;
                } catch (e4) {
                  return;
                }
              }();
              var e3;
              if (t3)
                this.supportAV1RtpSpec = true, null === (e3 = r2.send) || void 0 === e3 || e3.videoExtensions.push(t3);
            }
            let o2;
            return i3.sdp && Mx(i3.sdp) && (o2 = $w(r2), (t2 = o2).send && (cx(lU.VIDEO, t2.send.videoExtensions), cx(lU.AUDIO, t2.send.audioExtensions)), t2.recv && (cx(lU.VIDEO, t2.recv.videoExtensions), cx(lU.AUDIO, t2.recv.audioExtensions)), t2.sendrecv && (cx(lU.VIDEO, t2.sendrecv.videoExtensions), cx(lU.AUDIO, t2.sendrecv.audioExtensions))), EF(EF({}, n2), {}, { rtpCapabilities: o2 || r2, offerSDP: i3.sdp });
          } catch (e4) {
            throw new Ew(_w.GET_LOCAL_CONNECTION_PARAMS_FAILED, e4.toString());
          }
          var t2;
        }
        async connect(e3) {
          try {
            if (!this.initialOffer)
              throw new Error("Cannot establish P2PConnection without initial offer.");
            this.initialOffer.sdp && Mx(this.initialOffer.sdp) && (t2 = e3.rtpCapabilities, i3 = this.localCapabilities, t2.send && (ax(lU.VIDEO, t2.send.videoExtensions, i3.send.videoExtensions), ax(lU.AUDIO, t2.send.audioExtensions, i3.send.audioExtensions)), t2.recv && (ax(lU.VIDEO, t2.recv.videoExtensions, i3.recv.videoExtensions), ax(lU.AUDIO, t2.recv.audioExtensions, i3.recv.audioExtensions))), this.remoteSDP = new class {
              get localCapabilities() {
                return $w(this._localCapabilities);
              }
              get rtpCapabilities() {
                return $w(this._rtpCapabilities);
              }
              get candidates() {
                return $w(this._candidates);
              }
              get iceParameters() {
                return $w(this._iceParameters);
              }
              get dtlsParameters() {
                return $w(this._dtlsParameters);
              }
              constructor(e4) {
                let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                QI(this, "sessionDesc", void 0), QI(this, "_localCapabilities", void 0), QI(this, "_rtpCapabilities", void 0), QI(this, "_candidates", void 0), QI(this, "_originCandidates", void 0), QI(this, "_iceParameters", void 0), QI(this, "_isUseExtmapAllowMixed", void 0), QI(this, "_dtlsParameters", void 0), QI(this, "setup", void 0), QI(this, "currentMidIndex", void 0), QI(this, "cname", void 0), QI(this, "firefoxSsrcMidMap", /* @__PURE__ */ new Map()), this._isUseExtmapAllowMixed = t3, e4 = $w(e4);
                const { iceParameters: i4, dtlsParameters: n3, candidates: r3, rtpCapabilities: o3, setup: s3, localCapabilities: a3, cname: c2 } = e4;
                this._rtpCapabilities = o3, this._candidates = r3, this._originCandidates = $w(r3), this._iceParameters = i4, this._dtlsParameters = n3, this._localCapabilities = a3, this.setup = s3, this.cname = c2, this.sessionDesc = this.updateRemoteRTPCapabilities(o3), this.currentMidIndex = this.sessionDesc.mediaDescriptions.length - 1;
              }
              preloadRemoteMedia(e4) {
                const t3 = this.candidates, i4 = this.dtlsParameters, n3 = this.iceParameters, r3 = this.rtpCapabilities.send;
                let o3 = this.sessionDesc.mediaDescriptions.length - 1;
                for (let s3 = 1; s3 < e4; s3++) {
                  const e5 = 2 * s3 + 2e4, a3 = 2 * s3 + YV, { ssrcs: c2, ssrcGroups: d2 } = Tx([{ ssrcId: e5 }], this.cname), { ssrcs: l2, ssrcGroups: u2 } = Tx([{ ssrcId: a3, rtx: dN("USE_SUB_RTX") ? a3 + 1 : void 0 }], this.cname);
                  this.sessionDesc.mediaDescriptions.push({ media: { mediaType: "video", port: KV, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: r3.videoCodecs.map((e6) => e6.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: n3.iceUfrag, icePwd: n3.icePwd, unrecognized: [], candidates: t3, extmaps: r3.videoExtensions, fingerprints: i4.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: l2, ssrcGroups: u2, rtcpFeedbackWildcards: [], payloads: r3.videoCodecs, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: "sendonly", rtcpMux: true, rtcpRsize: true, mid: "".concat(++o3) } }), this.sessionDesc.mediaDescriptions.push({ media: { mediaType: "audio", port: KV, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: r3.audioCodecs.map((e6) => e6.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: n3.iceUfrag, icePwd: n3.icePwd, unrecognized: [], candidates: t3, extmaps: r3.audioExtensions, fingerprints: i4.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: c2, ssrcGroups: d2, rtcpFeedbackWildcards: [], payloads: r3.audioCodecs, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: "sendonly", rtcpMux: true, rtcpRsize: true, mid: "".concat(++o3) } }), this.currentMidIndex += 2;
                }
                this.updateBundleMids();
              }
              toString() {
                return gN(this.sessionDesc);
              }
              send(e4, t3, i4, n3) {
                const { ssrcs: r3, ssrcGroups: o3 } = Tx(t3, this.cname, dN("SYNC_GROUP") ? i4 : void 0), s3 = this.findPreloadMediaDesc(r3);
                if (s3) {
                  if (Kb() && this.firefoxSsrcMidMap.set(r3[0].ssrcId, s3.attributes.mid), n3 && (n3.twcc || n3.remb)) {
                    const e5 = this.sessionDesc.mediaDescriptions.indexOf(s3);
                    return this.sessionDesc.mediaDescriptions[e5] = this.mungSendMediaDesc(s3, n3), { mid: s3.attributes.mid, needExchangeSDP: true };
                  }
                  return { mid: s3.attributes.mid, needExchangeSDP: false };
                }
                {
                  const t4 = this.findAvailableMediaIndex(e4, r3);
                  let i5;
                  return -1 === t4 || 1 === t4 && (Wb() || function() {
                    const e5 = xb();
                    return !(e5.name !== Lb.CHROME || !e5.osVersion) && Number(e5.version) <= 90;
                  }()) || 0 === t4 && dN("USE_SUB_RTX") || ew() ? (i5 = this.createOrRecycleSendMedia(e4, r3, o3, "sendonly", n3), this.updateBundleMids()) : (i5 = $w(this.sessionDesc.mediaDescriptions[t4]), i5.attributes.direction = "sendonly", i5.attributes.ssrcs = r3, i5.attributes.ssrcGroups = o3, this.sessionDesc.mediaDescriptions[t4] = this.mungSendMediaDesc(i5, n3)), Kb() && this.firefoxSsrcMidMap.set(r3[0].ssrcId, i5.attributes.mid), { mid: i5.attributes.mid, needExchangeSDP: true };
                }
              }
              sendDataChannel() {
                const { mediaDesc: e4, needExchangeSDP: t3 } = this.createOrRecycleDataChannel();
                return this.updateBundleMids(), { mid: e4.attributes.mid, needExchangeSDP: t3 };
              }
              batchSend(e4) {
                const t3 = e4.map((e5) => {
                  let { kind: t4, ssrcMsg: i5, mslabel: n4 } = e5;
                  return this.send(t4, i5, n4);
                }), i4 = [];
                let n3 = false;
                return t3.forEach((e5) => {
                  let { mid: t4, needExchangeSDP: r3 } = e5;
                  r3 && (n3 = true), i4.push(t4);
                }), { mids: i4, needExchangeSDP: n3 };
              }
              stopSending(e4) {
                const t3 = this.sessionDesc.mediaDescriptions.filter((t4) => t4.attributes.mid && -1 !== e4.indexOf(t4.attributes.mid));
                if (t3.length !== e4.length)
                  throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending.");
                t3.forEach((e5) => {
                  "0" === e5.attributes.mid || Kb() || ew() ? e5.attributes.ssrcs = [] : (e5.attributes.ssrcs = [], e5.attributes.direction = "inactive", e5.media.port = "0");
                }), this.updateBundleMids();
              }
              mute(e4) {
                const t3 = this.sessionDesc.mediaDescriptions.find((t4) => t4.attributes.mid === e4);
                if (!t3)
                  throw new Error("mediaDescription not found with ".concat(e4, " in remote SDP when calling RemoteSDP.mute."));
                t3.attributes.direction = "inactive";
              }
              unmute(e4) {
                const t3 = this.sessionDesc.mediaDescriptions.find((t4) => t4.attributes.mid === e4);
                if (!t3)
                  throw new Error("mediaDescription not found with ".concat(e4, " in remote SDP when calling RemoteSDP.unmute."));
                t3.attributes.direction = "sendonly";
              }
              muteRemote(e4) {
                const t3 = this.sessionDesc.mediaDescriptions.filter((t4) => Dn(e4).call(e4, t4.attributes.mid || ""));
                if (t3.length !== e4.length)
                  throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
                t3.forEach((e5) => {
                  e5.attributes.direction = "inactive";
                });
              }
              unmuteRemote(e4) {
                const t3 = this.sessionDesc.mediaDescriptions.filter((t4) => Dn(e4).call(e4, t4.attributes.mid || ""));
                if (t3.length !== e4.length)
                  throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
                t3.forEach((e5) => {
                  e5.attributes.direction = "recvonly";
                });
              }
              receive(e4, t3, i4, n3) {
                e4.forEach((e5, r3) => {
                  this.createOrRecycleRecvMedia(e5, [], "recvonly", t3, i4, n3[r3]);
                }), this.updateBundleMids();
              }
              stopReceiving(e4) {
                const t3 = this.sessionDesc.mediaDescriptions.filter((t4) => -1 !== e4.indexOf(t4.attributes.mid));
                if (t3.length !== e4.length)
                  throw new Error("MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive.");
                t3.forEach((e5) => {
                  e5.media.port = "0", e5.attributes.direction = "inactive";
                }), this.updateBundleMids();
              }
              updateRemoteRTPCapabilities(e4) {
                const t3 = this.sessionDesc || SN((i4 = this._isUseExtmapAllowMixed, "v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0 1\na=msid-semantic: WMS\na=ice-lite".concat(i4 ? "\na=extmap-allow-mixed" : "", "\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:0\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:1\n")));
                var i4;
                this._rtpCapabilities = e4;
                const n3 = this.rtpCapabilities.send, r3 = this.localCapabilities.send;
                for (const e5 of t3.mediaDescriptions) {
                  if (e5.attributes.iceUfrag = this._iceParameters.iceUfrag, e5.attributes.icePwd = this._iceParameters.icePwd, e5.attributes.fingerprints = this._dtlsParameters.fingerprints, e5.attributes.candidates = this._candidates, e5.attributes.setup = this.setup, "application" === e5.media.mediaType && (e5.attributes.sctpPort = "5000"), "video" === e5.media.mediaType) {
                    if (0 === n3.videoCodecs.length) {
                      const t4 = r3.videoCodecs.filter((e6) => {
                        var t5, i5;
                        return null === (t5 = e6.rtpMap) || void 0 === t5 ? void 0 : Dn(i5 = t5.encodingName.toLowerCase()).call(i5, "vp8");
                      }) || [r3.videoCodecs[0]];
                      e5.media.fmts = t4.map((e6) => e6.payloadType.toString(10)), e5.attributes.payloads = t4, e5.attributes.extmaps = [];
                    } else if (e5.media.fmts = n3.videoCodecs.map((e6) => e6.payloadType.toString(10)), e5.attributes.payloads = n3.videoCodecs, e5.attributes.extmaps = n3.videoExtensions, dN("PRELOAD_MEDIA_COUNT") > 0) {
                      const { ssrcs: t4, ssrcGroups: i5 } = Tx([{ ssrcId: YV, rtx: dN("USE_SUB_RTX") ? 40001 : void 0 }], this.cname);
                      e5.attributes.ssrcs = t4, e5.attributes.ssrcGroups = i5;
                    }
                  }
                  if ("audio" === e5.media.mediaType) {
                    if (0 === n3.audioCodecs.length) {
                      const t4 = r3.audioCodecs.filter((e6) => {
                        var t5, i5;
                        return null === (t5 = e6.rtpMap) || void 0 === t5 ? void 0 : Dn(i5 = t5.encodingName.toLowerCase()).call(i5, "opus");
                      }) || [r3.audioCodecs[0]];
                      e5.media.fmts = t4.map((e6) => e6.payloadType.toString(10)), e5.attributes.payloads = t4, e5.attributes.extmaps = [];
                    } else if (e5.media.fmts = n3.audioCodecs.map((e6) => e6.payloadType.toString(10)), e5.attributes.payloads = n3.audioCodecs, e5.attributes.extmaps = n3.audioExtensions, Ox(e5), dN("PRELOAD_MEDIA_COUNT") > 0) {
                      const { ssrcs: t4, ssrcGroups: i5 } = Tx([{ ssrcId: 2e4 }], this.cname);
                      e5.attributes.ssrcs = t4, e5.attributes.ssrcGroups = i5;
                    }
                  }
                }
                return this.sessionDesc = t3, this.currentMidIndex = t3.mediaDescriptions.length - 1, this.sessionDesc;
              }
              updateCandidates(e4) {
                const t3 = this._originCandidates.filter((e5) => "udp" === e5.transport), i4 = [];
                if (t3.forEach((e5) => {
                  i4.push(HV(HV({}, e5), {}, { foundation: "tcpcandidate", priority: Number(e5.priority) - 1 + "", transport: "tcp", port: Number(e5.port) + 90 + "" }));
                }), 0 !== t3.length) {
                  switch (e4) {
                    case uU.TCP_RELAY:
                      this._candidates = i4;
                      break;
                    case uU.UDP_TCP_RELAY:
                    case uU.RELAY:
                      this._candidates = [...t3, ...i4];
                      break;
                    default:
                      this._candidates = t3;
                  }
                  for (const e5 of this.sessionDesc.mediaDescriptions)
                    e5.attributes.candidates = this.candidates;
                }
              }
              restartICE(e4) {
                e4 = $w(e4), this._iceParameters = e4, this.sessionDesc.mediaDescriptions.forEach((t3) => {
                  t3.attributes.iceUfrag = e4.iceUfrag, t3.attributes.icePwd = e4.icePwd;
                });
              }
              predictReceivingMids(e4) {
                const t3 = [];
                for (let i4 = 0; i4 < e4; i4++)
                  t3.push((this.currentMidIndex + i4 + 1).toString(10));
                return t3;
              }
              findAvailableMediaIndex(e4, t3) {
                return this.sessionDesc.mediaDescriptions.findIndex((i4) => {
                  const n3 = i4.media.mediaType === e4 && "0" !== i4.media.port && ("sendonly" === i4.attributes.direction || "sendrecv" === i4.attributes.direction) && 0 === i4.attributes.ssrcs.length;
                  if (Kb()) {
                    if (n3) {
                      const e5 = this.firefoxSsrcMidMap.get(t3[0].ssrcId);
                      return !(e5 || "0" !== i4.attributes.mid && "1" !== i4.attributes.mid) || !(!e5 || e5 !== i4.attributes.mid);
                    }
                    return false;
                  }
                  return n3;
                });
              }
              createOrRecycleDataChannel() {
                for (const e5 of this.sessionDesc.mediaDescriptions)
                  if ("application" === e5.media.mediaType)
                    return { mediaDesc: e5, needExchangeSDP: false };
                this.currentMidIndex += 1;
                const e4 = "".concat(this.currentMidIndex), t3 = { media: { mediaType: "application", port: KV, protos: ["UDP", "DTLS", "SCTP"], fmts: ["webrtc-datachannel"] }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: [], fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: [], ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: [], rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, mid: "".concat(e4), sctpPort: "5000" } };
                return this.sessionDesc.mediaDescriptions.push(t3), { mediaDesc: t3, needExchangeSDP: true };
              }
              createOrRecycleRecvMedia(e4, t3, i4, n3, r3, o3) {
                const s3 = e4._mediaStreamTrack.kind, a3 = this.rtpCapabilities.recv, c2 = Nx(s3, a3, this.localCapabilities.send, s3 === lU.VIDEO ? n3 : r3), d2 = s3 === lU.VIDEO ? a3.videoExtensions : a3.audioExtensions;
                this.currentMidIndex += 1;
                const l2 = "".concat(this.currentMidIndex);
                let u2 = { media: { mediaType: s3, port: KV, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: c2.map((e5) => e5.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: d2, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t3, ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: c2, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: i4, rtcpMux: true, rtcpRsize: true, mid: "".concat(l2) } };
                u2 = this.mungRecvMediaDsec(u2, e4, o3);
                const h2 = this.findFirstClosedMedia(s3);
                if (h2) {
                  const e5 = this.sessionDesc.mediaDescriptions.indexOf(h2);
                  this.sessionDesc.mediaDescriptions[e5] = u2;
                } else
                  this.sessionDesc.mediaDescriptions.push(u2);
                return u2;
              }
              updateRemoteCodec(e4, t3, i4) {
                const n3 = [...new Set(this._rtpCapabilities.recv.videoCodecs.map((e5) => e5.rtpMap && e5.rtpMap.encodingName.toLowerCase() || "").filter((e5) => {
                  var t4;
                  return Dn(t4 = Object.keys(hN)).call(t4, e5);
                }))], r3 = new Set(t3);
                if (n3.every((e5) => r3.has(e5)))
                  return BN.debug("codecs has not changed, no need to updateRemoteCodec, codecs: ".concat(t3)), false;
                const o3 = this._rtpCapabilities.recv.videoCodecs.filter((e5) => t3.some((t4) => {
                  var i5;
                  return Dn(i5 = e5.rtpMap && e5.rtpMap.encodingName.toLowerCase() || "").call(i5, t4);
                }));
                if (0 === o3.length)
                  return BN.debug("updateRemoteCodec failed, because cannot find matched codec, remoteCapabilities codecs: ".concat(n3, " codecs: ").concat(t3)), false;
                const s3 = [...new Set(o3.map((e5) => e5.rtpMap && e5.rtpMap.encodingName.toLowerCase() || ""))];
                let a3;
                if (BN.debug("updateRemoteCodec, from ".concat(n3, " to ").concat(s3)), 0 === e4.length)
                  a3 = this.sessionDesc.mediaDescriptions.filter((e5) => "video" === e5.media.mediaType && "recvonly" === e5.attributes.direction);
                else if (a3 = this.sessionDesc.mediaDescriptions.filter((t4) => t4.attributes.mid && Dn(e4).call(e4, t4.attributes.mid) && "recvonly" === t4.attributes.direction), a3.length !== e4.length)
                  return BN.debug("updateRemoteCodec failed, because cannot find mids, mids: ".concat(e4, ", codecs: ").concat(t3)), false;
                if (dN("USE_PUB_RTX") || dN("USE_SUB_RTX")) {
                  const e5 = Dx(o3, this.rtpCapabilities.recv.videoCodecs);
                  o3.push(...e5);
                }
                this._rtpCapabilities.recv.videoCodecs = o3;
                const c2 = this.localCapabilities.send, d2 = this.rtpCapabilities.recv, l2 = Nx(lU.VIDEO, d2, c2, i4);
                return a3.forEach((e5) => {
                  const t4 = l2.map((e6) => e6.payloadType.toString(10));
                  BN.debug("updateRemoteCodec mid: ".concat(e5.attributes.mid, ", from"), e5.attributes.payloads, "to", l2), e5.attributes.payloads = l2, e5.media.fmts = t4;
                }), true;
              }
              createOrRecycleSendMedia(e4, t3, i4, n3, r3) {
                const o3 = this.rtpCapabilities.send, s3 = e4 === lU.VIDEO ? o3.videoCodecs : o3.audioCodecs, a3 = e4 === lU.VIDEO ? o3.videoExtensions : o3.audioExtensions;
                this.currentMidIndex += 1;
                const c2 = "".concat(this.currentMidIndex);
                let d2 = { media: { mediaType: e4, port: KV, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: s3.map((e5) => e5.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: a3, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t3, ssrcGroups: i4, rtcpFeedbackWildcards: [], payloads: s3, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: n3, rtcpMux: true, rtcpRsize: true, mid: "".concat(c2) } };
                d2 = this.mungSendMediaDesc(d2, r3);
                const l2 = this.findFirstClosedMedia(e4);
                if (l2) {
                  const e5 = this.sessionDesc.mediaDescriptions.indexOf(l2);
                  this.sessionDesc.mediaDescriptions[e5] = d2;
                } else
                  this.sessionDesc.mediaDescriptions.push(d2);
                return d2;
              }
              updateBundleMids() {
                this.sessionDesc.attributes.groups[0].identificationTag = this.sessionDesc.mediaDescriptions.filter((e4) => "0" !== e4.media.port).map((e4) => e4.attributes.mid);
              }
              mungRecvMediaDsec(e4, t3, i4) {
                const n3 = $w(e4);
                return gx(n3), Sx(n3, t3), Rx(n3, t3), Cx(n3), vx(n3, i4, this.localCapabilities.send), n3;
              }
              mungSendMediaDesc(e4, t3) {
                const i4 = $w(e4);
                return vx(i4, t3, this.localCapabilities.recv), Ox(i4), i4;
              }
              updateRecvMedia(e4, t3) {
                const i4 = this.sessionDesc.mediaDescriptions.findIndex((t4) => t4.attributes.mid === e4);
                if (-1 !== i4) {
                  const e5 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i4], t3);
                  this.sessionDesc.mediaDescriptions[i4] = e5;
                }
              }
              bumpMid(e4) {
                this.currentMidIndex += e4;
              }
              findFirstClosedMedia(e4) {
                return this.sessionDesc.mediaDescriptions.find((t3) => Kb() ? "0" === t3.media.port && t3.media.mediaType === e4 : "0" === t3.media.port);
              }
              findPreloadMediaDesc(e4) {
                return this.sessionDesc.mediaDescriptions.find((t3) => {
                  var i4;
                  return (null === (i4 = t3.attributes) || void 0 === i4 || null === (i4 = i4.ssrcs[0]) || void 0 === i4 ? void 0 : i4.ssrcId) === e4[0].ssrcId;
                });
              }
              getSSRC(e4) {
                var t3;
                return null === (t3 = this.sessionDesc.mediaDescriptions.find((t4) => t4.attributes.mid === e4)) || void 0 === t3 ? void 0 : t3.attributes.ssrcs;
              }
            }(EF(EF({}, e3), {}, { localCapabilities: this.localCapabilities }), this.supportAV1RtpSpec), e3.preallocation && (this.isPreallocation = true), Array.isArray(this.remoteCodecs) && this.remoteCodecs.length > 0 && this.remoteSDP.updateRemoteCodec([], this.remoteCodecs, this.store.codec);
            const n2 = this.remoteSDP.toString(), r2 = Lx(this.initialOffer.sdp, this.extension), o2 = this.logSDPExchange(r2 || "", "offer", "local", "connect");
            this.store.descriptionStart(), await this.peerConnection.setLocalDescription({ type: "offer", sdp: r2 }), null == o2 || o2(n2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n2 });
            const s2 = this.peerConnection.getTransceivers()[0];
            if (null != s2 && s2.receiver && this.tryBindTransportEvents(s2.receiver), dN("PRELOAD_MEDIA_COUNT") > 0) {
              this.remoteSDP.preloadRemoteMedia(dN("PRELOAD_MEDIA_COUNT"));
              const e4 = this.remoteSDP.toString();
              await this.peerConnection.setRemoteDescription({ type: "offer", sdp: e4 });
              const t3 = await this.peerConnection.createAnswer();
              await this.peerConnection.setLocalDescription(t3);
            }
            const { preSSRCs: a2 } = e3;
            if (Array.isArray(a2) && a2.length > 0) {
              const { mids: e4 } = this.remoteSDP.batchSend(a2.map((e5) => ({ kind: e5.kind, ssrcMsg: [{ ssrcId: e5.ssrcId, rtx: e5.rtx }], mslabel: e5.mslabel })));
              e4.forEach((e5, t3) => {
                this.preSSRCMap.set(a2[t3].ssrcId, e5);
              }), await Px(this.peerConnection, this.remoteSDP, this.extension), BN.debug("[".concat(this.store.clientId, "] [P2PConnection] pre-batchReceive exchange SDP."));
            }
          } catch (e4) {
            throw new Ew(_w.EXCHANGE_SDP_FAILED, "P2PConnection.connect failed; ".concat(e4.toString()));
          }
          var t2, i3;
        }
        async updateRemoteConnect(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.updateRemoteConnect before remote SDP created");
            const { rtpCapabilities: t2 } = e3;
            this.remoteSDP.updateRemoteRTPCapabilities(t2), Array.isArray(this.remoteCodecs) && this.remoteCodecs.length > 0 && this.remoteSDP.updateRemoteCodec([], this.remoteCodecs, this.store.codec);
            const { preSSRCs: i3 } = e3;
            if (Array.isArray(i3) && i3.length > 0) {
              const { mids: e4 } = this.remoteSDP.batchSend(i3.map((e5) => Object.assign({}, { kind: e5.kind, ssrcMsg: [{ ssrcId: e5.ssrcId, rtx: e5.rtx }], mslabel: e5.mslabel })));
              e4.forEach((e5, t3) => {
                this.preSSRCMap.set(i3[t3].ssrcId, e5);
              });
            }
            await Px(this.peerConnection, this.remoteSDP, this.extension), BN.debug("[P2PConnection] updateRemoteRTPCapabilities by exchanging SDP.");
          } catch (e4) {
            throw new Ew(_w.EXCHANGE_SDP_FAILED, "P2PConnection.updateRemoteConnect failed; ".concat(e4.toString()));
          }
        }
        send(e3, t2, i3) {
          var n2 = this;
          return FA(function* () {
            const r2 = yield BA(n2.mutex.lock("From P2PConnection.send"));
            try {
              if (!n2.remoteSDP)
                throw new Error("Cannot call P2PConnection.send before remote SDP created");
              const o2 = [], s2 = ox();
              e3.forEach((e4) => {
                const t3 = n2.peerConnection.addTransceiver(e4._mediaStreamTrack, EF({ direction: "sendonly" }, "video" === e4.trackMediaType && n2.supportAV1RtpSpec && s2 ? { sendEncodings: [{ scalabilityMode: s2 }] } : {}));
                o2.push(t3), e4._updateRtpTransceiver(t3);
              }), Kb() && true === dN("SIMULCAST") && (yield BA(n2.applySimulcastForFirefox(o2, e3)));
              const a2 = yield BA(n2.peerConnection.createOffer()), c2 = n2.remoteSDP.predictReceivingMids(e3.length), d2 = n2.mungSendOfferSDP(a2.sdp, e3, c2), l2 = SN(d2), u2 = c2.map((e4) => {
                const t3 = l2.mediaDescriptions.find((t4) => t4.attributes.mid === e4);
                if (!t3)
                  throw new Error("Cannot extract ssrc from mediaDescription.");
                return Ex(t3, dN("USE_PUB_RTX"));
              });
              let h2;
              try {
                h2 = yield u2;
              } catch (r3) {
                h2 = [], n2.remoteSDP.receive(e3, t2, i3, h2);
                const o3 = n2.remoteSDP.toString();
                throw yield BA(n2.peerConnection.setLocalDescription({ type: "offer", sdp: d2 })), yield BA(n2.peerConnection.setRemoteDescription({ type: "answer", sdp: o3 })), yield BA(n2.stopSending(c2, true)), r3;
              }
              n2.remoteSDP.receive(e3, t2, i3, h2);
              const p3 = n2.remoteSDP.toString(), _2 = n2.logSDPExchange(d2, "offer", "local", "send");
              return yield BA(n2.peerConnection.setLocalDescription({ type: "offer", sdp: d2 })), yield BA(n2.applySimulcastEncodings(o2, e3)), yield BA(n2.applySendEncodings(o2, e3)), null == _2 || _2(p3), yield BA(n2.peerConnection.setRemoteDescription({ type: "answer", sdp: p3 })), o2.map((e4, t3) => {
                const i4 = c2[t3];
                return { localSSRC: u2[t3], id: i4, transceiver: e4 };
              });
            } catch (e4) {
              throw e4 instanceof Ew ? e4 : new Ew(_w.EXCHANGE_SDP_FAILED, "P2PConnection.send failed; ".concat(e4.toString()));
            } finally {
              r2();
            }
          })();
        }
        async createDataChannels(e3, t2) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.createDataChannels before remote SDP created");
            let i3 = this.dataStreamChannelMap.get(e3);
            if (i3 && "open" === i3.readyState)
              BN.debug("[P2PConnection] Channels are already available and can be reused directly.");
            else {
              const t3 = this.currentDataChannelId < 1023 ? this.currentDataChannelId++ : this.recoveredDataChannelIds.shift();
              if ("number" != typeof t3)
                throw new Error("create DataChannel error, because cannot get dc id");
              i3 = this.peerConnection.createDataChannel("datastream-channel", { id: t3, negotiated: true, ordered: false, maxRetransmits: dN("DATASTREAM_MAX_RETRANSMITS") }), i3.binaryType = "arraybuffer", this.dataStreamChannelMap.set(e3, i3);
            }
            t2.forEach((e4) => {
              e4._updateOriginDataChannel(i3);
            });
            const { needExchangeSDP: n2 } = this.remoteSDP.sendDataChannel();
            if (n2) {
              const e4 = this.remoteSDP.toString();
              await this.peerConnection.setRemoteDescription({ type: "offer", sdp: e4 });
              const t3 = await this.peerConnection.createAnswer();
              await this.peerConnection.setLocalDescription(t3), BN.debug("[P2PConnection] createDataChannels by exchanging SDP.");
            } else
              BN.debug("[P2PConnection] createDataChannels no need to exchange SDP.");
            return;
          } catch (e4) {
            throw e4 instanceof Ew ? e4 : new Ew(_w.EXCHANGE_SDP_FAILED, "P2PConnection.createDataChannels failed; ".concat(e4.toString()));
          }
        }
        async stopDataChannels(e3) {
          try {
            const t2 = this.dataStreamChannelMap.get(e3);
            return t2 && (t2.id && this.recoveredDataChannelIds.push(t2.id), t2.close()), void this.dataStreamChannelMap.delete(e3);
          } catch (e4) {
            throw e4 instanceof Ew ? e4 : new Ew(_w.DATACHANNEL_FAILED, "P2PConnection.stopDataChannels failed; ".concat(e4.toString()));
          }
        }
        async stopSending(e3, t2) {
          const i3 = t2 ? void 0 : await this.mutex.lock("From P2PConnection.stopSending");
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.stopSending before remote SDP created");
            const t3 = this.peerConnection.getTransceivers().filter((t4) => -1 !== e3.indexOf(t4.mid));
            if (t3.length !== e3.length)
              throw new Error("Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending.");
            t3.map((e4) => {
              var t4;
              oF(this.id + e4.mid, this), e4.direction = "inactive", null === (t4 = e4.stop) || void 0 === t4 || t4.call(e4);
            });
            const n2 = await this.peerConnection.createOffer(), r2 = this.logSDPExchange(n2.sdp || "", "offer", "local", "stopSending");
            await this.peerConnection.setLocalDescription(n2), this.remoteSDP.stopReceiving(e3);
            const o2 = this.remoteSDP.toString();
            null == r2 || r2(o2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: o2 });
          } catch (e4) {
            throw new Ew(_w.EXCHANGE_SDP_FAILED, "P2PConnection.stopSending failed; ".concat(e4.toString()));
          } finally {
            i3 && i3();
          }
        }
        async receive(e3, t2, i3, n2) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.receive ".concat(e3, " before remoteSDP created."));
            const { mid: r2, needExchangeSDP: o2 } = this.remoteSDP.send(e3, t2, i3, n2);
            o2 && (await Px(this.peerConnection, this.remoteSDP, this.extension), BN.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e3, " by exchanging SDP.")));
            const s2 = this.peerConnection.getTransceivers().find((e4) => e4.mid === r2);
            if (!s2)
              throw new Error("Cannot get transceiver after setLocalDescription.");
            return { track: s2.receiver.track, id: r2, transceiver: s2 };
          } catch (e4) {
            throw new Ew(_w.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e4.toString()));
          }
        }
        async batchReceive(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.batchReceive before remoteSDP created.");
            const { mids: t2, needExchangeSDP: i3 } = this.remoteSDP.batchSend(e3);
            return i3 && (await Px(this.peerConnection, this.remoteSDP, this.extension), BN.debug("[".concat(this.store.clientId, "] [P2PConnection] batchReceive by exchanging SDP."))), t2.map((e4) => {
              const t3 = this.peerConnection.getTransceivers().find((t4) => t4.mid === e4);
              if (!t3)
                throw new Error("Cannot get transceiver after setLocalDescription.");
              return { track: t3.receiver.track, id: e4, transceiver: t3 };
            });
          } catch (e4) {
            throw new Ew(_w.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e4.toString()));
          }
        }
        async stopReceiving(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
            e3.forEach((e4) => {
              Array.from(this.preSSRCMap.entries()).some((t3) => {
                let [i4, n3] = t3;
                if (n3 === e4)
                  return this.preSSRCMap.delete(i4), true;
              });
            }), this.remoteSDP.stopSending(e3);
            const t2 = this.remoteSDP.toString(), i3 = this.logSDPExchange(t2, "offer", "remote", "stopReceiving");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
            const n2 = await this.peerConnection.createAnswer();
            null == i3 || i3(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
          } catch (e4) {
            throw new Ew(_w.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e4.toString()));
          }
        }
        async muteRemote(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.muteRemote mid=".concat(e3, " before remote SDP created."));
            this.remoteSDP.mute(e3);
            const t2 = this.remoteSDP.toString(), i3 = this.logSDPExchange(t2, "offer", "remote", "muteRemote");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
            const n2 = await this.peerConnection.createAnswer();
            null == i3 || i3(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
          } catch (e4) {
            throw new Ew(_w.EXCHANGE_SDP_FAILED, "P2PConnection.muteRemote failed; ".concat(e4.toString()));
          }
        }
        async unmuteRemote(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.unmuteRemote mid=".concat(e3, " before remote SDP created."));
            this.remoteSDP.unmute(e3);
            const t2 = this.remoteSDP.toString(), i3 = this.logSDPExchange(t2, "offer", "remote", "unmuteRemote");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
            const n2 = await this.peerConnection.createAnswer();
            null == i3 || i3(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
          } catch (e4) {
            throw new Ew(_w.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteRemote failed; ".concat(e4.toString()));
          }
        }
        async muteLocal(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created.");
            const t2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid && -1 !== e3.indexOf(t3.mid));
            if (t2.length !== e3.length)
              throw new Error("Transceivers' length doesn't match mids' length.");
            t2.map((e4) => {
              e4.direction = "inactive";
            });
            const i3 = await this.peerConnection.createOffer(), n2 = this.logSDPExchange(i3.sdp || "", "offer", "local", "muteLocal");
            await this.peerConnection.setLocalDescription(i3), this.remoteSDP.muteRemote(e3);
            const r2 = this.remoteSDP.toString();
            null == n2 || n2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e4) {
            throw new Ew(_w.EXCHANGE_SDP_FAILED, "P2PConnection.muteLocal failed; ".concat(e4.toString()));
          }
        }
        async unmuteLocal(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created.");
            const t2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid && -1 !== e3.indexOf(t3.mid));
            if (t2.length !== e3.length)
              throw new Error("Transceivers' length doesn't match mids' length.");
            t2.map(async (e4, t3) => {
              e4.direction = "sendonly";
            });
            const i3 = await this.peerConnection.createOffer(), n2 = this.logSDPExchange(i3.sdp || "", "offer", "local", "unmuteLocal");
            await this.peerConnection.setLocalDescription(i3), this.remoteSDP.unmuteRemote(e3), Array.isArray(this.remoteCodecs) && this.remoteCodecs.length > 0 && this.remoteSDP.updateRemoteCodec(e3, this.remoteCodecs, this.store.codec);
            const r2 = this.remoteSDP.toString();
            null == n2 || n2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e4) {
            throw new Ew(_w.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteLocal failed; ".concat(e4.toString()));
          }
        }
        restartICE(e3) {
          var t2 = this;
          return FA(function* () {
            const i3 = yield BA(t2.mutex.lock("From P2PConnection.restartICE"));
            try {
              if (!t2.remoteSDP)
                throw new Error("Cannot restartICE before remoteSDP created.");
              const n2 = QN().supportPCSetConfiguration, r2 = dN("FORCE_TURN_TCP") || t2.forceTurn;
              if (e3 === uU.RELAY && !n2)
                return;
              if (n2 && !r2) {
                const i4 = e3 === uU.RELAY ? "relay" : "all", n3 = t2.peerConnection.getConfiguration();
                n3.iceTransportPolicy !== i4 && (BN.debug("[".concat(t2.store.clientId, "] restartICE change iceTransportPolicy from [").concat(n3.iceTransportPolicy, "] to [").concat(i4, "]")), n3.iceTransportPolicy = i4, t2.peerConnection.setConfiguration(n3));
              }
              t2.remoteSDP.updateCandidates(e3);
              const o2 = yield BA(t2.peerConnection.createOffer({ iceRestart: true }));
              if (!o2.sdp)
                throw new Error("Cannot restartICE because restart offer SDP does not exist.");
              const s2 = _x(o2.sdp), { remoteIceParameters: a2 } = yield s2.iceParameters;
              t2.remoteSDP.restartICE(a2);
              const c2 = t2.remoteSDP.toString(), d2 = t2.logSDPExchange(o2.sdp || "", "offer", "local", "restartICE");
              t2.store.descriptionStart(), yield BA(t2.peerConnection.setLocalDescription(o2)), null == d2 || d2(c2), yield BA(t2.peerConnection.setRemoteDescription({ type: "answer", sdp: c2 }));
            } catch (e4) {
              BN.warning("[".concat(t2.store.clientId, "] restart ICE failed, abort operation"), e4);
            } finally {
              i3();
            }
          })();
        }
        close() {
          var e3;
          this.peerConnection.getTransceivers().forEach((e4) => {
            oF(this.id + e4.mid, this);
          }), this.preSSRCMap.clear(), this.peerConnection.close(), null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, "closed"), this.tryUnbindTransportEvents(), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.transportEventReceiver = void 0, this.statsFilter.destroy(), this.dataStreamChannelMap.clear(), this.recoveredDataChannelIds = [], this.currentDataChannelId = 1;
        }
        getStats() {
          return EF(EF({}, this.statsFilter.getStats()), {}, { qualityLimitationReason: this.qualityLimitationReason });
        }
        getRemoteVideoIsReady(e3) {
          return this.statsFilter.getVideoIsReady(e3);
        }
        async updateEncoderConfig(e3, t2) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created.");
            const i3 = await this.peerConnection.createOffer(), n2 = this.mungSendOfferSDP(i3.sdp, [t2], [e3]);
            this.remoteSDP.updateRecvMedia(e3, t2);
            const r2 = this.remoteSDP.toString(), o2 = this.logSDPExchange(n2, "offer", "local", "updateEncoderConfig");
            await this.peerConnection.setLocalDescription({ type: "offer", sdp: n2 }), null == o2 || o2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e4) {
            throw new Ew(_w.EXCHANGE_SDP_FAILED, e4.toString());
          }
        }
        async updateSendParameters(e3, t2) {
          const i3 = this.peerConnection.getTransceivers().filter((t3) => t3.mid === e3);
          1 === i3.length && (this.isVP8Simulcast(t2) ? Kb() || await this.applySimulcastEncodings(i3, [t2]) : await this.applySendEncodings(i3, [t2]));
        }
        setStatsRemoteVideoIsReady(e3, t2) {
          this.statsFilter.setVideoIsReady2(e3, t2);
        }
        async replaceTrack(e3, t2) {
          const i3 = this.peerConnection.getTransceivers().find((e4) => e4.mid === t2);
          i3 && await i3.sender.replaceTrack(e3._mediaStreamTrack);
        }
        async getSelectedCandidatePair() {
          const e3 = this.peerConnection.getReceivers();
          if (e3.length > 0 && e3[0].transport && e3[0].transport.iceTransport && e3[0].transport.iceTransport.getSelectedCandidatePair && e3[0].transport.iceTransport.getSelectedCandidatePair()) {
            const t2 = e3[0].transport.iceTransport, { local: i3, remote: n2 } = t2.getSelectedCandidatePair();
            return { local: EF(EF({}, VO), {}, { candidateType: i3.type, protocol: i3.protocol, address: i3.address, port: i3.port }), remote: EF(EF({}, VO), {}, { candidateType: n2.type, protocol: n2.protocol, address: n2.address, port: n2.port }) };
          }
          return this.statsFilter.getSelectedCandidatePair();
        }
        bindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = () => {
            var e3;
            null === (e3 = this.onICEConnectionStateChange) || void 0 === e3 || e3.call(this, this.peerConnection.iceConnectionState);
          }, this.peerConnection.onconnectionstatechange = () => {
            var e3;
            null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, this.peerConnection.connectionState);
          }, this.peerConnection.onicecandidateerror = (e3) => {
            if (e3 && (e3.errorCode || e3.errorText)) {
              var t2;
              const i3 = "code: ".concat(e3.errorCode, ", message: ").concat(e3.errorText), n2 = e3.port ? "local: ".concat(e3.port) : "";
              BN.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICECandidateError(").concat(i3, "), url: ").concat(e3.url || "", ", host_candidate:").concat(n2)), null === (t2 = this.onICECandidateError) || void 0 === t2 || t2.call(this, i3);
            }
          }, this.peerConnection.onicegatheringstatechange = (e3) => {
            e3 && e3.target && "iceGatheringState" in e3.target && BN.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] RTCPeerConnection.onicegatheringstatechange(").concat(e3.target.iceGatheringState, ")"));
          }, this.peerConnection.onicecandidate = (e3) => {
            e3.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = true, BN.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount));
          }, setTimeout(() => {
            this.allCandidatesReceived || (this.allCandidatesReceived = true, BN.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount));
          }, dN("CANDIDATE_TIMEOUT"));
        }
        unbindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
        }
        static resolvePCConfiguration(t2) {
          const i3 = { iceServers: [] };
          return t2.iceServers ? i3.iceServers = t2.iceServers : t2.turnServer && "off" !== t2.turnServer.mode && (Vw(t2.turnServer.servers) ? i3.iceServers = t2.turnServer.servers : (i3.iceServers && i3.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.servers)), dN("USE_TURN_SERVER_OF_GATEWAY") && i3.iceServers && t2.turnServer.serversFromGateway && i3.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.serversFromGateway)), dN("FORCE_TURN_TCP") ? i3.iceTransportPolicy = "relay" : t2.turnServer.servers.concat(t2.turnServer.serversFromGateway || []).forEach((e3) => {
            e3.forceturn && (i3.iceTransportPolicy = "relay");
          }))), dN("ENABLE_ENCODED_TRANSFORM") && QN().supportWebRTCEncodedTransform && (i3.encodedInsertableStreams = true), i3;
        }
        static turnServerConfigToIceServers(e3) {
          const t2 = [];
          return e3.forEach((e4) => {
            e4.security ? e4.tcpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turns:".concat(JU(e4.turnServerURL), ":").concat(e4.tcpport, "?transport=tcp") }) : (e4.udpport && !dN("FORCE_TURN_TCP") && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.udpport, "?transport=udp") }), e4.tcpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.tcpport, "?transport=tcp") }));
          }), t2;
        }
        tryBindTransportEvents(e3) {
          const t2 = e3.transport;
          if (t2) {
            this.transportEventReceiver = e3, t2.onstatechange = () => {
              var e4;
              null != t2 && t2.state && (null === (e4 = this.onDTLSTransportStateChange) || void 0 === e4 || e4.call(this, t2.state));
            }, t2.onerror = (e4) => {
              var t3;
              null === (t3 = this.onDTLSTransportError) || void 0 === t3 || t3.call(this, "error" in e4 ? e4.error : e4);
            };
            const i3 = t2.iceTransport;
            i3 && (i3.onstatechange = () => {
              const e4 = null == t2 ? void 0 : t2.iceTransport.state;
              var i4;
              e4 && (null === (i4 = this.onICETransportStateChange) || void 0 === i4 || i4.call(this, e4));
            }, i3.getSelectedCandidatePair && (i3.onselectedcandidatepairchange = () => {
              if (i3.getSelectedCandidatePair()) {
                const { local: e4, remote: t3 } = i3.getSelectedCandidatePair();
                BN.info("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] selectedcandidatepairchange: local ").concat(JSON.stringify({ candidateType: e4.type, protocol: e4.protocol }), ", remote ").concat(JSON.stringify({ candidateType: t3.type, protocol: t3.protocol, address: t3.address, port: t3.port }), " )"));
              }
            }));
          }
        }
        tryUnbindTransportEvents() {
          this.transportEventReceiver && this.transportEventReceiver.transport && (this.transportEventReceiver.transport.onstatechange = null, this.transportEventReceiver.transport.onerror = null, this.transportEventReceiver.transport.iceTransport && (this.transportEventReceiver.transport.iceTransport.onstatechange = null));
        }
        async updateRtpSenderEncodings(e3, t2) {
          var i3, n2;
          if (!t2) {
            const i4 = this.peerConnection.getSenders();
            t2 = i4.find((t3) => t3.track === e3._mediaStreamTrack);
          }
          if (!t2)
            return BN.warn("[".concat(e3.getTrackId(), "] no rtpSender found}"));
          if (this.isVP8Simulcast(e3))
            return BN.warn("[updateRtpSenderEncodings] Track is VP8 simulcast, please apply simulcast encodings");
          if (!QN().supportSetRtpSenderParameters)
            return BN.warn("[updateRtpSenderEncodings] Browser not support set rtp-sender parameters");
          const r2 = {}, o2 = {};
          switch (e3._optimizationMode) {
            case "motion":
              r2.degradationPreference = "maintain-framerate";
              break;
            case "detail":
              r2.degradationPreference = "maintain-resolution";
              break;
            case "balanced":
              r2.degradationPreference = "balanced";
          }
          const s2 = function(e4, t3) {
            return e4.getTransceivers().find((e5) => e5.sender.track === t3 || e5.receiver.track === t3);
          }(this.peerConnection, e3._mediaStreamTrack), a2 = wP(e3);
          if (nF(e3) && s2 && t2 && a2 && this.getLocalVideoStats && Dn(i3 = ["vp8", "vp9"]).call(i3, this.store.codec)) {
            var c2;
            const i4 = r2.degradationPreference || (Dn(c2 = e3._hints).call(c2, fD.CUSTOM_TRACK) ? dN("CUSTOM_ADAPTATION_DEFAULT_MODE") : "maintain-framerate");
            !function(e4, t3, i5, n3, r3, o3) {
              if (oF(e4, i5), r3(t3), "balanced" !== n3 && "maintain-framerate" !== n3 && "maintain-resolution" !== n3)
                return;
              let s3 = -1;
              ZV(e4, t3);
              const a3 = window.setInterval(() => {
                const a4 = rF.get(e4);
                if (!dN("ENABLE_AG_ADAPTATION") || !a4)
                  return oF(e4, i5), void r3(t3);
                const c4 = o3();
                if (c4.sendPackets > 0 && c4.OutgoingAvailableBandwidth > 0) {
                  if (-1 === s3)
                    return void (s3 = Date.now());
                  if (Date.now() - s3 < 1e3)
                    return;
                  const o4 = c4.sendFrameRate, d3 = c4.OutgoingAvailableBandwidth, [l3, u3] = eF(e4, o4, d3, a4.adaptationConfig, t3, n3);
                  u3 && (i5.qualityLimitationReason = u3), l3 && a4.adaptationConfig.scale !== l3.scale && (BN.debug("[".concat(e4, "] applyAdaptation: ").concat(i5.qualityLimitationReason, "\n           sendFps ").concat(o4, ", bwe ").concat(d3, ", switch from ").concat(a4.adaptationConfig.scale, " to ").concat(l3.scale, " ")), a4.adaptationConfig = iF(iF({}, a4.adaptationConfig), l3), r3(l3));
                }
              }, dN("CHECK_LOCAL_STATS_INTERVAL")), c3 = iF({}, t3);
              rF.set(e4, { timer: a3, adaptationConfig: c3, originConfig: t3, adaptationFunc: r3 }), BN.debug("[".concat(e4, "] start adaptation, originConfig: ").concat(JSON.stringify(t3), ", degradationPreference: ").concat(n3));
            }(this.id + s2.mid, a2, this, i4, (e4) => {
              t2 && this.updateAdaptation(t2, e4);
            }, this.getLocalVideoStats.bind(this));
          }
          if (e3._encoderConfig) {
            var d2;
            const { bitrateMax: t3, frameRate: i4, scaleResolutionDownBy: n3 } = e3._encoderConfig;
            t3 && (o2.maxBitrate = 1e3 * t3), (Dn(d2 = e3._hints).call(d2, fD.LOW_STREAM) || e3.isUseScaleResolutionDownBy) && (i4 && (o2.maxFramerate = ZU(i4)), n3 && n3 >= 1 && (o2.scaleResolutionDownBy = n3));
          }
          const { maxFramerate: l2 } = dN("ENCODER_CONFIG_LIMIT");
          if (l2 && "number" == typeof l2 && (o2.maxFramerate = o2.maxFramerate ? Math.min(o2.maxFramerate, l2) : l2), dN("DSCP_TYPE") && cw()) {
            var u2;
            const e4 = dN("DSCP_TYPE");
            Dn(u2 = ["very-low", "low", "medium", "high"]).call(u2, e4) && (o2.networkPriority = e4);
          }
          const h2 = t2.getParameters(), p3 = null === (n2 = h2.encodings) || void 0 === n2 ? void 0 : n2[0];
          Kb() && !p3 && (r2.encodings = [o2]), p3 && Object.assign(p3, o2), Object.assign(h2, r2), BN.debug("[".concat(e3.getTrackId(), "] updateRtpSenderEncodings: ").concat(JSON.stringify(h2.encodings))), await t2.setParameters(h2), await async function(e4, t3, i4) {
            try {
              var n3;
              if (!QN().supportSetRtpSenderParameters)
                return;
              if (!function(e5) {
                return "vp9" === e5 || "av1" === e5;
              }(e4) || !dN("ENABLE_SVC"))
                return;
              const r3 = {}, o3 = {}, s3 = t3.getParameters(), a3 = null === (n3 = s3.encodings) || void 0 === n3 ? void 0 : n3[0];
              o3.scalabilityMode = ox(i4), a3 && Object.assign(a3, o3), Object.assign(s3, r3), await t3.setParameters(s3), BN.debug("[updateAdaptation] updateRtpSenderEncodings scalabilityMode success: ".concat(JSON.stringify(s3.encodings)));
            } catch (e5) {
              BN.debug("[updateAdaptation] updateRtpSenderEncodings scalabilityMode failed", e5);
            }
          }(this.store.codec, t2, dN("SVC_MODE"));
        }
        async updateAdaptation(e3, t2) {
          var i3, n2;
          if (!e3)
            return BN.debug("[updateAdaptation] no rtpSender found");
          if (!QN().supportSetRtpSenderParameters)
            return BN.debug("[updateAdaptation] Browser not support set rtp-sender parameters");
          const r2 = {}, { bitrateMax: o2, frameRate: s2, scaleResolutionDownBy: a2 } = t2;
          o2 && (r2.maxBitrate = 1e3 * o2), s2 && (r2.maxFramerate = ZU(s2)), a2 && a2 >= 1 && Dn(i3 = ["vp8", "vp9"]).call(i3, this.store.codec) && (r2.scaleResolutionDownBy = a2);
          const c2 = e3.getParameters(), d2 = null === (n2 = c2.encodings) || void 0 === n2 ? void 0 : n2[0];
          d2 && Object.assign(d2, r2), Object.assign(c2, {});
          try {
            await e3.setParameters(c2), BN.debug("[updateAdaptation] updateRtpSenderEncodings: ".concat(JSON.stringify(c2.encodings)));
          } catch (t3) {
            !("transport" in e3) || e3.transport && "connected" === e3.transport.state ? "connected" !== this.peerConnectionState ? BN.debug("[updateAdaptation] peerConnection not connected}") : BN.debug("[updateAdaptation] updateRtpSenderEncodings failed", t3) : BN.debug("[updateAdaptation] rtpSender transport not connected}");
          }
        }
        async applySendEncodings(e3, t2) {
          try {
            if (!QN().supportSetRtpSenderParameters)
              return;
            if (e3.length !== t2.length)
              return;
            for (let i3 = 0; i3 < e3.length; i3++) {
              const n2 = e3[i3], r2 = t2[i3];
              r2 instanceof ak && !this.isVP8Simulcast(r2) && await this.updateRtpSenderEncodings(r2, n2.sender);
            }
          } catch (e4) {
            BN.debug("[".concat(this.store.clientId, "] Apply RTPSendEncodings failed."));
          }
        }
        mungSendOfferSDP(e3, t2, i3) {
          const n2 = SN(e3);
          return t2.forEach((e4, t3) => {
            const r2 = i3[t3], o2 = n2.mediaDescriptions.find((e5) => e5.attributes.mid === r2);
            o2 && (Sx(o2, e4), Ix(o2, e4, this.store.codec));
          }), gN(n2);
        }
        bindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = (e3) => {
            var t2;
            null === (t2 = this.onFirstAudioReceived) || void 0 === t2 || t2.call(this, e3);
          }, this.statsFilter.onFirstVideoReceived = (e3) => {
            var t2;
            null === (t2 = this.onFirstVideoReceived) || void 0 === t2 || t2.call(this, e3);
          }, this.statsFilter.onFirstAudioDecoded = (e3) => {
            var t2;
            null === (t2 = this.onFirstAudioDecoded) || void 0 === t2 || t2.call(this, e3);
          }, this.statsFilter.onFirstVideoDecoded = (e3, t2, i3) => {
            var n2;
            null === (n2 = this.onFirstVideoDecoded) || void 0 === n2 || n2.call(this, e3, t2, i3);
          }, this.statsFilter.onSelectedLocalCandidateChanged = (e3, t2) => {
            var i3;
            null === (i3 = this.onSelectedLocalCandidateChanged) || void 0 === i3 || i3.call(this, e3, t2);
          }, this.statsFilter.onSelectedRemoteCandidateChanged = (e3, t2) => {
            var i3;
            null === (i3 = this.onSelectedRemoteCandidateChanged) || void 0 === i3 || i3.call(this, e3, t2);
          }, this.statsFilter.onFirstVideoDecodedTimeout = (e3) => {
            var t2;
            null === (t2 = this.onFirstVideoDecodedTimeout) || void 0 === t2 || t2.call(this, e3);
          };
        }
        unbindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0, this.statsFilter.onFirstVideoDecodedTimeout = void 0;
        }
        async applySimulcastForFirefox(e3, t2) {
          if (e3.length === t2.length)
            for (let a2 = 0; a2 < e3.length; a2++) {
              var i3, n2, r2, o2, s2;
              const c2 = e3[a2], d2 = t2[a2];
              if (d2 instanceof ak && !Dn(i3 = d2._hints).call(i3, fD.LOW_STREAM) && null !== (n2 = d2._encoderConfig) && void 0 !== n2 && n2.bitrateMax && (null === (r2 = d2._encoderConfig) || void 0 === r2 ? void 0 : r2.bitrateMax) > 200 && null !== (o2 = d2._scalabilityMode) && void 0 !== o2 && o2.numSpatialLayers && (null === (s2 = d2._scalabilityMode) || void 0 === s2 ? void 0 : s2.numSpatialLayers) > 1 && "vp8" === this.store.codec) {
                const e4 = {}, t3 = { high: 1e3 * (d2._encoderConfig.bitrateMax - 50), medium: 5e4 };
                e4.encodings = [{ rid: "m", active: true, maxBitrate: t3.medium, scaleResolutionDownBy: 4 }, { rid: "h", active: true, maxBitrate: t3.high }];
                const i4 = c2.sender.getParameters();
                await c2.sender.setParameters(Object.assign(i4, e4));
              }
            }
        }
        async applySimulcastEncodings(e3, t2) {
          if (!Kb() && e3.length === t2.length)
            for (let i3 = 0; i3 < e3.length; i3++) {
              const n2 = t2[i3];
              if (n2 instanceof ak && this.isVP8Simulcast(n2)) {
                const t3 = e3[i3], r2 = {}, o2 = { high: 1e3 * (n2._encoderConfig.bitrateMax - 50), medium: 5e4 };
                r2.encodings = [{ active: true, adaptivePtime: false, networkPriority: "high", priority: "high", maxBitrate: o2.high }, { active: true, adaptivePtime: false, networkPriority: "low", priority: "low", maxBitrate: o2.medium, scaleResolutionDownBy: 4 }];
                const s2 = t3.sender.getParameters();
                await t3.sender.setParameters(Object.assign(s2, r2));
              }
            }
        }
        isVP8Simulcast(e3) {
          var t2, i3, n2, r2, o2;
          return !!(e3 instanceof ak && dN("SIMULCAST") && "vp8" === this.store.codec && !Dn(t2 = e3._hints).call(t2, fD.LOW_STREAM) && null !== (i3 = e3._encoderConfig) && void 0 !== i3 && i3.bitrateMax && (null === (n2 = e3._encoderConfig) || void 0 === n2 ? void 0 : n2.bitrateMax) > 200 && null !== (r2 = e3._scalabilityMode) && void 0 !== r2 && r2.numSpatialLayers && (null === (o2 = e3._scalabilityMode) || void 0 === o2 ? void 0 : o2.numSpatialLayers) > 1);
        }
        logSDPExchange(e3, t2, i3, n2) {
          if (dN("SDP_LOGGING"))
            return BN.upload("[".concat(this.store.clientId, "] exchanging ").concat(i3, " ").concat(t2, " SDP during P2PConnection.").concat(n2, "\n"), e3), "offer" === t2 ? (e4) => {
              this.logSDPExchange(e4, "answer", "local" === i3 ? "remote" : "local", n2);
            } : void 0;
        }
        async getRemoteSSRC(e3) {
          if (!this.remoteSDP)
            return;
          const t2 = this.remoteSDP.getSSRC(e3);
          return t2 && 0 !== t2.length ? t2[0].ssrcId : void 0;
        }
        setConfiguration(t2) {
          if (QN().supportPCSetConfiguration) {
            const i3 = e2.resolvePCConfiguration(t2);
            this.peerConnection.setConfiguration(i3);
          }
        }
      }, IM(pF.prototype, "updateRemoteRTPCapabilities", [mF], Object.getOwnPropertyDescriptor(pF.prototype, "updateRemoteRTPCapabilities"), pF.prototype), IM(pF.prototype, "connect", [mF], Object.getOwnPropertyDescriptor(pF.prototype, "connect"), pF.prototype), IM(pF.prototype, "updateRemoteConnect", [mF], Object.getOwnPropertyDescriptor(pF.prototype, "updateRemoteConnect"), pF.prototype), IM(pF.prototype, "createDataChannels", [mF], Object.getOwnPropertyDescriptor(pF.prototype, "createDataChannels"), pF.prototype), IM(pF.prototype, "receive", [mF], Object.getOwnPropertyDescriptor(pF.prototype, "receive"), pF.prototype), IM(pF.prototype, "batchReceive", [mF], Object.getOwnPropertyDescriptor(pF.prototype, "batchReceive"), pF.prototype), IM(pF.prototype, "stopReceiving", [mF], Object.getOwnPropertyDescriptor(pF.prototype, "stopReceiving"), pF.prototype), IM(pF.prototype, "muteRemote", [mF], Object.getOwnPropertyDescriptor(pF.prototype, "muteRemote"), pF.prototype), IM(pF.prototype, "unmuteRemote", [mF], Object.getOwnPropertyDescriptor(pF.prototype, "unmuteRemote"), pF.prototype), IM(pF.prototype, "muteLocal", [mF], Object.getOwnPropertyDescriptor(pF.prototype, "muteLocal"), pF.prototype), IM(pF.prototype, "unmuteLocal", [mF], Object.getOwnPropertyDescriptor(pF.prototype, "unmuteLocal"), pF.prototype), IM(pF.prototype, "close", [mF], Object.getOwnPropertyDescriptor(pF.prototype, "close"), pF.prototype), IM(pF.prototype, "updateEncoderConfig", [mF], Object.getOwnPropertyDescriptor(pF.prototype, "updateEncoderConfig"), pF.prototype), IM(pF.prototype, "updateSendParameters", [mF], Object.getOwnPropertyDescriptor(pF.prototype, "updateSendParameters"), pF.prototype), IM(pF.prototype, "replaceTrack", [mF], Object.getOwnPropertyDescriptor(pF.prototype, "replaceTrack"), pF.prototype), IM(pF.prototype, "updateAdaptation", [mF], Object.getOwnPropertyDescriptor(pF.prototype, "updateAdaptation"), pF.prototype), IM(pF.prototype, "getRemoteSSRC", [mF], Object.getOwnPropertyDescriptor(pF.prototype, "getRemoteSSRC"), pF.prototype), pF);
      function mF(e2, t2, i3) {
        const n2 = e2[t2];
        if ("function" != typeof n2)
          throw new Error("Cannot use mutex on object property.");
        return i3.value = async function() {
          const e3 = this.mutex, i4 = await e3.lock("From P2PConnection.".concat(t2));
          try {
            for (var r2 = arguments.length, o2 = new Array(r2), s2 = 0; s2 < r2; s2++)
              o2[s2] = arguments[s2];
            return await n2.apply(this, o2);
          } finally {
            i4();
          }
        }, i3;
      }
      function TF(e2, t2) {
        let i3 = document.createElement("video"), n2 = document.createElement("canvas");
        i3.setAttribute("style", "display:none"), n2.setAttribute("style", "display:none"), i3.setAttribute("muted", ""), i3.muted = true, i3.setAttribute("autoplay", ""), i3.autoplay = true, i3.setAttribute("playsinline", ""), n2.width = ZU(t2.width), n2.height = ZU(t2.height);
        const r2 = ZU(t2.framerate || 15);
        document.body.append(i3), document.body.append(n2);
        let o2 = e2._mediaStreamTrack;
        i3.srcObject = new MediaStream([o2]), i3.play();
        const s2 = n2.getContext("2d");
        if (!s2)
          throw new XN(_w.UNEXPECTED_ERROR, "can not get canvas context");
        const a2 = QN(), c2 = n2.captureStream(a2.supportRequestFrame ? 0 : r2).getVideoTracks()[0];
        c2.canvas || (c2.canvas = n2), n2.startCapture = () => {
          if (!i3)
            return n2.stopCapture && n2.stopCapture();
          if (i3.paused && i3.play(), i3.videoHeight > 2 && i3.videoWidth > 2) {
            const e3 = i3.videoWidth, t3 = i3.videoHeight / e3, r3 = n2.width * t3;
            Math.abs(r3 - n2.height) >= 2 && (BN.debug("adjust low stream resolution", "".concat(n2.width, "x").concat(n2.height, " -> ").concat(n2.width, "x").concat(r3)), n2.height = r3);
          }
          s2.drawImage(i3, 0, 0, n2.width, n2.height), c2.requestFrame && c2.requestFrame(), o2 !== e2._mediaStreamTrack && (o2 = e2._mediaStreamTrack, i3.srcObject = new MediaStream([o2]));
        }, n2.stopCapture = JD(() => n2.startCapture && n2.startCapture(), r2);
        const d2 = c2.stop;
        return c2.stop = () => {
          d2.call(c2), i3 && (i3.remove(), i3.srcObject = null, i3 = null), n2 && (n2.width = 0, n2.remove(), n2.stopCapture && n2.stopCapture(), n2.startCapture = void 0, n2.stopCapture = void 0, n2 = null), BN.debug("clean low stream renderer");
        }, c2;
      }
      var SF = function(e2) {
        return e2[e2.HEIGHT = 2033] = "HEIGHT", e2[e2.FRAME_RATE = 2034] = "FRAME_RATE", e2[e2.WIDTH = 2035] = "WIDTH", e2;
      }(SF || {}), gF = function(e2) {
        return e2[e2.FRAME_RATE = 2002] = "FRAME_RATE", e2[e2.WIDTH = 2003] = "WIDTH", e2[e2.HEIGHT = 2004] = "HEIGHT", e2[e2.PACKAGE_LOST = 2005] = "PACKAGE_LOST", e2[e2.AVG_ENCODE = 2007] = "AVG_ENCODE", e2[e2.NACKS = 2009] = "NACKS", e2[e2.PLIS = 2010] = "PLIS", e2[e2.FIRS = 2011] = "FIRS", e2[e2.BITRATE = 2012] = "BITRATE", e2[e2.PACKAGE_RATE = 2031] = "PACKAGE_RATE", e2[e2.ADAPTATION = 2032] = "ADAPTATION", e2[e2.ACTUAL_ENCODED = 2060] = "ACTUAL_ENCODED", e2[e2.BANDWIDTH = 2061] = "BANDWIDTH", e2[e2.RETRANSMIT = 2062] = "RETRANSMIT", e2[e2.TARGET_ENCODED = 2064] = "TARGET_ENCODED", e2[e2.TRANSMIT = 2066] = "TRANSMIT", e2[e2.FREEZE = 2082] = "FREEZE", e2[e2.DISABLED = 2095] = "DISABLED", e2[e2.PLAYER_STATUS = 2128] = "PLAYER_STATUS", e2[e2.QP_SUM = 2143] = "QP_SUM", e2[e2.BYTES_RETRANSMIT = 2173] = "BYTES_RETRANSMIT", e2[e2.PACKAGES_RETRANSMIT = 2172] = "PACKAGES_RETRANSMIT", e2[e2.HUGE_FRAME_SENT = 2174] = "HUGE_FRAME_SENT", e2[e2.KEY_FRAMES_ENCODED = 2207] = "KEY_FRAMES_ENCODED", e2;
      }(gF || {}), RF = function(e2) {
        return e2[e2.BITRATE = 2069] = "BITRATE", e2[e2.PACKAGE_LOST = 2070] = "PACKAGE_LOST", e2[e2.PACKAGE_RATE = 2071] = "PACKAGE_RATE", e2[e2.HEIGHT = 2073] = "HEIGHT", e2[e2.FRAME_RATE = 2075] = "FRAME_RATE", e2[e2.WIDTH = 2077] = "WIDTH", e2;
      }(RF || {}), CF = function(e2) {
        return e2[e2.JITTER = -1] = "JITTER", e2[e2.PACKAGE_LOST = 2014] = "PACKAGE_LOST", e2[e2.WIDTH = 2018] = "WIDTH", e2[e2.HEIGHT = 2019] = "HEIGHT", e2[e2.FRAME_RATE = 2020] = "FRAME_RATE", e2[e2.JITTER_BUFFER = 2023] = "JITTER_BUFFER", e2[e2.CURRENT_DELAY = 2024] = "CURRENT_DELAY", e2[e2.NACKS = 2026] = "NACKS", e2[e2.PLIS = 2027] = "PLIS", e2[e2.FIRS = 2028] = "FIRS", e2[e2.BITRATE = 2029] = "BITRATE", e2[e2.PACKAGE_RATE = 2078] = "PACKAGE_RATE", e2[e2.FREEZE = 2084] = "FREEZE", e2[e2.DISABLED = 2101] = "DISABLED", e2[e2.PLAYER_STATUS = 2129] = "PLAYER_STATUS", e2[e2.QP_SUM = 2144] = "QP_SUM", e2[e2.I_FRAME_DELAY = 2149] = "I_FRAME_DELAY", e2[e2.FRAMES_DROPPED = 2181] = "FRAMES_DROPPED", e2[e2.BYTES_RETRANSMIT = 2175] = "BYTES_RETRANSMIT", e2[e2.PACKAGES_RETRANSMIT = 2176] = "PACKAGES_RETRANSMIT", e2[e2.PACKAGES_DISCARDED = 2198] = "PACKAGES_DISCARDED", e2[e2.AVG_DECODE = 2200] = "AVG_DECODE", e2[e2.AVG_PROCESSING_DELAY = 2202] = "AVG_PROCESSING_DELAY", e2[e2.AVG_ASSEMBLY_TIME = 2203] = "AVG_ASSEMBLY_TIME", e2[e2.AVG_INTER_FRAME_DELAY = 2204] = "AVG_INTER_FRAME_DELAY", e2[e2.KEY_FRAMES_DECODED = 2206] = "KEY_FRAMES_DECODED", e2;
      }(CF || {}), vF = function(e2) {
        return e2[e2.FRAME_RATE_DECODE = 2021] = "FRAME_RATE_DECODE", e2[e2.FRAME_RATE_RENDER = 2022] = "FRAME_RATE_RENDER", e2[e2.FRAME_RATE_OUTPUT = 2155] = "FRAME_RATE_OUTPUT", e2[e2.FREEZE_TIME = 2109] = "FREEZE_TIME", e2[e2.FREEZE_TIME_RENDER = 2147] = "FREEZE_TIME_RENDER", e2[e2.FREEZE_DURATION = 2156] = "FREEZE_DURATION", e2;
      }(vF || {}), IF = function(e2) {
        return e2[e2.PCM_LEVEL = 2104] = "PCM_LEVEL", e2;
      }(IF || {}), yF = function(e2) {
        return e2[e2.PACKAGE_LOST = -1] = "PACKAGE_LOST", e2[e2.LEVEL = 2038] = "LEVEL", e2[e2.BITRATE = 2039] = "BITRATE", e2[e2.PACKAGE_RATE = 2040] = "PACKAGE_RATE", e2[e2.AEC_RETURN_LOSS = 2041] = "AEC_RETURN_LOSS", e2[e2.AEC_RETURN_LOSS_ENH = 2042] = "AEC_RETURN_LOSS_ENH", e2[e2.FREEZE = 2081] = "FREEZE", e2[e2.DISABLED = 2096] = "DISABLED", e2[e2.BYTES_RETRANSMIT = 2179] = "BYTES_RETRANSMIT", e2[e2.PACKAGES_RETRANSMIT = 2180] = "PACKAGES_RETRANSMIT", e2;
      }(yF || {}), AF = function(e2) {
        return e2[e2.BITRATE = 2044] = "BITRATE", e2[e2.PACKAGE_LOST = 2045] = "PACKAGE_LOST", e2[e2.PACKAGE_RATE = 2046] = "PACKAGE_RATE", e2[e2.CURRENT_DELAY = 2047] = "CURRENT_DELAY", e2[e2.JITTER_BUFFER = 2054] = "JITTER_BUFFER", e2[e2.JITTER = 2055] = "JITTER", e2[e2.FREEZE = 2083] = "FREEZE", e2[e2.DISABLED = 2102] = "DISABLED", e2[e2.PCM_LEVEL = 2105] = "PCM_LEVEL", e2[e2.PLAYER_STATUS = 2130] = "PLAYER_STATUS", e2[e2.CONCEALED_SAMPLES = 2148] = "CONCEALED_SAMPLES", e2[e2.BYTES_RETRANSMIT = 2178] = "BYTES_RETRANSMIT", e2[e2.PACKAGES_RETRANSMIT = 2177] = "PACKAGES_RETRANSMIT", e2[e2.PACKAGES_DISCARDED = 2199] = "PACKAGES_DISCARDED", e2[e2.AVG_PROCESSING_DELAY = 2201] = "AVG_PROCESSING_DELAY", e2;
      }(AF || {}), bF = function(e2) {
        return e2[e2.FREEZE_TIME = -1] = "FREEZE_TIME", e2[e2.LEVEL = 2043] = "LEVEL", e2;
      }(bF || {}), wF = function(e2) {
        return e2[e2.RTT = 2006] = "RTT", e2[e2.CONN_TYPE = 801] = "CONN_TYPE", e2[e2.STATS_UPDATE_INTERVAL = 2205] = "STATS_UPDATE_INTERVAL", e2;
      }(wF || {}), OF = function(e2) {
        return e2[e2.RTC_PEER_CONNECTION_STATE = 2219] = "RTC_PEER_CONNECTION_STATE", e2;
      }(OF || {});
      const NF = 1e3, DF = 6, PF = 3, LF = Math.max(DF, PF);
      function kF(e2, t2, i3) {
        null != i3 && Number.isFinite(i3) && (e2[t2] = Math.round(Math.max(0, i3)));
      }
      function MF(e2) {
        const t2 = { [wF.CONN_TYPE]: 0, [wF.RTT]: e2.rtt, [wF.STATS_UPDATE_INTERVAL]: e2.updateInterval ? Math.round(Math.max(0, e2.updateInterval)) : void 0 };
        switch (e2.selectedCandidatePair.localCandidate.candidateType) {
          case "relay": {
            const i3 = e2.selectedCandidatePair.localCandidate.relayProtocol;
            "udp" === i3 && (t2[wF.CONN_TYPE] = 1), "tcp" === i3 && (t2[wF.CONN_TYPE] = 3), "tls" === i3 && (t2[wF.CONN_TYPE] = 4);
            break;
          }
          case "srflx":
            t2[wF.CONN_TYPE] = 2;
            break;
          case "unknown":
            t2[wF.CONN_TYPE] = 5;
            break;
          default:
            t2[wF.CONN_TYPE] = 0;
        }
        return t2;
      }
      function UF(e2) {
        let t2 = 0;
        switch (e2) {
          case "none":
            t2 = 0;
            break;
          case "cpu":
            t2 = 1;
            break;
          case "bandwidth":
            t2 = 2;
            break;
          case "other":
            t2 = 3;
        }
        return t2;
      }
      class xF extends Nw {
        constructor(e2) {
          super(), QI(this, "store", void 0), QI(this, "uploadWRTCStatsTimer", void 0), QI(this, "uploadOutboundDenoiserStatsTimer", void 0), QI(this, "uploadExtStatsTimer", void 0), QI(this, "uploadExtUsageStatsTimer", void 0), QI(this, "uploadInboundExtStatsTimer", void 0), QI(this, "requestStats", void 0), QI(this, "requestTransportStats", void 0), QI(this, "requestLocalMedia", void 0), QI(this, "requestRemoteMedia", void 0), QI(this, "requestAllTracks", void 0), QI(this, "requestVideoIsReady", void 0), QI(this, "requestUploadStats", void 0), QI(this, "requestUpload", void 0), QI(this, "uploadOutboundStarted", false), QI(this, "uploadInboundStarted", false), QI(this, "uploadTransportStarted", false), QI(this, "uploadBaseStatsStarted", false), QI(this, "uploadExtensionUsageStarted", false), QI(this, "lastRecvStats", void 0), QI(this, "lastSendStats", void 0), QI(this, "lastRefRecvStats", void 0), QI(this, "lastRefSendStats", void 0), QI(this, "lastFullRecvStats", void 0), QI(this, "lastFullSendStats", void 0), QI(this, "needUploadRenderFreezeTime", true), this.store = e2;
        }
        uploadWRTCStats(e2) {
          if (!this.requestStats || !this.requestUploadStats)
            return;
          const t2 = e2 % PF == 0, i3 = e2 % DF == 0;
          let n2, r2;
          if (this.uploadTransportStarted && (n2 = this.requestStats(), this.store.useP2P && (r2 = this.requestStats(true))), !n2 && this.uploadOutboundStarted && (n2 = this.requestStats()), !r2 && this.uploadInboundStarted && (r2 = this.requestStats(true)), n2 || r2) {
            var o2;
            const e3 = {};
            if (this.uploadTransportStarted && n2) {
              const i4 = this.getTransportStats(n2, r2, t2);
              i4 && (e3.misc = [i4]);
            }
            if (this.uploadOutboundStarted && n2) {
              const r3 = this.getOutboundStats(n2, i3 ? this.lastFullSendStats : t2 ? this.lastRefSendStats : this.lastSendStats, t2, i3);
              r3 && (e3.outbound = [r3]);
            }
            if (this.uploadInboundStarted && r2) {
              const n3 = this.getInboundStats(r2, i3 ? this.lastFullRecvStats : t2 ? this.lastRefRecvStats : this.lastRecvStats, t2, i3);
              n3 && (e3.inbound = n3);
            }
            const s2 = null === (o2 = this.requestTransportStats) || void 0 === o2 ? void 0 : o2.call(this).connectState;
            s2 && (Array.isArray(e3.misc) ? e3.misc[0] && e3.misc[0].addition && (e3.misc[0].addition[OF.RTC_PEER_CONNECTION_STATE] = zO[s2]) : e3.misc = [{ addition: { [OF.RTC_PEER_CONNECTION_STATE]: zO[s2] } }]), this.requestUploadStats(e3);
          }
          this.lastRecvStats = r2, this.lastSendStats = n2, i3 && (this.lastFullRecvStats = r2, this.lastFullSendStats = n2), t2 && (this.lastRefRecvStats = r2, this.lastRefSendStats = n2);
        }
        startUploadWRTCStats() {
          if (this.uploadWRTCStatsTimer)
            return;
          this.uploadBaseStatsStarted = true;
          let e2 = 1;
          this.uploadWRTCStatsTimer = window.setInterval(() => {
            if (!this.uploadTransportStarted && !this.uploadInboundStarted && !this.uploadOutboundStarted) {
              if (this.uploadBaseStatsStarted) {
                var t2, i3;
                const e3 = null === (t2 = this.requestTransportStats) || void 0 === t2 ? void 0 : t2.call(this);
                return void (e3 && (null === (i3 = this.requestUploadStats) || void 0 === i3 || i3.call(this, { misc: [{ addition: { [OF.RTC_PEER_CONNECTION_STATE]: zO[e3.connectState] } }] })));
              }
              return this.stopUploadWRTCStats();
            }
            this.uploadWRTCStats(e2), ++e2 === LF + 1 && (e2 = 1);
          }, NF);
        }
        stopUploadWRTCStats() {
          window.clearInterval(this.uploadWRTCStatsTimer), this.uploadWRTCStatsTimer = void 0, this.lastSendStats && (this.lastSendStats.videoSend = [], this.lastSendStats.audioSend = [], this.lastSendStats = void 0), this.lastRecvStats && (this.lastRecvStats.videoRecv = [], this.lastRecvStats.audioRecv = [], this.lastRecvStats = void 0);
        }
        getTransportStats(e2, t2, i3) {
          if (!this.requestStats)
            return;
          if (!i3)
            return null == e2.rtt ? void 0 : { addition: { [wF.RTT]: e2.rtt, [wF.CONN_TYPE]: void 0, [wF.STATS_UPDATE_INTERVAL]: e2.updateInterval || void 0 } };
          const n2 = MF(e2);
          if (this.store.useP2P) {
            if (t2) {
              const e3 = MF(t2);
              n2[wF.CONN_TYPE] += e3[wF.CONN_TYPE] << 3;
            }
            n2[wF.CONN_TYPE] += 110;
          } else
            n2[wF.CONN_TYPE] += 100;
          return { addition: n2 };
        }
        getOutboundStats(e2, t2, i3, n2) {
          if (!this.requestUploadStats || !this.requestLocalMedia)
            return;
          const r2 = this.requestLocalMedia();
          if (!r2 || 0 === r2.length)
            return;
          let o2, s2, a2;
          return r2.forEach((r3) => {
            let [c2, { track: d2, ssrcs: l2 }] = r3;
            switch (c2) {
              case _U.LocalVideoLowTrack:
              case _U.LocalVideoTrack:
                if (c2 === _U.LocalVideoTrack) {
                  const r4 = function(e3, t3, i4, n3, r5, o4) {
                    const s3 = t3.videoSend.find((t4) => t4.ssrc === e3);
                    if (!s3)
                      return;
                    const a4 = {}, { sentFrame: c3, inputFrame: d3 } = s3;
                    if (o4 && (kF(a4, gF.QP_SUM, s3.qpSumPerFrame), d3 && c3)) {
                      const e4 = d3.frameRate, t4 = c3.frameRate;
                      a4[gF.FREEZE] = function(e5, t5) {
                        let i5 = true;
                        return i5 = !(e5 <= 5) && (e5 <= 10 ? t5 < 3 : e5 <= 20 ? t5 < 4 : t5 < 5), i5;
                      }(e4, t4) ? 1 : 0;
                    }
                    if (r5) {
                      switch (c3 && (kF(a4, gF.HEIGHT, c3.height), kF(a4, gF.WIDTH, c3.width), kF(a4, gF.FRAME_RATE, c3.frameRate)), a4[gF.DISABLED] = n3._originMediaStreamTrack && !n3._originMediaStreamTrack.enabled || n3._mediaStreamTrack && !n3._mediaStreamTrack.enabled ? 1 : 0, s3.adaptionChangeReason) {
                        case "none":
                          a4[gF.ADAPTATION] = 0;
                          break;
                        case "cpu":
                          a4[gF.ADAPTATION] = 1;
                          break;
                        case "bandwidth":
                          a4[gF.ADAPTATION] = 2;
                          break;
                        case "other":
                          a4[gF.ADAPTATION] = 3;
                      }
                      let o5 = 0;
                      s3.adaptionChangeReason && (o5 += UF(s3.adaptionChangeReason)), t3.qualityLimitationReason && (o5 += UF(t3.qualityLimitationReason) << 3), a4[gF.ADAPTATION] = o5, a4[gF.PLAYER_STATUS] = UD[n3._player ? n3._player.videoElementStatus : "uninit"], kF(a4, gF.NACKS, s3.nacksCount), kF(a4, gF.PLIS, s3.plisCount), kF(a4, gF.FIRS, s3.firsCount), kF(a4, gF.AVG_ENCODE, s3.avgEncodeMs), kF(a4, gF.HUGE_FRAME_SENT, s3.hugeFramesSent), kF(a4, gF.BYTES_RETRANSMIT, s3.retransmittedBytesSent), kF(a4, gF.PACKAGES_RETRANSMIT, s3.retransmittedPacketsSent), kF(a4, gF.KEY_FRAMES_ENCODED, s3.keyFramesEncoded);
                      const d4 = i4 && i4.videoSend.find((t4) => t4.ssrc === e3);
                      if (d4) {
                        let e4 = r5 ? NF : NF * DF;
                        d4.timestamp && s3.timestamp && (e4 = s3.timestamp - d4.timestamp), null != d4.packets && null != s3.packets && kF(a4, gF.PACKAGE_RATE, 1e3 * (s3.packets - d4.packets) / e4), null != s3.packetsLost && null != d4.packetsLost && kF(a4, gF.PACKAGE_LOST, s3.packetsLost - d4.packetsLost), null != d4.bytes && null != s3.bytes && kF(a4, gF.BITRATE, 8 * (s3.bytes - d4.bytes) / e4);
                      }
                    }
                    return a4;
                  }(l2[0].ssrcId, e2, t2, d2, i3, n2), o3 = d2 && function(e3, t3, i4, n3) {
                    const r5 = t3.videoSend.find((t4) => t4.ssrc === e3);
                    if (!r5)
                      return null;
                    const o4 = {};
                    if (n3) {
                      const e4 = r5.inputFrame, t4 = e4 && e4.height || i4.videoHeight || 0, n4 = e4 && e4.width || i4.videoWidth || 0, s3 = e4 && e4.frameRate || 0;
                      kF(o4, SF.HEIGHT, t4), kF(o4, SF.WIDTH, n4), kF(o4, SF.FRAME_RATE, s3);
                    }
                    return o4;
                  }(l2[0].ssrcId, e2, d2, i3), a3 = function(e3, t3) {
                    const i4 = {};
                    return t3 && (kF(i4, gF.RETRANSMIT, e3.bitrate.retransmit), kF(i4, gF.TARGET_ENCODED, e3.bitrate.targetEncoded), kF(i4, gF.ACTUAL_ENCODED, e3.bitrate.actualEncoded), kF(i4, gF.TRANSMIT, e3.bitrate.transmit), kF(i4, gF.BANDWIDTH, e3.sendBandwidth)), i4;
                  }(e2, i3);
                  s2 = Object.assign({}, r4, o3, a3);
                } else
                  a2 = function(e3, t3, i4, n3) {
                    const r4 = t3.videoSend.find((t4) => t4.ssrc === e3);
                    if (!r4)
                      return;
                    const o3 = {};
                    if (n3) {
                      const t4 = r4.sentFrame;
                      if (t4 && (kF(o3, RF.HEIGHT, t4.height), kF(o3, RF.WIDTH, t4.width), kF(o3, RF.FRAME_RATE, t4.frameRate)), i4) {
                        const t5 = i4.videoSend.find((t6) => t6.ssrc === e3);
                        if (t5) {
                          let e4 = NF * DF;
                          t5.timestamp && r4.timestamp && (e4 = r4.timestamp - t5.timestamp), null != t5.packets && null != r4.packets && kF(o3, RF.PACKAGE_RATE, 1e3 * (r4.packets - t5.packets) / e4), null != r4.packetsLost && null != t5.packetsLost && kF(o3, RF.PACKAGE_LOST, r4.packetsLost - t5.packetsLost), null != t5.bytes && null != r4.bytes && kF(o3, RF.BITRATE, 8 * (r4.bytes - t5.bytes) / e4);
                        }
                      }
                    }
                    return o3;
                  }(l2[0].ssrcId, e2, t2, i3);
                break;
              case _U.LocalAudioTrack:
                o2 = d2 && function(e3, t3, i4, n3, r4) {
                  const o3 = t3.audioSend.find((t4) => t4.ssrc === e3);
                  if (!o3)
                    return;
                  const s3 = {};
                  if (r4) {
                    s3[yF.DISABLED] = n3._originMediaStreamTrack && !n3._originMediaStreamTrack.enabled || n3._mediaStreamTrack && !n3._mediaStreamTrack.enabled ? 1 : 0;
                    const t4 = 100 * n3._source.getAccurateVolumeLevel(), r5 = o3.inputLevel;
                    if (null != r5) {
                      const e4 = Math.ceil(50 * Math.log10(100 * r5 + 1));
                      kF(s3, yF.LEVEL, e4);
                    }
                    kF(s3, IF.PCM_LEVEL, t4), kF(s3, yF.AEC_RETURN_LOSS, o3.aecReturnLoss), kF(s3, yF.AEC_RETURN_LOSS_ENH, o3.aecReturnLossEnhancement), kF(s3, yF.BYTES_RETRANSMIT, o3.retransmittedBytesSent), kF(s3, yF.PACKAGES_RETRANSMIT, o3.retransmittedPacketsSent), s3[yF.FREEZE] = 0;
                    const a3 = i4 && i4.audioSend.find((t5) => t5.ssrc === e3);
                    if (a3) {
                      let e4 = NF * DF;
                      a3.timestamp && o3.timestamp && (e4 = o3.timestamp - a3.timestamp), null != a3.bytes && null != o3.bytes && kF(s3, yF.BITRATE, 8 * (o3.bytes - a3.bytes) / e4), null != a3.packets && null != o3.packets && kF(s3, yF.PACKAGE_RATE, 1e3 * (o3.packets - a3.packets) / e4);
                    }
                  }
                  return s3;
                }(l2[0].ssrcId, e2, t2, d2, i3);
            }
          }), { high: s2, low: a2, audio: o2 };
        }
        getInboundStats(e2, t2, i3, n2) {
          if (!this.requestRemoteMedia)
            return;
          const r2 = this.requestRemoteMedia() || [], o2 = [];
          return r2.forEach((r3) => {
            let [s2, a2] = r3;
            const c2 = { peer: s2.uid };
            if (a2.has(lU.VIDEO) && s2.videoTrack) {
              const r4 = s2._videoSSRC && this.requestVideoIsReady && this.requestVideoIsReady(s2._videoSSRC) || false, o3 = s2.videoTrack ? function(e3, t3, i4, n3, r5, o4, s3, a3) {
                const c3 = t3.videoRecv.find((t4) => t4.ssrc === e3);
                if (!c3)
                  return;
                const d2 = {}, { receivedFrame: l2, outputFrame: u2, decodeFrameRate: h2 } = c3, p3 = i4 && i4.videoRecv.find((t4) => t4.ssrc === e3);
                if (kF(d2, vF.FRAME_RATE_DECODE, h2), c3.framesRateFirefox && kF(d2, CF.FRAME_RATE, c3.framesRateFirefox), l2 && kF(d2, CF.FRAME_RATE, l2.frameRate), kF(d2, CF.FRAMES_DROPPED, c3.framesDroppedCount), kF(d2, CF.BYTES_RETRANSMIT, c3.retransmittedBytesReceived), kF(d2, CF.PACKAGES_RETRANSMIT, c3.retransmittedPacketsReceived), kF(d2, CF.PACKAGES_DISCARDED, c3.packetsDiscarded), kF(d2, CF.AVG_DECODE, c3.avgDecodeMs), kF(d2, CF.AVG_PROCESSING_DELAY, c3.avgProcessingDelayMs), kF(d2, CF.AVG_ASSEMBLY_TIME, c3.avgFramesAssembledFromMultiplePacketsMs), kF(d2, CF.AVG_INTER_FRAME_DELAY, c3.avgInterFrameDelayMs), kF(d2, CF.KEY_FRAMES_DECODED, c3.keyFramesDecoded), p3) {
                  const e4 = t3.timestamp - i4.timestamp || NF * (a3 ? DF : s3 ? PF : 1);
                  null != c3.packetsLost && null != p3.packetsLost && kF(d2, CF.PACKAGE_LOST, c3.packetsLost - p3.packetsLost), null != p3.bytes && null != c3.bytes && kF(d2, CF.BITRATE, 8 * (c3.bytes - p3.bytes) / e4), null != p3.packets && null != c3.packets && kF(d2, CF.PACKAGE_RATE, 1e3 * (c3.packets - p3.packets) / e4);
                }
                if (a3 && (kF(d2, CF.QP_SUM, c3.qpSumPerFrame), d2[CF.FREEZE] = r5 && FV.isRemoteVideoFreeze(n3, c3, p3) ? 1 : 0), s3) {
                  var _2;
                  l2 ? (kF(d2, CF.HEIGHT, l2.height), kF(d2, CF.WIDTH, l2.width)) : n3 && (kF(d2, CF.HEIGHT, n3._videoHeight || 0), kF(d2, CF.WIDTH, n3._videoWidth || 0)), u2 && kF(d2, vF.FRAME_RATE_OUTPUT, u2.frameRate);
                  const e4 = null === (_2 = n3._player) || void 0 === _2 ? void 0 : _2.rendFrameRate.toFixed(0);
                  if (e4 && kF(d2, vF.FRAME_RATE_RENDER, +e4), kF(d2, CF.JITTER_BUFFER, c3.jitterBufferMs), kF(d2, CF.CURRENT_DELAY, c3.currentDelayMs), kF(d2, CF.FIRS, c3.firsCount), kF(d2, CF.NACKS, c3.nacksCount), kF(d2, CF.PLIS, c3.plisCount), n3) {
                    d2[CF.DISABLED] = n3._originMediaStreamTrack.enabled && n3._mediaStreamTrack.enabled ? 0 : 1;
                    const e5 = n3._player;
                    if (e5) {
                      const { freezeTimeCounterList: t4, renderFreezeAccTime: i5, videoElementStatus: n4 } = e5;
                      if (t4 && t4.length > 0 && kF(d2, vF.FREEZE_TIME, t4.splice(0, 1)[0]), o4 && "visible" === yk.visibility && n4 === kD.PLAYING && QN().supportRequestVideoFrameCallback) {
                        const t5 = Math.min(6e3, i5);
                        e5.renderFreezeAccTime = Math.max(0, i5 - t5), kF(d2, vF.FREEZE_TIME_RENDER, t5);
                      }
                      if ("number" == typeof c3.totalFreezesDuration) {
                        const e6 = p3 && p3.totalFreezesDuration ? c3.totalFreezesDuration - p3.totalFreezesDuration : c3.totalFreezesDuration;
                        kF(d2, vF.FREEZE_DURATION, 1e3 * e6);
                      }
                    }
                  }
                  if (d2[CF.PLAYER_STATUS] = UD[n3._player ? n3._player.videoElementStatus : "uninit"], p3 && void 0 !== c3.totalInterFrameDelay && void 0 !== c3.totalSquaredInterFrameDelay && void 0 !== p3.totalInterFrameDelay && void 0 !== p3.totalSquaredInterFrameDelay) {
                    const e5 = c3.totalInterFrameDelay - p3.totalInterFrameDelay, t4 = c3.totalSquaredInterFrameDelay - p3.totalSquaredInterFrameDelay, i5 = c3.framesDecodeCount - p3.framesDecodeCount, n4 = e5 / i5 * 1e3, r6 = Math.round(1e3 * Math.sqrt((t4 - Math.pow(e5, 2) / i5) / i5));
                    !isNaN(r6) && n4 + r6 > Math.max(3 * n4, n4 + 150) && (d2[CF.I_FRAME_DELAY] = r6);
                  }
                }
                return d2;
              }(s2._videoSSRC, e2, t2, s2.videoTrack, true === r4, this.needUploadRenderFreezeTime, i3, n2) : void 0;
              o3 && (c2.video = o3);
            }
            if (a2.has(lU.AUDIO) && s2.audioTrack) {
              const r4 = s2.audioTrack ? function(e3, t3, i4, n3, r5, o3) {
                const s3 = t3.audioRecv.find((t4) => t4.ssrc === e3);
                if (!s3)
                  return;
                const a3 = {}, c3 = i4 && i4.audioRecv.find((t4) => t4.ssrc === e3);
                if (kF(a3, AF.JITTER, s3.jitterMs), kF(a3, AF.BYTES_RETRANSMIT, s3.retransmittedBytesReceived), kF(a3, AF.PACKAGES_RETRANSMIT, s3.retransmittedPacketsReceived), kF(a3, AF.PACKAGES_DISCARDED, s3.packetsDiscarded), kF(a3, AF.AVG_PROCESSING_DELAY, s3.avgProcessingDelayMs), c3) {
                  const e4 = t3.timestamp - i4.timestamp || NF * (o3 ? DF : r5 ? PF : 1);
                  null != s3.packets && null != c3.packets && kF(a3, AF.PACKAGE_RATE, 1e3 * (s3.packets - c3.packets) / e4), r5 && null != c3.bytes && null != s3.bytes && kF(a3, AF.BITRATE, 8 * (s3.bytes - c3.bytes) / e4), null != s3.packetsLost && null != c3.packetsLost && kF(a3, AF.PACKAGE_LOST, s3.packetsLost - c3.packetsLost);
                }
                if (o3) {
                  const { receivedFrames: e4, droppedFrames: t4 } = s3;
                  null != e4 && null != t4 && (a3[AF.FREEZE] = 0 === (d2 = e4) || 100 * t4 / d2 > 20 ? 1 : 0);
                }
                var d2;
                if (r5) {
                  const e4 = 100 * n3._source.getAccurateVolumeLevel(), t4 = s3.outputLevel;
                  if (null != t4) {
                    const e5 = Math.ceil(50 * Math.log10(100 * t4 + 1));
                    kF(a3, bF.LEVEL, e5);
                  }
                  if (kF(a3, AF.PCM_LEVEL, e4), n3 && (a3[AF.DISABLED] = n3._originMediaStreamTrack.enabled && n3._mediaStreamTrack.enabled ? 0 : 1), kF(a3, AF.JITTER_BUFFER, s3.jitterBufferMs), kF(a3, AF.CURRENT_DELAY, s3.jitterBufferMs), a3[AF.PLAYER_STATUS] = UD[fP.getPlayerState(n3.getTrackId())], c3) {
                    const e5 = s3.concealedSamples - c3.concealedSamples;
                    e5 > 0 && kF(a3, AF.CONCEALED_SAMPLES, e5);
                  }
                }
                return a3;
              }(s2._audioSSRC, e2, t2, s2.audioTrack, i3, n2) : void 0;
              r4 && (c2.audio = r4);
            }
            (c2.video || c2.audio) && o2.push(c2);
          }), this.needUploadRenderFreezeTime = !this.needUploadRenderFreezeTime, o2;
        }
        startUploadTransportStats() {
          this.uploadTransportStarted = true, this.uploadWRTCStatsTimer || this.startUploadWRTCStats();
        }
        stopUploadTransportStats() {
          this.uploadTransportStarted = false;
        }
        startUploadOutboundStats() {
          this.uploadOutboundStarted || (this.uploadOutboundStarted = true, this.uploadWRTCStatsTimer || this.startUploadWRTCStats(), this.uploadOutboundDenoiserStatsTimer && window.clearInterval(this.uploadOutboundDenoiserStatsTimer), this.uploadOutboundDenoiserStatsTimer = window.setInterval(() => {
            if (!this.requestAllTracks || !this.requestUpload)
              return;
            const e2 = (this.requestAllTracks() || []).find((e3) => e3 instanceof SL);
            if (e2 && e2._external.getDenoiserStats) {
              const t2 = e2._external.getDenoiserStats();
              t2 && this.requestUpload(LM.DENOISER_STATS, t2);
            }
          }, 2e3), this.uploadExtStatsTimer && window.clearInterval(this.uploadExtStatsTimer), this.uploadExtStatsTimer = window.setInterval(() => {
            if (!this.requestAllTracks || !this.requestUpload)
              return;
            this.requestAllTracks().forEach((e2) => {
              e2.getProcessorStats().forEach((e3) => {
                this.requestUpload && this.requestUpload(e3.type, e3.stats);
              });
            });
          }, 2e3));
        }
        stopUploadOutboundStats() {
          this.uploadOutboundStarted && (this.uploadOutboundStarted = false, this.lastSendStats && (this.lastSendStats.videoSend = [], this.lastSendStats.audioSend = [], this.lastSendStats = void 0), this.uploadOutboundDenoiserStatsTimer && window.clearInterval(this.uploadOutboundDenoiserStatsTimer), this.uploadOutboundDenoiserStatsTimer = void 0);
        }
        startUploadInboundStats() {
          this.uploadInboundStarted || (this.uploadInboundStarted = true, this.uploadWRTCStatsTimer || this.startUploadWRTCStats(), this.uploadInboundExtStatsTimer && window.clearInterval(this.uploadInboundExtStatsTimer), this.uploadInboundExtStatsTimer = window.setInterval(() => {
            if (!this.requestUpload || !this.requestRemoteMedia)
              return;
            (this.requestRemoteMedia() || []).forEach((e2) => {
              let [t2, i3] = e2;
              if (i3.has(lU.VIDEO) && t2.videoTrack) {
                t2.videoTrack.getProcessorStats().forEach((e3) => {
                  this.requestUpload && this.requestUpload(e3.type, e3.stats);
                });
              }
              if (i3.has(lU.AUDIO) && t2.audioTrack) {
                t2.audioTrack.getProcessorStats().forEach((e3) => {
                  this.requestUpload && this.requestUpload(e3.type, e3.stats);
                });
              }
            });
          }, 2e3));
        }
        stopUploadInboundStats() {
          this.uploadInboundStarted && (this.uploadInboundStarted = false, this.lastRecvStats && (this.lastRecvStats.videoRecv = [], this.lastRecvStats.audioRecv = [], this.lastRecvStats = void 0));
        }
        startUploadExtensionUsageStats() {
          if (this.uploadExtensionUsageStarted)
            return;
          this.uploadExtensionUsageStarted = true, this.uploadExtUsageStatsTimer && window.clearInterval(this.uploadExtUsageStatsTimer);
          const e2 = /* @__PURE__ */ new Map();
          this.uploadExtUsageStatsTimer = window.setInterval(async () => {
            const t2 = Date.now(), i3 = { connectionInterval: dN("EXTENSION_USAGE_UPLOAD_INTERVAL") / 1e3, details: [], lts: t2 };
            let n2 = [];
            const r2 = this.requestAllTracks && this.requestAllTracks() || [];
            for (const e3 of r2)
              !e3.muted && e3.enabled && (n2 = n2.concat(await e3.getProcessorUsage()));
            const o2 = this.requestRemoteMedia && this.requestRemoteMedia() || [];
            for (const [e3, t3] of o2)
              t3.has(lU.VIDEO) && e3.videoTrack && (n2 = n2.concat(await e3.videoTrack.getProcessorUsage())), t3.has(lU.AUDIO) && e3.audioTrack && (n2 = n2.concat(await e3.audioTrack.getProcessorUsage()));
            if (0 === n2.length)
              return;
            i3.details = function(e3, t3) {
              const i4 = {};
              for (const { id: s3, value: a3, level: c2, direction: d2 } of e3) {
                var n3;
                const e4 = null !== (n3 = t3.get(s3)) && void 0 !== n3 ? n3 : 0, l2 = 2 === a3 ? e4 + dN("EXTENSION_USAGE_UPLOAD_INTERVAL") / 1e3 : e4;
                var r3, o3;
                t3.set(s3, l2), i4[s3] ? (2 === a3 && (i4[s3].value = a3), c2 > i4[s3].level && (i4[s3].level = c2), "remote" === d2 && (i4[s3].remoteUidCount += 1), i4[s3].totalTs = null !== (r3 = t3.get(s3)) && void 0 !== r3 ? r3 : 0) : i4[s3] = { value: a3, level: c2, remoteUidCount: "local" === d2 ? 0 : 1, totalTs: null !== (o3 = t3.get(s3)) && void 0 !== o3 ? o3 : 0 };
              }
              return Object.keys(i4).map((e4) => {
                const { level: t4, value: n4, totalTs: r4 } = i4[e4];
                return { id: e4, level: t4, value: n4, totalTs: r4 };
              });
            }(n2, e2);
            const s2 = Date.now(), a2 = s2 > t2 ? s2 : t2 + 1;
            this.requestUpload && this.requestUpload(LM.EXTENSION_USAGE_STATS, { usageStats: i3, sendTs: a2 });
          }, dN("EXTENSION_USAGE_UPLOAD_INTERVAL"));
        }
        stopUploadExtensionUsageStats() {
          this.uploadExtensionUsageStarted && (this.uploadExtensionUsageStarted = false, this.uploadExtUsageStatsTimer && window.clearInterval(this.uploadExtUsageStatsTimer), this.uploadExtUsageStatsTimer = void 0);
        }
        stopUploadBaseStats() {
          this.uploadBaseStatsStarted = false;
        }
      }
      const VF = dN("ICE_RESTART_INTERVAL");
      let FF = /* @__PURE__ */ new Map(), BF = /* @__PURE__ */ new Map(), jF = [uU.UDP_TCP_RELAY, uU.TCP_RELAY, uU.RELAY], GF = dN("JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE") && QN().supportPCSetConfiguration;
      function WF(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        const i3 = FF.get(e2.id);
        i3 && (window.clearTimeout(i3), FF.delete(e2.id));
        const n2 = BF.get(e2.id);
        t2 && n2 && n2.index === jF.length - 1 && (BN.debug("[".concat(e2.id, "] reset ICE restart policy")), BF.delete(e2.id));
      }
      function HF(e2, t2, i3) {
        if (0 === FF.size && 0 === BF.size && (Array.isArray(dN("RESTART_SEQUENCE")) && dN("RESTART_SEQUENCE").length > 0 && !function(e3, t3) {
          if (e3.length !== t3.length)
            return false;
          for (let i4 = 0; i4 < e3.length; i4 += 1) {
            const n3 = e3[i4];
            if (e3.filter((e4) => e4 === n3).length !== t3.filter((e4) => e4 === n3).length)
              return false;
          }
          return true;
        }(jF, dN("RESTART_SEQUENCE")) && (jF = dN("RESTART_SEQUENCE").filter((e3) => {
          var t3;
          if (Dn(t3 = Object.values(uU)).call(t3, e3))
            return true;
        }), BN.debug("use reconnection policy from config distribution, queues: ".concat(jF.join(" => ")))), GF = dN("JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE") && QN().supportPCSetConfiguration), 0 === jF.length)
          return void i3();
        let n2, { index: r2 = 0, type: o2 } = BF.get(e2.id) || {};
        if (GF && o2 === uU.RELAY)
          return void i3();
        let s2 = o2 && r2 >= jF.length - 1;
        if (GF)
          o2 = uU.RELAY;
        else {
          if (s2)
            return void i3();
          o2 ? (r2++, o2 = jF[r2]) : (o2 = jF[0], r2 = 0);
        }
        BN.debug("[".concat(e2.id, "] choose ICE restart policy: ").concat(o2, ", index: ").concat(r2)), t2(o2), BF.set(e2.id, { index: r2, type: o2 }), n2 = window.setTimeout(() => HF(e2, t2, i3), VF), FF.set(e2.id, n2);
      }
      var KF;
      function YF(e2, t2) {
        var i3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i3.push.apply(i3, n2);
        }
        return i3;
      }
      function qF(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i3 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? YF(Object(i3), true).forEach(function(t3) {
            QI(e2, t3, i3[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : YF(Object(i3)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
          });
        }
        return e2;
      }
      function zF(e2) {
        var t2, i3, n2, r2 = 2;
        for ("undefined" != typeof Symbol && (i3 = GA, n2 = Symbol.iterator); r2--; ) {
          if (i3 && null != (t2 = e2[i3]))
            return t2.call(e2);
          if (n2 && null != (t2 = e2[n2]))
            return new XF(t2.call(e2));
          i3 = "@@asyncIterator", n2 = "@@iterator";
        }
        throw new TypeError("Object is not async iterable");
      }
      function XF(e2) {
        function t2(e3) {
          if (Object(e3) !== e3)
            return Wh.reject(new TypeError(e3 + " is not an object."));
          var t3 = e3.done;
          return Wh.resolve(e3.value).then(function(e4) {
            return { value: e4, done: t3 };
          });
        }
        return XF = function(e3) {
          this.s = e3, this.n = e3.next;
        }, XF.prototype = { s: null, n: null, next: function() {
          return t2(this.n.apply(this.s, arguments));
        }, return: function(e3) {
          var i3 = this.s.return;
          return void 0 === i3 ? Wh.resolve({ value: e3, done: true }) : t2(i3.apply(this.s, arguments));
        }, throw: function(e3) {
          var i3 = this.s.return;
          return void 0 === i3 ? Wh.reject(e3) : t2(i3.apply(this.s, arguments));
        } }, new XF(e2);
      }
      let JF = (KF = class extends Nw {
        get state() {
          return this._state;
        }
        set state(e2) {
          const t2 = this._state;
          this._state = e2, this.emit(fU.StateChange, t2, this._state);
        }
        constructor(e2, t2) {
          super(), QI(this, "isPlanB", void 0), QI(this, "store", void 0), QI(this, "statsUploader", void 0), QI(this, "connection", void 0), QI(this, "localTrackMap", /* @__PURE__ */ new Map()), QI(this, "remoteUserMap", /* @__PURE__ */ new Map()), QI(this, "localDataChannels", []), QI(this, "remoteDataChannelMap", /* @__PURE__ */ new Map()), QI(this, "pendingLocalTracks", []), QI(this, "pendingRemoteTracks", []), QI(this, "pendingLocalDataChannels", []), QI(this, "pendingRemoteDataChannels", []), QI(this, "statsCollector", void 0), QI(this, "shouldForwardP2PCreation", void 0), QI(this, "iceFailedCount", 0), QI(this, "dtlsFailedCount", 0), QI(this, "mutex", void 0), QI(this, "_state", EU.Disconnected), QI(this, "_pcStatsUploadType", dN("NEW_ICE_RESTART") ? hU.FIRST_CONNECTION : hU.OLD_FIRST_CONNECTION), QI(this, "_isStartRestartIce", false), QI(this, "_restartTimer", void 0), QI(this, "_isTryConnecting", false), QI(this, "_iceError", null), QI(this, "_forceTurn", false), QI(this, "_isWaitPcToRePub", false), QI(this, "handleMuteLocalTrack", async (e3, t3, i3) => {
            const n2 = await this.mutex.lock("Locking from P2PChannel.handleMuteLocalTrack");
            try {
              if (!this.connection || this.state !== EU.Connected)
                return void i3(new Ew(_w.INVALID_OPERATION, "Cannot call P2PChannel.handleMuteLocalTrack before connection established."));
              const r2 = this.filterTobeMutedTracks(e3);
              if (0 === r2.length)
                return void t3();
              const o2 = r2.find((e4) => "videoLowTrack" === e4[0]);
              if (o2) {
                o2[1].track._originMediaStreamTrack.stop();
              }
              await this.connection.muteLocal(r2.map((e4) => {
                let [, { id: t4 }] = e4;
                return t4;
              }));
              const s2 = this.createMuteMessage(r2);
              await Yw(this, fU.RequestMuteLocal, s2), t3();
            } catch (e4) {
              i3(e4);
            } finally {
              n2();
            }
          }), QI(this, "handleUnmuteLocalTrack", async (e3, t3, i3) => {
            const n2 = await this.mutex.lock("Locking from P2PChannel.handleUnmuteLocalTrack");
            try {
              if (!this.connection || this.state !== EU.Connected)
                return void i3(new Ew(_w.INVALID_OPERATION, "Cannot call P2PChannel.handleUnmuteLocalTrack before connection established."));
              const r2 = this.filterTobeUnmutedTracks(e3);
              if (0 === r2.length)
                return void t3();
              const o2 = r2.find((e4) => "videoLowTrack" === e4[0]);
              if (o2) {
                const t4 = o2[1];
                if (t4.track._originMediaStreamTrack.stop(), !dN("DISABLE_DUAL_STREAM_USE_ENCODING") && QN().supportDualStreamEncoding) {
                  const i4 = e3._mediaStreamTrack.clone();
                  t4.track._mediaStreamTrack = i4, t4.track._originMediaStreamTrack = i4;
                } else {
                  const i4 = TF(e3, zw(this, fU.RequestLowStreamParameter));
                  t4.track._mediaStreamTrack = i4, t4.track._originMediaStreamTrack = i4;
                }
                await new Wh((e4, i4) => {
                  this.handleReplaceTrack(t4.track, e4, i4, true);
                });
              }
              await this.connection.unmuteLocal(r2.map((e4) => {
                let [, { id: t4 }] = e4;
                return t4;
              }));
              const s2 = this.createUnmuteMessage(r2);
              await Yw(this, fU.RequestUnmuteLocal, s2), t3();
            } catch (e4) {
              i3(e4);
            } finally {
              n2();
            }
          }), QI(this, "handleUpdateVideoEncoder", async (e3, t3, i3, n2) => {
            let r2;
            n2 || (r2 = await this.mutex.lock("Locking from P2PChannel.handleUpdateVideoEncoder"));
            try {
              const i4 = this.localTrackMap.get(_U.LocalVideoTrack);
              if (!this.connection || !i4 || i4.track !== e3 || this.state !== EU.Connected)
                return void t3();
              const { id: n3, track: s2 } = i4;
              await this.connection.updateSendParameters(n3, s2), await this.connection.updateEncoderConfig(n3, s2), this.emit(fU.UpdateVideoEncoder, s2), t3();
            } catch (e4) {
              i3(e4);
            } finally {
              var o2;
              null === (o2 = r2) || void 0 === o2 || o2();
            }
          }), QI(this, "handleUpdateVideoSendParameters", async (e3, t3, i3) => {
            const n2 = await this.mutex.lock("Locking from P2PChannel.handleUpdateVideoSendParameters");
            try {
              const i4 = this.localTrackMap.get(_U.LocalVideoTrack);
              if (!this.connection || !i4 || i4.track !== e3 || this.state !== EU.Connected)
                return void t3();
              const { id: r2, track: o2 } = i4;
              await this.connection.updateSendParameters(r2, o2), t3();
            } catch (e4) {
              i3(e4);
            } finally {
              n2();
            }
          }), QI(this, "handleReplaceMixingTrack", async (e3, t3, i3, n2) => {
            if (!this.connection || this.state !== EU.Connected)
              return void t3();
            const r2 = cF([e3]);
            let o2;
            BN.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection will replace audioTrack [").concat(r2.getTrackId(), "]")), "boolean" == typeof n2 && n2 || (o2 = await this.mutex.lock("From P2PChannel.handleReplaceMixingTrack"));
            try {
              await this.replaceTrack(e3, r2), t3();
            } catch (e4) {
              i3(e4);
            } finally {
              var s2;
              null === (s2 = o2) || void 0 === s2 || s2();
            }
          }), QI(this, "handleReplaceTrack", async (e3, t3, i3, n2) => {
            let r2;
            BN.debug("[".concat(this.store.clientId, "] P2PChannel handleReplaceTrack for [track-id-").concat(e3.getTrackId(), "]")), "boolean" == typeof n2 && n2 || (r2 = await this.mutex.lock("From P2PChannel.handleReplaceTrack"));
            try {
              var o2;
              const i4 = Array.from(this.localTrackMap.entries()).find((t4) => {
                let [, { track: i5 }] = t4;
                return e3 === i5;
              });
              if (!this.connection || !i4 || this.state !== EU.Connected)
                return void t3();
              if (await (null === (o2 = this.connection) || void 0 === o2 ? void 0 : o2.replaceTrack(e3, i4[1].id)), this.isPlanB) {
                const t4 = i4[1];
                t4.id = e3._mediaStreamTrack.id, this.localTrackMap.set(i4[0], t4);
              }
              if (i4[0] === _U.LocalVideoTrack && !dN("DISABLE_DUAL_STREAM_USE_ENCODING") && QN().supportDualStreamEncoding) {
                const t4 = this.localTrackMap.get(_U.LocalVideoLowTrack);
                if (t4) {
                  const i5 = e3._mediaStreamTrack.clone();
                  t4.track._originMediaStreamTrack.stop(), t4.track._mediaStreamTrack = i5, t4.track._originMediaStreamTrack = i5, await new Wh((e4, i6) => {
                    this.handleReplaceTrack(t4.track, e4, i6, true);
                  });
                }
              }
              t3();
            } catch (e4) {
              i3(e4);
            } finally {
              var s2;
              null === (s2 = r2) || void 0 === s2 || s2();
            }
          }), QI(this, "handleGetRTCStats", (e3) => {
            e3(this.statsCollector.getRTCStats());
          }), QI(this, "handleGetLocalVideoStats", (e3) => {
            e3(this.statsCollector.getLocalVideoTrackStats());
          }), QI(this, "handleGetLocalAudioStats", (e3) => {
            e3(this.statsCollector.getLocalAudioTrackStats());
          }), QI(this, "handleGetRemoteVideoStats", (e3) => this.statsCollector.getRemoteVideoTrackStats(e3.uid)[e3.uid]), QI(this, "handleGetRemoteAudioStats", (e3) => this.statsCollector.getRemoteAudioTrackStats(e3.uid)[e3.uid]), this.store = e2, this.statsCollector = t2, this.statsCollector.addP2PChannel(this), this.statsUploader = new xF(this.store), this.bindStatsUploaderEvents(), this.mutex = new vO("P2PChannel-mutex", this.store.clientId), this.isPlanB = !QN().supportUnifiedPlan || dN("CHROME_FORCE_PLAN_B") && cw(), this.shouldForwardP2PCreation = dN("FORWARD_P2P_CREATION") && QN().supportPCSetConfiguration && aw(), this.shouldForwardP2PCreation && (this.connection = lF(this.store), this.emit(fU.PeerConnectionStateChange, this.connection.peerConnectionState), this.bindConnectionEvents(this.connection));
        }
        async startP2PConnection(e2) {
          var t2;
          this.state = EU.New, this._forceTurn = hF(e2), BN.debug("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] forceTurn: ").concat(this._forceTurn));
          const i3 = this.shouldForwardP2PCreation && "closed" === (null === (t2 = this.connection) || void 0 === t2 ? void 0 : t2.peerConnectionState);
          if (this.shouldForwardP2PCreation && !i3 || (i3 && this.connection && (BN.warning("[".concat(this.store.clientId, "] P2PChannel.startP2PConnection ForwardP2P closed.")), this.resetConnection(this.connection)), this.connection = lF(this.store, e2), this.emit(fU.PeerConnectionStateChange, this.connection.peerConnectionState), this.bindConnectionEvents(this.connection)), !this.connection)
            throw new Ew(_w.UNEXPECTED_ERROR, "Cannot P2PChannel.startConnection before P2PConnection initialization .");
          return this._pcStatsUploadType = dN("NEW_ICE_RESTART") ? hU.FIRST_CONNECTION : hU.OLD_FIRST_CONNECTION, this._isTryConnecting = true, this._isStartRestartIce = false, this._iceError = null, this.connection.setConfiguration(e2), this.connection.establishPromise;
        }
        async connect(e2) {
          if (!this.connection)
            throw new Ew(_w.UNEXPECTED_ERROR, "Cannot P2PChannel.connect before P2PChannel.startP2PConnection .");
          dN("ENABLE_PREALLOC_PC") && this.state === EU.Connected ? await this.connection.updateRemoteConnect(e2) : (this.store.peerConnectionStart(), await this.connection.connect(e2), this.statsUploader.startUploadTransportStats(), this.statsUploader.startUploadExtensionUsageStats(), this.state = EU.Connected);
        }
        updateRemoteRTPCapabilities(e2) {
          const t2 = Array.from(this.localTrackMap.entries()).filter((e3) => {
            var t3;
            let [i4] = e3;
            return Dn(t3 = [_U.LocalVideoLowTrack, _U.LocalVideoTrack]).call(t3, i4);
          }), i3 = t2.map((e3) => {
            let [, { id: t3 }] = e3;
            return t3;
          }), n2 = t2.map((e3) => {
            let [t3] = e3;
            return t3;
          });
          if (this.connection instanceof fF) {
            if (zN.updateRemoteRTPCapabilities(this.store.sessionId, { trackTypes: JSON.stringify(n2), localCodecs: JSON.stringify(this.connection.localCodecs), remoteCodecs: JSON.stringify(e2) }), !Dn(e2).call(e2, this.store.codec)) {
              const t3 = ["vp9", "vp8", "h264"].find((t4) => Dn(e2).call(e2, t4));
              t3 && (this.store.codec = t3, BN.debug("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, " updateRemoteRTPCapabilities] default codec is not available, hence the fallback to ").concat(t3, ".")));
            }
            this.connection.updateRemoteRTPCapabilities(i3, e2);
          }
        }
        async getEstablishParams() {
          var e2;
          if (this.connection instanceof fF && "closed" !== this.connection.peerConnectionState && Dn(e2 = [EU.New, EU.Connected]).call(e2, this.state))
            return this.connection.establishPromise;
        }
        async publishDataChannel(e2) {
          if (!this.connection || this.state !== EU.Connected) {
            if (this.state === EU.Disconnected)
              throw new Ew(_w.UNEXPECTED_ERROR, "PeerConnection already disconnected.");
            return e2.forEach((e3) => {
              var t3;
              Dn(t3 = this.pendingLocalDataChannels).call(t3, e3) || this.pendingLocalDataChannels.push(e3);
            }), [];
          }
          const t2 = this.filterTobePublishedDataChannels(e2);
          return 0 === t2.length ? [] : (t2.forEach((e3) => {
            const t3 = Date.now();
            this.store.publish(e3.id.toString(), "datachannel", t3);
          }), await this.connection.createDataChannels(this.store.uid, t2), t2.forEach((e3) => {
            this.localDataChannels.push(e3);
            const t3 = Date.now();
            this.store.publish(e3.id + "", "datachannel", void 0, t3);
          }), e2.map((e3) => ({ streamId: e3.id, ordered: e3.ordered, maxRetransmits: e3.maxRetransmits, metadata: e3.metadata, channelId: e3._originDataChannelId })));
        }
        publish(e2, t2, i3) {
          var n2 = this;
          return FA(function* () {
            const r2 = yield BA(n2.mutex.lock("From P2PChannel.publish"));
            try {
              var o2;
              const s2 = n2.connection && Dn(o2 = ["disconnected", "failed"]).call(o2, n2.connection.peerConnectionState);
              if (!n2.connection || n2.state !== EU.Connected || s2) {
                if (n2.state === EU.Disconnected)
                  throw new Ew(_w.UNEXPECTED_ERROR, "PeerConnection already disconnected.");
                n2.throwIfTrackTypeNotMatch(e2);
                const t3 = e2.filter((e3) => -1 === n2.pendingLocalTracks.indexOf(e3));
                return n2.pendingLocalTracks = n2.pendingLocalTracks.concat(t3), void (s2 && (n2._isWaitPcToRePub = true));
              }
              n2.store.pubId = n2.store.pubId + 1, UV.markPublishStart(n2.store.clientId, n2.store.pubId);
              const a2 = n2.filterTobePublishedTracks(e2, t2, i3);
              if (0 === a2.length)
                return void (yield BA(n2.tryToUnmuteAudio(e2)));
              yield* jA(zF(n2.doPublish(n2.connection, a2)));
            } finally {
              r2();
            }
          })();
        }
        doPublish(e2, t2) {
          var i3 = this;
          return FA(function* () {
            t2.forEach((e3) => {
              let { track: t3, type: n3 } = e3;
              const r3 = Date.now();
              i3.store.publish(t3.getTrackId(), n3 === _U.LocalAudioTrack ? "audio" : "video", r3);
            }), i3.bindLocalTrackEvents(t2);
            const n2 = t2.map((e3) => {
              let { track: t3 } = e3;
              return t3;
            }), r2 = yield BA(e2.send(n2, i3.store.codec, i3.store.audioCodec)), o2 = (yield BA(r2.next())).value, s2 = i3.createGatewayPublishMessage(t2, o2);
            let a2;
            try {
              a2 = yield s2;
            } catch (e3) {
              throw r2.throw(e3), (null == e3 ? void 0 : e3.code) === _w.WS_ABORT && t2.forEach((e4) => {
                let { track: t3 } = e4;
                -1 === i3.pendingLocalTracks.indexOf(t3) && i3.pendingLocalTracks.push(t3);
              }), i3.unbindLocalTrackEvents(t2), e3;
            }
            const c2 = i3.mapPubResToRemoteConfig(s2, a2, n2), d2 = (yield BA(r2.next(c2))).value, l2 = dN("ENABLE_VIDEO_SEI");
            n2.forEach(async (e3) => {
              const t3 = e3.getRTCRtpTransceiver();
              t3 && l2 && (e3.trackMediaType === lU.VIDEO ? await Mk(t3.sender, e3) : e3.trackMediaType === lU.AUDIO && await async function(e4) {
                if (!QN().supportWebRTCEncodedTransform)
                  return void BN.warning("browser not support audio encoded transform");
                if (Nk.has(e4))
                  return;
                if (!e4.track)
                  return;
                const t4 = { track: e4.track };
                if (Gb()) {
                  if (!e4.createEncodedStreams)
                    return void BN.warning("browser not support createEncodedStreams() API");
                  let n3 = null;
                  try {
                    n3 = e4.createEncodedStreams();
                  } catch (e5) {
                    return void BN.error("create audio-encoded-streams error", e5 && e5.message);
                  }
                  const r3 = new TransformStream({ transform(n4, r4) {
                    t4.controller || (t4.controller = r4), e4.track && e4.track.id !== t4.track.id && (BN.debug("audio track changed: ".concat(t4.track.id, " => ").concat(e4.track.id)), t4.track.removeEventListener("ended", i4), t4.track = e4.track, t4.track.addEventListener("ended", i4)), r4.enqueue(n4);
                  } });
                  n3.readable.pipeThrough(r3).pipeTo(n3.writable);
                } else if (Wb()) {
                  if ("undefined" == typeof RTCRtpScriptTransform)
                    return void BN.warning("browser not support RTCRtpScriptTransform");
                  const n3 = Ok2(), r3 = new MessageChannel();
                  await new Wh((e5) => n3.onmessage = (t5) => {
                    "registered" === t5.data && e5(void 0);
                  });
                  const o3 = new RTCRtpScriptTransform(n3, { name: "tx", port: r3.port2 }, [r3.port2]);
                  e4.transform = o3, await new Wh((e5) => n3.onmessage = (t5) => {
                    "started" === t5.data && e5(void 0);
                  }), r3.port1.onmessage = (n4) => {
                    var r4;
                    n4.data.transformed && e4.track && (null === (r4 = e4.track) || void 0 === r4 ? void 0 : r4.id) !== t4.track.id && (BN.debug("audio track changed: ".concat(t4.track.id, " => ").concat(e4.track.id)), t4.track.removeEventListener("ended", i4), t4.track = e4.track, t4.track.addEventListener("ended", i4));
                  }, t4.worker = n3;
                }
                function i4() {
                  if (e4.track) {
                    if (this.id !== e4.track.id)
                      return;
                    e4.track.removeEventListener("ended", i4);
                  }
                  const t5 = Nk.get(e4);
                  if (t5) {
                    Nk.delete(e4);
                    try {
                      var n3, r3;
                      null === (n3 = t5.controller) || void 0 === n3 || n3.terminate(), null === (r3 = t5.worker) || void 0 === r3 || r3.terminate();
                    } catch (e5) {
                      BN.warning(e5 && e5.message);
                    }
                  }
                }
                Nk.set(e4, t4), e4.track.addEventListener("ended", i4);
              }(t3.sender));
            }), t2.forEach((e3) => {
              let { type: t3 } = e3;
              i3.statsCollector.addLocalStats(t3);
            }), i3.assignLocalTracks(t2, d2), i3.statsUploader.startUploadOutboundStats(), t2.forEach((e3) => {
              let { track: t3, type: n3 } = e3;
              const r3 = Date.now();
              i3.store.publish(t3.getTrackId(), n3 === _U.LocalAudioTrack ? "audio" : "video", void 0, r3);
            });
          })();
        }
        async updateVideoStreamParameter(e2, t2) {
          const i3 = this.localTrackMap.get(t2);
          if (!i3 || !this.connection)
            return;
          if (!(i3.track instanceof ak))
            return BN.warn("[updateVideoStreamParameter]: track is not an instance of LocalVideoTrack");
          const { track: n2 } = i3, r2 = function(e3, t3) {
            const i4 = {};
            return e3.height && e3.width && (i4.scaleResolutionDownBy = nx(e3, t3)), i4.maxFramerate = e3.framerate ? ZU(e3.framerate) : void 0, i4.maxBitrate = e3.bitrate ? 1e3 * e3.bitrate : void 0, i4;
          }(e2, n2);
          if (n2._encoderConfig || (n2._encoderConfig = {}), t2 !== _U.LocalVideoLowTrack || !dN("DISABLE_DUAL_STREAM_USE_ENCODING") && QN().supportDualStreamEncoding)
            null != r2.scaleResolutionDownBy && (n2._encoderConfig.scaleResolutionDownBy = r2.scaleResolutionDownBy);
          else {
            const t3 = n2._originMediaStreamTrack;
            if (!t3.canvas)
              return BN.warn("[".concat(n2.getTrackId(), "] no canvas on track"));
            !function(e3, t4) {
              const i4 = e3.canvas;
              t4.width && (i4.width = ZU(t4.width)), t4.height && (i4.height = ZU(t4.height)), t4.framerate && (i4.stopCapture && i4.stopCapture(), i4.stopCapture = JD(() => {
                !i4.startCapture && i4.stopCapture && i4.stopCapture(), i4.startCapture && i4.startCapture();
              }, ZU(t4.framerate)));
            }(t3, e2);
          }
          null != r2.maxBitrate && (n2._encoderConfig.bitrateMax = r2.maxBitrate / 1e3), null != r2.maxFramerate && (n2._encoderConfig.frameRate && "object" == typeof n2._encoderConfig.frameRate ? n2._encoderConfig.frameRate.max = r2.maxFramerate : n2._encoderConfig.frameRate = { max: r2.maxFramerate }), BN.debug("[".concat(n2.getTrackId(), "] LowStreamEncoderConfig: , ").concat(JSON.stringify(n2._encoderConfig))), await this.connection.updateRtpSenderEncodings(n2);
        }
        publishLowStream(e2) {
          var t2 = this;
          return FA(function* () {
            if (!t2.connection || t2.state !== EU.Connected)
              return;
            const i3 = yield BA(t2.mutex.lock("Locking from P2PChannel.publishLowStream"));
            try {
              const r2 = t2.localTrackMap.get(_U.LocalVideoTrack);
              if (!r2)
                throw new Ew(_w.UNEXPECTED_ERROR, "Could not find high stream");
              if (t2.localTrackMap.has(_U.LocalVideoLowTrack))
                throw new Ew(_w.UNEXPECTED_ERROR, "[".concat(t2.store.clientId, "] Can't publish low stream when stream already publish"));
              const o2 = [{ track: t2.getLowVideoTrack(r2.track, e2), type: _U.LocalVideoLowTrack }];
              if (yield* jA(zF(t2.doPublish(t2.connection, o2))), r2.track.muted || !r2.track.enabled) {
                var n2;
                const e3 = null === (n2 = t2.localTrackMap.get(_U.LocalVideoLowTrack)) || void 0 === n2 ? void 0 : n2.id;
                void 0 !== e3 && (yield BA(t2.connection.muteLocal([e3])));
              }
            } finally {
              i3();
            }
          })();
        }
        async republish() {
          this.pendingLocalTracks.length > 0 && (BN.debug("[".concat(this.store.clientId, "] Emit P2PChannelEvents.RequestRePublish to republish tracks.")), await Kw(this, fU.RequestRePublish, this.pendingLocalTracks), this.emit(fU.MediaReconnectEnd, this.store.uid), this.pendingLocalTracks = []), this.pendingLocalDataChannels.length > 0 && (BN.debug("Emit P2PChannelEvents.RequestRePublishDataChannel to republish datachannels."), await Kw(this, fU.RequestRePublishDataChannel, this.pendingLocalDataChannels), this.pendingLocalDataChannels = []), this._isWaitPcToRePub = false;
        }
        async reSubscribe(e2) {
          for (let e3 = this.pendingRemoteTracks.length - 1; e3 >= 0; e3--) {
            const { user: t2, kind: i3 } = this.pendingRemoteTracks[e3];
            (i3 !== lU.AUDIO || t2._audio_added_ && t2._audioSSRC) && (i3 !== lU.VIDEO || t2._video_added_ && t2._videoSSRC) || this.pendingRemoteTracks.splice(e3, 1);
          }
          if (e2)
            await Kw(this, fU.RequestReSubscribe, this.pendingRemoteTracks);
          else
            for (const { user: e3, kind: t2 } of this.pendingRemoteTracks)
              await this.subscribe(e3, t2, t2 === lU.VIDEO ? e3._videoSSRC : e3._audioSSRC);
          this.pendingRemoteTracks.forEach((e3) => {
            let { user: t2 } = e3;
            this.emit(fU.MediaReconnectEnd, t2.uid);
          }), this.pendingRemoteTracks = [];
        }
        async unpublish(e2) {
          if (!this.connection || this.state !== EU.Connected)
            return void e2.forEach((e3) => {
              const t3 = this.pendingLocalTracks.indexOf(e3);
              -1 !== t3 && this.pendingLocalTracks.splice(t3, 1);
            });
          const t2 = this.filterTobeUnpublishedTracks(e2);
          if (0 === t2.length)
            return;
          const i3 = t2.find((e3) => "videoLowTrack" === e3[0]);
          if (i3) {
            i3[1].track.close();
          }
          return this.doUnpublish(this.connection, t2);
        }
        async unpublishDataChannel(e2) {
          if (!this.connection || this.state !== EU.Connected)
            return void e2.forEach((e3) => {
              const t3 = this.pendingLocalDataChannels.indexOf(e3);
              -1 !== t3 && this.pendingLocalDataChannels.splice(t3, 1);
            });
          const t2 = this.filterTobeUnpublishedDataChannels(e2);
          return 0 !== t2.length ? (t2.forEach((e3) => {
            const t3 = this.localDataChannels.indexOf(e3);
            -1 !== t3 && this.localDataChannels.splice(t3, 1);
          }), 0 === this.localDataChannels.length && await this.connection.stopDataChannels(this.store.uid), t2.map((e3) => e3.id)) : void 0;
        }
        async unpublishLowStream() {
          if (!this.connection || this.state !== EU.Connected)
            return;
          const e2 = this.localTrackMap.get(_U.LocalVideoLowTrack);
          if (!e2)
            return;
          e2.track.close();
          const t2 = [[_U.LocalVideoLowTrack, e2]];
          return this.doUnpublish(this.connection, t2);
        }
        async doUnpublish(e2, t2) {
          const i3 = this.createGatewayUnpublishMessage(t2);
          return await e2.stopSending(t2.map((e3) => {
            let [, { id: t3 }] = e3;
            return t3;
          })), this.withdrawLocalTracks(t2), this.unbindLocalTrackEvents(t2.map((e3) => {
            let [t3, { track: i4 }] = e3;
            return { type: t3, track: i4 };
          })), t2.forEach((e3) => {
            let [t3] = e3;
            this.statsCollector.removeLocalStats(t3);
          }), 0 === this.localTrackMap.size && this.statsUploader.stopUploadOutboundStats(), i3;
        }
        async subscribeDataChannel(e2, t2) {
          if (!this.connection || this.state !== EU.Connected)
            throw new Ew(_w.INVALID_OPERATION, "Cannot subscribe remote user when peerConnection disconnected.");
          const i3 = t2.filter((t3) => {
            var i4;
            return !(null !== (i4 = this.remoteDataChannelMap.get(e2)) && void 0 !== i4 && i4.get(t3.id));
          });
          if (0 !== i3.length)
            return await this.connection.createDataChannels(e2.uid, i3), i3.forEach((t3) => {
              var i4;
              this.remoteDataChannelMap.has(e2) ? null === (i4 = this.remoteDataChannelMap.get(e2)) || void 0 === i4 || i4.set(t3.id, t3) : this.remoteDataChannelMap.set(e2, /* @__PURE__ */ new Map([[t3.id, t3]]));
              const n2 = this.pendingRemoteDataChannels.findIndex((i5) => {
                let { user: n3, id: r2 } = i5;
                return n3.uid === e2.uid && r2 === t3.id;
              });
              -1 !== n2 && this.pendingRemoteDataChannels.splice(n2, 1);
            }), i3.map((e3) => e3.id);
        }
        async subscribe(e2, t2, i3, n2, r2) {
          var o2;
          if (!this.connection || this.state !== EU.Connected)
            throw new Ew(_w.INVALID_OPERATION, "Cannot subscribe remote user when peerConnection disconnected.");
          if (null !== (o2 = this.remoteUserMap.get(e2)) && void 0 !== o2 && o2.has(t2))
            return;
          let s2, a2, c2;
          const d2 = this.connection.getPreMedia(i3);
          if (d2)
            BN.debug("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] preSSRCMap has ssrcId: ").concat(i3, ", no need to send sub to gateway.")), c2 = d2.transceiver, s2 = d2.track, a2 = d2.id;
          else if (r2) {
            const i4 = r2.find((e3) => {
              let { stream_type: i5 } = e3;
              return i5 === t2;
            });
            if (!i4)
              throw new Ew(_w.UNEXPECTED_ERROR, "Cannot subscribe to remote ".concat(t2, " for user: ").concat(e2.uid, " because subscribe answer from gateway does not contain stream_type: ").concat(t2, "."));
            const n3 = await this.connection.receive(t2, i4.ssrcs, String(e2._uintid), i4.attributes);
            this.connection instanceof fF && (c2 = n3.transceiver), s2 = n3.track, a2 = n3.id;
          } else {
            const r3 = await this.connection.receive(t2, [{ ssrcId: i3, rtx: n2 }], String(e2._uintid), void 0);
            this.connection instanceof fF && (c2 = r3.transceiver), s2 = r3.track, a2 = r3.id;
          }
          t2 === lU.AUDIO ? (e2._audioTrack ? e2._audioTrack._updateOriginMediaStreamTrack(s2) : (e2._audioTrack = new Ik(s2, e2.uid, e2._uintid, this.store), BN.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote audio track: ").concat(e2._audioTrack.getTrackId()))), c2 && e2._audioTrack._updateRtpTransceiver(c2), this.bindRemoteTrackEvents(e2, e2._audioTrack)) : (e2._videoTrack ? e2._videoTrack._updateOriginMediaStreamTrack(s2) : (e2._videoTrack = new vk(s2, e2.uid, e2._uintid, this.store), BN.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote video track: ").concat(e2._videoTrack.getTrackId()))), c2 && e2._videoTrack._updateRtpTransceiver(c2), this.bindRemoteTrackEvents(e2, e2._videoTrack)), dN("ENABLE_VIDEO_SEI") && c2 && (t2 == lU.VIDEO ? await xk(c2.receiver, { onSei: (t3) => {
            var i4;
            null === (i4 = e2._videoTrack) || void 0 === i4 || i4._onSei(t3);
          } }) : t2 == lU.AUDIO && await Pk(c2.receiver));
          const l2 = this.remoteUserMap.get(e2);
          l2 ? l2.set(t2, a2) : this.remoteUserMap.set(e2, /* @__PURE__ */ new Map([[t2, a2]])), this.statsCollector.addRemoteStats(e2.uid), this.statsUploader.startUploadInboundStats();
          const u2 = this.pendingRemoteTracks.findIndex((i4) => {
            let { user: n3, kind: r3 } = i4;
            return n3.uid === e2.uid && t2 === r3;
          });
          -1 !== u2 && (this.pendingRemoteTracks.splice(u2, 1), this.emit(fU.MediaReconnectEnd, e2.uid));
        }
        async massSubscribe(e2) {
          return this.massSubscribeNoLock(e2);
        }
        async massSubscribeNoLock(e2) {
          if (!this.connection || this.state !== EU.Connected)
            throw new Ew(_w.INVALID_OPERATION, "Cannot subscribeAll remote users when peerConnection disconnected.");
          e2 = e2.filter((e3) => {
            var t3;
            let { user: i4, mediaType: n3 } = e3;
            return !(null !== (t3 = this.remoteUserMap.get(i4)) && void 0 !== t3 && t3.has(n3));
          });
          const t2 = [], i3 = /* @__PURE__ */ new Map();
          e2.forEach((e3) => {
            if (!this.connection)
              return;
            const n3 = this.connection.getPreMedia(e3.ssrcId);
            n3 ? i3.set(e3.ssrcId, n3) : t2.push(e3);
          });
          const n2 = await this.connection.batchReceive(t2.map((e3) => {
            let { user: t3, mediaType: i4, ssrcId: n3, rtxSsrcId: r2 } = e3;
            return { kind: i4, ssrcMsg: [{ ssrcId: n3, rtx: r2 }], mslabel: String(t3._uintid) };
          }));
          t2.forEach((e3, t3) => {
            i3.set(e3.ssrcId, n2[t3]);
          });
          for (const { user: t3, mediaType: n3, ssrcId: r2 } of e2) {
            const e3 = i3.get(r2);
            if (!e3)
              return void BN.debug("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] cannot find ").concat(t3.uid, " subscribe data,").concat(n3, ", ").concat(r2));
            const { track: o2, id: s2, transceiver: a2 } = e3;
            n3 === lU.AUDIO ? (t3._audioTrack ? t3._audioTrack._updateOriginMediaStreamTrack(o2) : (t3._audioTrack = new Ik(o2, t3.uid, t3._uintid, this.store), BN.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote audio track: ").concat(t3._audioTrack.getTrackId()))), a2 && t3._audioTrack._updateRtpTransceiver(a2), this.bindRemoteTrackEvents(t3, t3._audioTrack)) : (t3._videoTrack ? t3._videoTrack._updateOriginMediaStreamTrack(o2) : (t3._videoTrack = new vk(o2, t3.uid, t3._uintid, this.store), BN.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote video track: ").concat(t3._videoTrack.getTrackId()))), a2 && t3._videoTrack._updateRtpTransceiver(a2), this.bindRemoteTrackEvents(t3, t3._videoTrack)), dN("ENABLE_VIDEO_SEI") && a2 && (n3 == lU.VIDEO ? await xk(a2.receiver, { onSei: (e4) => {
              var i4;
              null === (i4 = t3._videoTrack) || void 0 === i4 || i4._onSei(e4);
            } }) : n3 == lU.AUDIO && await Pk(a2.receiver));
            const c2 = this.remoteUserMap.get(t3);
            c2 ? c2.set(n3, s2) : this.remoteUserMap.set(t3, /* @__PURE__ */ new Map([[n3, s2]])), this.statsCollector.addRemoteStats(t3.uid), this.statsUploader.startUploadInboundStats();
            const d2 = this.pendingRemoteTracks.findIndex((e4) => {
              let { user: i4, kind: r3 } = e4;
              return i4.uid === t3.uid && n3 === r3;
            });
            -1 !== d2 && (this.pendingRemoteTracks.splice(d2, 1), this.emit(fU.MediaReconnectEnd, t3.uid));
          }
        }
        async unsubscribe(e2, t2, i3) {
          const n2 = this.pendingRemoteTracks.filter((i4) => {
            let { user: n3, kind: r3 } = i4;
            return void 0 !== t2 ? n3.uid === e2.uid && t2 === r3 : n3.uid === e2.uid;
          });
          if (n2.forEach((e3) => {
            const t3 = this.pendingRemoteTracks.indexOf(e3);
            this.pendingRemoteTracks.splice(t3, 1);
          }), this.connection && this.state === EU.Connected || i3 || n2.forEach((t3) => {
            let { kind: i4 } = t3;
            var n3;
            if (i4 === lU.AUDIO)
              null === (n3 = e2._audioTrack) || void 0 === n3 || n3._destroy(), e2._audioTrack = void 0;
            else if (i4 === lU.VIDEO) {
              var r3;
              null === (r3 = e2._videoTrack) || void 0 === r3 || r3._destroy(), e2._videoTrack = void 0;
            }
          }), !this.connection || this.state !== EU.Connected)
            return;
          const r2 = this.filterTobeUnSubscribedTracks(e2, t2);
          if (0 === r2.length)
            return;
          await this.connection.stopReceiving(r2.map((e3) => {
            let [, { id: t3 }] = e3;
            return t3;
          }));
          const o2 = this.createUnsubscribeMessage(r2);
          return this.withdrawRemoteTracks(r2), 0 === this.remoteUserMap.size && this.statsUploader.stopUploadInboundStats(), r2.forEach((e3) => {
            let [t3, { kind: n3 }] = e3;
            var r3, o3;
            n3 === lU.VIDEO && t3._videoSSRC && (null === (r3 = this.connection) || void 0 === r3 || r3.setStatsRemoteVideoIsReady(t3._videoSSRC, false));
            if (n3 === lU.VIDEO)
              this.unbindRemoteTrackEvents(t3._videoTrack), i3 || (null === (o3 = t3._videoTrack) || void 0 === o3 || o3._destroy(), t3._videoTrack = void 0);
            else if (n3 === lU.AUDIO) {
              var s2;
              if (this.unbindRemoteTrackEvents(t3._audioTrack), !i3)
                null === (s2 = t3._audioTrack) || void 0 === s2 || s2._destroy(), t3._audioTrack = void 0;
            }
          }), o2;
        }
        async unsubscribeDataChannel(e2, t2) {
          if (t2.forEach((e3) => {
            const t3 = this.pendingRemoteDataChannels.findIndex((t4) => t4.id === e3.id);
            -1 !== t3 && this.pendingRemoteDataChannels.splice(t3, 1);
          }), !this.connection)
            return;
          const i3 = this.filterTobeUnSubscribedDataChannels(e2, t2);
          if (0 === i3.length)
            return;
          t2.forEach((e3) => {
            e3._close();
          });
          const n2 = this.remoteDataChannelMap.get(e2);
          return i3.forEach((e3) => {
            n2 && n2.delete(e3.id);
          }), n2 && 0 === n2.size && (this.remoteDataChannelMap.delete(e2), await this.connection.stopDataChannels(e2.uid)), i3.map((e3) => e3.id);
        }
        async massUnsubscribe(e2) {
          return this.massUnsubscribeNoLock(e2);
        }
        async massUnsubscribeNoLock(e2) {
          let t2 = [];
          for (const { user: i4, mediaType: n3 } of e2) {
            const e3 = this.pendingRemoteTracks.filter((e4) => {
              let { user: t3, kind: r2 } = e4;
              return void 0 !== n3 ? t3.uid === i4.uid && n3 === r2 : t3.uid === i4.uid;
            });
            e3.forEach((e4) => {
              const t3 = this.pendingRemoteTracks.indexOf(e4);
              this.pendingRemoteTracks.splice(t3, 1);
            }), t2 = t2.concat(e3);
          }
          if (!this.connection || this.state !== EU.Connected)
            return void t2.forEach((e3) => {
              let { user: t3, kind: i4 } = e3;
              var n3;
              if (i4 === lU.AUDIO)
                null === (n3 = t3._audioTrack) || void 0 === n3 || n3._destroy(), t3._audioTrack = void 0;
              else if (i4 === lU.VIDEO) {
                var r2;
                null === (r2 = t3._videoTrack) || void 0 === r2 || r2._destroy(), t3._videoTrack = void 0;
              }
            });
          const i3 = Xn(e2).call(e2, (e3, t3) => {
            let { user: i4, mediaType: n3 } = t3;
            const r2 = this.filterTobeUnSubscribedTracks(i4, n3);
            return e3.concat(r2);
          }, []);
          if (0 === i3.length)
            return;
          await this.connection.stopReceiving(i3.map((e3) => {
            let [, { id: t3 }] = e3;
            return t3;
          }));
          const n2 = this.createUnsubscribeAllMessage(i3);
          return this.withdrawRemoteTracks(i3), 0 === this.remoteUserMap.size && this.statsUploader.stopUploadInboundStats(), i3.forEach((e3) => {
            let [t3, { kind: i4 }] = e3;
            var n3, r2;
            i4 === lU.VIDEO && t3._videoSSRC && (null === (n3 = this.connection) || void 0 === n3 || n3.setStatsRemoteVideoIsReady(t3._videoSSRC, false));
            if (i4 === lU.VIDEO)
              this.unbindRemoteTrackEvents(t3._videoTrack), null === (r2 = t3._videoTrack) || void 0 === r2 || r2._destroy(), t3._videoTrack = void 0;
            else if (i4 === lU.AUDIO) {
              var o2;
              this.unbindRemoteTrackEvents(t3._audioTrack), null === (o2 = t3._audioTrack) || void 0 === o2 || o2._destroy(), t3._audioTrack = void 0;
            }
          }), n2;
        }
        isPreSubScribe(e2) {
          if (!this.connection || this.state !== EU.Connected)
            return false;
          return !!this.connection.getPreMedia(e2);
        }
        async muteRemote(e2, t2) {
          if (!this.connection)
            return;
          const i3 = this.remoteUserMap.get(e2);
          if (!i3)
            return void BN.warning("[".concat(this.store.clientId, "] P2PChannel.muteRemote has no remote user ").concat(e2.uid, "."));
          if (!i3.get(t2))
            return void BN.warning("[".concat(this.store.clientId, "] P2PChannel.muteRemote has no remote user ").concat(e2.uid, " media type ").concat(t2, "."));
          const n2 = t2 === lU.VIDEO ? e2._videoSSRC : e2._audioSSRC;
          void 0 !== n2 && this.connection.setStatsRemoteVideoIsReady(n2, false);
        }
        async unmuteRemote(e2, t2) {
          return this.unmuteRemoteNoLock(e2, t2);
        }
        async unmuteRemoteNoLock(e2, t2) {
          if (!this.connection)
            return;
          const i3 = this.remoteUserMap.get(e2);
          if (!i3)
            return void BN.warning("[".concat(this.store.clientId, "] P2PChannel.unmuteRemote has no remote user ").concat(e2.uid, "."));
          i3.get(t2) || BN.warning("[".concat(this.store.clientId, "] P2PChannel.unmuteRemote has no remote user ").concat(e2.uid, " media type ").concat(t2, "."));
        }
        getAllTracks(e2) {
          const t2 = this.localTrackMap.get(_U.LocalAudioTrack);
          if ((null == t2 ? void 0 : t2.track) instanceof RL) {
            const i3 = t2.track;
            return Array.from(this.localTrackMap.entries()).filter((e3) => {
              let [t3] = e3;
              return t3 !== _U.LocalAudioTrack;
            }).filter((t3) => {
              let [i4] = t3;
              return !(e2 && i4 === _U.LocalVideoLowTrack);
            }).map((e3) => {
              let [, { track: t3 }] = e3;
              return t3;
            }).concat(i3.trackList);
          }
          return Array.from(this.localTrackMap.entries()).filter((t3) => {
            let [i3] = t3;
            return !(e2 && i3 === _U.LocalVideoLowTrack);
          }).map((e3) => {
            let [, { track: t3 }] = e3;
            return t3;
          });
        }
        getAllDataChannels() {
          return this.localDataChannels;
        }
        reportPublishEvent(e2, t2, i3, n2, r2) {
          if (e2) {
            const i4 = this.localTrackMap.get(_U.LocalAudioTrack), o3 = n2 ? this.localTrackMap.get(_U.LocalVideoLowTrack) : this.localTrackMap.get(_U.LocalVideoTrack);
            zN.publish(this.store.sessionId, { eventElapse: UV.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: e2, ec: t2, audioName: null == i4 ? void 0 : i4.track.getTrackLabel(), videoName: null == o3 ? void 0 : o3.track.getTrackLabel(), screenshare: -1 !== (null == o3 ? void 0 : o3.track._hints.indexOf(fD.SCREEN_TRACK)), audio: !!i4, video: !!o3, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: r2 });
          } else {
            var o2;
            i3 || (i3 = []);
            const s2 = i3.find((e3) => e3 instanceof TL), a2 = n2 ? null === (o2 = this.localTrackMap.get(_U.LocalVideoTrack)) || void 0 === o2 ? void 0 : o2.track : i3.find((e3) => e3 instanceof ak);
            zN.publish(this.store.sessionId, { eventElapse: UV.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: e2, ec: t2, audioName: null == s2 ? void 0 : s2.getTrackLabel(), videoName: null == a2 ? void 0 : a2.getTrackLabel(), screenshare: -1 !== (null == a2 ? void 0 : a2._hints.indexOf(fD.SCREEN_TRACK)), audio: !!s2, video: !!a2, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: r2 });
          }
        }
        reportSubscribeEvent(e2, t2, i3, n2) {
          const r2 = n2 === lU.VIDEO ? i3._videoSSRC : i3._audioSSRC;
          r2 && zN.subscribe(this.store.sessionId, { succ: e2, ec: t2, video: n2 === lU.VIDEO, audio: n2 === lU.AUDIO, peerid: i3.uid, subscribeRequestid: r2, p2pid: this.store.p2pId, eventElapse: UV.measureFromSubscribeStart(this.store.clientId, r2), preSsrc: this.isPreSubScribe(r2) });
        }
        reset() {
          BN.debug("[".concat(this.store.clientId, "] P2PChannel.reset")), this.mutex = new vO("P2PChannel-mutex", this.store.clientId), this.connection && (this.resetConnection(this.connection), this.connection = void 0), this.shouldForwardP2PCreation && (this.connection = lF(this.store), this.emit(fU.PeerConnectionStateChange, this.connection.peerConnectionState), this.bindConnectionEvents(this.connection)), this.statsUploader.stopUploadOutboundStats(), this.statsUploader.stopUploadInboundStats(), this.statsUploader.stopUploadTransportStats(), this.statsUploader.stopUploadExtensionUsageStats(), this.statsUploader.stopUploadBaseStats(), this.unbindLocalTrackEvents(), this.unbindAllRemoteTrackEvents(), this.unbindRtpTransceiver();
          const e2 = this.localTrackMap.get(_U.LocalAudioTrack);
          if ((null == e2 ? void 0 : e2.track) instanceof RL) {
            if (e2.track.trackList.length > 0) {
              const t2 = e2.track;
              e2.track.trackList.forEach((e3) => {
                t2.removeAudioTrack(e3);
              });
            }
            e2.track.close();
          }
          this.localTrackMap.clear(), this.remoteUserMap.clear(), this.statsCollector.removeRemoteStats(), this.statsCollector.removeLocalStats(), this.iceFailedCount = 0, this.dtlsFailedCount = 0, this.pendingLocalTracks = [], this.pendingRemoteTracks = [], this.localDataChannels = [], this.remoteDataChannelMap.clear(), this.pendingLocalDataChannels = [], this.pendingRemoteDataChannels = [], this.state = EU.Disconnected;
        }
        getStats() {
          var e2;
          return null === (e2 = this.connection) || void 0 === e2 ? void 0 : e2.getStats();
        }
        getRemoteVideoIsReady(e2) {
          var t2;
          return (null === (t2 = this.connection) || void 0 === t2 ? void 0 : t2.getRemoteVideoIsReady(e2)) || false;
        }
        getLocalAudioVolume() {
          const e2 = this.localTrackMap.get(_U.LocalAudioTrack);
          if (e2)
            return e2.track.getVolumeLevel();
        }
        getLocalVideoSize() {
          const e2 = this.localTrackMap.get(_U.LocalVideoTrack);
          if (e2)
            return { width: e2.track.videoWidth || 0, height: e2.track.videoHeight || 0 };
        }
        getEncoderConfig(e2) {
          const t2 = this.localTrackMap.get(e2);
          return t2 && t2.track instanceof ak || t2 && t2.track instanceof TL ? t2.track._encoderConfig : void 0;
        }
        getLocalMedia(e2) {
          return this.localTrackMap.get(e2);
        }
        hasLocalMedia() {
          return this.localTrackMap.size > 0;
        }
        hasRemoteMedia(e2, t2) {
          if (!e2)
            return this.remoteUserMap.size > 0;
          const i3 = this.remoteUserMap.get(e2);
          return !!i3 && (!t2 || i3.has(t2));
        }
        async hasRemoteMediaWithLock(e2, t2) {
          if (!e2)
            return this.remoteUserMap.size > 0;
          const i3 = this.remoteUserMap.get(e2);
          return !!i3 && (!t2 || i3.has(t2));
        }
        getRemoteMedia(e2) {
          var t2;
          const i3 = Array.from(ON(t2 = this.remoteUserMap).call(t2)).find((t3) => t3.uid === e2);
          return i3 ? { audioTrack: i3.audioTrack, audioSSRC: i3._audioSSRC, videoTrack: i3.videoTrack, videoSSRC: i3._videoSSRC } : {};
        }
        getAudioLevels() {
          let e2 = Array.from(this.remoteUserMap.entries()).map((e3) => {
            let [t3] = e3;
            return { uid: t3.uid, level: t3.audioTrack ? 100 * t3.audioTrack._source.getAccurateVolumeLevel() : 0 };
          });
          const t2 = this.localTrackMap.get(_U.LocalAudioTrack);
          return t2 && e2.push({ level: 100 * t2.track._source.getAccurateVolumeLevel(), uid: this.store.uid }), e2 = CS(e2).call(e2, (e3, t3) => e3.level - t3.level), e2;
        }
        async disconnectForReconnect() {
          this.connection && (BN.debug("[".concat(this.store.clientId, "] P2PChannel.disconnectForReconnect closing P2PConnection")), this.state = EU.Reconnecting, dN("KEEP_LAST_FRAME") && 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach((e2) => {
            let [t2] = e2;
            var i3;
            t2._videoTrack && t2._videoTrack._player && (null === (i3 = t2._videoTrack._player.getVideoElement()) || void 0 === i3 || i3.pause(), t2._videoTrack._player.isKeepLastFrame = true, t2._videoTrack._originMediaStreamTrack.stop());
          }), this.resetConnection(this.connection), this.connection = void 0, this.shouldForwardP2PCreation && (this.connection = lF(this.store), this.emit(fU.PeerConnectionStateChange, this.connection.peerConnectionState), this.bindConnectionEvents(this.connection)), 0 !== this.localTrackMap.size && (Array.from(this.localTrackMap.entries()).forEach((e2) => {
            var t2;
            let [i3, { track: n2 }] = e2;
            switch (i3) {
              case _U.LocalVideoTrack:
                Dn(t2 = n2._hints).call(t2, fD.LOW_STREAM) ? n2.close() : this.pendingLocalTracks.push(n2);
                break;
              case _U.LocalAudioTrack:
                n2 instanceof RL ? this.pendingLocalTracks = this.pendingLocalTracks.concat(n2.trackList) : this.pendingLocalTracks.push(n2);
              case _U.LocalVideoLowTrack:
            }
          }), this.emit(fU.MediaReconnectStart, this.store.uid)), this.unbindLocalTrackEvents(), this.localTrackMap.clear(), 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach((e2) => {
            let [t2, i3] = e2;
            Array.from(ON(i3).call(i3)).forEach((e3) => {
              this.setPendingRemoteMedia(t2, e3);
            }), this.emit(fU.MediaReconnectStart, t2.uid);
          }), this.unbindAllRemoteTrackEvents(), this.remoteUserMap.clear(), 0 !== this.localDataChannels.length && (this.localDataChannels.forEach((e2) => {
            this.pendingLocalDataChannels.push(e2);
          }), this.localDataChannels.length = 0), 0 !== this.remoteDataChannelMap.size && (Array.from(this.remoteDataChannelMap.entries()).forEach((e2) => {
            let [t2, i3] = e2;
            Array.from(ON(i3).call(i3)).forEach((e3) => {
              this.setPendingRemoteDataChannel(t2, e3);
            });
          }), this.remoteDataChannelMap.clear()), this.statsUploader.stopUploadOutboundStats(), this.statsUploader.stopUploadInboundStats(), this.statsUploader.stopUploadTransportStats(), BN.debug("[".concat(this.store.clientId, "] P2PChannel disconnected, waiting to reconnect.")));
        }
        hasPendingRemoteDataChannel(e2, t2) {
          for (const i3 of this.pendingRemoteDataChannels) {
            const { user: n2, id: r2 } = i3;
            if ((e2 instanceof GV ? e2.uid : e2) === n2.uid && r2 === t2)
              return true;
          }
          return false;
        }
        setPendingRemoteDataChannel(e2, t2) {
          this.hasPendingRemoteDataChannel(e2, t2) || this.pendingRemoteDataChannels.push({ user: e2, id: t2 });
        }
        hasPendingRemoteMedia(e2, t2) {
          for (const i3 of this.pendingRemoteTracks) {
            const { user: n2, kind: r2 } = i3;
            if ((e2 instanceof GV ? e2.uid : e2) === n2.uid && t2 === r2)
              return true;
          }
          return false;
        }
        setPendingRemoteMedia(e2, t2) {
          this.hasPendingRemoteMedia(e2, t2) || this.pendingRemoteTracks.push({ user: e2, kind: t2 });
        }
        restartICE(e2) {
          var t2 = this;
          return FA(function* () {
            if (!t2.connection || t2.state !== EU.Connected)
              return;
            const i3 = yield BA(t2.mutex.lock("From P2PChannel.restartICE"));
            let n2;
            try {
              n2 = yield BA(t2.connection.restartICE(e2));
              const r3 = yield BA(n2.next());
              if (r3.done)
                return;
              const o2 = r3.value, s2 = yield o2;
              switch (uF(t2.connection) && t2.reportPCStats(Date.now(), false, t2._pcStatsUploadType), e2) {
                case uU.UDP_TCP_RELAY:
                  t2._pcStatsUploadType = hU.UDP_TCP_RESTART;
                  break;
                case uU.TCP_RELAY:
                  t2._pcStatsUploadType = hU.TCP_RESTART;
                  break;
                case uU.RELAY:
                  t2._pcStatsUploadType = hU.RELAY_RESTART;
                  break;
                default:
                  t2._pcStatsUploadType = hU.OLD_RESTART;
              }
              t2._isTryConnecting = true, n2.next(s2);
            } catch (e3) {
              var r2;
              null === (r2 = n2) || void 0 === r2 || r2.throw(e3);
            } finally {
              i3();
            }
          })();
        }
        getUplinkNetworkQuality() {
          if (!this.connection)
            return 0;
          const e2 = this.connection.getStats(), t2 = this.localTrackMap.get(_U.LocalVideoTrack), i3 = this.localTrackMap.get(_U.LocalAudioTrack), n2 = e2.videoSend.find((e3) => e3.ssrc === (null == t2 ? void 0 : t2.ssrcs[0].ssrcId)), r2 = e2.audioSend.find((e3) => e3.ssrc === (null == i3 ? void 0 : i3.ssrcs[0].ssrcId));
          if (!n2 || !r2)
            return 1;
          const o2 = qw(this, fU.NeedSignalRTT), s2 = n2 ? n2.rttMs : void 0, a2 = r2 ? r2.rttMs : void 0, c2 = s2 && a2 ? (s2 + a2) / 2 : s2 || a2, d2 = (c2 && o2 ? (c2 + o2) / 2 : c2 || o2) || 0, l2 = 100 * e2.sendPacketLossRate * 0.7 / 50 + 0.3 * d2 / 1500, u2 = l2 < 0.17 ? 1 : l2 < 0.36 ? 2 : l2 < 0.59 ? 3 : l2 < 0.1 ? 4 : 5, h2 = null == t2 ? void 0 : t2.track;
          if (h2 && h2._encoderConfig && -1 === h2._hints.indexOf(fD.SCREEN_TRACK)) {
            const t3 = h2._encoderConfig.bitrateMax, i4 = e2.bitrate.actualEncoded;
            if (t3 && i4) {
              const e3 = (1e3 * t3 - i4) / (1e3 * t3);
              return Fk[e3 < 0.15 ? 0 : e3 < 0.3 ? 1 : e3 < 0.45 ? 2 : e3 < 0.6 ? 3 : 4][u2];
            }
          }
          return u2;
        }
        getDownlinkNetworkQuality() {
          if (!this.connection)
            return 0;
          const e2 = this.connection.getStats();
          let t2 = 0;
          return Array.from(this.remoteUserMap.entries()).forEach((i3) => {
            let [n2] = i3;
            const r2 = n2._audioSSRC, o2 = n2._videoSSRC, s2 = e2.audioRecv.find((e3) => e3.ssrc === r2), a2 = e2.videoRecv.find((e3) => e3.ssrc === o2);
            if (!s2 && !a2)
              return void (t2 += 1);
            const c2 = qw(this, fU.NeedSignalRTT), d2 = e2.rtt, l2 = (d2 && c2 ? (d2 + c2) / 2 : d2 || c2) || 0, u2 = s2 ? s2.jitterMs : void 0, h2 = e2.recvPacketLossRate;
            let p3 = 0.7 * h2 * 100 / 50 + 0.3 * l2 / 1500;
            u2 && (p3 = 0.6 * h2 * 100 / 50 + 0.2 * l2 / 1500 + 0.2 * u2 / 400);
            t2 += p3 < 0.1 ? 1 : p3 < 0.17 ? 2 : p3 < 0.36 ? 3 : p3 < 0.59 ? 4 : 5;
          }), this.remoteUserMap.size > 0 ? Math.round(t2 / this.remoteUserMap.size) : t2;
        }
        async muteLocalTrack(e2) {
          return new Wh((t2, i3) => {
            this.handleMuteLocalTrack(e2, t2, i3);
          });
        }
        async replaceTrack(e2, t2) {
          var i3;
          if (BN.debug("[".concat(this.store.clientId, "] P2PChannel replaceTrack from [").concat(e2.getTrackId(), "] to [").concat(t2.getTrackId(), "]")), !this.connection || this.state !== EU.Connected)
            return;
          const n2 = Array.from(this.localTrackMap.entries()).find((t3) => {
            let [, { track: i4 }] = t3;
            return e2 === i4;
          });
          if (!n2)
            return;
          const r2 = n2[0];
          if (e2 !== t2 && (this.unbindLocalTrackEvents([{ track: e2, type: r2 }]), this.bindLocalTrackEvents([{ track: t2, type: r2 }]), n2[1].track = t2), await (null === (i3 = this.connection) || void 0 === i3 ? void 0 : i3.replaceTrack(t2, n2[1].id)), this.isPlanB) {
            const e3 = n2[1];
            e3.id = t2._mediaStreamTrack.id, this.localTrackMap.set(r2, e3);
          }
          if (r2 === _U.LocalVideoTrack && !dN("DISABLE_DUAL_STREAM_USE_ENCODING") && QN().supportDualStreamEncoding) {
            const t3 = this.localTrackMap.get(_U.LocalVideoLowTrack);
            if (t3) {
              const i4 = e2._mediaStreamTrack.clone();
              t3.track._originMediaStreamTrack.stop(), t3.track._mediaStreamTrack = i4, t3.track._originMediaStreamTrack = i4, await new Wh((e3, i5) => {
                this.handleReplaceTrack(t3.track, e3, i5, true);
              });
            }
          }
        }
        filterTobePublishedTracks(e2, t2, i3) {
          const n2 = [], r2 = this.getAllTracks();
          e2 = Qw(e2 = e2.filter((e3) => -1 === r2.indexOf(e3)));
          let o2, s2 = false;
          const a2 = this.localTrackMap.get(_U.LocalAudioTrack);
          for (const r3 of e2) {
            if (r3 instanceof ak && (this.localTrackMap.has(_U.LocalVideoTrack) || s2 ? new Ew(_w.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS).throw() : (n2.push({ track: r3, type: _U.LocalVideoTrack }), s2 = true), t2)) {
              const e3 = this.getLowVideoTrack(r3, i3);
              n2.push({ track: e3, type: _U.LocalVideoLowTrack });
            }
            if (r3 instanceof TL)
              if (a2) {
                const e3 = a2.track;
                if (e3 instanceof RL)
                  aF([r3]), e3.addAudioTrack(r3), this.bindLocalAudioTrackEvents(r3, true);
                else {
                  const t3 = cF([e3, r3]);
                  BN.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection will replace audioTrack [").concat(t3.getTrackId(), "]")), this.replaceTrack(e3, t3);
                }
              } else if (o2 instanceof RL)
                aF([r3]), o2.addAudioTrack(r3);
              else if (o2 || !r3._useAudioElement && QN().webAudioMediaStreamDest && !r3._bypassWebAudio) {
                o2 = cF(o2 ? [r3, o2] : [r3]);
              } else
                o2 = r3;
          }
          return o2 && (BN.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection will send audioTrack [").concat(o2.getTrackId(), "]")), n2.push({ track: o2, type: _U.LocalAudioTrack })), n2;
        }
        filterTobeUnpublishedTracks(e2) {
          const t2 = [], i3 = this.getAllTracks();
          e2 = Qw(e2 = e2.filter((e3) => -1 !== i3.indexOf(e3)));
          for (const i4 of e2) {
            if (i4 instanceof TL) {
              const e3 = this.localTrackMap.get(_U.LocalAudioTrack);
              if (!e3)
                continue;
              e3.track instanceof RL ? (e3.track.removeAudioTrack(i4), this.unbindLocalAudioTrackEvents(i4), 0 === e3.track.trackList.length && (t2.push([_U.LocalAudioTrack, e3]), e3.track.close())) : t2.push([_U.LocalAudioTrack, e3]);
            }
            if (i4 instanceof ak) {
              const e3 = this.localTrackMap.get(_U.LocalVideoTrack);
              if (!e3)
                continue;
              t2.push([_U.LocalVideoTrack, e3]);
              const i5 = this.localTrackMap.get(_U.LocalVideoLowTrack);
              i5 && t2.push([_U.LocalVideoLowTrack, i5]);
            }
          }
          return t2;
        }
        filterTobePublishedDataChannels(e2) {
          return e2 = (e2 = Qw(e2)).filter((e3) => -1 === this.localDataChannels.findIndex((t2) => t2.id === e3.id));
        }
        filterTobeUnpublishedDataChannels(e2) {
          return e2 = (e2 = (e2 = Qw(e2)).filter((e3) => -1 !== this.localDataChannels.indexOf(e3))).filter((e3) => e3._originDataChannel);
        }
        bindLocalTrackEvents(e2) {
          e2.forEach((e3) => {
            let { track: t2, type: i3 } = e3;
            switch (i3) {
              case _U.LocalVideoTrack:
                t2.addListener(ED.GET_STATS, this.handleGetLocalVideoStats), t2.addListener(ED.GET_RTC_STATS, this.handleGetRTCStats), t2.addListener(ED.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t2.addListener(ED.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t2.addListener(ED.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t2.addListener(ED.NEED_UPDATE_VIDEO_SEND_PARAMETERS, this.handleUpdateVideoSendParameters), t2.addListener(ED.NEED_REPLACE_TRACK, this.handleReplaceTrack), t2.addListener(ED.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t2.addListener(ED.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
                break;
              case _U.LocalAudioTrack:
                this.bindLocalAudioTrackEvents(t2);
              case _U.LocalVideoLowTrack:
            }
          });
        }
        bindLocalAudioTrackEvents(e2, t2) {
          e2 instanceof RL ? e2.trackList.forEach((e3) => {
            e3.addListener(ED.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e3.addListener(ED.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e3.addListener(ED.GET_STATS, this.handleGetLocalAudioStats), e3.addListener(ED.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e3.addListener(ED.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
          }) : (e2.addListener(ED.GET_STATS, this.handleGetLocalAudioStats), e2.addListener(ED.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e2.addListener(ED.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e2.addListener(ED.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e2.addListener(ED.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack), t2 || (e2.addListener(ED.NEED_REPLACE_TRACK, this.handleReplaceTrack), e2.addListener(ED.NEED_REPLACE_MIXING_TRACK, this.handleReplaceMixingTrack)));
        }
        unbindLocalTrackEvents(e2) {
          e2 || (e2 = Array.from(this.localTrackMap.entries()).map((e3) => {
            let [t2, { track: i3 }] = e3;
            return { track: i3, type: t2 };
          })), e2.forEach((e3) => {
            let { track: t2, type: i3 } = e3;
            switch (i3) {
              case _U.LocalVideoTrack:
                t2.off(ED.GET_STATS, this.handleGetLocalVideoStats), t2.off(ED.GET_RTC_STATS, this.handleGetRTCStats), t2.off(ED.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t2.off(ED.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t2.off(ED.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t2.off(ED.NEED_UPDATE_VIDEO_SEND_PARAMETERS, this.handleUpdateVideoSendParameters), t2.off(ED.NEED_REPLACE_TRACK, this.handleReplaceTrack), t2.off(ED.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t2.off(ED.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
                break;
              case _U.LocalAudioTrack:
                this.unbindLocalAudioTrackEvents(t2);
              case _U.LocalVideoLowTrack:
            }
          });
        }
        unbindLocalAudioTrackEvents(e2) {
          e2 instanceof RL ? e2.trackList.forEach((e3) => {
            e3.off(ED.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e3.off(ED.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e3.off(ED.GET_STATS, this.handleGetLocalAudioStats), e3.off(ED.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e3.off(ED.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
          }) : (e2.off(ED.GET_STATS, this.handleGetLocalAudioStats), e2.off(ED.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e2.off(ED.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e2.off(ED.NEED_REPLACE_TRACK, this.handleReplaceTrack), e2.off(ED.NEED_REPLACE_MIXING_TRACK, this.handleReplaceMixingTrack), e2.off(ED.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e2.off(ED.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack));
        }
        bindRemoteTrackEvents(e2, t2) {
          t2 instanceof vk && t2.addListener(ED.GET_STATS, (t3) => {
            t3(this.handleGetRemoteVideoStats(e2));
          }), t2 instanceof Ik && t2.addListener(ED.GET_STATS, (t3) => {
            t3(this.handleGetRemoteAudioStats(e2));
          });
        }
        unbindRemoteTrackEvents(e2) {
          e2 && e2.removeAllListeners(ED.GET_STATS);
        }
        unbindAllRemoteTrackEvents() {
          Array.from(this.remoteUserMap.entries()).forEach((e2) => {
            let [t2, i3] = e2;
            i3.has(lU.AUDIO) && this.unbindRemoteTrackEvents(t2._audioTrack), i3.has(lU.VIDEO) && this.unbindRemoteTrackEvents(t2._videoTrack);
          });
        }
        createGatewayPublishMessage(e2, t2) {
          return e2.map((e3, i3) => {
            var n2;
            let r2, o2, { track: s2, type: a2 } = e3;
            switch (a2) {
              case _U.LocalAudioTrack:
                r2 = ZM.Audio, o2 = { dtx: s2 instanceof SL && s2._config.DTX, hq: false, lq: false, stereo: false, speech: false };
                break;
              case _U.LocalVideoTrack:
                r2 = Dn(n2 = s2._hints).call(n2, fD.SCREEN_TRACK) ? ZM.Screen : ZM.High, o2 = qF(qF({}, $U(s2)), {}, { codec: this.store.codec, svc_mode: ox() });
                break;
              case _U.LocalVideoLowTrack:
                r2 = ZM.Low, o2 = qF(qF({}, $U(s2)), {}, { codec: this.store.codec, svc_mode: ox() });
            }
            return { stream_type: r2, attributes: o2, ssrcs: t2[i3] };
          });
        }
        createGatewayUnpublishMessage(e2) {
          return e2.map((e3) => {
            var t2;
            let i3, [n2, { track: r2, ssrcs: o2, id: s2 }] = e3;
            switch (n2) {
              case _U.LocalVideoTrack:
                i3 = Dn(t2 = r2._hints).call(t2, fD.SCREEN_TRACK) ? ZM.Screen : ZM.High;
                break;
              case _U.LocalAudioTrack:
                i3 = ZM.Audio;
                break;
              case _U.LocalVideoLowTrack:
                i3 = ZM.Low;
            }
            return { stream_type: i3, ssrcs: o2, mid: s2 };
          });
        }
        assignLocalTracks(e2, t2) {
          e2.forEach((e3, i3) => {
            let { track: n2, type: r2 } = e3;
            this.localTrackMap.set(r2, { track: n2, id: t2[i3].id, ssrcs: t2[i3].localSSRC });
          });
        }
        withdrawLocalTracks(e2) {
          e2.forEach((e3) => {
            let [t2] = e3;
            this.localTrackMap.delete(t2);
          });
        }
        bindConnectionEvents(e2) {
          e2.onConnectionStateChange = async (t2) => {
            if (BN.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onConnectionStateChange(").concat(t2, ")")), this.emit(fU.PeerConnectionStateChange, t2), "connected" !== t2 || this.store.keyMetrics.peerConnectionEnd || this.store.peerConnectionEnd(), "connected" === t2) {
              this._restartTimer && (window.clearTimeout(this._restartTimer), this._restartTimer = void 0), e2 instanceof fF && WF(e2, true), this._isTryConnecting && this.reportPCStats(Date.now(), true, this._pcStatsUploadType), this._isTryConnecting = false, this._isStartRestartIce = false, this._pcStatsUploadType = hU.DISCONNECTED_OR_FAILED;
              if ("CONNECTED" === qw(this, fU.QueryClientConnectionState) && this._isWaitPcToRePub) {
                const e3 = this.pendingLocalTracks.map((e4) => e4.getTrackId()), t3 = this.pendingLocalDataChannels.map((e4) => "dc_".concat(e4.id));
                zN.reportApiInvoke(this.store.sessionId, { name: Lw.REPUB_AFTER_PC_CONNECTED, options: e3.concat(t3), tag: kw.TRACER }).onSuccess(), this.republish();
              }
            }
            if (dN("NEW_ICE_RESTART") && e2 instanceof fF && !Kb() && !this._forceTurn) {
              if (Dn(pU).call(pU, t2)) {
                if (this._isStartRestartIce)
                  return;
                this._isStartRestartIce = true;
                const t3 = (t4) => {
                  if (uF(e2)) {
                    BN.debug("[".concat(this.store.clientId, "] [P2PChannel] try to restartICE, type is ").concat(t4));
                    "CONNECTED" === qw(this, fU.QueryClientConnectionState) && this.emit(fU.RequestRestartICE, t4);
                  }
                }, i3 = () => {
                  uF(e2) && (this.reportPCStats(Date.now(), false, this._pcStatsUploadType), BN.debug("[".concat(this.store.clientId, "] P2PConnection disconnected timeout, force reconnect")), setTimeout(() => this.emit(fU.P2PLost), 0), this.iceFailedCount += 1, this.requestReconnect());
                };
                return void (this._restartTimer = window.setTimeout(() => {
                  HF(e2, t3, i3);
                }, 800));
              }
            } else {
              if ("disconnected" === t2 && "disconnected" === e2.iceConnectionState)
                return setTimeout(() => {
                  if ("disconnected" === e2.iceConnectionState && dN("ICE_RESTART")) {
                    "CONNECTED" === qw(this, fU.QueryClientConnectionState) && this.emit(fU.RequestRestartICE);
                  }
                }, 800), void setTimeout(() => {
                  "disconnected" === e2.peerConnectionState && (BN.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection disconnected timeout 4000ms, force reconnect")), this.reportPCStats(Date.now(), false, this._pcStatsUploadType), this._isTryConnecting = false, setTimeout(() => this.emit(fU.P2PLost), 0), this.iceFailedCount += 1, this.requestReconnect());
                }, 4e3);
              "failed" === t2 && (BN.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection state failed, force reconnect")), this.reportPCStats(Date.now(), false, this._pcStatsUploadType), setTimeout(() => this.emit(fU.P2PLost), 0), this.iceFailedCount += 1, await this.requestReconnect());
            }
          }, e2.onICEConnectionStateChange = (e3) => {
            "connected" !== e3 || this.store.keyMetrics.iceConnectionEnd || this.store.iceConnectionEnd(), BN.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICEConnectionStateChange(").concat(e3, ")")), zN.reportApiInvoke(this.store.sessionId, { name: "ICEConnectionStateChange", options: e3, tag: kw.TRACER }).onSuccess(), this.emit(fU.IceConnectionStateChange, e3);
          }, e2.onICETransportStateChange = (e3) => {
            BN.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICETransportStateChange(").concat(e3, ")"));
          }, e2.onDTLSTransportStateChange = (e3) => {
            BN.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportStateChange(").concat(e3, ")"));
          }, e2.onDTLSTransportError = (e3) => {
            BN.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportError(").concat(e3, ")"));
          }, e2.onFirstAudioDecoded = (e3) => {
            var t2;
            const i3 = Array.from(ON(t2 = this.remoteUserMap).call(t2)).find((t3) => t3._audioSSRC === e3);
            var n2;
            i3 && (this.store.subscribe(i3.uid, "audio", void 0, void 0, void 0, Date.now()), null === (n2 = i3.audioTrack) || void 0 === n2 || n2.emit(CD.FIRST_FRAME_DECODED), zN.firstRemoteFrame(this.store.sessionId, HN.FIRST_AUDIO_DECODE, KN.FIRST_AUDIO_DECODE, { peer: i3._uintid, subscribeElapse: UV.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId }));
          }, e2.onFirstAudioReceived = (e3) => {
            var t2;
            const i3 = Array.from(ON(t2 = this.remoteUserMap).call(t2)).find((t3) => t3._audioSSRC === e3);
            i3 && zN.firstRemoteFrame(this.store.sessionId, HN.FIRST_AUDIO_RECEIVED, KN.FIRST_AUDIO_RECEIVED, { peer: i3._uintid, subscribeElapse: UV.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId });
          }, e2.onFirstVideoDecoded = (e3, t2, i3) => {
            this.reportVideoFirstFrameDecoded(e3, t2, i3);
          }, e2.onFirstVideoReceived = (e3) => {
            var t2;
            const i3 = Array.from(ON(t2 = this.remoteUserMap).call(t2)).find((t3) => t3._videoSSRC === e3);
            i3 && zN.firstRemoteFrame(this.store.sessionId, HN.FIRST_VIDEO_RECEIVED, KN.FIRST_VIDEO_RECEIVED, { peer: i3._uintid, subscribeElapse: UV.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId });
          }, e2.onSelectedLocalCandidateChanged = (e3, t2) => {
            const i3 = "relay" === e3.candidateType, n2 = "relay" === t2.candidateType;
            "unknown" !== t2.candidateType && i3 === n2 || this.emit(fU.ConnectionTypeChange, i3), BN.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.SelectedLocalCandidateChanged(").concat(JSON.stringify(rx(t2)), " -> ").concat(JSON.stringify(rx(e3)), ")"));
          }, e2.onSelectedRemoteCandidateChanged = (e3, t2) => {
            BN.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.SelectedRemoteCandidateChanged(").concat(JSON.stringify(rx(t2)), " -> ").concat(JSON.stringify(rx(e3)), ")"));
          }, e2.onFirstVideoDecodedTimeout = (e3) => {
            this.reportVideoFirstFrameDecoded(e3, void 0, void 0, true);
          }, e2.getLocalVideoStats = () => {
            const e3 = this.statsCollector.getLocalVideoTrackStats(), t2 = this.statsCollector.getRTCStats();
            return qF(qF({}, e3), t2);
          }, e2.onICECandidateError = (e3) => {
            this._iceError = e3;
          };
        }
        resetConnection(e2) {
          e2 instanceof fF && function(e3) {
            BF.delete(e3.id), WF(e3);
          }(e2), e2.close(), this.emit(fU.PeerConnectionStateChange, "closed"), function(e3) {
            e3.onConnectionStateChange = void 0, e3.onICEConnectionStateChange = void 0, e3.onICETransportStateChange = void 0, e3.onDTLSTransportStateChange = void 0, e3.onDTLSTransportError = void 0, e3.onFirstAudioDecoded = void 0, e3.onFirstAudioReceived = void 0, e3.onFirstVideoDecoded = void 0, e3.onFirstVideoReceived = void 0, e3.onSelectedLocalCandidateChanged = void 0, e3.onSelectedRemoteCandidateChanged = void 0, e3.onFirstVideoDecodedTimeout = void 0, e3.getLocalVideoStats = void 0;
          }(e2), this._isWaitPcToRePub = false;
        }
        filterTobeMutedTracks(e2) {
          const t2 = [];
          if (-1 === this.getAllTracks().indexOf(e2))
            return t2;
          const i3 = this.localTrackMap.get(_U.LocalAudioTrack);
          if (e2 instanceof TL && (null == i3 ? void 0 : i3.track) instanceof RL)
            return i3.track.isActive || t2.push([_U.LocalAudioTrack, i3]), t2;
          const n2 = Array.from(this.localTrackMap.entries()).find((t3) => {
            let [, { track: i4 }] = t3;
            return e2 === i4;
          });
          if (n2 && (t2.push(n2), n2[0] === _U.LocalVideoTrack)) {
            const e3 = this.localTrackMap.get(_U.LocalVideoLowTrack);
            e3 && t2.push([_U.LocalVideoLowTrack, e3]);
          }
          return t2;
        }
        filterTobeUnmutedTracks(e2) {
          const t2 = [], i3 = this.localTrackMap.get(_U.LocalAudioTrack);
          if (e2 instanceof TL && (null == i3 ? void 0 : i3.track) instanceof RL)
            return i3.track.isActive && t2.push([_U.LocalAudioTrack, i3]), t2;
          const n2 = Array.from(this.localTrackMap.entries()).find((t3) => {
            let [, { track: i4 }] = t3;
            return e2 === i4;
          });
          if (n2)
            if (n2[0] === _U.LocalVideoTrack) {
              t2.push(n2);
              const e3 = this.localTrackMap.get(_U.LocalVideoLowTrack);
              e3 && t2.push([_U.LocalVideoLowTrack, e3]);
            } else
              t2.push(n2);
          return t2;
        }
        createMuteMessage(e2) {
          return e2.map((e3) => {
            var t2;
            let i3, [n2, { track: r2, ssrcs: o2, id: s2 }] = e3;
            switch (n2) {
              case _U.LocalAudioTrack:
                i3 = ZM.Audio;
                break;
              case _U.LocalVideoTrack:
                i3 = Dn(t2 = r2._hints).call(t2, fD.SCREEN_TRACK) ? ZM.Screen : ZM.High;
                break;
              case _U.LocalVideoLowTrack:
                i3 = ZM.Low;
            }
            return { stream_type: i3, ssrcs: o2, mid: s2 };
          });
        }
        createUnmuteMessage(e2) {
          return e2.map((e3) => {
            var t2;
            let i3, [n2, { track: r2, ssrcs: o2, id: s2 }] = e3;
            switch (n2) {
              case _U.LocalAudioTrack:
                i3 = ZM.Audio;
                break;
              case _U.LocalVideoTrack:
                i3 = Dn(t2 = r2._hints).call(t2, fD.SCREEN_TRACK) ? ZM.Screen : ZM.High;
                break;
              case _U.LocalVideoLowTrack:
                i3 = ZM.Low;
            }
            return { stream_type: i3, ssrcs: o2, mid: s2 };
          });
        }
        filterTobeUnSubscribedTracks(e2, t2) {
          const i3 = [], n2 = this.remoteUserMap.get(e2);
          if (!n2)
            return i3;
          if (t2) {
            const r2 = n2.get(t2);
            if (!r2)
              return i3;
            i3.push([e2, { kind: t2, id: r2 }]);
          } else
            Array.from(n2.entries()).forEach((t3) => {
              let [n3, r2] = t3;
              i3.push([e2, { kind: n3, id: r2 }]);
            });
          return i3;
        }
        filterTobeUnSubscribedDataChannels(e2, t2) {
          const i3 = [];
          return t2.forEach((t3) => {
            var n2;
            null !== (n2 = this.remoteDataChannelMap.get(e2)) && void 0 !== n2 && n2.has(t3.id) && i3.push(t3);
          }), i3;
        }
        createUnsubscribeMessage(e2) {
          const t2 = [];
          return e2.forEach((e3) => {
            let [i3, { kind: n2, id: r2 }] = e3;
            switch (n2) {
              case lU.VIDEO:
                return void (i3._videoSSRC && t2.push({ stream_type: lU.VIDEO, ssrcId: i3._videoSSRC }));
              case lU.AUDIO:
                return void (i3._audioSSRC && t2.push({ stream_type: lU.AUDIO, ssrcId: i3._audioSSRC }));
            }
          }), t2;
        }
        createUnsubscribeAllMessage(e2) {
          const t2 = /* @__PURE__ */ new Map();
          return e2.forEach((e3) => {
            let [i3, { kind: n2 }] = e3;
            if (t2.has(i3)) {
              let e4 = t2.get(i3);
              n2 === lU.VIDEO ? e4 |= tU.Video : e4 |= tU.Audio, t2.set(i3, e4);
            } else
              n2 === lU.VIDEO ? t2.set(i3, tU.Video) : t2.set(i3, tU.Audio);
          }), { users: Array.from(t2.entries()).map((e3) => {
            let [t3, i3] = e3;
            return { stream_id: t3.uid, stream_type: i3 };
          }) };
        }
        withdrawRemoteTracks(e2) {
          e2.forEach((e3) => {
            let [t2, { kind: i3 }] = e3;
            const n2 = this.remoteUserMap.get(t2);
            n2 && (n2.delete(i3), 0 === Array.from(n2.entries()).length && this.remoteUserMap.delete(t2));
          });
        }
        async updateBitrateLimit(e2) {
          const t2 = this.localTrackMap.get(_U.LocalVideoTrack), i3 = this.localTrackMap.get(_U.LocalVideoLowTrack);
          t2 && (await t2.track.setBitrateLimit(e2.uplink), await new Wh((e3, i4) => {
            this.handleUpdateVideoEncoder(t2.track, e3, i4, true);
          })), i3 && e2.low_stream_uplink && (await i3.track.setBitrateLimit({ max_bitrate: e2.low_stream_uplink.bitrate, min_bitrate: e2.low_stream_uplink.bitrate || 0 }), await new Wh((e3, t3) => {
            this.handleUpdateVideoEncoder(i3.track, e3, t3, true);
          }));
        }
        isP2PDisconnected() {
          if (this.connection) {
            return "connected" !== this.connection.peerConnectionState;
          }
          return true;
        }
        mapPubResToRemoteConfig(e2, t2, i3) {
          return e2.map((e3, n2) => {
            var r2;
            let { stream_type: o2 } = e3;
            const s2 = null === (r2 = t2.find((e4) => {
              let { stream_type: t3 } = e4;
              return o2 === t3;
            })) || void 0 === r2 ? void 0 : r2.attributes;
            if (s2 && dN("DISABLE_SCREEN_SHARE_REMB")) {
              const e4 = i3[n2]._hints;
              (Dn(e4).call(e4, fD.SCREEN_TRACK) || Dn(e4).call(e4, fD.SCREEN_LOW_TRACK)) && (s2.remb = false, BN.debug("disable remb for screen share, hints:", e4));
            }
            return s2;
          });
        }
        async tryToUnmuteAudio(e2) {
          for (let i3 = 0; i3 < e2.length; i3++)
            if (e2[i3] instanceof TL) {
              var t2;
              const n2 = this.filterTobeUnmutedTracks(e2[i3]);
              if (0 === n2.length)
                continue;
              await (null === (t2 = this.connection) || void 0 === t2 ? void 0 : t2.unmuteLocal(n2.map((e3) => {
                let [, { id: t3 }] = e3;
                return t3;
              })));
              const r2 = this.createUnmuteMessage(n2);
              return void await Yw(this, fU.RequestUnmuteLocal, r2);
            }
        }
        bindStatsUploaderEvents() {
          this.statsUploader.requestStats = () => this.getStats(), this.statsUploader.requestLocalMedia = () => Array.from(this.localTrackMap.entries()), this.statsUploader.requestRemoteMedia = () => Array.from(this.remoteUserMap.entries()), this.statsUploader.requestVideoIsReady = (e2) => {
            var t2;
            return !(null === (t2 = this.connection) || void 0 === t2 || !t2.getRemoteVideoIsReady(e2));
          }, this.statsUploader.requestUpload = (e2, t2) => this.emit(fU.RequestUpload, e2, t2), this.statsUploader.requestUploadStats = (e2) => this.emit(fU.RequestUploadStats, e2), this.statsUploader.requestAllTracks = () => this.getAllTracks(), this.statsUploader.requestTransportStats = () => {
            var e2;
            return { connectState: (null === (e2 = this.connection) || void 0 === e2 ? void 0 : e2.peerConnectionState) || "closed" };
          };
        }
        unbindStatsUploaderEvents() {
          this.statsUploader.requestStats = void 0, this.statsUploader.requestLocalMedia = void 0, this.statsUploader.requestRemoteMedia = void 0, this.statsUploader.requestVideoIsReady = void 0;
        }
        async requestReconnect() {
          this.dtlsFailedCount += 1, await lO(AO(this.dtlsFailedCount, yO)), this.emit(fU.RequestReconnect);
        }
        async reconnectP2P() {
          const e2 = Array.from(this.localTrackMap.entries()), t2 = this.createGatewayUnpublishMessage(e2);
          Array.from(this.remoteUserMap.entries()), t2.length > 0 && await Kw(this, fU.RequestUnpublishForReconnectPC, t2), this.disconnectForReconnect(), this.emit(fU.RequestReconnectPC);
        }
        canPublishLowStream() {
          return this.localTrackMap.has(_U.LocalVideoTrack) || this.pendingLocalTracks.some((e2) => e2 instanceof ak);
        }
        throwIfTrackTypeNotMatch(e2) {
          if (e2.filter((e3) => e3 instanceof ak).length > 1)
            throw new Ew(_w.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
          if (e2.filter((e3) => e3 instanceof TL).length > 1 && (e2.some((e3) => e3 instanceof TL && e3._bypassWebAudio) || !QN().webAudioMediaStreamDest))
            throw new Ew(_w.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
          for (const t2 of e2) {
            if (t2 instanceof ak && this.pendingLocalTracks.some((e3) => e3 instanceof ak))
              throw new Ew(_w.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
            if (t2 instanceof TL && this.pendingLocalTracks.some((e3) => e3 instanceof TL) && (!QN().webAudioMediaStreamDest || t2._bypassWebAudio || this.pendingLocalTracks.some((e3) => e3 instanceof TL && e3._bypassWebAudio)))
              throw new Ew(_w.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
          }
        }
        getLowVideoTrack(e2, t2) {
          var i3;
          const n2 = !dN("DISABLE_DUAL_STREAM_USE_ENCODING") && QN().supportDualStreamEncoding, r2 = qF(qF({}, { width: 160, height: 120, framerate: 15, bitrate: 50 }), t2);
          let o2;
          o2 = n2 ? e2._mediaStreamTrack.clone() : TF(e2, r2);
          const s2 = uO(8, "track-low-"), a2 = new ak(o2, qF(qF({}, n2 && { scaleResolutionDownBy: nx(r2, e2) }), {}, { frameRate: r2.framerate, bitrateMax: r2.bitrate, bitrateMin: r2.bitrate }), void 0, void 0, s2);
          return a2.on(gD.TRANSCEIVER_UPDATED, (t3) => {
            e2._updateRtpTransceiver(t3, mD.LOW_STREAM);
          }), a2._hints.push(fD.LOW_STREAM), Dn(i3 = e2._hints).call(i3, fD.SCREEN_TRACK) && a2._hints.push(fD.SCREEN_LOW_TRACK), e2.on("sei-to-send", (e3) => {
            a2.emit("sei-to-send", e3);
          }), e2.addListener(ED.NEED_CLOSE, () => {
            a2.close();
          }), a2;
        }
        async globalLock() {
          return this.mutex.lock("From P2PChannel.globalLock");
        }
        async reportPCStats(e2, t2, i3) {
          let n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
          if (this.connection && this.connection instanceof fF) {
            var r2, o2, s2, a2;
            const c2 = this.store.keyMetrics.descriptionStart || 0, { iceConnectionState: d2, dtlsTransportState: l2, peerConnectionState: u2 } = this.connection, { local: h2, remote: p3 } = await this.connection.getSelectedCandidatePair();
            zN.pcStats(this.store.sessionId, { startTime: c2, eventElapse: e2 - c2 || 0, iceconnectionsate: d2, dtlsstate: l2, connectionstate: u2, intSucc: t2 ? 1 : 2, error: this._iceError || n2 || "", selectedLocalCandidateProtocol: null !== (r2 = null == h2 ? void 0 : h2.protocol) && void 0 !== r2 ? r2 : "", selectedLocalCandidateType: null !== (o2 = h2.candidateType) && void 0 !== o2 ? o2 : "", selectedLocalCandidateAddress: "".concat(h2.address, ":").concat(h2.port), selectedRemoteCandidateProtocol: null !== (s2 = p3.protocol) && void 0 !== s2 ? s2 : "", selectedRemoteCandidateType: null !== (a2 = p3.candidateType) && void 0 !== a2 ? a2 : "", selectedRemoteCandidateAddress: "".concat(p3.address, ":").concat(p3.port), restartCnt: i3, preallocation: this.connection.isPreallocation }), this._iceError = null;
          }
        }
        reportVideoFirstFrameDecoded(e2, t2, i3, n2) {
          var r2;
          const o2 = Array.from(ON(r2 = this.remoteUserMap).call(r2)).find((t3) => t3._videoSSRC === e2);
          if (o2) {
            n2 || this.store.subscribe(o2.uid, "video", void 0, void 0, void 0, void 0, Date.now());
            const r3 = this.store.keyMetrics, s2 = r3.subscribe.find((e3) => e3.userId === o2.uid && "video" === e3.type);
            zN.firstRemoteVideoDecode(this.store.sessionId, HN.FIRST_VIDEO_DECODE, KN.FIRST_VIDEO_DECODE, { peer: o2._uintid, videowidth: t2, videoheight: i3, subscribeElapse: UV.measureFromSubscribeStart(this.store.clientId, e2), subscribeRequestid: e2, p2pid: this.store.p2pId, apEnd: r3.requestAPEnd || 0, apStart: r3.requestAPStart || 0, joinGwEnd: r3.joinGatewayEnd || 0, joinGwStart: r3.joinGatewayStart || 0, pcEnd: r3.peerConnectionEnd || 0, pcStart: r3.peerConnectionStart || 0, subscriberEnd: (null == s2 ? void 0 : s2.subscribeEnd) || 0, subscriberStart: (null == s2 ? void 0 : s2.subscribeStart) || 0, videoAddNotify: (null == s2 ? void 0 : s2.streamAdded) || 0, state: n2 ? 1 : 0, firstFrame: (null == s2 ? void 0 : s2.firstFrame) || 0 });
          }
        }
        async remoteMediaSsrcChanged(e2, t2, i3) {
          if (!this.connection)
            return false;
          const n2 = this.remoteUserMap.get(e2);
          if (!n2)
            return false;
          const r2 = n2.get(t2);
          if (!r2)
            return false;
          const o2 = await this.connection.getRemoteSSRC(r2);
          return void 0 !== o2 && o2 !== i3;
        }
        unbindRtpTransceiver() {
          0 !== this.localTrackMap.size && Array.from(this.localTrackMap.entries()).forEach((e2) => {
            let [t2, { track: i3 }] = e2;
            t2 === _U.LocalVideoLowTrack ? i3._updateRtpTransceiver(void 0, mD.LOW_STREAM) : i3._updateRtpTransceiver(void 0);
          });
        }
      }, IM(KF.prototype, "startP2PConnection", [QF], Object.getOwnPropertyDescriptor(KF.prototype, "startP2PConnection"), KF.prototype), IM(KF.prototype, "connect", [QF], Object.getOwnPropertyDescriptor(KF.prototype, "connect"), KF.prototype), IM(KF.prototype, "updateRemoteRTPCapabilities", [QF], Object.getOwnPropertyDescriptor(KF.prototype, "updateRemoteRTPCapabilities"), KF.prototype), IM(KF.prototype, "publishDataChannel", [QF], Object.getOwnPropertyDescriptor(KF.prototype, "publishDataChannel"), KF.prototype), IM(KF.prototype, "unpublish", [QF], Object.getOwnPropertyDescriptor(KF.prototype, "unpublish"), KF.prototype), IM(KF.prototype, "unpublishDataChannel", [QF], Object.getOwnPropertyDescriptor(KF.prototype, "unpublishDataChannel"), KF.prototype), IM(KF.prototype, "unpublishLowStream", [QF], Object.getOwnPropertyDescriptor(KF.prototype, "unpublishLowStream"), KF.prototype), IM(KF.prototype, "subscribeDataChannel", [QF], Object.getOwnPropertyDescriptor(KF.prototype, "subscribeDataChannel"), KF.prototype), IM(KF.prototype, "subscribe", [QF], Object.getOwnPropertyDescriptor(KF.prototype, "subscribe"), KF.prototype), IM(KF.prototype, "massSubscribe", [QF], Object.getOwnPropertyDescriptor(KF.prototype, "massSubscribe"), KF.prototype), IM(KF.prototype, "unsubscribe", [QF], Object.getOwnPropertyDescriptor(KF.prototype, "unsubscribe"), KF.prototype), IM(KF.prototype, "unsubscribeDataChannel", [QF], Object.getOwnPropertyDescriptor(KF.prototype, "unsubscribeDataChannel"), KF.prototype), IM(KF.prototype, "massUnsubscribe", [QF], Object.getOwnPropertyDescriptor(KF.prototype, "massUnsubscribe"), KF.prototype), IM(KF.prototype, "muteRemote", [QF], Object.getOwnPropertyDescriptor(KF.prototype, "muteRemote"), KF.prototype), IM(KF.prototype, "unmuteRemote", [QF], Object.getOwnPropertyDescriptor(KF.prototype, "unmuteRemote"), KF.prototype), IM(KF.prototype, "hasRemoteMediaWithLock", [QF], Object.getOwnPropertyDescriptor(KF.prototype, "hasRemoteMediaWithLock"), KF.prototype), IM(KF.prototype, "disconnectForReconnect", [QF], Object.getOwnPropertyDescriptor(KF.prototype, "disconnectForReconnect"), KF.prototype), IM(KF.prototype, "updateBitrateLimit", [QF], Object.getOwnPropertyDescriptor(KF.prototype, "updateBitrateLimit"), KF.prototype), IM(KF.prototype, "remoteMediaSsrcChanged", [QF], Object.getOwnPropertyDescriptor(KF.prototype, "remoteMediaSsrcChanged"), KF.prototype), KF);
      function QF(e2, t2, i3) {
        const n2 = e2[t2];
        if ("function" != typeof n2)
          throw new Error("Cannot use mutex on object property.");
        return i3.value = async function() {
          const e3 = this.mutex, i4 = await e3.lock("From P2PChannel.".concat(t2));
          try {
            for (var r2 = arguments.length, o2 = new Array(r2), s2 = 0; s2 < r2; s2++)
              o2[s2] = arguments[s2];
            return await n2.apply(this, o2);
          } finally {
            i4();
          }
        }, i3;
      }
      function ZF(e2, t2) {
        var i3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i3.push.apply(i3, n2);
        }
        return i3;
      }
      function $F(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i3 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? ZF(Object(i3), true).forEach(function(t3) {
            QI(e2, t3, i3[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : ZF(Object(i3)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
          });
        }
        return e2;
      }
      const eB = Date.now(), tB = 20, iB = /* @__PURE__ */ new Map(), nB = /* @__PURE__ */ new Map();
      async function rB(e2) {
        const t2 = iB.get(e2), i3 = Array.isArray(t2) && t2[t2.length - 1], n2 = nB.get(e2);
        if (!i3)
          return void (n2.isSyncing = false);
        const r2 = { uid: i3.uid, payload: i3.payload };
        0 === n2.firstRecvTs && (n2.firstRecvTs = i3.recvTs, n2.firstSendTs = i3.sendTs);
        const o2 = i3.sendTs - n2.firstSendTs, s2 = o2 - (Date.now() - n2.firstRecvTs);
        s2 > 0 && (n2.firstRecvTs = Date.now() - o2);
        let a2 = i3.mediaDelay + s2;
        a2 <= 0 ? (t2.pop(), oB(i3.context, r2), a2 = 0) : a2 = Math.min(a2, tB), setTimeout(() => t2.length && rB(e2), a2);
      }
      function oB(e2, t2) {
        e2.safeEmit(jw.STREAM_MESSAGE, t2.uid, t2.payload), e2.onStreamMessage && e2.onStreamMessage(t2);
      }
      function sB(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i3 = arguments.length > 2 ? arguments[2] : void 0;
        if (!e2.syncWithAudio)
          return oB(i3, { uid: e2.uid, payload: e2.payload });
        const n2 = "".concat(i3.id, "-").concat(e2.uid), r2 = iB.get(n2) || [], o2 = r2.findIndex((t3) => e2.sendTs >= t3.sendTs), s2 = $F($F({}, e2), {}, { context: i3, mediaDelay: t2, recvTs: Date.now() });
        -1 === o2 ? r2.push(s2) : r2.splice(o2, 0, s2), iB.set(n2, r2);
        let a2 = false;
        var c2;
        nB.has(n2) ? a2 = !(null === (c2 = nB.get(n2)) || void 0 === c2 || !c2.isSyncing) : nB.set(n2, { isSyncing: a2, firstRecvTs: 0, firstSendTs: 0 });
        a2 || rB(n2);
      }
      const aB = xb().name;
      function cB(e2, t2) {
        var i3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i3.push.apply(i3, n2);
        }
        return i3;
      }
      function dB(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i3 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? cB(Object(i3), true).forEach(function(t3) {
            QI(e2, t3, i3[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : cB(Object(i3)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
          });
        }
        return e2;
      }
      const lB = "websdk_ng_cache_parameter", uB = dN("MAX_PRELOAD_ASYNC_LENGTH"), hB = 1e4, pB = /* @__PURE__ */ new Map(), _B = [];
      let EB = null, fB = 0, mB = 0;
      const TB = /* @__PURE__ */ new Map(), SB = function(e2, t2) {
        const i3 = [];
        let n2 = 0;
        const r2 = async () => {
          const e3 = i3.shift();
          e3 && await e3(), i3.length > 0 && n2 < t2 ? r2() : n2--;
        };
        return async function() {
          for (var o2 = arguments.length, s2 = new Array(o2), a2 = 0; a2 < o2; a2++)
            s2[a2] = arguments[a2];
          return new Wh(async (o3, a3) => {
            i3.push(async () => {
              try {
                const t3 = await e2(...s2);
                o3(t3);
              } catch (e3) {
                a3(e3);
              }
            }), n2 < t2 && (n2++, r2());
          });
        };
      }(RB, uB), gB = Ab.CancelToken.source();
      async function RB(e2, t2, i3, n2, r2, o2) {
        try {
          if (!dN("ENABLE_PRELOAD"))
            return;
          if (!QN().supportWebCrypto)
            return void iO(() => {
              BN.warn("Your browser does not support preloading, this feature  be run in a secure environment");
            }, "preload_webcrypto_not_supported");
          if (!i3 && null !== i3)
            throw new Ew(_w.INVALID_PARAMS, "Invalid token: ".concat(i3, ". If you don not use token, set it to null"));
          i3 && gw(i3, "token", 1, 2047), gw(e2, "appid", 1, 2047), xM(t2), n2 && VM(n2);
          const s2 = hO();
          BN.debug("preload channel ".concat(t2, ", uid is ").concat(n2));
          const a2 = { appId: e2, cname: t2, token: i3 || e2, uid: "string" != typeof n2 ? n2 : null, sid: s2, proxyServer: r2 };
          let c2, d2;
          "string" == typeof n2 ? (a2.stringUid = n2, [d2, c2] = await Wh.all([yV(n2, { sid: s2, appId: e2 }, gB.token), bV(dB(dB({}, a2), {}, { token: i3 || e2, uid: 0 }), gB.token)]), a2.uid = d2.uid, c2.gatewayInfo.uid = a2.uid, c2.gatewayInfo.res.uid = a2.uid) : (o2 && (a2.stringUid = o2), c2 = await bV(a2, gB.token));
          const l2 = { sid: s2, appId: e2, cname: t2, token: i3 || e2, uid: a2.stringUid || n2, intUid: a2.uid || c2.gatewayInfo.uid, stringUid: a2.stringUid, ts: Date.now(), sua: d2, ap: c2 };
          await async function(e3) {
            let t3;
            try {
              e3.uid && vB({ appId: e3.appId, cname: e3.cname, token: e3.token, uid: e3.uid, stringUid: e3.stringUid });
              const i4 = OB(e3), n3 = await async function(e4, t4) {
                try {
                  const i5 = await window.crypto.subtle.importKey("raw", oO(t4), "AES-GCM", false, ["encrypt"]), n4 = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: new Uint8Array(1) }, i5, nO(window.btoa(JSON.stringify(e4))));
                  return rO(new Uint8Array(n4));
                } catch (e5) {
                  return;
                }
              }(e3, e3.token || e3.appId);
              if (!n3)
                return;
              t3 = bB(lB);
              const r3 = t3 ? JSON.parse(t3) : [];
              r3.push({ [i4]: n3 }), r3.length > dN("AP_CACHE_NUM") && r3.shift(), wB(lB, JSON.stringify(r3));
            } catch (e4) {
              BN.warn("Error caching server parameters:", e4.message), wB(lB, "");
            }
          }(l2), fB++;
        } catch (e3) {
          throw mB++, function(e4) {
            EB || (EB = window.setTimeout(() => {
              let t4 = "";
              TB.forEach((e5, i4) => {
                t4 += "".concat(i4, ": ").concat(e5, " ;");
              }), zN.reportApiInvoke(null, { name: Lw.PRELOAD, options: { success: fB, failed: mB, err: t4 } }).onError(e4), fB = 0, mB = 0, TB.clear(), EB = null;
            }, hB));
            const t3 = TB.get(e4.code) || 0;
            TB.set(e4.code, t3 + 1);
          }(e3), e3;
        }
      }
      async function CB(e2) {
        try {
          if (dN("AP_REQUEST_DETAIL") || dN("ENABLE_ROLE_SELECT_EDGE"))
            return;
          const t2 = vB(e2);
          if (!t2 || "disabled" !== e2.cloudProxyServer)
            return;
          const i3 = await async function(e3, t3) {
            try {
              const i4 = await window.crypto.subtle.importKey("raw", oO(t3), "AES-GCM", false, ["decrypt"]), n2 = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv: new Uint8Array(1) }, i4, nO(e3));
              return JSON.parse(window.atob(rO(new Uint8Array(n2))));
            } catch (e4) {
              return;
            }
          }(t2, e2.token || e2.appId);
          if (!i3)
            return;
          if (!function(e3, t3) {
            const i4 = e3.cname === t3.cname && e3.appId === t3.appId && e3.token === t3.token;
            if (!i4)
              return false;
            return t3.stringUid ? e3.stringUid === t3.stringUid : "number" == typeof t3.uid ? e3.uid === t3.uid : e3.uid == t3.uid;
          }(i3, e2))
            return;
          if (i3 && Date.now() - i3.ts < dN("AP_CACHE_LIFETIME"))
            return i3;
        } catch (e3) {
          BN.warn("Error get preloadInfo", e3.message);
        }
      }
      function vB(e2) {
        let t2;
        try {
          if (t2 = bB(lB), !t2)
            return;
          const i3 = JSON.parse(t2), n2 = OB(e2), r2 = function(e3, t3) {
            for (let i4 = e3.length - 1; i4 >= 0; i4--)
              if (t3(e3[i4]))
                return i4;
            return -1;
          }(i3, (e3) => n2 in e3);
          if (-1 === r2)
            return;
          const o2 = i3.splice(r2, 1)[0];
          return wB(lB, JSON.stringify(i3)), o2[n2];
        } catch (e3) {
          BN.warn("Error delete preload info: ".concat(t2), e3.message), wB(lB, "");
        }
      }
      function IB(e2) {
        if (e2) {
          let t2 = pB.get(e2);
          t2 && (window.clearTimeout(t2), t2 = null, pB.delete(e2)), Dn(_B).call(_B, e2) || "disabled" !== e2.cloudProxyServer || _B.push(e2);
        }
        if (pB.size < dN("AP_CACHE_NUM") && _B.length > 0) {
          const e3 = _B.shift();
          pB.set(e3, window.setTimeout(async () => {
            const { appId: t2, cname: i3, token: n2, stringUid: r2, uid: o2, proxyServer: s2 } = e3;
            try {
              await SB(t2, i3, n2, o2, s2, r2), pB.has(e3) && IB(e3);
            } catch (t3) {
              BN.warn("update preload failed", t3.message), yB(e3);
            }
          }, dN("AP_UPDATE_INTERVAL")));
        }
      }
      function yB(e2) {
        const t2 = _B.indexOf(e2);
        -1 !== t2 && _B.splice(t2, 1);
        let i3 = pB.get(e2);
        i3 && (window.clearTimeout(i3), i3 = null, pB.delete(e2), IB());
      }
      function AB(e2, t2) {
        const i3 = e2.sua, n2 = e2.ap;
        t2 && i3 && zN.reqUserAccount(e2.sid, { lts: i3.requestTime, elapse: i3.elapse, success: true, serverAddr: i3.url, stringUid: t2, uid: e2.intUid, errorCode: null, extend: i3.req }), zN.reportResourceTiming(e2.ap.url, e2.sid), zN.joinWebProxyAP(e2.sid, { lts: n2.requestTime, elapse: n2.elapse, sucess: 1, apServerAddr: n2.url, turnServerAddrList: n2.proxyInfo.addresses.map((e3) => e3.ip).join(","), eventType: "disabled", unilbsServerIds: [qU.CHOOSE_SERVER, qU.CLOUD_PROXY_FALLBACK].toString() }), zN.joinChooseServer(e2.sid, { lts: n2.requestTime, elapse: n2.elapse, succ: true, csAddr: n2.url, opid: n2.opid, serverList: n2.gatewayInfo.gatewayAddrs.map((e3) => e3.address), ec: null, cid: n2.gatewayInfo.cid.toString(), uid: n2.gatewayInfo.uid.toString(), csIp: n2.gatewayInfo.csIp, unilbsServerIds: [qU.CHOOSE_SERVER].toString(), isHttp3: n2.isHttp3 });
      }
      function bB(e2) {
        return window.atob(window.localStorage.getItem(e2) || "");
      }
      function wB(e2, t2) {
        window.localStorage.setItem(e2, window.btoa(t2));
      }
      function OB(e2) {
        let t2 = "".concat(e2.appId, "_").concat(e2.cname);
        return "string" == typeof e2.uid && (t2 += "_s_".concat(e2.uid)), "number" == typeof e2.uid && (t2 += "_".concat(e2.uid)), e2.token && (t2 += "_".concat(e2.token)), gO(t2);
      }
      function NB(e2) {
        let t2 = function() {
          const e3 = kB.pop();
          return e3 ? (e3.offset = e3.limit = 0, e3) : { bytes: new Uint8Array(64), offset: 0, limit: 0 };
        }();
        return function(e3, t3) {
          let i3 = e3.appId;
          void 0 !== i3 && (KB(t3, 10), jB(t3, i3));
          let n2 = e3.cid;
          void 0 !== n2 && (KB(t3, 16), KB(t3, n2));
          let r2 = e3.cname;
          void 0 !== r2 && (KB(t3, 26), jB(t3, r2));
          let o2 = e3.deviceId;
          void 0 !== o2 && (KB(t3, 34), jB(t3, o2));
          let s2 = e3.elapse;
          void 0 !== s2 && (KB(t3, 40), qB(t3, s2));
          let a2 = e3.fileSize;
          void 0 !== a2 && (KB(t3, 48), qB(t3, LB(a2)));
          let c2 = e3.height;
          void 0 !== c2 && (KB(t3, 56), qB(t3, LB(c2)));
          let d2 = e3.jpg;
          void 0 !== d2 && (KB(t3, 66), KB(t3, d2.length), FB(t3, d2));
          let l2 = e3.networkType;
          void 0 !== l2 && (KB(t3, 72), qB(t3, LB(l2)));
          let u2 = e3.osType;
          void 0 !== u2 && (KB(t3, 80), qB(t3, LB(u2)));
          let h2 = e3.requestId;
          void 0 !== h2 && (KB(t3, 90), jB(t3, h2));
          let p3 = e3.sdkVersion;
          void 0 !== p3 && (KB(t3, 98), jB(t3, p3));
          let _2 = e3.sequence;
          void 0 !== _2 && (KB(t3, 104), qB(t3, LB(_2)));
          let E2 = e3.sid;
          void 0 !== E2 && (KB(t3, 114), jB(t3, E2));
          let f2 = e3.timestamp;
          void 0 !== f2 && (KB(t3, 120), qB(t3, f2));
          let m2 = e3.uid;
          void 0 !== m2 && (KB(t3, 128), KB(t3, m2));
          let T2 = e3.vid;
          void 0 !== T2 && (KB(t3, 136), KB(t3, T2));
          let S2 = e3.width;
          void 0 !== S2 && (KB(t3, 144), qB(t3, LB(S2)));
          let g2 = e3.service;
          void 0 !== g2 && (KB(t3, 152), KB(t3, g2));
          let R3 = e3.callbackData;
          void 0 !== R3 && (KB(t3, 162), KB(t3, R3.length), FB(t3, R3));
          let C2 = e3.ticket;
          void 0 !== C2 && (KB(t3, 170), jB(t3, C2));
          let v2 = e3.vendorConfigs;
          void 0 !== v2 && (KB(t3, 178), jB(t3, v2));
        }(e2, t2), function(e3) {
          let t3 = e3.bytes, i3 = e3.limit;
          return t3.length === i3 ? t3 : t3.subarray(0, i3);
        }(t2);
      }
      function DB(e2) {
        return function(e3) {
          let t3 = {};
          e:
            for (; !UB(e3); ) {
              let i3 = HB(e3);
              switch (i3 >>> 3) {
                case 0:
                  break e;
                case 1:
                  t3.code = HB(e3);
                  break;
                case 2:
                  t3.msg = BB(e3, HB(e3));
                  break;
                case 3:
                  t3.requestId = BB(e3, HB(e3));
                  break;
                case 4:
                  t3.timestamp = YB(e3, false);
                  break;
                default:
                  PB(e3, 7 & i3);
              }
            }
          return t3;
        }({ bytes: t2 = e2, offset: 0, limit: t2.length });
        var t2;
      }
      function PB(e2, t2) {
        switch (t2) {
          case 0:
            for (; 128 & GB(e2); )
              ;
            break;
          case 2:
            MB(e2, HB(e2));
            break;
          case 5:
            MB(e2, 4);
            break;
          case 1:
            MB(e2, 8);
            break;
          default:
            throw new Error("Unimplemented type: " + t2);
        }
      }
      function LB(e2) {
        return { low: e2 |= 0, high: e2 >> 31, unsigned: e2 >= 0 };
      }
      let kB = [];
      function MB(e2, t2) {
        if (e2.offset + t2 > e2.limit)
          throw new Error("Skip past limit");
        e2.offset += t2;
      }
      function UB(e2) {
        return e2.offset >= e2.limit;
      }
      function xB(e2, t2) {
        let i3 = e2.bytes, n2 = e2.offset, r2 = e2.limit, o2 = n2 + t2;
        if (o2 > i3.length) {
          let t3 = new Uint8Array(2 * o2);
          t3.set(i3), e2.bytes = t3;
        }
        return e2.offset = o2, o2 > r2 && (e2.limit = o2), n2;
      }
      function VB(e2, t2) {
        let i3 = e2.offset;
        if (i3 + t2 > e2.limit)
          throw new Error("Read past limit");
        return e2.offset += t2, i3;
      }
      function FB(e2, t2) {
        let i3 = xB(e2, t2.length);
        e2.bytes.set(t2, i3);
      }
      function BB(e2, t2) {
        let i3 = VB(e2, t2), n2 = String.fromCharCode, r2 = e2.bytes, o2 = "ï¿½", s2 = "";
        for (let e3 = 0; e3 < t2; e3++) {
          let a2, c2, d2, l2, u2 = r2[e3 + i3];
          0 == (128 & u2) ? s2 += n2(u2) : 192 == (224 & u2) ? e3 + 1 >= t2 ? s2 += o2 : (a2 = r2[e3 + i3 + 1], 128 != (192 & a2) ? s2 += o2 : (l2 = (31 & u2) << 6 | 63 & a2, l2 < 128 ? s2 += o2 : (s2 += n2(l2), e3++))) : 224 == (240 & u2) ? e3 + 2 >= t2 ? s2 += o2 : (a2 = r2[e3 + i3 + 1], c2 = r2[e3 + i3 + 2], 32896 != (49344 & (a2 | c2 << 8)) ? s2 += o2 : (l2 = (15 & u2) << 12 | (63 & a2) << 6 | 63 & c2, l2 < 2048 || l2 >= 55296 && l2 <= 57343 ? s2 += o2 : (s2 += n2(l2), e3 += 2))) : 240 == (248 & u2) ? e3 + 3 >= t2 ? s2 += o2 : (a2 = r2[e3 + i3 + 1], c2 = r2[e3 + i3 + 2], d2 = r2[e3 + i3 + 3], 8421504 != (12632256 & (a2 | c2 << 8 | d2 << 16)) ? s2 += o2 : (l2 = (7 & u2) << 18 | (63 & a2) << 12 | (63 & c2) << 6 | 63 & d2, l2 < 65536 || l2 > 1114111 ? s2 += o2 : (l2 -= 65536, s2 += n2(55296 + (l2 >> 10), 56320 + (1023 & l2)), e3 += 3))) : s2 += o2;
        }
        return s2;
      }
      function jB(e2, t2) {
        let i3 = t2.length, n2 = 0;
        for (let e3 = 0; e3 < i3; e3++) {
          let r3 = t2.charCodeAt(e3);
          r3 >= 55296 && r3 <= 56319 && e3 + 1 < i3 && (r3 = (r3 << 10) + t2.charCodeAt(++e3) - 56613888), n2 += r3 < 128 ? 1 : r3 < 2048 ? 2 : r3 < 65536 ? 3 : 4;
        }
        KB(e2, n2);
        let r2 = xB(e2, n2), o2 = e2.bytes;
        for (let e3 = 0; e3 < i3; e3++) {
          let n3 = t2.charCodeAt(e3);
          n3 >= 55296 && n3 <= 56319 && e3 + 1 < i3 && (n3 = (n3 << 10) + t2.charCodeAt(++e3) - 56613888), n3 < 128 ? o2[r2++] = n3 : (n3 < 2048 ? o2[r2++] = n3 >> 6 & 31 | 192 : (n3 < 65536 ? o2[r2++] = n3 >> 12 & 15 | 224 : (o2[r2++] = n3 >> 18 & 7 | 240, o2[r2++] = n3 >> 12 & 63 | 128), o2[r2++] = n3 >> 6 & 63 | 128), o2[r2++] = 63 & n3 | 128);
        }
      }
      function GB(e2) {
        return e2.bytes[VB(e2, 1)];
      }
      function WB(e2, t2) {
        let i3 = xB(e2, 1);
        e2.bytes[i3] = t2;
      }
      function HB(e2) {
        let t2, i3 = 0, n2 = 0;
        do {
          t2 = GB(e2), i3 < 32 && (n2 |= (127 & t2) << i3), i3 += 7;
        } while (128 & t2);
        return n2;
      }
      function KB(e2, t2) {
        for (t2 >>>= 0; t2 >= 128; )
          WB(e2, 127 & t2 | 128), t2 >>>= 7;
        WB(e2, t2);
      }
      function YB(e2, t2) {
        let i3, n2 = 0, r2 = 0, o2 = 0;
        return i3 = GB(e2), n2 = 127 & i3, 128 & i3 && (i3 = GB(e2), n2 |= (127 & i3) << 7, 128 & i3 && (i3 = GB(e2), n2 |= (127 & i3) << 14, 128 & i3 && (i3 = GB(e2), n2 |= (127 & i3) << 21, 128 & i3 && (i3 = GB(e2), r2 = 127 & i3, 128 & i3 && (i3 = GB(e2), r2 |= (127 & i3) << 7, 128 & i3 && (i3 = GB(e2), r2 |= (127 & i3) << 14, 128 & i3 && (i3 = GB(e2), r2 |= (127 & i3) << 21, 128 & i3 && (i3 = GB(e2), o2 = 127 & i3, 128 & i3 && (i3 = GB(e2), o2 |= (127 & i3) << 7))))))))), { low: n2 | r2 << 28, high: r2 >>> 4 | o2 << 24, unsigned: t2 };
      }
      function qB(e2, t2) {
        let i3 = t2.low >>> 0, n2 = (t2.low >>> 28 | t2.high << 4) >>> 0, r2 = t2.high >>> 24, o2 = 0 === r2 ? 0 === n2 ? i3 < 16384 ? i3 < 128 ? 1 : 2 : i3 < 1 << 21 ? 3 : 4 : n2 < 16384 ? n2 < 128 ? 5 : 6 : n2 < 1 << 21 ? 7 : 8 : r2 < 128 ? 9 : 10, s2 = xB(e2, o2), a2 = e2.bytes;
        switch (o2) {
          case 10:
            a2[s2 + 9] = r2 >>> 7 & 1;
          case 9:
            a2[s2 + 8] = 9 !== o2 ? 128 | r2 : 127 & r2;
          case 8:
            a2[s2 + 7] = 8 !== o2 ? n2 >>> 21 | 128 : n2 >>> 21 & 127;
          case 7:
            a2[s2 + 6] = 7 !== o2 ? n2 >>> 14 | 128 : n2 >>> 14 & 127;
          case 6:
            a2[s2 + 5] = 6 !== o2 ? n2 >>> 7 | 128 : n2 >>> 7 & 127;
          case 5:
            a2[s2 + 4] = 5 !== o2 ? 128 | n2 : 127 & n2;
          case 4:
            a2[s2 + 3] = 4 !== o2 ? i3 >>> 21 | 128 : i3 >>> 21 & 127;
          case 3:
            a2[s2 + 2] = 3 !== o2 ? i3 >>> 14 | 128 : i3 >>> 14 & 127;
          case 2:
            a2[s2 + 1] = 2 !== o2 ? i3 >>> 7 | 128 : i3 >>> 7 & 127;
          case 1:
            a2[s2] = 1 !== o2 ? 128 | i3 : 127 & i3;
        }
      }
      const zB = {}, XB = {}, JB = 4294967296, QB = JB * JB, ZB = QB / 2, $B = rj(0, true), ej = rj(0), tj = oj(0, -2147483648, false), ij = oj(-1, 2147483647, false), nj = oj(-1, -1, true);
      function rj(e2, t2) {
        let i3, n2, r2;
        return t2 ? (r2 = 0 <= (e2 >>>= 0) && e2 < 256) && (n2 = XB[e2], n2) ? n2 : (i3 = oj(e2, 0, true), r2 && (XB[e2] = i3), i3) : (r2 = -128 <= (e2 |= 0) && e2 < 128) && (n2 = zB[e2], n2) ? n2 : (i3 = oj(e2, e2 < 0 ? -1 : 0, false), r2 && (zB[e2] = i3), i3);
      }
      function oj(e2, t2, i3) {
        return { low: 0 | e2, high: 0 | t2, unsigned: !!i3 };
      }
      function sj(e2, t2) {
        if (isNaN(e2))
          return t2 ? $B : ej;
        if (t2) {
          if (e2 < 0)
            return $B;
          if (e2 >= QB)
            return nj;
        } else {
          if (e2 <= -ZB)
            return tj;
          if (e2 + 1 >= ZB)
            return ij;
        }
        return e2 < 0 ? t2 ? $B : ej : oj(e2 % JB | 0, e2 / JB | 0, t2);
      }
      function aj(e2, t2) {
        var i3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i3.push.apply(i3, n2);
        }
        return i3;
      }
      class cj extends Nw {
        get connectionState() {
          return this._connectionState;
        }
        set connectionState(e2) {
          if (this._connectionState === e2)
            return;
          const t2 = this._connectionState;
          this._connectionState = e2, this.emit(vU.CONNECTION_STATE_CHANGE, e2, t2);
        }
        get quality() {
          return this._quality;
        }
        set quality(e2) {
          this._quality = e2 > 1 ? 1 : e2 < 0.1 ? 0.1 : e2, this._qualityTimer && (window.clearTimeout(this._qualityTimer), this._qualityTimer = null), this._quality >= 1 || (this._qualityTimer = window.setTimeout(() => {
            this.quality = this._quality / this._qualityRatio;
          }, 6e4));
        }
        constructor(e2) {
          var t2;
          super(), QI(this, "name", "AgoraRTCImageModeration"), QI(this, "_connectionState", CU.CONNECTING), QI(this, "_sequence", 0), QI(this, "_moderationStartTime", void 0), QI(this, "_workerConnection", void 0), QI(this, "_workerMessageLengthLimit", void 0), QI(this, "_qualityRatio", void 0), QI(this, "_connectInfo", void 0), QI(this, "_cancelTokenSource", Ab.CancelToken.source()), QI(this, "_retryConfig", void 0), QI(this, "_moderationInterval", void 0), QI(this, "_moderationTimer", null), QI(this, "_moderationMode", 1), QI(this, "_quality", 1), QI(this, "_qualityTimer", null), QI(this, "_ticket", void 0), QI(this, "_moderationIntervalMinimum", void 0), QI(this, "_uploadFailedNum", 0), QI(this, "_uploadNum", 0), QI(this, "_uploadTimer", null), QI(this, "_extraInfo", void 0), QI(this, "_vendor", ""), QI(this, "_encoder", new TextEncoder()), QI(this, "_moderationId", void 0), QI(this, "inspectImage", () => {
            if (this.connectionState !== CU.CONNECTED)
              throw new XN(_w.OPERATION_ABORTED, "image moderation service connection status is ".concat(this.connectionState));
            this._moderationTimer && (window.clearInterval(this._moderationTimer), this._moderationTimer = null), this._moderationTimer = window.setInterval(() => {
              this.connectionState === CU.CONNECTED ? this.requestToInspectImage() : BN.debug("[".concat(this._moderationId, "] Moderation State is not connected , "), this.connectionState);
            }, this._moderationInterval < this._moderationIntervalMinimum ? this._moderationIntervalMinimum : this._moderationInterval), this.requestToInspectImage();
          }), this._moderationId = uO(5, "image-moderation-"), this._workerMessageLengthLimit = dN("IMAGE_MODERATION_WORKER_MESSAGE_LENGTH_LIMIT"), this._moderationIntervalMinimum = dN("IMAGE_MODERATION_INTERVAL_MINIMUM"), this._moderationInterval = null !== (t2 = e2.interval) && void 0 !== t2 ? t2 : 1e3, e2.extraInfo && (this._extraInfo = this._encoder.encode(e2.extraInfo)), e2.vendor && (this._vendor = e2.vendor), this._qualityRatio = dN("IMAGE_MODERATION_QUALITY_RATIO"), this._moderationStartTime = Number(Date.now()), this._workerConnection = new KU("worker-" + this._moderationId, yO), this.on(vU.STATE_CHANGE, (e3, t3) => {
            BN.debug("[".concat(this._moderationId, "] Moderation operation :").concat(IU[e3], " ").concat(t3 || ""));
          }), this.handleWorkerEvents();
        }
        async init(e2, t2) {
          this.emit(vU.STATE_CHANGE, IU.CONNECT_AP), this._connectInfo = e2;
          const i3 = this._cancelTokenSource.token;
          return this._retryConfig = t2, new Wh((n2, r2) => {
            this.on(vU.CONNECTION_STATE_CHANGE, (e3, t3) => {
              e3 === CU.CONNECTED && n2();
            }), this.requestAP(e2, i3, t2).then((e3) => {
              this.connectWorker(e3);
            }).catch((e3) => {
              r2(e3);
            });
          });
        }
        updateConfig(e2) {
          var t2;
          this._moderationInterval = null !== (t2 = e2.interval) && void 0 !== t2 ? t2 : 1e3, e2.extraInfo && (this._extraInfo = this._encoder.encode(e2.extraInfo)), e2.vendor && (this._vendor = e2.vendor), BN.debug("[".concat(this._moderationId, "] updateConfig: ").concat(JSON.stringify(e2))), this.connectionState === CU.CONNECTED && this.inspectImage();
        }
        async requestAP(e2, t2, i3) {
          const n2 = dN("WEBCS_DOMAIN").map((e3) => "https://".concat(e3, "/api/v1")), r2 = await function(e3, t3, i4, n3) {
            let { appId: r3, areaCode: o3, cname: s3, sid: a2, token: c2, uid: d2 } = t3;
            TV++;
            const l2 = "moderation_plugin", u2 = { service_name: l2, json_body: JSON.stringify({ appId: r3, areaCode: o3, cname: s3, command: "allocateEdge", requestId: TV, seq: TV, sid: a2, appToken: c2, ts: Date.now(), uid: d2 + "" }) };
            let h2, p3, _2 = e3[0];
            return bO(async () => {
              h2 = Date.now();
              const e4 = await Jx(_2, { data: u2, cancelToken: i4, headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "61" }, params: { action: "wrtc_gateway" } });
              if (p3 = Date.now() - h2, 0 !== e4.code) {
                const t5 = new XN(_w.UNEXPECTED_RESPONSE, "moderation plugin ap error, code" + e4.code, { retry: true, responseTime: p3 });
                throw BN.error(t5.toString()), t5;
              }
              const t4 = JSON.parse(e4.json_body);
              if (200 !== t4.code) {
                const e5 = new XN(_w.UNEXPECTED_RESPONSE, "moderation plugin ap error, code: ".concat(t4.code, ", reason: ").concat(t4.reason), { code: t4.code, responseTime: p3 });
                throw BN.error(e5.toString()), e5;
              }
              if (!t4.servers || !Array.isArray(t4.servers) || 0 === t4.servers.length) {
                const e5 = new XN(_w.UNEXPECTED_RESPONSE, "moderation plugin ap empty server", { code: t4.code, responseTime: p3 });
                throw BN.error(e5.toString()), e5;
              }
              if (!t4.servers.some((e5) => !!e5.wss)) {
                const e5 = new XN(_w.UNEXPECTED_RESPONSE, "moderation plugin ap empty port", { code: t4.code, responseTime: p3 });
                throw BN.error(e5.toString()), e5;
              }
              const n4 = dN("IMAGE_MODERATION_WORKER_HOST");
              return { addressList: t4.servers.map((e5) => {
                let { address: t5, wss: i5 } = e5;
                if (t5 && i5)
                  return "wss://".concat(t5.replace(/\./g, "-"), ".").concat(n4, ":").concat(i5, "/moderation");
              }).filter((e5) => !!e5), workerToken: t4.workerToken, vid: t4.vid, ticket: t4.appTicket, responseTime: p3 };
            }, (t4, i5) => (zN.apworkerEvent(a2, { success: true, sc: 200, serviceName: l2, responseDetail: JSON.stringify(t4.addressList), firstSuccess: 0 === i5, responseTime: p3, serverIp: e3[i5 % e3.length] }), false), (t4, i5) => (zN.apworkerEvent(a2, { success: false, sc: t4.data && t4.data.code || 200, serviceName: l2, responseTime: p3, serverIp: e3[i5 % e3.length] }), !!(t4.code !== _w.OPERATION_ABORTED && t4.code !== _w.UNEXPECTED_RESPONSE || t4.data && t4.data.retry) && (_2 = e3[(i5 + 1) % e3.length], true)), n3);
          }(n2, e2, t2, i3);
          this.emit(vU.STATE_CHANGE, IU.AP_CONNECTED);
          const { addressList: o2, ticket: s2 } = r2;
          return this._ticket = s2, o2;
        }
        async connectWorker(e2) {
          this.emit(vU.STATE_CHANGE, IU.CONNECT_WORKER), await this._workerConnection.init(e2, 1e4);
        }
        handleWorkerEvents() {
          this._workerConnection.on(UM.CONNECTED, async () => {
            this.emit(vU.STATE_CHANGE, IU.WORKER_CONNECTED, this._workerConnection.url), this.connectionState = CU.CONNECTED;
          }), this._workerConnection.on(UM.CLOSED, () => {
            this.connectionState = CU.CLOSED;
          }), this._workerConnection.on(UM.FAILED, () => {
            this.connectionState = CU.CLOSED;
          }), this._workerConnection.on(UM.RECONNECTING, () => {
            this.connectionState = this.connectionState === CU.CONNECTED ? CU.RECONNECTING : CU.CONNECTING;
          }), this._workerConnection.on(UM.ON_MESSAGE, async (e2) => {
            if (e2.data instanceof ArrayBuffer) {
              const t2 = DB(new Uint8Array(e2.data));
              dN("SHOW_IMAGE_MODERATION_WORKER_MESSAGE") && BN.debug("[".concat(this._moderationId, "] Response message for worker of image moderation "), JSON.stringify(t2)), this._uploadNum++, void 0 === t2.code || 0 === t2.code || (this._uploadFailedNum++, BN.error("[".concat(this._moderationId, "] Error response from worke, code is ").concat(t2.code, ", msg is ").concat(t2.msg)), this._uploadTimer || (this._uploadTimer = window.setTimeout(() => {
                zN.reportApiInvoke(this._connectInfo.sid || null, { name: Lw.IMAGE_MODERATION_UPLOAD, options: [this._uploadFailedNum, this._uploadNum, t2.code], tag: kw.TRACER }).onError(new XN(_w.IMAGE_MODERATION_UPLOAD_FAILED, t2.msg)), this._uploadTimer = null;
              }, dN("IMAGE_MODERATION_UPLOAD_REPORT_INTERVAL"))));
            } else
              BN.error("[".concat(this._moderationId, "] Unexpected message type from worker"));
          }), this._workerConnection.on(UM.WILL_RECONNECT, (e2, t2, i3) => {
            "recover" === e2 && i3(e2), i3("tryNext");
          }), this._workerConnection.on(UM.REQUEST_NEW_URLS, (e2, t2) => {
            this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then(e2).catch(t2);
          });
        }
        static intToLong(e2) {
          return { low: e2 |= 0, high: e2 >> 31, unsigned: e2 >= 0 };
        }
        async requestToInspectImage() {
          const e2 = qw(this, vU.CLIENT_LOCAL_VIDEO_TRACK), t2 = { appId: this._connectInfo.appId, cname: this._connectInfo.cname, cid: this._connectInfo.cid, sid: this._connectInfo.sid, uid: this._connectInfo.uid, vid: this._connectInfo.vid };
          if (e2) {
            if (!e2.isPlaying)
              return void (dN("SHOW_IMAGE_MODERATION_WORKER_MESSAGE") && BN.debug("Only the track being played can be inspected"));
            this._sequence++;
            const i3 = await this.generateRequestData(e2, t2);
            this._workerConnection.sendMessage(i3, true, true);
          } else
            dN("SHOW_IMAGE_MODERATION_WORKER_MESSAGE") && BN.debug("Only the track being published can be inspected");
        }
        async generateRequestData(e2, t2) {
          let { appId: i3, cname: n2, cid: r2, vid: o2, sid: s2, uid: a2 } = t2;
          const c2 = Date.now(), d2 = await e2.getCurrentFrameImage("image/jpeg", this.quality), l2 = await OP(d2, i3, n2), u2 = this._sequence + "-" + r2 + "-" + a2 + "-" + c2 + "-" + uO(12, ""), h2 = { appId: i3, cid: r2, cname: n2, deviceId: "", elapse: cj.intToLong(Number(c2 - this._moderationStartTime)), fileSize: d2.buffer.byteLength, height: d2.height, width: d2.width, jpg: l2, networkType: 6, osType: 7, requestId: u2, sdkVersion: "4.23.0", sequence: this._sequence, sid: s2, timestamp: sj(c2), uid: a2, vid: o2, service: this._moderationMode, ticket: this._ticket, callbackData: this._extraInfo, vendorConfigs: this._vendor };
          void 0 === this._extraInfo && delete h2.callbackData;
          const p3 = NB(h2);
          if (p3.byteLength < this._workerMessageLengthLimit) {
            if (dN("SHOW_IMAGE_MODERATION_WORKER_MESSAGE")) {
              const e3 = function(e4) {
                for (var t3 = 1; t3 < arguments.length; t3++) {
                  var i4 = null != arguments[t3] ? arguments[t3] : {};
                  t3 % 2 ? aj(Object(i4), true).forEach(function(t4) {
                    QI(e4, t4, i4[t4]);
                  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(i4)) : aj(Object(i4)).forEach(function(t4) {
                    Object.defineProperty(e4, t4, Object.getOwnPropertyDescriptor(i4, t4));
                  });
                }
                return e4;
              }({}, h2);
              delete e3.jpg, BN.debug("[".concat(this._moderationId, "] Request message for worker of image moderation service: "), JSON.stringify(e3));
            }
            return p3;
          }
          {
            const t3 = this.quality * this._qualityRatio;
            return this.quality = t3, await this.generateRequestData(e2, { appId: i3, cname: n2, cid: r2, vid: o2, sid: s2, uid: a2 });
          }
        }
        close() {
          this._cancelTokenSource.cancel(), this._cancelTokenSource = Ab.CancelToken.source(), this._workerConnection && this._workerConnection.close(), this._moderationTimer && window.clearInterval(this._moderationTimer), this._moderationTimer = null, this._uploadTimer && window.clearTimeout(this._uploadTimer), this._uploadTimer = null, this.connectionState = CU.CLOSED, this.emit(vU.STATE_CHANGE, IU.CLOSED);
        }
      }
      function dj(e2) {
        if (Tw(e2.interval, "interval", 1e3, 1 / 0), e2 && e2.extraInfo && e2.extraInfo.length > 1024)
          throw new XN(_w.INVALID_PARAMS, "config.extraInfo length cannot exceed 1024 bytes");
        if (e2 && e2.vendor && e2.vendor.length > 1024)
          throw new XN(_w.INVALID_PARAMS, "config.vendor length cannot exceed 1024 bytes");
      }
      const lj = { name: "ImageModeration", create: function(e2) {
        let { config: t2 } = e2;
        return dj(t2), new cj(t2);
      } };
      var uj, hj, pj, _j, Ej, fj, mj, Tj, Sj, gj, Rj, Cj, vj, Ij, yj, Aj, bj, wj, Oj, Nj, Dj, Pj, Lj, kj, Mj, Uj, xj, Vj, Fj, Bj, jj, Gj, Wj, Hj, Kj, Yj, qj, zj, Xj, Jj, Qj, Zj;
      function $j(e2, t2) {
        var i3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i3.push.apply(i3, n2);
        }
        return i3;
      }
      function eG(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i3 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? $j(Object(i3), true).forEach(function(t3) {
            QI(e2, t3, i3[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : $j(Object(i3)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
          });
        }
        return e2;
      }
      vO.setLogger(BN);
      let tG = (uj = qN(), hj = qN({ argsMap: (e2, t2) => {
        if (!Array.isArray(t2)) {
          if (!(t2 instanceof WD))
            return [t2];
          t2 = [t2];
        }
        return t2.map((e3) => e3 ? Object(e3).toString() : "null");
      } }), pj = qN({ argsMap: (e2, t2) => (t2 || (t2 = []), Array.isArray(t2) || t2.trackMediaType !== vD.DATA ? (Array.isArray(t2) || (t2 = [t2]), t2.map((e3) => e3.getTrackId())) : [t2.getChannelId()]) }), _j = qN({ argsMap: (e2, t2, i3, n2) => ["object" == typeof t2 ? t2.uid : t2, i3, n2] }), Ej = qN({ argsMap: (e2, t2, i3) => [t2, i3] }), fj = qN({ argsMap: (e2, t2) => t2.map((e3) => {
        let { user: t3, mediaType: i3 } = e3;
        return [null == t3 ? void 0 : t3.uid, i3];
      }) }), mj = qN({ argsMap: (e2, t2, i3, n2) => ["object" == typeof t2 ? t2.uid : t2, i3, n2] }), Tj = qN({ argsMap: (e2, t2) => t2.map((e3) => {
        let { user: t3, mediaType: i3 } = e3;
        return { uid: null == t3 ? void 0 : t3.uid, mediaType: i3 };
      }) }), Sj = qN(), gj = qN(), Rj = qN(), Cj = qN(), vj = qN(), Ij = qN(), yj = qN(), Aj = qN(), bj = qN(), wj = qN(), Oj = qN(), Nj = qN(), Dj = qN(), Pj = qN(), Lj = qN(), kj = qN({ argsMap: (e2, t2) => [t2] }), Mj = qN(), Uj = qN(), xj = qN(), Vj = qN(), Fj = qN(), Bj = qN(), jj = qN(), Gj = qN(), Wj = qN({ argsMap: (e2, t2) => (Array.isArray(t2) || (t2 = [t2]), [JSON.stringify(t2)]) }), Hj = qN(), Kj = qN(), Yj = qN(), qj = qN(), zj = qN(), Xj = qN(), Jj = qN({ reportResult: true }), Qj = qN(), Zj = class extends Nw {
        get connectionState() {
          return this._gateway.state;
        }
        get remoteUsers() {
          return this._users;
        }
        get localTracks() {
          return this._p2pChannel.getAllTracks(true);
        }
        get uid() {
          return this._uid;
        }
        get channelName() {
          return this._channelName;
        }
        get localDataChannels() {
          return this._p2pChannel.getAllDataChannels();
        }
        get mode() {
          return this._config.mode;
        }
        get role() {
          var e2;
          return (null === (e2 = this._config) || void 0 === e2 ? void 0 : e2.role) || "audience";
        }
        get codec() {
          return this._config.codec;
        }
        get audioCodec() {
          return this._config.audioCodec || "opus";
        }
        get isStringUID() {
          return !!this._joinInfo && !!this._joinInfo.stringUid;
        }
        get __className__() {
          return "Client";
        }
        constructor(e2, t2) {
          let i3;
          if (super(), QI(this, "store", void 0), QI(this, "_uid", void 0), QI(this, "_channelName", void 0), QI(this, "_uintUid", void 0), QI(this, "_users", []), QI(this, "_config", void 0), QI(this, "_clientId", void 0), QI(this, "_appId", void 0), QI(this, "_sessionId", null), QI(this, "_key", void 0), QI(this, "_rtmConfig", {}), QI(this, "_joinInfo", void 0), QI(this, "_gateway", void 0), QI(this, "_statsCollector", void 0), QI(this, "_configDistribute", void 0), QI(this, "_leaveMutex", void 0), QI(this, "_publishMutex", void 0), QI(this, "_renewTokenMutex", void 0), QI(this, "_subscribeMutex", void 0), QI(this, "_encryptionMode", "none"), QI(this, "_encryptionSecret", null), QI(this, "_encryptionSalt", null), QI(this, "_encryptDataStream", false), QI(this, "_encryptDataStreamKey", null), QI(this, "_encryptDataStreamIv", null), QI(this, "_proxyServer", void 0), QI(this, "_turnServer", { servers: [], mode: "auto" }), QI(this, "_cloudProxyServerMode", "disabled"), QI(this, "_isDualStreamEnabled", false), QI(this, "_defaultStreamFallbackType", void 0), QI(this, "_lowStreamParameter", void 0), QI(this, "_streamFallbackTypeCacheMap", /* @__PURE__ */ new Map()), QI(this, "_remoteStreamTypeCacheMap", /* @__PURE__ */ new Map()), QI(this, "_axiosCancelSource", Ab.CancelToken.source()), QI(this, "_audioVolumeIndicationInterval", void 0), QI(this, "_networkQualityInterval", void 0), QI(this, "_userOfflineTimeout", void 0), QI(this, "_streamRemovedTimeout", void 0), QI(this, "_liveTranscodeStreamingClient", void 0), QI(this, "_liveRawStreamingClient", void 0), QI(this, "_channelMediaRelayClient", void 0), QI(this, "_networkQualitySensitivity", "normal"), QI(this, "_p2pChannel", void 0), QI(this, "_useLocalAccessPoint", false), QI(this, "_setLocalAPVersion", void 0), QI(this, "_joinAndNotLeaveYet", false), QI(this, "_numberOfJoinCount", 0), QI(this, "_remoteDefaultVideoStreamType", void 0), QI(this, "_inspect", void 0), QI(this, "_moderation", void 0), QI(this, "_license", void 0), QI(this, "_pendingPublishedUsers", []), QI(this, "ntpAlignErrorCount", 0), QI(this, "remoteInboundOffset", 0), QI(this, "_peerConnectionState", void 0), QI(this, "_handleLocalTrackEnable", (e3, t3, i4) => {
            this.publish(e3, false).then(t3).catch(i4);
          }), QI(this, "_handleLocalTrackDisable", (e3, t3, i4) => {
            this.unpublish(e3).then(t3).catch(i4);
          }), QI(this, "_handleUserOnline", (e3) => {
            if (dN("BLOCK_LOCAL_CLIENT") && jk(e3.uid, this.channelName))
              return void BN.debug("[".concat(e3.uid, "] will be ignored in local"));
            this.isStringUID && "string" != typeof e3.uid && BN.error("[".concat(this._clientId, "] StringUID is Mixed with UintUID"));
            const t3 = this._users.find((t4) => t4.uid === e3.uid);
            if (t3)
              t3._trust_in_room_ = true, t3._is_pre_created && (t3._is_pre_created = false, this.safeEmit(jw.USER_JOINED, t3));
            else {
              const t4 = new GV(e3.uid, e3.uint_id || e3.uid);
              this._users.push(t4), BN.debug("[".concat(this._clientId, "] user online"), e3.uid), this.safeEmit(jw.USER_JOINED, t4);
            }
          }), QI(this, "_handleUserOffline", (e3) => {
            if (dN("BLOCK_LOCAL_CLIENT") && jk(e3.uid, this.channelName))
              return;
            const t3 = this._users.find((t4) => t4.uid === e3.uid);
            t3 && (this._handleRemoveStream(e3), this._handleRemoveDataChannels(e3), t3._audio_pre_subscribed || t3._video_pre_subscribed ? t3._is_pre_created = true : Jw(this._users, t3), this._remoteStreamTypeCacheMap.delete(t3.uid), this._streamFallbackTypeCacheMap.delete(t3.uid), BN.debug("[".concat(this._clientId, "] user offline"), e3.uid, "reason:", e3.reason), this.safeEmit(jw.USER_LEAVED, t3, e3.reason));
          }), QI(this, "_handleAddAudioOrVideoStream", (e3, t3, i4, n3, r2, o2, s2) => {
            if (dN("BLOCK_LOCAL_CLIENT") && jk(t3, this.channelName))
              return;
            const a2 = this._users.find((e4) => e4.uid === t3);
            if (!a2)
              return void BN.error("[".concat(this._clientId, "] can not find target user!(on_add_stream)"));
            BN.debug("[".concat(this._clientId, "] stream added with uid ").concat(t3, ", type ").concat(e3)), this.store.subscribe(a2.uid, e3, void 0, void 0, void 0, Date.now());
            const c2 = "audio" === e3 ? a2.hasAudio : a2.hasVideo;
            a2._uintid || (a2._uintid = r2 || t3), "audio" === e3 ? a2._trust_audio_stream_added_state_ = true : a2._trust_video_stream_added_state_ = true, "audio" === e3 ? (a2._audio_added_ = true, void 0 !== i4 && (a2._audioSSRC = i4), void 0 !== n3 && (a2._cname = n3), o2 && (a2._audioOrtc = o2)) : (a2._video_added_ = true, void 0 !== i4 && (a2._videoSSRC = i4), void 0 !== n3 && (a2._cname = n3), void 0 !== s2 && (a2._rtxSsrcId = s2), o2 && (a2._videoOrtc = o2)), ("audio" === e3 ? a2.hasAudio : a2.hasVideo) && !c2 && (BN.info("[".concat(this._clientId, "] remote user ").concat(a2.uid, " published ").concat(e3)), this.safeEmit(jw.USER_PUBLISHED, a2, e3)), "video" === e3 ? zN.onGatewayStream(this._sessionId, HN.ON_ADD_VIDEO_STREAM, KN.ON_ADD_VIDEO_STREAM, { peer: r2 || t3, ssrc: a2._videoSSRC }) : zN.onGatewayStream(this._sessionId, HN.ON_ADD_AUDIO_STREAM, KN.ON_ADD_AUDIO_STREAM, { peer: r2 || t3, ssrc: a2._audioSSRC }), this._p2pChannel.remoteMediaSsrcChanged(a2, e3, i4).then((t4) => {
              if (t4 && (BN.debug("[".concat(this._clientId, "] resubscribe ").concat(e3, " for user ").concat(a2.uid, " after rejoin because SSRC id changed.")), this._p2pChannel instanceof JF))
                return this._p2pChannel.unsubscribe(a2, e3, true).then(() => this._subscribe(a2, e3, true).catch((e4) => {
                  BN.error("[".concat(this._clientId, "] resubscribe error"), e4.toString());
                }));
            }), this._p2pChannel.hasPendingRemoteMedia(a2, e3) && (BN.debug("[".concat(this._clientId, "] resubscribe ").concat(e3, " for user ").concat(a2.uid, " after reconnect.")), this._subscribe(a2, e3, true).catch((e4) => {
              BN.error("[".concat(this._clientId, "] resubscribe error"), e4.toString());
            }));
          }), QI(this, "_handleRemoveStream", (e3) => {
            if (dN("BLOCK_LOCAL_CLIENT") && jk(e3.uid, this.channelName))
              return;
            const t3 = this._users.find((t4) => t4.uid === e3.uid);
            if (!t3)
              return void BN.warning("[".concat(this._clientId, "] can not find target user!(on_remove_stream)"));
            BN.debug("[".concat(this._clientId, "] stream removed with uid ").concat(e3.uid));
            let i4 = () => {
            };
            t3.hasAudio && t3.hasVideo ? i4 = () => {
              BN.info("[".concat(this._clientId, "] remote user ").concat(t3.uid, " unpublished audio track")), this.safeEmit(jw.USER_UNPUBLISHED, t3, "audio"), BN.info("[".concat(this._clientId, "] remote user ").concat(t3.uid, " unpublished video track")), this.safeEmit(jw.USER_UNPUBLISHED, t3, "video");
            } : t3.hasVideo ? i4 = () => {
              BN.info("[".concat(this._clientId, "] remote user ").concat(t3.uid, " unpublished video track")), this.safeEmit(jw.USER_UNPUBLISHED, t3, "video");
            } : t3.hasAudio && (i4 = () => {
              BN.info("[".concat(this._clientId, "] remote user ").concat(t3.uid, " unpublished audio track")), this.safeEmit(jw.USER_UNPUBLISHED, t3, "audio");
            }), t3._video_pre_subscribed || t3._audio_pre_subscribed || (t3._trust_audio_stream_added_state_ = true, t3._trust_video_stream_added_state_ = true, t3._audio_added_ = false, t3._video_added_ = false, this._p2pChannel instanceof JF && this._p2pChannel.unsubscribe(t3).then((e4) => {
              if (e4)
                return this._gateway.unsubscribe(e4, t3.uid);
            }), t3._audioSSRC = void 0, t3._videoSSRC = void 0, t3._audioOrtc = void 0, t3._videoOrtc = void 0, t3._rtxSsrcId = void 0), zN.onGatewayStream(this._sessionId, HN.ON_REMOVE_STREAM, KN.ON_REMOVE_STREAM, { peer: e3.uint_id || e3.uid }), i4();
          }), QI(this, "_handleSetStreamLocalEnable", (e3, t3, i4) => {
            if (dN("BLOCK_LOCAL_CLIENT") && jk(t3, this.channelName))
              return;
            const n3 = this._users.find((e4) => e4.uid === t3);
            if (!n3)
              return void BN.error("[".concat(this._clientId, "] can not find target user!(disable_local)"));
            BN.debug("[".concat(this._clientId, "] local ").concat(e3, " ").concat(i4 ? "enabled" : "disabled", " with uid ").concat(t3));
            const r2 = "audio" === e3 ? n3.hasAudio : n3.hasVideo;
            if ("audio" === e3) {
              n3._trust_audio_enabled_state_ = true;
              const e4 = n3._audio_enabled_;
              if (n3._audio_enabled_ = i4, n3._audio_enabled_ === e4)
                return;
              {
                const e5 = n3._audio_enabled_ ? "enable-local-audio" : "disable-local-audio";
                BN.debug("[".concat(this._clientId, "] user-info-updated, uid: ").concat(t3, ", msg: ").concat(e5)), this.safeEmit(jw.USER_INFO_UPDATED, t3, e5);
              }
            } else {
              n3._trust_video_enabled_state_ = true;
              const e4 = n3._video_enabled_;
              if (n3._video_enabled_ = i4, n3._video_enabled_ === e4)
                return;
              {
                const e5 = n3._video_enabled_ ? "enable-local-video" : "disable-local-video";
                BN.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(t3, ", msg: ").concat(e5)), this.safeEmit(jw.USER_INFO_UPDATED, t3, e5);
              }
            }
            const o2 = "audio" === e3 ? n3.hasAudio : n3.hasVideo;
            return r2 !== o2 ? !r2 && o2 ? (BN.info("[".concat(this._clientId, "] remote user ").concat(t3, " published ").concat(e3)), void this.safeEmit(jw.USER_PUBLISHED, n3, e3)) : ("video" === e3 && n3._videoTrack && n3._videoTrack._destroy(), "audio" === e3 && n3._audioTrack, this._p2pChannel.muteRemote(n3, e3), BN.info("[".concat(this._clientId, "] remote user ").concat(t3, " unpublished ").concat(e3)), void this.safeEmit(jw.USER_UNPUBLISHED, n3, e3)) : void 0;
          }), QI(this, "_handleMuteStream", (e3, t3, i4) => {
            if (dN("BLOCK_LOCAL_CLIENT") && jk(e3, this.channelName))
              return;
            BN.debug("[".concat(this._clientId, "] receive mute message"), e3, t3, i4);
            const n3 = this._users.find((t4) => t4.uid === e3);
            if (!n3)
              return void BN.warning("[".concat(this._clientId, "] can not find remote user, ignore mute event, uid: ").concat(e3));
            const r2 = "audio" === t3 ? n3.hasAudio : n3.hasVideo;
            if ("audio" === t3) {
              n3._trust_audio_mute_state_ = true;
              const t4 = n3._audio_muted_;
              if (n3._audio_muted_ = i4, n3._audio_muted_ === t4)
                return;
              {
                const t5 = n3._audio_muted_ ? "mute-audio" : "unmute-audio";
                BN.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(e3, ", msg: ").concat(t5)), this.safeEmit(jw.USER_INFO_UPDATED, e3, t5);
              }
            } else {
              n3._trust_video_mute_state_ = true;
              const t4 = n3._video_muted_;
              if (n3._video_muted_ = i4, n3._video_muted_ === t4)
                return;
              {
                const t5 = n3._video_muted_ ? "mute-video" : "unmute-video";
                BN.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(e3, ", msg: ").concat(t5)), this.safeEmit(jw.USER_INFO_UPDATED, e3, t5);
              }
            }
            const o2 = "audio" === t3 ? n3.hasAudio : n3.hasVideo;
            if (r2 !== o2) {
              if (!r2 && o2) {
                return ("audio" === t3 ? n3._audioSSRC : n3._videoSSRC) ? (BN.info("[".concat(this._clientId, "] remote user ").concat(e3, " published ").concat(t3)), void this.safeEmit(jw.USER_PUBLISHED, n3, t3)) : void BN.warning("[".concat(this._clientId, "] remote user ").concat(e3, " receive ").concat(t3, " unmute message  before add stream message, ").concat(t3, " SSRC doesn't exist yet."));
              }
              "video" === t3 && n3._videoTrack && !n3._video_pre_subscribed && n3._videoTrack._destroy(), "audio" === t3 && n3._audioTrack, this._p2pChannel.muteRemote(n3, t3), BN.info("[".concat(this._clientId, "] remote user ").concat(e3, " unpublished ").concat(t3)), this.safeEmit(jw.USER_UNPUBLISHED, n3, t3);
            }
          }), QI(this, "_handleP2PLost", async (e3) => {
            BN.debug("[".concat(this._clientId, "] receive p2p lost"), e3), parseInt(e3.p2pid, 10) === this.store.p2pId ? await this._p2pChannel.requestReconnect() : BN.warning("[".concat(this._clientId, "] P2PLost stream not found"), e3);
          }), QI(this, "_handleTokenWillExpire", () => {
            BN.debug("[".concat(this._clientId, "] received message onTokenPrivilegeWillExpire")), this.safeEmit(jw.ON_TOKEN_PRIVILEGE_WILL_EXPIRE);
          }), QI(this, "_handleBeforeUnload", (e3) => {
            "beforeunload" === e3.type && void 0 !== e3.returnValue && "" !== e3.returnValue || (this.leave(), BN.info("[".concat(this._clientId, "] auto leave onbeforeunload or pagehide")));
          }), QI(this, "_handleUpdateNetworkQuality", () => {
            if ("normal" === this._networkQualitySensitivity)
              return;
            if (navigator && void 0 !== navigator.onLine && !navigator.onLine)
              return void this.safeEmit(jw.NETWORK_QUALITY, { downlinkNetworkQuality: 6, uplinkNetworkQuality: 6 });
            const e3 = { downlinkNetworkQuality: 0, uplinkNetworkQuality: 0 };
            e3.uplinkNetworkQuality = this._p2pChannel.getUplinkNetworkQuality(), e3.downlinkNetworkQuality = this._p2pChannel.getDownlinkNetworkQuality(), this.safeEmit(jw.NETWORK_QUALITY, e3);
          }), QI(this, "_handleP2PAddAudioOrVideoStream", (e3, t3, i4, n3) => {
            const r2 = this._users.find((e4) => e4.uid === t3);
            if (!r2)
              return void BN.error("[".concat(this._clientId, "] can not find target user!(on_add_stream)"));
            BN.debug("[".concat(this._clientId, "] stream added with uid ").concat(t3, ", type ").concat(e3)), this.store.subscribe(r2.uid, e3, void 0, void 0, void 0, Date.now());
            const o2 = "audio" === e3 ? r2.hasAudio : r2.hasVideo;
            "audio" === e3 ? r2._trust_audio_stream_added_state_ = true : r2._trust_video_stream_added_state_ = true, "audio" === e3 ? (r2._audio_added_ = true, void 0 !== i4 && (r2._audioSSRC = i4), void 0 !== n3 && (r2._audioMid = n3)) : (r2._video_added_ = true, void 0 !== i4 && (r2._videoSSRC = i4), void 0 !== n3 && (r2._videoMid = n3)), ("audio" === e3 ? r2.hasAudio : r2.hasVideo) && !o2 && (BN.info("[".concat(this._clientId, "] remote user ").concat(r2.uid, " published ").concat(e3)), this.safeEmit(jw.USER_PUBLISHED, r2, e3)), this._p2pChannel.hasPendingRemoteMedia(r2, e3) && (BN.debug("[".concat(this._clientId, "] resubscribe ").concat(e3, " for user ").concat(r2.uid, " after reconnect.")), this._subscribe(r2, e3, true).catch((e4) => {
              BN.error("[".concat(this._clientId, "] resubscribe error"), e4.toString());
            }));
          }), this._config = e2, this._clientId = t2 || uO(5, "client-"), this.store = new class {
            constructor(e3, t3, i4, n3) {
              uw(this, "state", void 0), this.state = { codec: e3, audioCodec: t3, mode: i4, clientId: n3, sessionId: null, p2pId: 0, dcId: 0, pubId: 0, subId: 0, avoidJoinStart: 0, keyMetrics: { publish: [], subscribe: [] }, joinChannelServiceRecords: [], cloudProxyServerMode: "disabled", useP2P: false, p2pTransport: nN.Default };
            }
            dispatch(e3) {
              this.state = function(e4, t3) {
                switch (t3.type) {
                  case uN.SET_SESSION_ID:
                    return pw(pw({}, e4), {}, { sessionId: t3.sessionId });
                  case uN.SET_P2P_ID:
                    return pw(pw({}, e4), {}, { p2pId: t3.p2pId });
                  case uN.SET_UID:
                    return pw(pw({}, e4), {}, { uid: t3.uid });
                  case uN.SET_INT_UID:
                    return pw(pw({}, e4), {}, { intUid: t3.intUid });
                  case uN.SET_PUB_ID:
                    return pw(pw({}, e4), {}, { pubId: t3.pubId });
                  case uN.KEY_METRIC_CLIENT_CREATED:
                    return pw(pw({}, e4), {}, { keyMetrics: pw(pw({}, e4.keyMetrics), {}, { clientCreated: t3.metric }) });
                  case uN.KEY_METRIC_JOIN_START:
                    return pw(pw({}, e4), {}, { keyMetrics: pw(pw({}, e4.keyMetrics), {}, { joinStart: t3.metric }) });
                  case uN.AVOID_JOIN_START:
                    return pw(pw({}, e4), {}, { avoidJoinStart: t3.avoidJoinStart });
                  case uN.KEY_METRIC_JOIN_END:
                    return pw(pw({}, e4), {}, { keyMetrics: pw(pw({}, e4.keyMetrics), {}, { joinEnd: t3.metric }) });
                  case uN.KEY_METRIC_REQUEST_AP_START:
                    return pw(pw({}, e4), {}, { keyMetrics: pw(pw({}, e4.keyMetrics), {}, { requestAPStart: t3.metric }) });
                  case uN.KEY_METRIC_REQUEST_AP_END:
                    return pw(pw({}, e4), {}, { keyMetrics: pw(pw({}, e4.keyMetrics), {}, { requestAPEnd: t3.metric }) });
                  case uN.KEY_METRIC_JOIN_GATEWAY_START:
                    return pw(pw({}, e4), {}, { keyMetrics: pw(pw({}, e4.keyMetrics), {}, { joinGatewayStart: t3.metric }) });
                  case uN.KEY_METRIC_JOIN_GATEWAY_END:
                    return pw(pw({}, e4), {}, { keyMetrics: pw(pw({}, e4.keyMetrics), {}, { joinGatewayEnd: t3.metric }) });
                  case uN.KEY_METRIC_PEER_CONNECTION_START:
                    return pw(pw({}, e4), {}, { keyMetrics: pw(pw({}, e4.keyMetrics), {}, { peerConnectionStart: t3.metric }) });
                  case uN.KEY_METRIC_PEER_CONNECTION_END:
                    return pw(pw({}, e4), {}, { keyMetrics: pw(pw({}, e4.keyMetrics), {}, { peerConnectionEnd: t3.metric }) });
                  case uN.KEY_METRIC_DESCRIPTION_START:
                    return pw(pw({}, e4), {}, { keyMetrics: pw(pw({}, e4.keyMetrics), {}, { descriptionStart: t3.metric }) });
                  case uN.KEY_METRIC_SIGNAL_CHANNEL_OPEN:
                    return pw(pw({}, e4), {}, { keyMetrics: pw(pw({}, e4.keyMetrics), {}, { signalChannelOpen: t3.metric }) });
                  case uN.KEY_METRIC_ICE_CONNECTION_END:
                    return pw(pw({}, e4), {}, { keyMetrics: pw(pw({}, e4.keyMetrics), {}, { iceConnectionEnd: t3.metric }) });
                  case uN.KEY_METRIC_PUBLISH: {
                    const i4 = e4.keyMetrics.publish, n3 = i4.findIndex((e5) => e5.trackId === t3.metric.trackId);
                    return -1 !== n3 ? (i4[n3] = pw(pw({}, i4[n3]), t3.metric), pw(pw({}, e4), {}, { keyMetrics: pw(pw({}, e4.keyMetrics), {}, { publish: [...i4] }) })) : pw(pw({}, e4), {}, { keyMetrics: pw(pw({}, e4.keyMetrics), {}, { publish: [...e4.keyMetrics.publish, t3.metric] }) });
                  }
                  case uN.KEY_METRIC_SUBSCRIBE: {
                    const i4 = e4.keyMetrics.subscribe, n3 = i4.findIndex((e5) => e5.userId === t3.metric.userId && e5.type === t3.metric.type);
                    return -1 !== n3 ? (i4[n3] = pw(pw({}, i4[n3]), t3.metric), pw(pw({}, e4), {}, { keyMetrics: pw(pw({}, e4.keyMetrics), {}, { subscribe: [...i4] }) })) : pw(pw({}, e4), {}, { keyMetrics: pw(pw({}, e4.keyMetrics), {}, { subscribe: [...e4.keyMetrics.subscribe, t3.metric] }) });
                  }
                  case uN.SET_CLOUD_PROXY_SERVER_MODE:
                    return e4.cloudProxyServerMode = t3.mode, e4;
                  case uN.RECORD_JOIN_CHANNEL_SERVICE:
                    return "number" != typeof t3.index ? e4.joinChannelServiceRecords = [...e4.joinChannelServiceRecords, t3.record] : (e4.joinChannelServiceRecords[t3.index] = pw(pw({}, e4.joinChannelServiceRecords[t3.index]), t3.record), e4.joinChannelServiceRecords = [...e4.joinChannelServiceRecords]), e4;
                  case uN.RESET_JOIN_CHANNEL_SERVICE_RECORDS:
                    return e4.joinChannelServiceRecords = [], e4;
                  case uN.RESET_KEY_METRICS:
                    return e4.keyMetrics = { publish: [], subscribe: [] }, e4;
                  case uN.SET_USE_P2P:
                    return pw(pw({}, e4), {}, { useP2P: t3.val });
                  case uN.SET_TRANSPORT_TYPE:
                    return pw(pw({}, e4), {}, { p2pTransport: t3.val });
                  default:
                    return e4;
                }
              }(this.state, e3);
            }
            set sessionId(e3) {
              this.dispatch({ type: uN.SET_SESSION_ID, sessionId: e3 });
            }
            get sessionId() {
              return this.state.sessionId;
            }
            set codec(e3) {
              this.state.codec = e3;
            }
            get codec() {
              return this.state.codec;
            }
            get mode() {
              return this.state.mode;
            }
            get audioCodec() {
              return this.state.audioCodec;
            }
            get clientId() {
              return this.state.clientId;
            }
            set p2pId(e3) {
              this.dispatch({ type: uN.SET_P2P_ID, p2pId: e3 });
            }
            get p2pId() {
              return this.state.p2pId;
            }
            set dcId(e3) {
              this.dispatch({ type: uN.SET_DC_ID, dcId: e3 });
            }
            get dcId() {
              return this.state.dcId;
            }
            set uid(e3) {
              this.dispatch({ type: uN.SET_UID, uid: e3 });
            }
            get uid() {
              return this.state.uid;
            }
            set intUid(e3) {
              this.dispatch({ type: uN.SET_INT_UID, intUid: e3 });
            }
            get intUid() {
              return this.state.intUid;
            }
            set pubId(e3) {
              this.dispatch({ type: uN.SET_PUB_ID, pubId: e3 });
            }
            get pubId() {
              return this.state.pubId;
            }
            set cloudProxyServerMode(e3) {
              this.dispatch({ type: uN.SET_CLOUD_PROXY_SERVER_MODE, mode: e3 });
            }
            get cloudProxyServerMode() {
              return this.state.cloudProxyServerMode;
            }
            set useP2P(e3) {
              this.dispatch({ type: uN.SET_USE_P2P, val: e3 });
            }
            get useP2P() {
              return this.state.useP2P;
            }
            set p2pTransport(e3) {
              this.dispatch({ type: uN.SET_TRANSPORT_TYPE, val: e3 });
            }
            get p2pTransport() {
              return this.state.p2pTransport;
            }
            clientCreated() {
              this.dispatch({ type: uN.KEY_METRIC_CLIENT_CREATED, metric: Date.now() });
            }
            joinStart() {
              this.dispatch({ type: uN.KEY_METRIC_JOIN_START, metric: Date.now() });
            }
            joinEnd() {
              this.dispatch({ type: uN.KEY_METRIC_JOIN_END, metric: Date.now() });
            }
            requestAPStart() {
              this.dispatch({ type: uN.KEY_METRIC_REQUEST_AP_START, metric: Date.now() });
            }
            requestAPEnd() {
              this.dispatch({ type: uN.KEY_METRIC_REQUEST_AP_END, metric: Date.now() });
            }
            joinGatewayStart() {
              this.dispatch({ type: uN.KEY_METRIC_JOIN_GATEWAY_START, metric: Date.now() });
            }
            joinGatewayEnd() {
              this.dispatch({ type: uN.KEY_METRIC_JOIN_GATEWAY_END, metric: Date.now() });
            }
            peerConnectionStart() {
              this.dispatch({ type: uN.KEY_METRIC_PEER_CONNECTION_START, metric: Date.now() });
            }
            peerConnectionEnd() {
              this.dispatch({ type: uN.KEY_METRIC_PEER_CONNECTION_END, metric: Date.now() });
            }
            descriptionStart() {
              this.dispatch({ type: uN.KEY_METRIC_DESCRIPTION_START, metric: Date.now() });
            }
            signalChannelOpen() {
              this.dispatch({ type: uN.KEY_METRIC_SIGNAL_CHANNEL_OPEN, metric: Date.now() });
            }
            iceConnectionEnd() {
              this.dispatch({ type: uN.KEY_METRIC_ICE_CONNECTION_END, metric: Date.now() });
            }
            publish(e3, t3, i4, n3) {
              this.dispatch({ type: uN.KEY_METRIC_PUBLISH, metric: pw(pw({ trackId: e3, type: t3 }, i4 && { publishStart: i4 }), n3 && { publishEnd: n3 }) });
            }
            subscribe(e3, t3, i4, n3, r2, o2, s2) {
              this.dispatch({ type: uN.KEY_METRIC_SUBSCRIBE, metric: pw(pw(pw(pw(pw({ userId: e3, type: t3 }, i4 && { subscribeStart: i4 }), n3 && { subscribeEnd: n3 }), r2 && { firstFrame: r2 }), o2 && { streamAdded: o2 }), s2 && { firstDecoded: s2 }) });
            }
            massSubscribe(e3, t3, i4, n3) {
              e3.forEach((e4) => {
                this.dispatch({ type: uN.KEY_METRIC_SUBSCRIBE, metric: pw(pw(pw({ userId: e4.userId, type: e4.type }, t3 && { subscribeStart: t3 }), i4 && { subscribeEnd: i4 }), n3 && { firstFrame: n3 }) });
              });
            }
            get keyMetrics() {
              return this.state.keyMetrics;
            }
            recordJoinChannelService(e3, t3) {
              "gateway" === e3.service && Array.isArray(e3.urls) && (e3.urls = e3.urls.map((e4) => e4.replace(/(\d+)-\d+-\d+-(\d+)/, "$1-*-*-$2")));
              try {
                return "number" != typeof t3 ? (this.dispatch({ type: uN.RECORD_JOIN_CHANNEL_SERVICE, record: pw(pw({}, e3), {}, { sessionId: this.sessionId, cloudProxyMode: this.cloudProxyServerMode, uid: this.uid }) }), this.state.joinChannelServiceRecords.length - 1) : (t3 < 0 || t3 >= this.state.joinChannelServiceRecords.length || this.dispatch({ type: uN.RECORD_JOIN_CHANNEL_SERVICE, record: e3, index: t3 }), t3);
              } catch (e4) {
                return 0;
              }
            }
            resetJoinChannelServiceRecords() {
              this.dispatch({ type: uN.RESET_JOIN_CHANNEL_SERVICE_RECORDS });
            }
            resetKeyMetrics() {
              this.dispatch({ type: uN.RESET_KEY_METRICS });
            }
            get joinChannelServiceRecords() {
              try {
                return this.state.joinChannelServiceRecords;
              } catch (e3) {
                return [];
              }
            }
            get avoidJoinStart() {
              return this.state.avoidJoinStart;
            }
            set avoidJoinStart(e3) {
              this.dispatch({ type: uN.AVOID_JOIN_START, avoidJoinStart: e3 });
            }
          }(e2.codec, e2.audioCodec, e2.mode, this._clientId), this._leaveMutex = new vO("client-leave", this._clientId), this._publishMutex = new vO("client-publish", this._clientId), this._renewTokenMutex = new vO("client-renewtoken", this._clientId), this._subscribeMutex = new vO("client-subscribe", this._clientId), this.store.clientCreated(), e2.proxyServer && this.setProxyServer(e2.proxyServer, true), e2.turnServer && this.setTurnServer(e2.turnServer, true), BN.info("[".concat(this._clientId, "] Initializing AgoraRTC client v").concat(tN, " build: ").concat(sN, ", mode: ").concat(this.mode, ", codec: ").concat(this.codec)), e2.clientRoleOptions)
            try {
              Bw(e2.clientRoleOptions), i3 = Object.assign({}, e2.clientRoleOptions);
            } catch (e3) {
              BN.warning("[".concat(this._clientId, "] ").concat(e3.toString()));
            }
          var n2;
          this._statsCollector = new FV(this.store), this._statsCollector.onStatsException = (e3, t3, i4) => {
            BN.warn("[".concat(this._clientId, "] receive exception msg, code: ").concat(e3, ", msg: ").concat(t3, ", uid: ").concat(i4)), this.safeEmit(jw.EXCEPTION, { code: e3, msg: t3, uid: i4 });
          }, this._statsCollector.onUploadPublishDuration = (e3, t3, i4, n3) => {
            const r2 = this._users.find((t4) => t4.uid === e3);
            r2 && zN.peerPublishStatus(this._sessionId, { subscribeElapse: n3, audioPublishDuration: t3, videoPublishDuration: i4, peer: r2._uintid });
          }, this.store.useP2P = "p2p" === e2.mode, this._gateway = new qx(this.store, { clientId: this._clientId, mode: this.mode, codec: this.codec, websocketRetryConfig: e2.websocketRetryConfig || yO, httpRetryConfig: e2.httpRetryConfig || yO, forceWaitGatewayResponse: void 0 === e2.forceWaitGatewayResponse || e2.forceWaitGatewayResponse, statsCollector: this._statsCollector, role: e2.role, clientRoleOptions: i3 }), this._configDistribute = new LV(this._clientId), this.store.useP2P ? (this._p2pChannel = (n2 = { store: this.store, statsCollector: this._statsCollector }, Gx("P2PChannel").create(n2)), this._handleP2PEvents()) : this._p2pChannel = new JF(this.store, this._statsCollector), this._handleP2PChannelEvents(), this._handleGatewayEvents(), this._handleGatewaySignalEvents();
        }
        async joinMeta(e2, t2, i3, n2, r2) {
          let o2 = !(arguments.length > 5 && void 0 !== arguments[5]) || arguments[5], s2 = arguments.length > 6 && void 0 !== arguments[6] && arguments[6];
          cN("JOIN_GATEWAY_USE_443PORT_ONLY", o2), cN("JOIN_GATEWAY_USE_DUAL_DOMAIN", s2);
          const a2 = this._gateway.signal.websocket;
          return a2 instanceof HU && (a2.use443PortOnly = o2, a2.tryDoubleDomain = s2), async function(e3, t3, i4) {
            Ob.get(e3) || Ob.set(e3, []), Nb2.get(e3) || Nb2.set(e3, t3), Db.get(e3) || Db.set(e3, 0);
            const n3 = Ob.get(e3), r3 = Nb2.get(e3);
            if (!n3 || !r3)
              throw new Error("concurrent: deferQueue or maxConcurrency is null");
            if (Db.get(e3) === r3) {
              const e4 = wb();
              n3.push(e4), await e4.promise;
            }
            Db.set(e3, Db.get(e3) + 1);
            for (var o3 = arguments.length, s3 = new Array(o3 > 3 ? o3 - 3 : 0), a3 = 3; a3 < o3; a3++)
              s3[a3 - 3] = arguments[a3];
            const c2 = await i4(...s3);
            return Db.set(e3, Db.get(e3) - 1), Db.get(e3) === r3 - 1 && n3.length > 0 && (n3[0].resolve(), n3.shift()), 0 === Db.get(e3) && (Ob.set(e3, []), Nb2.set(e3, 0), Db.set(e3, 0)), c2;
          }("client.join", dN("JOIN_MAX_CONCURRENCY"), this.join.bind(this), e2, t2, i3, n2, r2);
        }
        async join(e2, t2, i3, n2, r2) {
          const o2 = ++this._numberOfJoinCount;
          this.store.joinStart(), n2 && (this.store.uid = n2);
          const s2 = "HTTPS" === (wO || wO || (wO = (window.location.protocol.split(":")[0] || "").toUpperCase(), wO)), a2 = kO() ? window.isSecureContext : "Browser Not Support";
          if (!kO() && !s2 || !window.isSecureContext) {
            const e3 = "The website must be running in a secure context (About secure context: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts ), otherwise the media collection will be restricted by the browser";
            BN.warning(e3);
          }
          "DISCONNECTED" === this.connectionState && (this.store.avoidJoinStart = Math.round(Date.now()), BN.debug("[".concat(this._clientId, "] set avoidJoinStart to ").concat(this.store.avoidJoinStart))), zN.setAppId(e2);
          try {
            if (!i3 && null !== i3)
              throw new XN(_w.INVALID_PARAMS, "Invalid token: ".concat(i3, ". If you don not use token, set it to null"));
            i3 && gw(i3, "token", 1, 2047), gw(e2, "appid", 1, 2047), xM(t2), n2 && VM(n2), r2 && gw(r2, "optionalInfo", 1, 2047);
          } catch (r3) {
            throw zN.reportApiInvoke(hO(), { name: Lw.JOIN, options: [e2, t2, i3, n2], states: { isHttps: s2, isSecureContext: a2 }, tag: kw.TRACER }).onError(r3), r3;
          }
          if (this._leaveMutex.isLocked) {
            BN.debug("[".concat(this._clientId, "] join: waiting leave operation"));
            (await this._leaveMutex.lock())(), BN.debug("[".concat(this._clientId, "] join: continue"));
          }
          if (this._joinAndNotLeaveYet = true, "DISCONNECTED" !== this.connectionState) {
            const r3 = new XN(_w.INVALID_OPERATION, "[".concat(this._clientId, "] Client already in connecting/connected state"));
            throw zN.reportApiInvoke(hO(), { name: Lw.JOIN, options: [e2, t2, i3, n2], states: { isHttps: s2, isSecureContext: a2 }, tag: kw.TRACER }).onError(r3), r3;
          }
          this._gateway.state = "CONNECTING";
          const c2 = await CB({ appId: e2, cname: t2, uid: n2, stringUid: "string" == typeof n2 ? n2 : void 0, token: i3 || e2, cloudProxyServer: this._cloudProxyServerMode });
          if (!this._joinAndNotLeaveYet)
            throw new XN(_w.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
          const d2 = (null == c2 ? void 0 : c2.sid) || hO();
          BN.info("[".concat(this._clientId, "] start join channel ").concat(t2, ", join number: ").concat(o2)), this._sessionId || (this._sessionId = d2, this.store.sessionId = this._sessionId);
          const l2 = zN.reportApiInvoke(d2, { id: this._clientId, name: Lw.JOIN, options: [e2, t2, i3, n2], states: { isHttps: s2, isSecureContext: a2 }, tag: kw.TRACER }), u2 = eG(eG(eG({}, this._rtmConfig), {}, { role: this.role, clientId: this._clientId, appId: e2, sid: this._sessionId, cname: t2, uid: "string" != typeof n2 ? n2 : null, turnServer: this._turnServer, proxyServer: this._proxyServer, token: i3 || e2, cloudProxyServer: this._cloudProxyServerMode, optionalInfo: r2, license: this._license, useLocalAccessPoint: this._useLocalAccessPoint, preload: !!c2 }, void 0 !== this._remoteDefaultVideoStreamType && { defaultVideoStream: this._remoteDefaultVideoStreamType }), {}, { apRequestDetail: dN("AP_REQUEST_DETAIL") || void 0 });
          if (this._useLocalAccessPoint && (u2.setLocalAPVersion = this._setLocalAPVersion), "string" == typeof n2 && (u2.stringUid = n2, this._uintUid ? (u2.uid = this._uintUid, this._uintUid = void 0) : u2.uid = 0), "none" !== this._encryptionMode && this._encryptionSecret) {
            if (u2.aesmode = this._encryptionMode, u2.aespassword = await (async (e3) => {
              const t3 = function(e4) {
                const t4 = window.atob("MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDCMnXAHkKIGAM+x4N22gCI+Wyu\nSTM9ztkT3uYslTT2PuKmZfPzhH6kVdO7PTjGCOZnAsyb3oTtWat0KcxQ4jxvqQV+\nHvYl3iI1Yd4vl2c3qRMJPLtRDfNxa2Mcxgq7e9aEUibzdd0st+OJAy3tOj/Y0aVy\nxQiYDz3vqa6bP29adwIDAQAB"), i5 = new Uint8Array(new ArrayBuffer(t4.length));
                for (let e5 = 0; e5 < t4.length; e5 += 1)
                  i5[e5] = t4.charCodeAt(e5);
                return i5;
              }(), i4 = await window.crypto.subtle.importKey("spki", t3, { name: "RSA-OAEP", hash: "SHA-256" }, true, ["encrypt"]), n3 = bw(e3), r3 = await window.crypto.subtle.encrypt({ name: "RSA-OAEP" }, i4, n3);
              return function(e4) {
                let t4 = "";
                for (let i5 = 0; i5 < e4.length; i5 += 1)
                  t4 += String.fromCharCode(e4[i5]);
                return window.btoa(t4);
              }(new Uint8Array(r3));
            })(this._encryptionSecret), !this._joinAndNotLeaveYet)
              throw new XN(_w.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
            this._encryptionSalt && (u2.aessalt = this._encryptionSalt);
          }
          if (this._encryptDataStream && ("aes-128-gcm2" === this._encryptionMode || "aes-256-gcm2" === this._encryptionMode))
            if (this._encryptionSalt && this._encryptionSecret)
              if (window.crypto.subtle) {
                const e3 = new TextEncoder(), t3 = dN("USE_PURE_ENCRYPTION_MASTER_KEY") ? e3.encode(u2.appId + this._encryptionSecret + this._encryptionSecret) : e3.encode(u2.appId + u2.cname + this._encryptionSecret);
                this._encryptDataStreamIv = await async function(e4, t4, i4) {
                  const n3 = await window.crypto.subtle.importKey("raw", t4, "PBKDF2", false, ["deriveBits", "deriveKey"]), r3 = "aes-128-gcm2" === e4 ? 128 : 256, o3 = await window.crypto.subtle.deriveBits({ name: "PBKDF2", iterations: EN, hash: "SHA-256", salt: i4 }, n3, r3 + _N);
                  return new Uint8Array(o3).subarray(r3 / 8);
                }(this._encryptionMode, t3, nO(this._encryptionSalt)), this._encryptDataStreamKey = await async function(e4, t4, i4) {
                  const n3 = await window.crypto.subtle.importKey("raw", t4, "PBKDF2", false, ["deriveBits", "deriveKey"]), r3 = "aes-128-gcm2" === e4 ? 128 : 256;
                  return await window.crypto.subtle.deriveKey({ name: "PBKDF2", iterations: EN, hash: "SHA-256", salt: i4 }, n3, { name: "AES-GCM", length: r3 }, true, ["encrypt", "decrypt"]);
                }(this._encryptionMode, t3, nO(this._encryptionSalt));
              } else
                a2 ? BN.warning("[".concat(this._clientId, "] encrypt datastream must be running in a secure context, fallback to plain data stream")) : BN.warning("[".concat(this._clientId, "] current browser do not support WebCrypto ,fallback to plain data stream")), this._encryptDataStream = false;
            else
              this._encryptDataStream = false, BN.debug("[".concat(this._clientId, "] no salt / secret, cannot support encrypt data stream, fallback to plain data stream"));
          this._startSession(this._sessionId, { channel: t2, appId: e2, stringUid: u2.stringUid });
          const h2 = this._sessionId;
          setTimeout(() => {
            "CONNECTING" === this.connectionState && h2 === this._sessionId && zN.joinChannelTimeout(this._sessionId, 5);
          }, 5e3);
          try {
            var p3;
            let n3;
            const r3 = u2.cloudProxyServer;
            if (Dn(p3 = ["proxy3", "proxy4", "proxy5"]).call(p3, r3)) {
              const e3 = dN("PROXY_SERVER_TYPE3");
              Array.isArray(e3) ? u2.proxyServer = e3[0] : u2.proxyServer = e3;
            }
            if (zN.setProxyServer(u2.proxyServer), BN.setProxyServer(u2.proxyServer), this.store.requestAPStart(), c2) {
              if (BN.debug("[".concat(this._clientId, "] get serverInfo Success from Preload Cache ").concat(u2.stringUid ? ", ".concat(u2.stringUid, " => ").concat(c2.intUid) : "", " ")), u2.stringUid && !u2.uid && (u2.uid = c2.intUid), n3 = { gatewayInfo: c2.ap.gatewayInfo }, dN("JOIN_WITH_FALLBACK_MEDIA_PROXY") && "auto" === u2.turnServer.mode)
                if (0 === c2.ap.proxyInfo.addresses.length)
                  BN.warning("no edge services in ap response of proxy fallback, will not set proxy in iceServers");
                else {
                  const e3 = (await ix(c2.ap.proxyInfo, c2.ap.gatewayInfo.uid)).map((e4) => ({ turnServerURL: e4.address, tcpport: e4.tcpport || rN.tcpport, udpport: e4.udpport || rN.udpport, username: e4.username || rN.username, password: e4.password || rN.password, forceturn: false, security: true }));
                  u2.turnServer = { mode: "manual", servers: e3 };
                }
              AB(c2, u2.stringUid);
            } else {
              if (u2.stringUid && !u2.uid) {
                let e3;
                [e3, n3] = await Wh.all([IV(u2.stringUid, u2, this._axiosCancelSource.token, this._config.httpRetryConfig || yO, this.store), vV(u2, this._axiosCancelSource.token, this._config.httpRetryConfig || yO, true, this.store)]), BN.debug("[".concat(this._clientId, "] getUserAccount Success ").concat(u2.stringUid, " => ").concat(e3)), u2.uid = e3, n3.gatewayInfo.uid = e3, n3.gatewayInfo.res.uid = e3;
              } else
                n3 = await vV(u2, this._axiosCancelSource.token, this._config.httpRetryConfig || yO, true, this.store);
              if (!this._joinAndNotLeaveYet)
                throw new XN(_w.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
            }
            this.store.requestAPEnd(), setTimeout(() => {
              this._configDistribute.startGetConfigDistribute(u2, this._axiosCancelSource.token), this._configDistribute.on(sU.UPDATE_BITRATE_LIMIT, (e3) => {
                this._p2pChannel.updateBitrateLimit(e3);
              }), this._configDistribute.on(sU.UPDATE_CLIENT_ROLE_OPTIONS, (e3) => {
                this._setClientRoleOptions(e3);
              });
            }, 0), this._key = i3 || e2;
            const o3 = n3.gatewayInfo, s3 = u2.uid ? u2.uid : o3.uid;
            this._joinInfo = eG(eG({}, u2), {}, { cid: o3.cid, uid: s3, vid: o3.vid, apResponse: o3.res, apGatewayAddress: o3.apGatewayAddress, uni_lbs_ip: o3.uni_lbs_ip, gatewayAddrs: o3.gatewayAddrs }), this.store.intUid = s3;
            const a3 = await this._joinGateway();
            if (!this._joinAndNotLeaveYet)
              throw new XN(_w.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
            l2.onSuccess(a3), this._appId = e2, this._channelName = u2.cname, this._uid = a3, this.store.uid = a3, setTimeout(() => {
              this._networkQualityInterval && window.clearInterval(this._networkQualityInterval), this._networkQualityInterval = window.setInterval(this._handleUpdateNetworkQuality, 2e3), window.addEventListener(Wb() ? "beforeunload" : "pagehide", this._handleBeforeUnload), this._statsCollector.startUpdateStats();
            }, 0);
            const d3 = u2.stringUid ? "string uid: ".concat(u2.stringUid, ",uid: ").concat(u2.uid) : "uid: ".concat(this._uid);
            return BN.info("[".concat(this._clientId, "] Joining channel success: channel: ").concat(t2, ",").concat(d3)), setTimeout(() => {
              BN.startUpload();
            }, 5e3), this.store.joinEnd(), _2 = this, Dn(Bk).call(Bk, _2) || Bk.push(_2), "disabled" === this._cloudProxyServerMode && QN().supportWebCrypto && dN("ENABLE_PRELOAD") && IB(this._joinInfo), a3;
          } catch (e3) {
            const t3 = Array.isArray(e3) ? e3[0] : e3;
            throw t3 && t3.code === _w.OPERATION_ABORTED ? BN.warning("[".concat(this._clientId, "] join number: ").concat(o2, ", Joining channel failed, rollback"), t3) : BN.error("[".concat(this._clientId, "] join number: ").concat(o2, ", Joining channel failed, rollback"), t3), t3.code !== _w.OPERATION_ABORTED && this._numberOfJoinCount === o2 && (this._gateway.state = "DISCONNECTED", this._reset()), l2.onError(t3), t3;
          }
          var _2;
        }
        _joinGateway() {
          if (!this._joinInfo || !this._key)
            throw new XN(_w.INVALID_OPERATION);
          return this._gateway.join(this._joinInfo, this._key, !("disabled" !== this._joinInfo.cloudProxyServer || this._joinInfo.proxyServer || !dN("JOIN_WITH_FALLBACK_SIGNAL_PROXY")));
        }
        async leave() {
          BN.info("[".concat(this._clientId, "] Leaving channel")), window.removeEventListener(Wb() ? "beforeunload" : "pagehide", this._handleBeforeUnload), this._reset(), function(e3) {
            const t2 = Bk.indexOf(e3);
            -1 !== t2 && Bk.splice(t2, 1);
          }(this), this._statsCollector.stopUpdateStats();
          const e2 = await this._leaveMutex.lock();
          if ("DISCONNECTED" === this.connectionState)
            return BN.info("[".concat(this._clientId, "] Leaving channel repeated, success")), void e2();
          await this._gateway.leave("CONNECTED" !== this.connectionState, xw.LEAVE), BN.info("[".concat(this._clientId, "] Leaving channel success")), this._joinAndNotLeaveYet = false, this.store.resetJoinChannelServiceRecords(), e2();
        }
        async publish(e2) {
          let t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          if (!Array.isArray(e2)) {
            if (!(e2 instanceof WD))
              return this._publishDataChannel(e2);
            e2 = [e2];
          }
          if (0 === e2.length)
            throw new XN(_w.INVALID_PARAMS, "param list is empty");
          const i3 = e2;
          if ("audience" === this._gateway.role)
            throw new XN(_w.INVALID_OPERATION, "audience can not publish stream");
          for (const e3 of i3) {
            if (!(e3 instanceof WD))
              throw new XN(_w.INVALID_PARAMS, "parameter is not local track");
            if (!e3._enabled && t2)
              throw new XN(_w.TRACK_IS_DISABLED, "can not publish a disabled track: ".concat(e3.getTrackId()));
          }
          BN.info("[".concat(this._clientId, "] Publishing tracks, id ").concat(i3.map((e3) => "".concat(e3.getTrackId(), " "))));
          const n2 = await this._publishMutex.lock();
          await this._configDistribute.awaitConfigDistributeComplete(), t2 && i3.forEach((e3) => {
            const t3 = this._configDistribute.getBitrateLimit();
            e3 instanceof ak && t3 && e3.setBitrateLimit(t3.uplink);
          });
          try {
            await this._publishHighStream(i3), BN.info("[".concat(this._clientId, "] Publish success, id ").concat(i3.map((e3) => "".concat(e3.getTrackId(), " "))));
          } catch (e3) {
            throw BN.error("[".concat(this._clientId, "] publish error"), e3.toString()), e3;
          } finally {
            n2();
          }
        }
        async _publishDataChannel(e2) {
          Tw(e2.id, "id", 0, 65535, true), fw(e2.ordered, "ordered"), gw(e2.metadata, "metadata", 0, 512), BN.info("[".concat(this._clientId, "] Publishing datachannels, id ").concat(e2.id));
          const t2 = await this._publishMutex.lock();
          try {
            if (-1 !== this._p2pChannel.getAllDataChannels().findIndex((t3) => t3.id === e2.id))
              throw new XN(_w.INVALID_PARAMS, "Invalid id: ".concat(e2.id, ". If you want to republish the datachannel, unpublish first"));
            if (!this._joinInfo || void 0 === this._uid)
              throw new XN(_w.INVALID_OPERATION, "Can't publish datachannel, haven't joined yet!");
            if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState)
              throw new XN(_w.INVALID_OPERATION, "can not publish datachannel in ".concat(this.connectionState, " state"));
            if ("auto" === this._turnServer.mode && dN("FORCE_TURN") && !dN("TURN_ENABLE_TCP") && !dN("TURN_ENABLE_UDP"))
              throw new XN(_w.UNEXPECTED_ERROR, "force TURN With No TURN Configuration");
            const i3 = function(e3) {
              return Wx(e3, false);
            }(e2), n2 = await this._p2pChannel.publishDataChannel([i3]);
            if (n2.length > 0) {
              if ("number" != typeof i3._originDataChannelId)
                throw BN.error("[".concat(this._clientId, "] can not publish with mediaType datachannel, cannot get RTCDatachannel id")), new XN(_w.CREATE_DATACHANNEL_ERROR);
              try {
                await Wh.all(n2.map((e3) => this._uid && this._gateway.publishDataChannel(this._uid, e3, true))), await i3._waitTillOpen();
              } catch (e3) {
                if (e3.code !== _w.DISCONNECT_P2P)
                  throw e3;
              }
            }
            return BN.info("[".concat(this._clientId, "] Publish dataChannels success, id ").concat(i3.id)), i3;
          } catch (e3) {
            throw BN.error("[".concat(this._clientId, "] publish datachannels error"), e3.toString()), e3;
          } finally {
            t2();
          }
        }
        async unpublish(e2) {
          if (!this._joinInfo || void 0 === this._uid)
            throw new XN(_w.INVALID_OPERATION, "Can't unpublish stream, haven't joined yet!");
          let t2 = [];
          if (e2)
            if (Array.isArray(e2))
              t2 = e2;
            else {
              if (!(e2 instanceof WD))
                return this._unpublishDataChannel([e2]);
              t2 = [e2];
            }
          else
            this.store.useP2P || await this._unpublishDataChannel(), t2 = this._p2pChannel.getAllTracks(true);
          BN.info("[".concat(this._clientId, "] Unpublish tracks, tracks ").concat(t2.map((e3) => "".concat(e3.getTrackId(), " ")), " "));
          const i3 = await this._publishMutex.lock();
          try {
            if (this.store.useP2P) {
              const e3 = await this._p2pChannel.unpublish(t2);
              e3 && await this._gateway.sendExtensionMessage(yU.UNPUBLISH, { unpubMsg: e3 }, true);
            } else {
              const e3 = await this._p2pChannel.unpublish(t2);
              e3 && await this._gateway.unpublish(e3, this._uid), BN.info("[".concat(this._clientId, "] Unpublish success,tracks ").concat(t2.map((e4) => "".concat(e4.getTrackId()))));
            }
          } catch (e3) {
            throw BN.error("[".concat(this._clientId, "] unpublish error"), e3.toString()), e3;
          } finally {
            i3 && i3();
          }
        }
        async _unpublishDataChannel(e2) {
          void 0 !== e2 && 0 !== e2.length || (e2 = this._p2pChannel.getAllDataChannels()), BN.info("[".concat(this._clientId, "] Unpublish datachannels, datachannels ").concat(e2.map((e3) => "".concat(e3.id, " ")), " "));
          const t2 = await this._publishMutex.lock();
          try {
            const i3 = await this._p2pChannel.unpublishDataChannel(e2);
            i3 && await this._gateway.unpublishDataChannel(i3), BN.info("[".concat(this._clientId, "] Unpublish dataChannel success,dataChannel ").concat(e2.map((e3) => "".concat(e3.id))));
          } catch (e3) {
            throw BN.error("[".concat(this._clientId, "] unpublish dataChannel error"), e3.toString()), e3;
          } finally {
            t2 && t2();
          }
        }
        async subscribe(e2, t2, i3) {
          if (!(e2 instanceof GV)) {
            const t3 = this.remoteUsers.find((t4) => t4.uid === e2);
            if (!t3)
              throw new XN(_w.INVALID_REMOTE_USER, "user is not in the channel");
            e2 = t3;
          }
          return "datachannel" === t2 ? this._subscribeDataChannel(e2, i3) : this._subscribe(e2, t2);
        }
        async presubscribe(e2, t2) {
          if (mw(t2, "mediaType", ["audio", "video"]), this.store.useP2P)
            throw new XN(_w.INVALID_OPERATION, "can't presub at p2p mode");
          if (!this._joinInfo)
            throw new XN(_w.INVALID_OPERATION, "can't presub when not join");
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState)
            throw new XN(_w.INVALID_OPERATION, "can't presub in ".concat(this.connectionState, " state"));
          const i3 = t2 === lU.AUDIO, n2 = t2 === lU.VIDEO, r2 = await this._subscribeMutex.lock();
          try {
            const { ssrcId: o2, ortc: s2, rtxSsrcId: a2, cname: c2, uint_id: d2 } = await this._gateway.presubscribe(e2, t2, true);
            if (null == o2)
              throw new XN(_w.UNEXPECTED_RESPONSE, "no ssrc id");
            let l2 = this._users.find((t3) => t3.uid === e2);
            l2 || (l2 = new GV(e2, d2 || e2), l2._is_pre_created = true, this._users.push(l2)), c2 && (l2._cname = c2), l2._uintid || (l2._uintid = d2 || e2), i3 && (l2._audioSSRC = o2, l2._audio_pre_subscribed = true, s2 && (l2._audioOrtc = s2)), n2 && (l2._videoSSRC = o2, l2._video_pre_subscribed = true, s2 && (l2._videoOrtc = s2), null != a2 && (l2._rtxSsrcId = a2)), BN.info("[".concat(this._clientId, "] presub succeed ssrc: ").concat(o2)), await this._p2pChannel.subscribe(l2, t2, o2, a2, s2);
            const u2 = i3 ? l2._audioTrack : l2._videoTrack;
            if (!u2)
              throw new XN(_w.UNEXPECTED_ERROR, "can not find remote track in user");
            return i3 && (l2._trust_audio_stream_added_state_ = true, l2._audio_added_ = true), n2 && (l2._trust_video_stream_added_state_ = true, l2._video_added_ = true), u2;
          } catch (t3) {
            throw BN.error("[".concat(this._clientId, "] presub user ").concat(e2, " error"), t3), t3;
          } finally {
            r2();
          }
        }
        async _subscribeDataChannel(e2, t2) {
          var i3;
          if (Tw(t2, "channelId", 0, 65535, true), !this._joinInfo)
            throw new XN(_w.INVALID_OPERATION, "Can't subscribe datachannel, not joined");
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState)
            throw new XN(_w.INVALID_OPERATION, "Can't subscribe datachannel in ".concat(this.connectionState, " state"));
          const n2 = this._users.find((t3) => t3 === e2);
          if (!n2)
            throw BN.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", this user is not in the channel")), new XN(_w.INVALID_REMOTE_USER, "user is not in the channel");
          if (!e2.hasAudio && !e2.hasVideo && 0 === e2._dataChannels.length)
            throw BN.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", user is not published")), new XN(_w.INVALID_REMOTE_USER, "user is not published");
          const r2 = null === (i3 = e2._dataChannels) || void 0 === i3 ? void 0 : i3.find((e3) => e3.id === t2);
          if (!r2)
            throw BN.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, " with mediaType datachannel, remote datachannel is not published")), new XN(_w.REMOTE_USER_IS_NOT_PUBLISHED);
          const o2 = await this._subscribeMutex.lock();
          BN.info("[".concat(this._clientId, "] subscribe user ").concat(e2.uid, ", mediaType: datachannel"));
          try {
            const t3 = await this._p2pChannel.subscribeDataChannel(e2, [r2]);
            if (t3 && Dn(t3).call(t3, r2.id))
              try {
                var s2;
                if ("number" != typeof r2._originDataChannelId)
                  throw BN.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, " with mediaType datachannel, cannot get RTCDatachannel")), new XN(_w.CREATE_DATACHANNEL_ERROR);
                const t4 = { id: r2.id, datachannelId: r2._originDataChannelId, ordered: r2.ordered, maxRetransmits: r2.maxRetransmits, metadata: null !== (s2 = r2.metadata) && void 0 !== s2 ? s2 : "" };
                await this._gateway.subscribeDataChannel(e2.uid, t4, true), await r2._waitTillOpen();
              } catch (t4) {
                if ((null == t4 ? void 0 : t4.code) !== _w.WS_ABORT)
                  throw await this._p2pChannel.unsubscribeDataChannel(e2, [r2]), t4;
                await this._p2pChannel.unsubscribeDataChannel(e2, [r2]), this._p2pChannel.setPendingRemoteDataChannel(e2, r2.id);
              }
            return BN.info("[".concat(this._clientId, "] subscribe success user ").concat(e2.uid, ", mediaType: datachannel")), r2;
          } finally {
            o2();
          }
        }
        async _p2pSubscribe(e2, t2, i3) {
          if (mw(t2, "mediaType", ["audio", "video"]), !this._joinInfo)
            throw new XN(_w.INVALID_OPERATION, "Can't subscribe stream, not joined");
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState)
            throw new XN(_w.INVALID_OPERATION, "Can't subscribe stream in ".concat(this.connectionState, " state"));
          const n2 = this._users.find((t3) => t3 === e2);
          if (!n2) {
            const t3 = new XN(_w.INVALID_REMOTE_USER, "user is not in the channel");
            throw BN.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", this user is not in the channel")), t3;
          }
          if (!e2.hasAudio && !e2.hasVideo) {
            const t3 = new XN(_w.INVALID_REMOTE_USER, "user is not published");
            throw BN.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", user is not published")), t3;
          }
          if (!i3 && ("audio" === t2 && !e2.hasAudio || "video" === t2 && !e2.hasVideo)) {
            const i4 = new XN(_w.REMOTE_USER_IS_NOT_PUBLISHED);
            throw BN.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, " with mediaType ").concat(t2, ", remote track is not published")), i4;
          }
          const r2 = await this._subscribeMutex.lock();
          BN.info("[".concat(this._clientId, "] subscribe user ").concat(e2.uid, ", mediaType: ").concat(t2));
          try {
            if (await this._p2pChannel.hasRemoteMediaWithLock(e2, t2))
              await this._p2pChannel.unmuteRemote(e2, t2);
            else
              try {
                const i5 = "audio" === t2 ? e2._audioSSRC : e2._videoSSRC, n3 = "audio" === t2 ? e2._audioMid : e2._videoMid;
                this.store.subscribe(e2.uid, t2, Date.now()), this.store.useP2P && await this._p2pChannel.subscribe(e2, t2, i5, n3);
              } catch (e3) {
                throw e3;
              }
            BN.info("[".concat(this._clientId, "] subscribe success user ").concat(e2.uid, ", mediaType: ").concat(t2)), this._defaultStreamFallbackType && this.setStreamFallbackOption(e2.uid, this._defaultStreamFallbackType).catch((e3) => {
              BN.warning("[".concat(this._clientId, "] auto set fallback failed"), e3);
            });
            const i4 = "audio" === t2 ? e2._audioTrack : e2._videoTrack;
            if (!i4)
              throw new XN(_w.UNEXPECTED_ERROR, "can not find remote track in user object");
            return i4;
          } catch (t3) {
            throw BN.error("[".concat(this._clientId, "] subscribe user ").concat(e2.uid, " error"), t3), t3;
          } finally {
            r2();
          }
        }
        async _subscribe(e2, t2, i3) {
          if (this.store.useP2P)
            return this._p2pSubscribe(e2, t2);
          if (mw(t2, "mediaType", ["audio", "video"]), !this._joinInfo)
            throw new XN(_w.INVALID_OPERATION, "Can't subscribe stream, not joined");
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState)
            throw new XN(_w.INVALID_OPERATION, "Can't subscribe stream in ".concat(this.connectionState, " state"));
          const n2 = this._users.find((t3) => t3 === e2);
          if (!n2) {
            const t3 = new XN(_w.INVALID_REMOTE_USER, "user is not in the channel");
            throw BN.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", this user is not in the channel")), t3;
          }
          if (!e2.hasAudio && !e2.hasVideo) {
            const t3 = new XN(_w.INVALID_REMOTE_USER, "user is not published");
            throw BN.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", user is not published")), t3;
          }
          if (!(i3 || ("audio" !== t2 || e2.hasAudio && void 0 !== e2._audioSSRC) && ("video" !== t2 || e2.hasVideo && void 0 !== e2._videoSSRC))) {
            const i4 = new XN(_w.REMOTE_USER_IS_NOT_PUBLISHED);
            throw BN.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, " with mediaType ").concat(t2, ", remote track is not published")), i4;
          }
          let r2 = "audio" === t2 ? e2._audioSSRC : e2._videoSSRC, o2 = "audio" === t2 ? e2._audioOrtc : e2._videoOrtc, s2 = "video" === t2 ? e2._rtxSsrcId : void 0, a2 = { stream_type: "audio" === t2 ? lU.AUDIO : lU.VIDEO, ssrcId: r2 };
          const c2 = await this._subscribeMutex.lock();
          BN.info("[".concat(this._clientId, "] subscribe user ").concat(e2.uid, ", mediaType: ").concat(t2));
          try {
            if (await this._p2pChannel.hasRemoteMediaWithLock(e2, t2))
              await this._p2pChannel.unmuteRemote(e2, t2);
            else
              try {
                const i5 = "audio" === t2 ? e2._audioSSRC : e2._videoSSRC;
                void 0 !== i5 && i5 !== r2 && (r2 = i5, o2 = "audio" === t2 ? e2._audioOrtc : e2._videoOrtc, s2 = "video" === t2 ? e2._rtxSsrcId : void 0, a2 = { stream_type: "audio" === t2 ? lU.AUDIO : lU.VIDEO, ssrcId: r2 }), UV.markSubscribeStart(this.store.clientId, r2), this.store.subscribe(e2.uid, t2, Date.now()), await this._p2pChannel.subscribe(e2, t2, r2, s2, o2);
                try {
                  this._p2pChannel.isPreSubScribe(r2) || await this._gateway.subscribe(e2.uid, a2, true);
                } catch (i6) {
                  if ((null == i6 ? void 0 : i6.code) !== _w.WS_ABORT)
                    throw await this._p2pChannel.unsubscribe(e2, t2), i6;
                  await this._p2pChannel.unsubscribe(e2, t2, true), this._p2pChannel.setPendingRemoteMedia(e2, t2);
                }
                this.store.subscribe(e2.uid, t2, void 0, Date.now()), this._p2pChannel.reportSubscribeEvent(true, null, e2, t2);
              } catch (i5) {
                throw this._p2pChannel.reportSubscribeEvent(false, null == i5 ? void 0 : i5.code, e2, t2), i5;
              }
            BN.info("[".concat(this._clientId, "] subscribe success user ").concat(e2.uid, ", mediaType: ").concat(t2)), this._defaultStreamFallbackType && this.setStreamFallbackOption(e2.uid, this._defaultStreamFallbackType).catch((e3) => {
              BN.warning("[".concat(this._clientId, "] auto set fallback failed"), e3);
            });
            const i4 = "audio" === t2 ? e2._audioTrack : e2._videoTrack;
            if (!i4)
              throw new XN(_w.UNEXPECTED_ERROR, "can not find remote track in user object");
            return i4;
          } catch (t3) {
            throw BN.error("[".concat(this._clientId, "] subscribe user ").concat(e2.uid, " error"), t3), t3;
          } finally {
            c2();
          }
        }
        async massSubscribe(e2) {
          if (Rw(e2, "subscribeList"), !this._joinInfo)
            throw new XN(_w.INVALID_OPERATION, "Can't subscribe stream, not joined");
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState)
            throw new XN(_w.INVALID_OPERATION, "Can't subscribe stream in ".concat(this.connectionState, " state"));
          const t2 = Date.now(), i3 = /* @__PURE__ */ new Map(), n2 = await this._subscribeMutex.lock();
          BN.info("[".concat(this._clientId, "]start massSubscribe user ").concat(e2.map((e3) => {
            let { user: t3, mediaType: i4 } = e3;
            return "user: ".concat(null == t3 ? void 0 : t3.uid, ", mediaType: ").concat(i4);
          }).join("; ")));
          const r2 = (e2 = [...e2]).map((e3) => {
            let { user: t3, mediaType: i4 } = e3;
            return { user: t3, mediaType: i4 };
          }), o2 = await this._p2pChannel.globalLock();
          try {
            var s2;
            for (let t3 = e2.length - 1; t3 >= 0; t3--) {
              const n3 = e2[t3], { user: o3, mediaType: s3 } = n3;
              if (mw(s3, "mediaType", ["audio", "video"]), !o3) {
                const e3 = new XN(_w.INVALID_PARAMS, "user property does not exist in subscribeList item");
                throw BN.error("[".concat(this._clientId, "] user property does not exist in subscribeList item")), e3;
              }
              const a3 = this._users.find((e3) => e3 === o3);
              if (!a3) {
                const i4 = new XN(_w.INVALID_REMOTE_USER, "user is not in the channel");
                BN.error("[".concat(this._clientId, "] can not massSubscribe ").concat(o3.uid, ", this user is not in the channel")), r2[t3].error = i4, e2.splice(t3, 1);
                continue;
              }
              if ("audio" === s3 && (!o3.hasAudio || void 0 === o3._audioSSRC) || "video" === s3 && (!o3.hasVideo || void 0 === o3._videoSSRC)) {
                const i4 = new XN(_w.REMOTE_USER_IS_NOT_PUBLISHED);
                BN.error("[".concat(this._clientId, "] can not subscribe ").concat(o3.uid, " with mediaType ").concat(s3, ", remote user is not published")), r2[t3].error = i4, e2.splice(t3, 1);
                continue;
              }
              const c2 = tU.Video | tU.LwoVideo, d2 = i3.get(o3);
              if (d2) {
                if ("video" === s3 ? d2 & c2 : d2 & tU.Audio) {
                  e2.splice(t3, 1), BN.warning("[".concat(this._clientId, "] repeat massSubscribe user:").concat(o3.uid, ", mediaType:").concat(s3, " twice"));
                  continue;
                }
                i3.set(o3, d2 | ("video" === s3 ? c2 : tU.Audio));
              } else
                i3.set(o3, "video" === s3 ? c2 : tU.Audio);
            }
            for (let t3 = e2.length - 1; t3 >= 0; t3--) {
              const n3 = e2[t3], { user: r3, mediaType: o3 } = n3, s3 = tU.Video | tU.LwoVideo;
              if (this._p2pChannel.hasRemoteMedia(r3, o3)) {
                await this._p2pChannel.unmuteRemoteNoLock(r3, o3);
                const n4 = i3.get(r3);
                i3.set(r3, "video" === o3 ? n4 ^ s3 : n4 ^ tU.Audio), e2.splice(t3, 1);
              }
            }
            this.store.massSubscribe(e2.map((e3) => ({ userId: e3.user.uid, type: e3.mediaType })), t2);
            let a2 = Xn(s2 = Array.from(i3.entries())).call(s2, (e3, t3) => {
              let [i4, n3] = t3;
              if (0 === n3)
                return e3;
              const r3 = { stream_id: i4.uid, stream_type: n3 };
              return n3 & tU.Audio && (r3.audio_ssrc = i4._audioSSRC), n3 & tU.Video && (r3.video_ssrc = i4._videoSSRC), e3.push(r3), e3;
            }, []);
            try {
              e2.length > 0 && await this._p2pChannel.massSubscribeNoLock(e2.map((e3) => {
                let { user: t3, mediaType: i5 } = e3;
                return { user: t3, mediaType: i5, ssrcId: i5 === lU.VIDEO ? t3._videoSSRC : t3._audioSSRC, rtxSsrcId: i5 === lU.VIDEO ? t3._rtxSsrcId : void 0 };
              }));
              const i4 = /* @__PURE__ */ new Map();
              if (a2 = a2.filter((e3) => e3.video_ssrc && !this._p2pChannel.isPreSubScribe(e3.video_ssrc) || e3.audio_ssrc && !this._p2pChannel.isPreSubScribe(e3.audio_ssrc) || !e3.video_ssrc && !e3.audio_ssrc), a2.length > 0) {
                const e3 = await this._gateway.subscribeAll(a2, true);
                ((null == e3 ? void 0 : e3.users) || []).forEach((e4) => {
                  let { stream_id: t3, video_error_code: n3, audio_error_code: r3, error_code: o3 } = e4;
                  (n3 || r3 || o3) && i4.set(t3, { video_error_code: n3, audio_error_code: r3, error_code: o3 });
                });
              }
              if (Array.from(i4.entries()).length > 0) {
                const e3 = [];
                Array.from(i4.entries()).forEach((t3) => {
                  let [i5, n3] = t3;
                  const r3 = this.remoteUsers.find((e4) => e4.uid === i5);
                  if (r3) {
                    let t4;
                    n3.error_code || n3.video_error_code && n3.audio_error_code ? t4 = void 0 : n3.video_error_code ? t4 = lU.VIDEO : n3.audio_error_code && (t4 = lU.AUDIO), e3.push({ user: r3, mediaType: t4 });
                  }
                }), e3.length > 0 && await this._p2pChannel.massUnsubscribeNoLock(e3);
              }
              for (const e3 of r2) {
                const t3 = i4.get(e3.user.uid);
                if (t3) {
                  const i5 = t3.error_code || "audio" === e3.mediaType && t3.audio_error_code || "video" === e3.mediaType && t3.video_error_code;
                  if (i5) {
                    const t4 = PU(i5);
                    BN.error("user:".concat(e3.user.uid, " mediaType:").concat(e3.mediaType, " has massSubscribe error ").concat(t4.desc)), e3.error = new XN(_w.SUBSCRIBE_FAILED, "code ".concat(i5, ": ").concat(t4.desc));
                  }
                }
                e3.error || ("video" === e3.mediaType ? e3.track = e3.user.videoTrack : e3.track = e3.user.audioTrack);
              }
              return this.store.massSubscribe(r2.filter((e3) => !e3.error).map((e3) => ({ userId: e3.user.uid, type: e3.mediaType })), void 0, Date.now()), r2.forEach((e3) => {
                var i5;
                zN.subscribe(this.store.sessionId, { succ: !!e3.error, ec: (null === (i5 = e3.error) || void 0 === i5 ? void 0 : i5.code) || null, video: e3.mediaType === lU.VIDEO, audio: e3.mediaType === lU.AUDIO, peerid: e3.user.uid, subscribeRequestid: e3.mediaType === lU.VIDEO ? e3.user._videoSSRC : e3.user._audioSSRC, p2pid: this.store.p2pId, eventElapse: Math.floor(performance.now() - t2), preSsrc: this._p2pChannel.isPreSubScribe(e3.user._videoSSRC) }, true);
              }), BN.info("[".concat(this._clientId, "] massSubscribe success ").concat(e2.map((e3) => {
                let { user: t3, mediaType: i5 } = e3;
                return "user: ".concat(null == t3 ? void 0 : t3.uid, ", mediaType: ").concat(i5);
              }).join("; "))), r2;
            } catch (t3) {
              throw await this._p2pChannel.massUnsubscribeNoLock(e2), t3;
            }
          } finally {
            o2(), n2();
          }
        }
        async unsubscribe(e2, t2, i3) {
          if (!(e2 instanceof GV)) {
            const t3 = this.remoteUsers.find((t4) => t4.uid === e2);
            if (!t3)
              throw new XN(_w.INVALID_REMOTE_USER, "user is not in the channel");
            e2 = t3;
          }
          if (t2 || this.store.useP2P) {
            if ("datachannel" === t2)
              return this._unsubscribeDataChannel(e2, i3);
          } else
            await this._unsubscribeDataChannel(e2, i3);
          if (t2 && mw(t2, "mediaType", ["audio", "video"]), !this._joinInfo)
            throw new XN(_w.INVALID_OPERATION, "Can't unsubscribe stream, haven't joined yet!");
          const n2 = this._users.find((t3) => t3 === e2);
          if (!n2) {
            const t3 = new XN(_w.INVALID_REMOTE_USER, "user is not in the channel");
            throw BN.error("[".concat(this._clientId, "] can not unsubscribe ").concat(e2.uid, ", user is not in the channel")), t3;
          }
          BN.info("[".concat(this._clientId, "] unsubscribe uid: ").concat(e2.uid, ", mediaType: ").concat(t2));
          const r2 = await this._subscribeMutex.lock();
          try {
            if (this.store.useP2P)
              await this._p2pChannel.unsubscribe(e2, t2);
            else {
              const i4 = await this._p2pChannel.unsubscribe(e2, t2);
              i4 && await this._gateway.unsubscribe(i4, e2.uid), t2 && "audio" !== t2 || (e2._audio_pre_subscribed = false), t2 && "video" !== t2 || (e2._video_pre_subscribed = false), e2._is_pre_created && Jw(this._users, e2), BN.info("[".concat(this._clientId, "] unsubscribe success uid: ").concat(e2.uid, ", mediaType: ").concat(t2));
            }
          } catch (t3) {
            if (t3.code === _w.DISCONNECT_P2P)
              return void BN.warning("disconnecting p2p, abort unsubscribe request.");
            throw BN.error("[".concat(this._clientId, "] unsubscribe user ").concat(e2.uid, " error"), t3.toString()), t3;
          } finally {
            r2();
          }
        }
        async _unsubscribeDataChannel(e2, t2) {
          if (t2 && Tw(t2, "id", 0, 65535, true), !this._joinInfo)
            throw new XN(_w.INVALID_OPERATION, "Can't unsubscribe datachannel, haven't joined yet!");
          const i3 = this._users.find((t3) => t3 === e2);
          if (!i3) {
            const t3 = new XN(_w.INVALID_REMOTE_USER, "user is not in the channel");
            throw BN.error("[".concat(this._clientId, "] can not unsubscribe ").concat(e2.uid, ", user is not in the channel")), t3;
          }
          let n2;
          if ("number" == typeof t2) {
            const i4 = e2._dataChannels.find((e3) => e3.id === t2);
            i4 && (n2 = [i4]);
          } else
            n2 = e2._dataChannels;
          if (void 0 === n2) {
            const i4 = new XN(_w.REMOTE_USER_IS_NOT_PUBLISHED);
            throw BN.error("[".concat(this._clientId, "] can not unsubscribe ").concat(e2.uid, " with channelId ").concat(t2, ", remote datachannel is not published")), i4;
          }
          BN.info("[".concat(this._clientId, "] unsubscribe uid: ").concat(e2.uid, ", mediaType: datachannel, ids: ").concat(n2.map((e3) => e3.id)));
          try {
            const t3 = await this._p2pChannel.unsubscribeDataChannel(e2, n2);
            t3 && await this._gateway.unsubscribeDataChannel(t3, e2.uid), BN.info("[".concat(this._clientId, "] unsubscribe datachannel success uid: ").concat(e2.uid, ", mediaType: datachannel, ids: ").concat(t3));
          } catch (t3) {
            if (t3.code === _w.DISCONNECT_P2P)
              return void BN.warning("disconnecting p2p, abort unsubscribe request.");
            throw BN.error("[".concat(this._clientId, "] unsubscribe user ").concat(e2.uid, " error"), t3.toString()), t3;
          }
        }
        async massUnsubscribe(e2) {
          if (Rw(e2, "unsubscribeList"), !this._joinInfo)
            throw new XN(_w.INVALID_OPERATION, "Can't unsubscribeAll stream, haven't joined yet!");
          BN.info("[".concat(this._clientId, "] start massUnsubscribe ").concat(e2.map((e3) => {
            let { user: t3, mediaType: i3 } = e3;
            return "user: ".concat(null == t3 ? void 0 : t3.uid, ", mediaType: ").concat(i3, ";");
          }).join())), e2 = [...e2];
          const t2 = /* @__PURE__ */ new Map();
          for (let i3 = e2.length - 1; i3 >= 0; i3--) {
            const { user: n2, mediaType: r2 } = e2[i3];
            if (!n2) {
              const e3 = new XN(_w.INVALID_PARAMS, "user property does not exist in unsubscribeList item");
              throw BN.error("[".concat(this._clientId, "] user property does not exist in unsubscribeList item")), e3;
            }
            mw(r2, "mediaType", ["video", "audio", void 0]);
            const o2 = this._users.find((e3) => e3 === n2);
            if (!o2) {
              BN.warning("[".concat(this._clientId, "] can not unsubscribe ").concat(n2.uid, ", user is not in the channel")), e2.splice(i3, 1);
              continue;
            }
            const s2 = tU.Video | tU.LwoVideo;
            if (t2.has(n2)) {
              const o3 = t2.get(n2);
              let a2;
              switch (r2) {
                case "video":
                  a2 = o3 & s2;
                  break;
                case "audio":
                  a2 = o3 & tU.Audio;
                  break;
                default:
                  a2 = o3 & (tU.Audio | s2);
              }
              if (a2) {
                BN.warning("[".concat(this._clientId, "] repeat massUnsubscribe user:").concat(n2.uid, ",mediaType:").concat(r2, " twice.")), e2.splice(i3, 1);
                continue;
              }
              r2 ? "audio" === r2 ? t2.set(n2, o3 | tU.Audio) : "video" === r2 && t2.set(n2, o3 | s2) : t2.set(n2, o3 | tU.Audio | s2);
            } else
              r2 ? "audio" === r2 ? t2.set(n2, tU.Audio) : "video" === r2 && t2.set(n2, s2) : t2.set(n2, tU.Audio | s2);
          }
          try {
            const t3 = await this._p2pChannel.massUnsubscribe(e2);
            t3 && await this._gateway.massUnsubscribe(t3), BN.info("[".concat(this._clientId, "] massUnsubscribe success ").concat(e2.map((e3) => {
              let { user: t4, mediaType: i3 } = e3;
              return "user: ".concat(null == t4 ? void 0 : t4.uid, ", mediaType: ").concat(i3, ";");
            }).join()));
          } catch (e3) {
            if (e3.code === _w.DISCONNECT_P2P)
              return void BN.warning("[".concat(this._clientId, "] disconnecting p2p, abort unsubscribe request."));
            throw BN.error("[".concat(this._clientId, "] massUnsubscribe error"), e3.toString()), e3;
          }
        }
        async setLowStreamParameter(e2) {
          !function(e3) {
            if (!e3)
              throw new Ew(_w.INVALID_PARAMS);
            Cw(e3.width) || Sw(e3.width, "streamParameter.width"), Cw(e3.height) || Sw(e3.height, "streamParameter.height"), Cw(e3.framerate) || Sw(e3.framerate, "streamParameter.framerate"), Cw(e3.bitrate) || Tw(e3.bitrate, "streamParameter.bitrate");
          }(e2), (!e2.width && e2.height || e2.width && !e2.height) && BN.warning("[".concat(this._clientId, "] The width and height parameters take effect only when both are set")), BN.info("[".concat(this._clientId, "] set low stream parameter to"), JSON.stringify(e2));
          const t2 = this._configDistribute.getLowStreamConfigDistribute();
          if (t2 && t2.bitrate && e2.bitrate && t2.bitrate < e2.bitrate && (e2.bitrate = t2.bitrate), this._lowStreamParameter = e2, this._isDualStreamEnabled)
            return this._p2pChannel.updateVideoStreamParameter(e2, _U.LocalVideoLowTrack);
        }
        async enableDualStream() {
          if (!QN().supportDualStream)
            throw zN.streamSwitch(this._sessionId, { lts: Date.now(), isdual: true, succ: false }), new XN(_w.NOT_SUPPORTED, "Your browser is not support dual stream");
          if (this._isDualStreamEnabled)
            throw new XN(_w.INVALID_OPERATION, "Dual stream is already enabled");
          if (this._p2pChannel.canPublishLowStream())
            try {
              await this._publishLowStream();
            } catch (e2) {
              throw zN.streamSwitch(this._sessionId, { lts: Date.now(), isdual: true, succ: false }), e2;
            }
          this._isDualStreamEnabled = true, zN.streamSwitch(this._sessionId, { lts: Date.now(), isdual: true, succ: true }), BN.info("[".concat(this._clientId, "] enable dual stream"));
        }
        async disableDualStream() {
          if (this._isDualStreamEnabled) {
            if (!this._joinInfo)
              throw new XN(_w.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
            if (this._p2pChannel.getLocalMedia(_U.LocalVideoLowTrack))
              try {
                const e2 = await this._p2pChannel.unpublishLowStream();
                e2 && await this._gateway.unpublish(e2, this._joinInfo.stringUid || this._joinInfo.uid);
              } catch (e2) {
                throw zN.streamSwitch(this._sessionId, { lts: Date.now(), isdual: false, succ: false }), e2;
              }
            this._isDualStreamEnabled = false, zN.streamSwitch(this._sessionId, { lts: Date.now(), isdual: false, succ: true }), BN.info("[".concat(this._clientId, "] disable dual stream"));
          }
        }
        async setClientRole(e2, t2) {
          if (function(e3) {
            mw(e3, "role", ["audience", "host"]);
          }(e2), t2 && Bw(t2), "rtc" === this.mode || "p2p" === this.mode)
            throw BN.warning("[".concat(this._clientId, "]").concat(this.mode, " mode can not use setClientRole")), new XN(_w.INVALID_OPERATION, "".concat(this.mode, " mode can not use setClientRole"));
          if (t2 && t2.level && "host" === e2)
            throw new XN(_w.INVALID_OPERATION, "host mode can not set audience latency level");
          if ("audience" === e2 && this._p2pChannel.hasLocalMedia())
            throw new XN(_w.INVALID_OPERATION, "can not set client role to audience when publishing stream");
          const i3 = this._config.role;
          this._joinInfo && (this._joinInfo.role = e2), e2 !== i3 && dN("ENABLE_ROLE_SELECT_EDGE") ? (this._gateway.updateClientRole(e2, t2), this._config.role = e2, this._gateway.reconnect("recover", Gw.REGIONAL_DISTRIBUTION)) : (await this._gateway.setClientRole(e2, t2), this._config.role = e2), BN.info("[".concat(this._clientId, "] set client role to ").concat(e2, ", level: ").concat(t2 && t2.level));
        }
        async _setClientRoleOptions(e2) {
          if ("rtc" === this.mode || "p2p" === this.mode)
            return;
          if ("audience" !== this._config.role || this._p2pChannel.hasLocalMedia())
            return;
          let t2 = false;
          try {
            e2 && Bw(e2), await this._gateway.setClientRole(this._config.role, e2), t2 = true;
          } catch (e3) {
          } finally {
            BN.info("[".concat(this._clientId, "] set client role options ").concat(t2 ? "succeed" : "failed", ", options is ").concat(e2));
          }
        }
        getRemoteInboundOffset() {
          var e2;
          const t2 = null === (e2 = this._p2pChannel.getStats()) || void 0 === e2 ? void 0 : e2.audioSend[0];
          if (!t2 || !t2.timestamp)
            return 0;
          const i3 = t2.timestamp - Date.now();
          return Math.abs(i3) > 1e3 + t2.rttMs + 100 ? this.ntpAlignErrorCount += 1 : this.ntpAlignErrorCount = 0, this.ntpAlignErrorCount >= 3 ? i3 : 0;
        }
        getNtpWallTimeInMs() {
          return "visible" === document.visibilityState && (this.remoteInboundOffset = this.getRemoteInboundOffset()), this.remoteInboundOffset + Date.now() + this._gateway.ntpOffset;
        }
        setProxyServer(e2, t2) {
          if (gw(e2, "proxyServer"), !t2) {
            if ("DISCONNECTED" !== this.connectionState)
              throw new XN(_w.INVALID_OPERATION, "Set proxy server before join channel");
            if ("disabled" !== this._cloudProxyServerMode || this._useLocalAccessPoint)
              throw new XN(_w.INVALID_OPERATION, "You have already set the proxy");
          }
          this._proxyServer = e2, zN.setProxyServer(this._proxyServer), BN.setProxyServer(this._proxyServer), BN.info("[".concat(this._clientId, "] Set proxy server ").concat(t2 ? "by initialize call" : "", " success."));
        }
        setTurnServer(e2, t2) {
          if (Array.isArray(e2) || (e2 = [e2]), !t2) {
            if ("DISCONNECTED" !== this.connectionState)
              throw new XN(_w.INVALID_OPERATION, "Set turn server before join channel");
            if ("disabled" !== this._cloudProxyServerMode || this._useLocalAccessPoint)
              throw new XN(_w.INVALID_OPERATION, "You have already set the proxy");
          }
          if (Vw(e2))
            return this._turnServer = { servers: e2, mode: "original-manual" }, void BN.info("[".concat(this._clientId, "] Set original turnserver ").concat(t2 ? "by initialize call" : "", " success: ").concat(e2.map((e3) => e3.urls).join(","), "."));
          e2.forEach((e3) => Fw(e3)), this._turnServer = { servers: e2, mode: "manual" }, BN.info("[".concat(this._clientId, "] Set turnserver ").concat(t2 ? "by initialize call" : "", " success."));
        }
        setLicense(e2) {
          if ("DISCONNECTED" !== this.connectionState) {
            throw new XN(_w.INVALID_OPERATION, "you should set license before join channel");
          }
          if (gw(e2, "license", 32, 32), !/^[A-Za-z\d]+$/.test(e2))
            throw new XN(_w.INVALID_PARAMS, "license should only contains characters from A-Z a-z 0-9");
          this._license = e2, BN.info("[".concat(this._clientId, "] set license success"), e2);
        }
        startProxyServer(e2) {
          if ("DISCONNECTED" !== this.connectionState)
            throw new XN(_w.INVALID_OPERATION, "Start proxy server before join channel");
          if (this._proxyServer || "manual" === this._turnServer.mode || this._useLocalAccessPoint)
            throw new XN(_w.INVALID_OPERATION, "You have already set the proxy");
          const t2 = [3, 4, 5];
          let i3;
          switch (void 0 === e2 && (e2 = 3), e2) {
            case 1:
            case 2:
              throw new XN(_w.NOT_SUPPORTED, "proxy mode 1/2 has been deprecated and not supported.");
            case 3:
              i3 = "proxy3";
              break;
            case 4:
              i3 = "proxy4";
              break;
            case 5:
              i3 = "proxy5";
              break;
            default:
              throw new XN(_w.INVALID_PARAMS, "proxy server mode must be ".concat(t2.join("|")));
          }
          this._cloudProxyServerMode = i3, this.store.cloudProxyServerMode = i3, BN.info("[".concat(this._clientId, "] set cloud proxy server mode to"), this._cloudProxyServerMode);
        }
        stopProxyServer() {
          if ("DISCONNECTED" !== this.connectionState)
            throw new XN(_w.INVALID_OPERATION, "Stop proxy server after leave channel");
          zN.setProxyServer(), BN.setProxyServer(), this._cloudProxyServerMode = "disabled", this.store.cloudProxyServerMode = "disabled", BN.info("[".concat(this._clientId, "] set cloud proxy server mode to"), this._cloudProxyServerMode), this._proxyServer = void 0, this._turnServer = { mode: "auto", servers: [] };
        }
        setLocalAccessPointsV2(e2) {
          if (!e2.accessPoints)
            throw new XN(_w.INVALID_PARAMS, "accessPoints is required.");
          Rw(e2.accessPoints.serverList, "accessPoints.serverList"), gw(e2.accessPoints.domain, "accessPoints.domain");
          const t2 = (e3, t3) => {
            Tw(e3, t3, 0, 65535, true);
          };
          let i3 = 443;
          if (e2.accessPoints.port && (t2(e2.accessPoints.port, "accessPoints.port"), i3 = e2.accessPoints.port), this._proxyServer || "disabled" !== this._cloudProxyServerMode)
            throw new XN(_w.INVALID_OPERATION, "set local access point failed, You have already set the cloud proxy");
          dN("CLOSE_AFB_FOR_LOCAL_AP") && (cN("JOIN_WITH_FALLBACK_SIGNAL_PROXY", false), cN("JOIN_WITH_FALLBACK_MEDIA_PROXY", false));
          const n2 = /^((\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.){3}(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/, r2 = e2.accessPoints.domain, o2 = e2.accessPoints.serverList.map((e3) => n2.test(e3) ? "".concat(e3.replace(/\./g, "-"), ".").concat(r2) : e3), s2 = o2.map((e3) => "".concat(e3, ":").concat(i3));
          this._useLocalAccessPoint = true, this._setLocalAPVersion = 2, cN("WEBCS_DOMAIN", s2), cN("WEBCS_DOMAIN_BACKUP_LIST", s2), cN("GATEWAY_DOMAINS", [r2]), e2.report && e2.report.hostname && Array.isArray(e2.report.hostname) && e2.report.hostname.length ? (Rw(e2.report.hostname, "report.hostname"), cN("EVENT_REPORT_DOMAIN", e2.report.hostname[0]), cN("EVENT_REPORT_BACKUP_DOMAIN", e2.report.hostname[1] || e2.report.hostname[0])) : (cN("EVENT_REPORT_DOMAIN", o2[0]), cN("EVENT_REPORT_BACKUP_DOMAIN", o2[1] || o2[0]));
          let a2 = 6443;
          e2.report && e2.report.port && (t2(e2.report.port, "report.port"), a2 = e2.report.port), cN("STATS_COLLECTOR_PORT", a2), e2.report ? cN("ENABLE_EVENT_REPORT", true) : cN("ENABLE_EVENT_REPORT", false);
          let c2 = "";
          e2.log && e2.log.hostname && Array.isArray(e2.log.hostname) && e2.log.hostname.length ? (Rw(e2.log.hostname, "log.hostname"), c2 = e2.log.hostname[0]) : c2 = o2[0];
          let d2 = 6444;
          e2.log && e2.log.port && (t2(e2.log.port, "log.port"), d2 = e2.log.port), cN("LOG_UPLOAD_SERVER", "".concat(c2, ":").concat(d2));
          let l2 = [];
          e2.cds && e2.cds.hostname && Array.isArray(e2.cds.hostname) && e2.cds.hostname.length ? (Rw(e2.cds.hostname, "cds.hostname"), l2 = e2.cds.hostname) : l2 = o2;
          let u2 = 443;
          e2.cds && e2.cds.port && (t2(e2.cds.port, "cds.port"), u2 = e2.cds.port), cN("CDS_AP", l2.map((e3) => "".concat(e3, ":").concat(u2))), e2.cds ? cN("ENABLE_CONFIG_DISTRIBUTE", true) : cN("ENABLE_CONFIG_DISTRIBUTE", false), BN.info("set local access point v2 success");
        }
        setLocalAccessPoints(e2, t2) {
          if (Rw(e2, "serverList"), gw(t2, "domain"), this._proxyServer || "disabled" !== this._cloudProxyServerMode)
            throw new XN(_w.INVALID_OPERATION, "set local access point failed, You have already set the cloud proxy");
          const i3 = /^(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/;
          e2 = e2.map((e3) => i3.test(e3) ? "".concat(e3.replace(/\./g, "-"), ".").concat(t2) : e3), this._useLocalAccessPoint = true, this._setLocalAPVersion = 1, cN("WEBCS_DOMAIN", e2), cN("WEBCS_DOMAIN_BACKUP_LIST", e2), cN("GATEWAY_DOMAINS", [t2]), cN("EVENT_REPORT_DOMAIN", e2[0]), cN("EVENT_REPORT_BACKUP_DOMAIN", e2[1] || e2[0]), cN("LOG_UPLOAD_SERVER", "".concat(e2[0], ":6444")), BN.info("[".concat(this._clientId, "] set local access point success"));
        }
        async setRemoteDefaultVideoStreamType(e2) {
          if (mw(e2, "streamType", [0, 1, 4, 5, 6, 7, 8, 9]), this._remoteDefaultVideoStreamType = e2, this._joinInfo)
            try {
              await this._gateway.setDefaultRemoteVideoStreamType(e2), this._joinInfo.defaultVideoStream = this._remoteDefaultVideoStreamType;
            } catch (e3) {
              throw BN.error("[".concat(this._clientId, "] set default remote video stream type error"), e3.toString()), e3;
            }
          else
            BN.debug("[".concat(this._clientId, "] haven't joined yet, cache remoteDefaultVideoStreamType ").concat(e2));
        }
        async setRemoteVideoStreamType(e2, t2) {
          mw(t2, "streamType", [0, 1, 4, 5, 6, 7, 8, 9]);
          try {
            await this._gateway.setRemoteVideoStreamType(e2, t2), setTimeout(() => {
              const t3 = this._users.find((t4) => t4.uid === e2);
              t3 && t3.videoTrack && t3.videoTrack.updateMediaStreamTrackResolution();
            }, 2e3);
          } catch (e3) {
            throw BN.error("[".concat(this._clientId, "] set remote video stream type error"), e3.toString()), e3;
          }
          BN.info("[".concat(this._clientId, "] set remote ").concat(e2, " video stream type to ").concat(t2)), this._remoteStreamTypeCacheMap.set(e2, t2);
        }
        async setStreamFallbackOption(e2, t2) {
          mw(t2, "fallbackType", [0, 1, 2, 3, 4, 5, 6, 7, 8]);
          try {
            await this._gateway.setStreamFallbackOption(e2, t2);
          } catch (e3) {
            throw BN.error("[".concat(this._clientId, "] set stream fallback option"), e3.toString()), e3;
          }
          BN.info("[".concat(this._clientId, "] set remote ").concat(e2, " stream fallback type to ").concat(t2)), this._streamFallbackTypeCacheMap.set(e2, t2);
        }
        setEncryptionConfig(e2, t2, i3, n2) {
          !function(e3) {
            mw(e3, "encryptionMode", ["aes-128-xts", "aes-256-xts", "aes-128-ecb", "sm4-128-ecb", "aes-128-gcm", "aes-256-gcm", "aes-128-gcm2", "aes-256-gcm2", "none"]);
          }(e2), gw(t2, "secret");
          const r2 = ["aes-128-gcm2", "aes-256-gcm2"];
          if (Dn(r2).call(r2, e2)) {
            if (!i3 || !(i3 instanceof Uint8Array && 32 === i3.length))
              throw new XN(_w.INVALID_PARAMS, "salt must be an Uint8Array and exactly equal to 32 bytes");
          } else if (i3)
            throw new XN(_w.INVALID_PARAMS, "current encrypt mode does not need salt");
          if (n2) {
            if (fw(n2, "encryptDataStream"), !Dn(r2).call(r2, e2))
              throw new XN(_w.INVALID_PARAMS, "current encrypt mode does not support data stream");
            this._encryptDataStream = true;
          }
          new RegExp(`^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*,.<>?/:;'"|{}\\[\\]])(?=.{8,})`).test(t2) || BN.warning("The secret is not strong:\n      The secret must contain at least 1 lowercase alphabetical character,\n      The secret must contain at least 1 uppercase alphabetical character,\n      The secret must contain at least 1 numeric character,\n      The secret must contain at least one special character,\n      The secret must be eight characters or longer.\n      "), this._encryptionMode = e2, this._encryptionSecret = t2, i3 && (this._encryptionSalt = rO(i3));
        }
        async renewToken(e2) {
          if (gw(e2, "token", 1, 2047), !this._key || !this._joinInfo)
            throw new XN(_w.INVALID_OPERATION, "renewToken should not be called before user join");
          const t2 = this._key;
          this._key = e2, this._joinInfo && (this._joinInfo.token = e2);
          const i3 = await this._renewTokenMutex.lock();
          try {
            if (dN("USE_NEW_TOKEN")) {
              BN.debug("[".concat(this._clientId, "] start renew token with ticket from unilbs"));
              const t3 = await NV(this._joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || yO);
              BN.debug("[".concat(this._clientId, "] get ticket from unilbs success")), await this._gateway.renewToken({ token: e2, ticket: t3 });
            } else
              BN.debug("[".concat(this._clientId, "] start renew token without ticket")), await this._gateway.renewToken({ token: e2 });
            BN.debug("[".concat(this._clientId, "] renewToken success"));
          } catch (e3) {
            throw this._key = t2, this._joinInfo.token = t2, BN.error("[".concat(this._clientId, "] renewToken failed"), e3.toString()), e3;
          } finally {
            i3();
          }
        }
        enableAudioVolumeIndicator() {
          this._audioVolumeIndicationInterval ? BN.warning("you have already enabled audio volume indicator!") : this._audioVolumeIndicationInterval = window.setInterval(() => {
            const e2 = this._p2pChannel.getAudioLevels();
            this.safeEmit(jw.VOLUME_INDICATOR, e2);
          }, dN("AUDIO_VOLUME_INDICATION_INTERVAL") || 2e3);
        }
        getRTCStats() {
          const e2 = this._statsCollector.getRTCStats(), t2 = this._gateway.getInChannelInfo();
          return e2.Duration = Math.round(t2.duration / 1e3), e2;
        }
        async startLiveStreaming(e2, t2) {
          if (!t2) {
            if ("h264" !== this.codec)
              throw new XN(_w.LIVE_STREAMING_INVALID_RAW_STREAM, "raw streaming is only support h264");
            if (!this._p2pChannel.hasLocalMedia())
              throw new XN(_w.LIVE_STREAMING_INVALID_RAW_STREAM, "can not find stream to raw streaming");
          }
          if (this._liveRawStreamingClient && this._liveRawStreamingClient.hasUrl(e2) || this._liveTranscodeStreamingClient && this._liveTranscodeStreamingClient.hasUrl(e2))
            throw new XN(_w.LIVE_STREAMING_TASK_CONFLICT);
          const i3 = t2 ? FM.TRANSCODE : FM.RAW;
          return this._createLiveStreamingClient(i3).startLiveStreamingTask(e2, i3);
        }
        setLiveTranscoding(e2) {
          return this._createLiveStreamingClient(FM.TRANSCODE).setTranscodingConfig(e2);
        }
        async stopLiveStreaming(e2) {
          const t2 = [this._liveRawStreamingClient, this._liveTranscodeStreamingClient].filter((t3) => t3 && t3.hasUrl(e2));
          if (!t2.length)
            throw new XN(_w.INVALID_PARAMS, "can not find live streaming url to stop");
          await Wh.all(t2.map((t3) => t3 && t3.stopLiveStreamingTask(e2)));
        }
        async startChannelMediaRelay(e2) {
          jV(e2);
          const t2 = this._createChannelMediaRelayClient();
          await t2.startChannelMediaRelay(e2);
        }
        async updateChannelMediaRelay(e2) {
          jV(e2);
          const t2 = this._createChannelMediaRelayClient();
          await t2.updateChannelMediaRelay(e2);
        }
        async stopChannelMediaRelay() {
          const e2 = this._createChannelMediaRelayClient();
          await e2.stopChannelMediaRelay(), this._statsCollector.onStatsChanged && (this._statsCollector.onStatsChanged = void 0);
        }
        async sendStreamMessage(e2) {
          var t2;
          let i3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          if (!this._joinInfo)
            throw new XN(_w.INVALID_OPERATION, "can not send data stream, not joined");
          if (("string" == typeof e2 || e2 instanceof Uint8Array) && (e2 = { payload: e2 }), "string" == typeof e2.payload) {
            const t3 = new TextEncoder();
            e2.payload = t3.encode(e2.payload);
          }
          let n2 = false;
          this._encryptDataStream && this._encryptDataStreamIv && this._encryptDataStreamKey && window.crypto.subtle && Dn(t2 = ["aes-128-gcm2", "aes-256-gcm2"]).call(t2, this._encryptionMode) && (n2 = true, e2.payload = await async function(e3, t3, i4) {
            var n3;
            const r2 = Xn(n3 = Array.from(i4)).call(n3, (e4, t4) => e4 + t4, 0), o2 = { serverTs: 0, seq: mN++, length: i4.length, checkSum: r2 }, s2 = new Uint8Array(TO(r2, 2)), a2 = new ArrayBuffer(fN), c2 = new DataView(a2);
            c2.setUint32(0, o2.serverTs), c2.setUint16(4, o2.seq), c2.setUint16(6, o2.length), c2.setUint16(8, o2.checkSum);
            const d2 = 16 - i4.length % 16;
            i4 = sO(i4, new Uint8Array(d2));
            const l2 = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: e3, tagLength: pN, additionalData: s2 }, t3, i4);
            return sO(new Uint8Array(a2), new Uint8Array(l2));
          }(this._encryptDataStreamIv, this._encryptDataStreamKey, e2.payload));
          if (new Blob([e2.payload]).size > 1024)
            throw new XN(_w.INVALID_PARAMS, n2 ? "encrypted stream message out of range." : "stream message out of range.");
          return this._gateway.signal.request(PM.DATA_STREAM, { payload: rO(e2.payload), syncWithAudio: e2.syncWithAudio, sendTs: Date.now() - eB }, !i3);
        }
        sendMetadata(e2) {
          if (!this._joinInfo)
            throw new XN(_w.INVALID_OPERATION, "can not send metadata, not joined");
          if (new Blob([e2]).size > 1024)
            throw new XN(_w.METADATA_OUT_OF_RANGE);
          return this._gateway.signal.request(PM.SEND_METADATA, { session_id: this._joinInfo.sid, metadata: rO(e2) });
        }
        async sendCustomReportMessage(e2) {
          if (Array.isArray(e2) || (e2 = [e2]), e2.forEach(GN), !this._joinInfo)
            throw new XN(_w.INVALID_OPERATION, "can not send custom report, not joined");
          await zN.sendCustomReportMessage(this._joinInfo.sid, e2);
        }
        getLocalAudioStats() {
          return this._statsCollector.getLocalAudioTrackStats();
        }
        getRemoteAudioStats() {
          return this._statsCollector.getRemoteAudioTrackStats();
        }
        getLocalVideoStats() {
          return this._statsCollector.getLocalVideoTrackStats();
        }
        getRemoteVideoStats() {
          return this._statsCollector.getRemoteVideoTrackStats();
        }
        getRemoteNetworkQuality() {
          return this._statsCollector.getRemoteNetworkQualityStats();
        }
        async pickSVCLayer(e2, t2) {
          mw(t2.spatialLayer, "spatialLayer", [0, 1, 2, 3]), mw(t2.temporalLayer, "temporalLayer", [0, 1, 2, 3]);
          try {
            await this._gateway.pickSVCLayer(e2, t2);
          } catch (e3) {
            throw BN.error("[".concat(this._clientId, "] pick SVC layer failed"), e3.toString()), e3;
          }
        }
        async setRTMConfig(e2) {
          const { apRTM: t2 = false, rtmFlag: i3 } = e2;
          if (fw(t2, "apRTM"), Tw(i3, "rtmFlag", 0), this._rtmConfig.apRTM = t2, this._rtmConfig.rtmFlag = i3, BN.debug("[".concat(this._clientId, "] setRTMconfig ").concat(JSON.stringify(e2), " in ").concat(this.connectionState, " state")), ("CONNECTED" === this.connectionState || "RECONNECTING" === this.connectionState) && this._joinInfo)
            return this._joinInfo.apRTM = t2, this._joinInfo.rtmFlag = i3, this._gateway.setRTM2Flag(i3);
        }
        _reset() {
          if (BN.debug("[".concat(this._clientId, "] reset client")), this._axiosCancelSource.cancel(), this._axiosCancelSource = Ab.CancelToken.source(), this._streamFallbackTypeCacheMap = /* @__PURE__ */ new Map(), this._remoteStreamTypeCacheMap = /* @__PURE__ */ new Map(), this._configDistribute.stopGetConfigDistribute(), this._joinInfo && yB(this._joinInfo), this._joinInfo = void 0, this._proxyServer = void 0, this._defaultStreamFallbackType = void 0, this._sessionId && zN.removeSid(this._sessionId), this._sessionId = null, this.store.sessionId = null, this._statsCollector.reset(), this._key = void 0, this._appId = void 0, this._uid = void 0, this.store.uid = void 0, this._channelName = void 0, this._encryptionMode = "none", this._encryptionSecret = null, this._encryptionSalt = null, this._encryptDataStreamKey = null, this._encryptDataStreamIv = null, this._pendingPublishedUsers = [], this._users.forEach((e2) => {
            e2._audioTrack && e2._audioTrack._destroy(), e2._videoTrack && e2._videoTrack._destroy(), e2._dataChannels && (e2._dataChannels.forEach((e3) => e3._close()), e2._dataChannels.length = 0);
          }), this._users = [], this._audioVolumeIndicationInterval && (window.clearInterval(this._audioVolumeIndicationInterval), this._audioVolumeIndicationInterval = void 0), "fallback" === this._cloudProxyServerMode && (this._cloudProxyServerMode = "disabled", this.store.cloudProxyServerMode = "disabled"), this._p2pChannel.reset(), this._publishMutex = new vO("client-publish", this._clientId), this._subscribeMutex = new vO("client-subscribe", this._clientId), this._networkQualityInterval && (window.clearInterval(this._networkQualityInterval), this._networkQualityInterval = void 0), this._liveRawStreamingClient && (this._liveRawStreamingClient.terminate(), this._liveRawStreamingClient.removeAllListeners(), this._liveRawStreamingClient = void 0), this._liveTranscodeStreamingClient && (this._liveTranscodeStreamingClient.terminate(), this._liveTranscodeStreamingClient.removeAllListeners(), this._liveTranscodeStreamingClient = void 0), this._channelMediaRelayClient && (this._channelMediaRelayClient.dispose(), this._channelMediaRelayClient = void 0), this._inspect)
            try {
              this._inspect.close(), this._inspect = void 0;
            } catch (e2) {
            }
          if (this._moderation)
            try {
              this.setImageModeration(false);
            } catch (e2) {
            }
        }
        _startSession(e2, t2) {
          var i3;
          const n2 = e2 || hO();
          e2 ? BN.debug("[".concat(this._clientId, "] new Session ").concat(n2)) : BN.debug("[".concat(this._clientId, "] renewSession ").concat(this._sessionId, " => ").concat(n2));
          const r2 = e2 ? "" : this._sessionId || "";
          this._sessionId = n2, this.store.sessionId = n2, zN.addSid(n2);
          const o2 = { lts: (/* @__PURE__ */ new Date()).getTime(), mode: this.mode, buildFormat: 1, stringUid: (null == t2 ? void 0 : t2.stringUid) || (null === (i3 = this._joinInfo) || void 0 === i3 ? void 0 : i3.stringUid), channelProfile: "live" === this.mode ? 1 : 0, channelMode: 0, isABTestSuccess: Number(this._configDistribute.isSuccess), lsid: r2, clientRole: "audience" === this.role ? 2 : 1 };
          zN.sessionInit(this._sessionId, eG({ cname: t2.channel, appid: t2.appId }, o2)), this._joinInfo && (this._joinInfo.sid = n2), this._gateway.joinInfo && (this._gateway.joinInfo.sid = n2);
        }
        async _publishHighStream(e2) {
          if (!this._joinInfo || void 0 === this._uid)
            throw new XN(_w.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState)
            throw new XN(_w.INVALID_OPERATION, "can not publish stream in ".concat(this.connectionState, " state"));
          if ("auto" === this._turnServer.mode && dN("FORCE_TURN") && !dN("TURN_ENABLE_TCP") && !dN("TURN_ENABLE_UDP"))
            throw new XN(_w.UNEXPECTED_ERROR, "force TURN With No TURN Configuration");
          BN.debug("[".concat(this._clientId, "] publish high stream"));
          try {
            const i3 = await this._p2pChannel.publish(e2, this._isDualStreamEnabled, this._lowStreamParameter);
            if (this.store.useP2P) {
              const e3 = (await i3.next()).value;
              if (e3) {
                try {
                  await this._gateway.sendExtensionMessage(yU.PUBLISH, e3, true);
                } catch (e4) {
                  throw i3.throw(e4), e4;
                }
                await i3.next();
              }
              this._p2pChannel.reportPublishEvent(true, null);
            } else {
              const n2 = (await i3.next()).value;
              if (n2) {
                var t2;
                let e3;
                try {
                  e3 = await this._gateway.publish(this._uid, n2, true);
                } catch (e4) {
                  if (e4.code !== _w.DISCONNECT_P2P)
                    throw i3.throw(e4), e4;
                }
                await i3.next((null === (t2 = e3) || void 0 === t2 ? void 0 : t2.ortc) || []);
              }
              this._p2pChannel.reportPublishEvent(true, null);
              for (const t3 of e2)
                t3 instanceof ak && t3._encoderConfig && this._gateway.setVideoProfile(t3._encoderConfig).catch((e3) => {
                  BN.debug("[".concat(this._clientId, "] stop setVideoProfile, because websocket is closed"));
                }), !t3.muted && t3.enabled || await this._p2pChannel.muteLocalTrack(t3);
            }
          } catch (t3) {
            if (this._p2pChannel.reportPublishEvent(false, null == t3 ? void 0 : t3.code, e2), (null == t3 ? void 0 : t3.code) === _w.WS_ABORT)
              return;
            throw t3;
          }
        }
        async _publishLowStream() {
          if (!this._joinInfo || void 0 === this._uid)
            throw new XN(_w.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState)
            throw new XN(_w.INVALID_OPERATION, "can not publish stream in ".concat(this.connectionState, " state"));
          BN.debug("[".concat(this._clientId, "] publish low stream"));
          const e2 = this._configDistribute.getLowStreamConfigDistribute();
          e2 && e2.bitrate && (this._lowStreamParameter || (this._lowStreamParameter = { width: 160, height: 120, framerate: 15, bitrate: 50 }), this._lowStreamParameter && this._lowStreamParameter.bitrate && e2.bitrate < this._lowStreamParameter.bitrate && (this._lowStreamParameter.bitrate = e2.bitrate));
          try {
            const e3 = await this._p2pChannel.publishLowStream(this._lowStreamParameter), i3 = (await e3.next()).value;
            if (i3) {
              var t2;
              let n2;
              try {
                n2 = await this._gateway.publish(this._uid, i3, true);
              } catch (t3) {
                if (t3.code !== _w.DISCONNECT_P2P)
                  throw e3.throw(t3), t3;
              }
              e3.next((null === (t2 = n2) || void 0 === t2 ? void 0 : t2.ortc) || []), this._p2pChannel.reportPublishEvent(true, null, void 0, true);
            }
          } catch (e3) {
            if (this._p2pChannel.reportPublishEvent(false, null == e3 ? void 0 : e3.code, void 0, true), (null == e3 ? void 0 : e3.code) === _w.WS_ABORT)
              return;
            throw e3;
          }
        }
        _createLiveStreamingClient(e2) {
          const t2 = () => {
            if (!this._joinInfo || !this._appId) {
              return new XN(_w.INVALID_OPERATION, "can not create live streaming client, please join channel first").throw();
            }
            const e3 = (t3 = { joinInfo: this._joinInfo, appId: this._appId, websocketRetryConfig: this._config.websocketRetryConfig, httpRetryConfig: this._config.httpRetryConfig }, Gx("LiveStreaming").create(t3));
            var t3;
            return e3.onLiveStreamError = (e4, t4) => {
              zN.reportApiInvoke(this._sessionId, { name: Lw.ON_LIVE_STREAM_ERROR, options: [e4, t4], tag: kw.TRACER }).onSuccess(), this.safeEmit(jw.LIVE_STREAMING_ERROR, e4, t4);
            }, e3.onLiveStreamWarning = (e4, t4) => {
              zN.reportApiInvoke(this._sessionId, { name: Lw.ON_LIVE_STREAM_WARNING, options: [e4, t4], tag: kw.TRACER }).onSuccess(), this.safeEmit(jw.LIVE_STREAMING_WARNING, e4, t4);
            }, e3.on(KM.REQUEST_WORKER_MANAGER_LIST, (e4, t4, i3) => {
              if (!this._joinInfo)
                return i3(new XN(_w.INVALID_OPERATION, "can not find join info to get worker manager"));
              (async function(e5, t5, i4, n2) {
                const r2 = dN("UAP_AP").slice(0, dN("AJAX_REQUEST_CONCURRENT")).map((e6) => t5.proxyServer ? "https://".concat(t5.proxyServer, "/ap/?url=").concat(e6 + "/api/v1?action=uap") : "https://".concat(e6, "/api/v1?action=uap"));
                return await dV(r2, e5, t5, i4, n2);
              })(e4, this._joinInfo, this._axiosCancelSource.token, yO).then(t4).catch(i3);
            }), e3;
          };
          return e2 === FM.RAW ? (this._liveRawStreamingClient = this._liveRawStreamingClient || t2(), this._liveRawStreamingClient) : (this._liveTranscodeStreamingClient = this._liveTranscodeStreamingClient || t2(), this._liveTranscodeStreamingClient);
        }
        _createChannelMediaRelayClient() {
          if (!this._joinInfo) {
            return new XN(_w.INVALID_OPERATION, "can not create channel media relay client, please join channel first").throw();
          }
          if (!this._channelMediaRelayClient) {
            const { sendResolutionWidth: t2, sendResolutionHeight: i3 } = this.getLocalVideoStats(), n2 = (e2 = { joinInfo: this._joinInfo, clientId: this._clientId, websocketRetryConfig: this._config.websocketRetryConfig, httpRetryConfig: this._config.httpRetryConfig, resolution: { width: t2, height: i3 } }, Gx("ChannelMediaRelay").create(e2));
            n2.on("state", (e3) => {
              e3 === JM.RELAY_STATE_FAILURE && n2 && n2.dispose(), this.safeEmit(jw.CHANNEL_MEDIA_RELAY_STATE, e3);
            }), n2.on("event", (e3) => {
              this.safeEmit(jw.CHANNEL_MEDIA_RELAY_EVENT, e3);
            }), this._channelMediaRelayClient = n2, this._statsCollector.onStatsChanged = (e3, t3) => {
              var i4;
              "resolution" === e3 && (null === (i4 = this._channelMediaRelayClient) || void 0 === i4 || i4.setVideoProfile(t3));
            };
          }
          var e2;
          return this._channelMediaRelayClient;
        }
        _handleUpdateDataChannel(e2, t2) {
          const { added: i3, deleted: n2 } = e2, r2 = [];
          if (t2) {
            const e3 = [];
            this._users.forEach((t3) => {
              t3._dataChannels.forEach((n3) => {
                i3.every((e4) => e4.uid !== t3._uintid || e4.stream_id !== n3.id) && e3.push({ uid: t3._uintid, stream_id: n3.id, ordered: n3.ordered, max_retrans_times: n3.maxRetransmits, metadata: n3.metadata });
              });
            }), e3.length > 0 && this._handleUpdateDataChannel({ added: [], deleted: e3 });
          }
          Array.isArray(i3) && i3.length > 0 && i3.forEach((e3) => {
            const { uid: i4, stream_id: n3, ordered: o2, max_retrans_times: s2, metadata: a2 } = e3, c2 = this._users.find((e4) => e4._uintid === i4);
            if (!c2)
              return void BN.error("[".concat(this._clientId, "] can not find target user!(on_add_data_channel)"));
            BN.debug("[".concat(this._clientId, "] data_channel added with uid ").concat(i4)), Dn(r2).call(r2, c2) || r2.push(c2), c2._uintid || (c2._uintid = i4);
            if (!(-1 !== c2._dataChannels.findIndex((t3) => t3.id === e3.stream_id))) {
              const e4 = { id: n3, ordered: !!o2, maxRetransmits: s2, metadata: a2 }, i5 = function(e5) {
                return Wx(e5, true);
              }(e4);
              c2._dataChannels.push(i5), BN.info("[".concat(this._clientId, "] remote user ").concat(c2.uid, " published datachannel")), t2 || this.safeEmit(jw.USER_PUBLISHED, c2, "datachannel", e4);
            }
            this._p2pChannel.hasPendingRemoteDataChannel(c2, e3.stream_id) && (BN.debug("[".concat(this._clientId, "] resubscribe datachannel for user ").concat(c2.uid, " after reconnect.")), this._subscribeDataChannel(c2, e3.stream_id).catch((e4) => {
              BN.error("[".concat(this._clientId, "] resubscribe datachannel error"), e4.toString());
            }));
          }), t2 && (this.safeEmit(jw.PUBLISHED_USER_LIST, this._pendingPublishedUsers), this._pendingPublishedUsers = []), Array.isArray(n2) && n2.length > 0 && n2.forEach((e3) => {
            const { uid: t3, stream_id: i4 } = e3, n3 = this._users.find((e4) => e4._uintid === t3);
            if (!n3)
              return void BN.error("[".concat(this._clientId, "] can not find target user!(on_delete_data_channel)"));
            const r3 = n3._dataChannels.find((t4) => t4.id === e3.stream_id);
            r3 && (BN.debug("[".concat(this._clientId, "] data_stream delete with uid ").concat(t3)), this._p2pChannel.unsubscribeDataChannel(n3, [r3]).then((e4) => {
              if (n3._dataChannels = n3._dataChannels.filter((e5) => e5 !== r3), e4)
                return this._gateway.unsubscribeDataChannel(e4, n3.uid);
            }), BN.info("[".concat(this._clientId, "] remote user ").concat(t3, " unpublished datachannel ,id:").concat(r3.id)), this.safeEmit(jw.USER_UNPUBLISHED, n3, "datachannel", r3._config));
          });
        }
        _handleRemoveDataChannels(e2) {
          const t2 = this._users.find((t3) => t3.uid === e2.uid);
          if (t2) {
            if (void 0 !== t2._dataChannels && t2._dataChannels.length > 0) {
              BN.debug("[".concat(this._clientId, "] datachannel removed with uid ").concat(e2.uid));
              const i3 = () => {
                BN.info("[".concat(this._clientId, "] remote user ").concat(t2.uid, " unpublished datachannel")), t2._dataChannels.forEach((e3) => {
                  this.safeEmit(jw.USER_UNPUBLISHED, t2, "datachannel", e3._config);
                });
              };
              this._p2pChannel.unsubscribeDataChannel(t2, t2._dataChannels).then((e3) => {
                if (e3)
                  return this._gateway.unsubscribeDataChannel(e3, t2.uid);
              }), i3();
            }
          } else
            BN.warning("[".concat(this._clientId, "] can not find target user!(on_remove_datachannel)"));
        }
        _handleGatewayEvents() {
          this._gateway.on($M.DISCONNECT_P2P, async () => {
            await this._p2pChannel.disconnectForReconnect();
          }), this._gateway.on($M.CONNECTION_STATE_CHANGE, (e2, t2, i3) => {
            var n2;
            if (i3 === xw.FALLBACK)
              return;
            const r2 = () => {
              this.safeEmit(jw.CONNECTION_STATE_CHANGE, e2, t2, i3);
            };
            if (zN.reportApiInvoke(this._sessionId || (null === (n2 = this._gateway.joinInfo) || void 0 === n2 ? void 0 : n2.sid) || null, { name: Lw.CONNECTION_STATE_CHANGE, options: [e2, t2, i3], tag: kw.TRACER }).onSuccess(JSON.stringify({ cur: e2, prev: t2, reason: i3 })), BN.info("[".concat(this._clientId, "] signal connection state change: ").concat(t2, " -> ").concat(e2)), "DISCONNECTED" === e2)
              return this._reset(), void r2();
            if ("RECONNECTING" === e2)
              this._users.forEach((e3) => {
                e3._trust_in_room_ = false, e3._trust_audio_enabled_state_ = false, e3._trust_video_enabled_state_ = false, e3._trust_audio_mute_state_ = false, e3._trust_video_mute_state_ = false, e3._trust_audio_stream_added_state_ = false, e3._trust_video_stream_added_state_ = false, e3._is_pre_created || (e3._audio_pre_subscribed || (e3._audioSSRC = void 0, e3._audioOrtc = void 0), e3._video_pre_subscribed || (e3._videoSSRC = void 0, e3._videoOrtc = void 0, e3._rtxSsrcId = void 0), e3._cname = void 0);
              }), this._userOfflineTimeout && window.clearTimeout(this._userOfflineTimeout), this._streamRemovedTimeout && window.clearTimeout(this._streamRemovedTimeout), this._userOfflineTimeout = void 0, this._streamRemovedTimeout = void 0;
            else if ("CONNECTED" === e2) {
              var o2;
              this._streamFallbackTypeCacheMap.forEach((e3, t3) => {
                this._gateway.setStreamFallbackOption(t3, e3).catch((e4) => {
                  BN.warning("[".concat(this._clientId, "] auto set stream fallback option failed"), e4);
                });
              }), this._remoteStreamTypeCacheMap.forEach((e3, t3) => {
                this._gateway.setRemoteVideoStreamType(t3, e3).catch((e4) => {
                  BN.warning("[".concat(this._clientId, "] auto set remote stream type failed"), e4);
                });
              }), void 0 !== this._remoteDefaultVideoStreamType && void 0 === (null === (o2 = this._joinInfo) || void 0 === o2 ? void 0 : o2.defaultVideoStream) && this.setRemoteDefaultVideoStreamType(this._remoteDefaultVideoStreamType).then(() => {
                BN.debug("[".concat(this._clientId, "] setRemoteDefaultVideoStreamType after gateway connected"));
              }).catch((e3) => {
                BN.error("[".concat(this._clientId, "] setRemoteDefaultVideoStreamType after gateway failed, ").concat(e3));
              }), this.store.useP2P || (this._p2pChannel.republish(), this._userOfflineTimeout = window.setTimeout(() => {
                if ("CONNECTED" !== this.connectionState)
                  return;
                this._userOfflineTimeout = void 0;
                this._users.filter((e3) => !e3._trust_in_room_).forEach((e3) => {
                  BN.debug("[".concat(this._clientId, "] user offline timeout, emit user offline ").concat(e3.uid)), this._handleUserOffline({ uid: e3.uid });
                });
              }, 3e3), this._streamRemovedTimeout = window.setTimeout(() => {
                "CONNECTED" === this.connectionState && (this._streamRemovedTimeout = void 0, this._users.forEach((e3) => {
                  e3._trust_audio_mute_state_ || (BN.debug("[".concat(this._clientId, "] auto dispatch audio unmute event ").concat(e3.uid)), this._handleMuteStream(e3.uid, lU.AUDIO, false)), e3._trust_video_mute_state_ || (BN.debug("[".concat(this._clientId, "] auto dispatch video unmute event ").concat(e3.uid)), this._handleMuteStream(e3.uid, lU.VIDEO, false)), e3._trust_audio_enabled_state_ || (BN.debug("[".concat(this._clientId, "] auto dispatch enable local audio ").concat(e3.uid)), this._handleSetStreamLocalEnable("audio", e3.uid, true)), e3._trust_video_enabled_state_ || (BN.debug("[".concat(this._clientId, "] auto dispatch enable local video ").concat(e3.uid)), this._handleSetStreamLocalEnable("video", e3.uid, true)), e3._trust_video_stream_added_state_ || (BN.debug("[".concat(this._clientId, "] auto dispatch reset video stream added ").concat(e3.uid)), this._handleResetAddStream(e3, "video")), e3._trust_audio_stream_added_state_ || (BN.debug("[".concat(this._clientId, "] auto dispatch reset audio stream added ").concat(e3.uid)), this._handleResetAddStream(e3, "audio")), e3._video_added_ || e3._audio_added_ || (BN.debug("[".concat(this._clientId, "] auto dispatch stream remove ").concat(e3.uid)), this._handleRemoveStream({ uid: e3.uid, uint_id: e3._uintid }));
                }));
              }, 1e3));
            }
            r2();
          }), this._gateway.on($M.REQUEST_NEW_GATEWAY_LIST, async (e2, t2) => {
            if (!this._joinInfo)
              return t2(new XN(_w.UNEXPECTED_ERROR, "can not recover, no join info"));
            try {
              let t3;
              const i3 = await CB(eG(eG({}, this._joinInfo), {}, { uid: this._joinInfo.uid, stringUid: void 0 }));
              i3 ? (t3 = i3.ap, AB(i3), this._joinInfo.preload = true) : (t3 = await CV(this._joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || yO, this.store), this._joinInfo.preload = false), this._joinInfo && (this._joinInfo.apResponse = t3.gatewayInfo.res, this._joinInfo.gatewayAddrs = t3.gatewayInfo.gatewayAddrs, this._joinInfo.uni_lbs_ip = t3.gatewayInfo.uni_lbs_ip);
              const n2 = [];
              t3.gatewayInfo.gatewayAddrs.forEach((e3) => {
                let { address: t4 } = e3;
                const [i4, r2] = t4.split(":");
                this._joinInfo && this._joinInfo.proxyServer ? n2.push({ proxy: this._joinInfo.proxyServer, host: i4, port: r2 }) : n2.push({ host: i4, port: r2 });
              }), e2(n2);
            } catch (e3) {
              t2(e3);
            }
          }), this._gateway.on($M.NETWORK_QUALITY, (e2) => {
            "normal" === this._networkQualitySensitivity && this.safeEmit(jw.NETWORK_QUALITY, e2);
          }), this._gateway.on($M.STREAM_TYPE_CHANGE, (e2, t2) => {
            this.safeEmit(jw.STREAM_TYPE_CHANGED, e2, t2);
            zN.reportApiInvoke(this._sessionId, { name: Lw.STREAM_TYPE_CHANGE, options: [e2, t2], tag: kw.TRACER }).onSuccess(JSON.stringify({ uid: e2, streamType: t2 }));
          }), this._gateway.on($M.IS_P2P_DISCONNECTED, (e2) => {
            this._p2pChannel.isP2PDisconnected() ? e2(true) : this._p2pChannel.hasLocalMedia() || this._p2pChannel.hasRemoteMedia() ? e2(false) : e2(true);
          }), this._gateway.on($M.REQUEST_P2P_CONNECTION_PARAMS, async (e2, t2, i3) => {
            try {
              let i4 = await this._p2pChannel.getEstablishParams();
              dN("ENABLE_PREALLOC_PC") && i4 || (i4 = await this._p2pChannel.startP2PConnection(e2)), t2(i4);
            } catch (e3) {
              i3(e3);
            }
          }), this._gateway.on($M.JOIN_RESPONSE, (e2, t2) => {
            if (this.store.useP2P)
              return;
            let i3;
            e2.attributes ? i3 = e2.attributes.userAttributes.preSubSsrcs : BN.debug("no attributes in joinResponse");
            const n2 = fx(e2.ortc, t2, i3);
            this._p2pChannel.connect(n2);
          }), this._gateway.on($M.PRE_CONNECT_PC, async (e2) => {
            const { candidates: t2, fingerprint: i3 } = e2;
            if (this._joinInfo && t2.length > 0 && !this._p2pChannel.isPlanB) {
              var n2;
              await this._p2pChannel.startP2PConnection({ turnServer: this._joinInfo.turnServer });
              const { cert: e3, cid: r2 } = this._joinInfo.apResponse;
              await this._p2pChannel.connect({ iceParameters: { iceUfrag: "".concat(r2, "_").concat(e3), icePwd: "".concat(r2, "_").concat(e3) }, dtlsParameters: { fingerprints: [{ hashFunction: "sha-256", fingerprint: null !== (n2 = dN("FINGERPRINT")) && void 0 !== n2 ? n2 : i3 }] }, candidates: t2, rtpCapabilities: { send: { audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: [] }, recv: { audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: [] } }, setup: "active", cname: "o/i14u9pJrxRKAsu", preallocation: true });
            }
          });
        }
        _handleGatewaySignalEvents() {
          this._gateway.signal.on(kM.ON_USER_ONLINE, this._handleUserOnline), this._gateway.signal.on(kM.ON_USER_OFFLINE, this._handleUserOffline), this._gateway.signal.on(kM.ON_ADD_AUDIO_STREAM, (e2) => this._handleAddAudioOrVideoStream("audio", e2.uid, e2.ssrcId, e2.cname, e2.uint_id, e2.ortc)), this._gateway.signal.on(kM.ON_ADD_VIDEO_STREAM, (e2) => this._handleAddAudioOrVideoStream("video", e2.uid, e2.ssrcId, e2.cname, e2.uint_id, e2.ortc, e2.rtxSsrcId)), this._gateway.signal.on(kM.ON_REMOTE_DATASTREAM_UPDATE, (e2) => {
            this._handleUpdateDataChannel(e2);
          }), this._gateway.signal.on(kM.ON_REMOTE_FULL_DATASTREAM_INFO, (e2) => {
            this._handleUpdateDataChannel({ added: e2.datastreams || [], deleted: [] }, true);
          }), this._gateway.signal.on(kM.ON_REMOVE_STREAM, this._handleRemoveStream), this._gateway.signal.on(kM.ON_P2P_LOST, this._handleP2PLost), this._gateway.signal.on(kM.MUTE_AUDIO, (e2) => this._handleMuteStream(e2.uid, lU.AUDIO, true)), this._gateway.signal.on(kM.UNMUTE_AUDIO, (e2) => this._handleMuteStream(e2.uid, lU.AUDIO, false)), this._gateway.signal.on(kM.MUTE_VIDEO, (e2) => this._handleMuteStream(e2.uid, lU.VIDEO, true)), this._gateway.signal.on(kM.UNMUTE_VIDEO, (e2) => this._handleMuteStream(e2.uid, lU.VIDEO, false)), this._gateway.signal.on(kM.RECEIVE_METADATA, (e2) => {
            const t2 = nO(e2.metadata);
            this.safeEmit(jw.RECEIVE_METADATA, e2.uid, t2);
          }), this._gateway.signal.on(kM.ON_DATA_STREAM, async (e2) => {
            var t2;
            if (!e2)
              return;
            let i3 = nO(e2.payload);
            if (this._encryptDataStream && this._encryptDataStreamIv && this._encryptDataStreamKey && window.crypto.subtle && Dn(t2 = ["aes-128-gcm2", "aes-256-gcm2"]).call(t2, this._encryptionMode)) {
              if (e2.payload.length < fN)
                throw new XN(_w.UNEXPECTED_RESPONSE, "payload length ".concat(e2.payload.length, " is less than header length ").concat(fN));
              const t3 = await async function(e3, t4, i4) {
                const n3 = i4.subarray(0, fN), r2 = n3.slice(8, fN), o2 = (r2[0] << 8) + r2[1], s2 = (n3[6] << 8) + n3[7], a2 = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv: e3, tagLength: pN, additionalData: new Uint8Array(TO(o2, 2)) }, t4, i4.subarray(fN));
                return new Uint8Array(a2).subarray(0, s2);
              }(this._encryptDataStreamIv, this._encryptDataStreamKey, i3);
              i3 = t3;
            }
            let n2 = 0;
            if (e2.ordered || e2.syncWithAudio) {
              const t3 = this._p2pChannel.getStats(), i4 = this.remoteUsers.find((t4) => t4.uid === e2.uid), r2 = null == t3 ? void 0 : t3.audioRecv.find((e3) => e3.ssrc === (null == i4 ? void 0 : i4._audioSSRC));
              n2 = null == r2 ? void 0 : r2.jitterBufferMs;
            }
            null == n2 && (n2 = 0), sB(eG(eG({}, e2), {}, { payload: i3 }), n2, { id: this._clientId, onStreamMessage: "function" == typeof this.onStreamMessage ? this.onStreamMessage.bind(this) : void 0, safeEmit: this.safeEmit.bind(this) });
          }), this._gateway.signal.on(kM.ON_CRYPT_ERROR, () => {
            iO(() => {
              BN.warning("[".concat(this._clientId, "] on crypt error")), this.safeEmit(jw.CRYPT_ERROR);
            }, this._sessionId);
          }), this._gateway.signal.on(kM.ON_TOKEN_PRIVILEGE_WILL_EXPIRE, this._handleTokenWillExpire), this._gateway.signal.on(kM.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
            BN.warning("[".concat(this._clientId, "] received message onTokenPrivilegeDidExpire, please get new token and join again")), this._gateway.leave(true, xw.TOKEN_EXPIRE), this.safeEmit(jw.ON_TOKEN_PRIVILEGE_DID_EXPIRE), this._reset();
          }), this._gateway.signal.on(kM.ON_STREAM_FALLBACK_UPDATE, (e2) => {
            BN.debug("[".concat(this._clientId, "] stream fallback peerId: ").concat(e2.stream_id, ", attr: ").concat(e2.stream_type)), this.safeEmit(jw.STREAM_FALLBACK, e2.stream_id, 1 === e2.stream_type ? "fallback" : "recover");
          }), this._gateway.signal.on(kM.ON_PUBLISH_STREAM, (e2) => {
            this.uid === this._uid && (this._p2pChannel.reportPublishEvent(true, null, void 0, false, JSON.stringify({ proxy: e2.proxy })), BN.info("[".concat(this._clientId, "] on publish stream, ").concat(JSON.stringify(e2))));
          }), this._gateway.signal.on(kM.ENABLE_LOCAL_VIDEO, (e2) => {
            this._handleSetStreamLocalEnable("video", e2.uid, true);
          }), this._gateway.signal.on(kM.DISABLE_LOCAL_VIDEO, (e2) => {
            this._handleSetStreamLocalEnable("video", e2.uid, false);
          }), this._gateway.signal.on(DM.REQUEST_TIMEOUT, (e2, t2) => {
            if (this._joinInfo)
              switch (e2) {
                case PM.PUBLISH: {
                  if (!t2)
                    return;
                  const e3 = t2.ortc;
                  if (e3) {
                    var i3, n2;
                    const r2 = e3.some((e4) => {
                      let { stream_type: t3 } = e4;
                      return t3 === ZM.Audio;
                    }), o2 = e3.some((e4) => {
                      let { stream_type: t3 } = e4;
                      return t3 !== ZM.Audio;
                    }), s2 = e3.some((e4) => {
                      let { stream_type: t3 } = e4;
                      return t3 === ZM.Screen || t3 === ZM.ScreenLow;
                    });
                    "offer" === t2.state && zN.publish(this._joinInfo.sid, { eventElapse: UV.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: false, ec: _w.TIMEOUT, audio: r2, video: o2, p2pid: t2.p2p_id, publishRequestid: this.store.pubId, screenshare: s2, audioName: r2 ? null === (i3 = e3.find((e4) => {
                      let { stream_type: t3 } = e4;
                      return t3 === ZM.Audio;
                    })) || void 0 === i3 || null === (i3 = i3.ssrcs[0]) || void 0 === i3 ? void 0 : i3.ssrcId.toString() : void 0, videoName: o2 ? null === (n2 = e3.find((e4) => {
                      let { stream_type: t3 } = e4;
                      return t3 !== ZM.Audio;
                    })) || void 0 === n2 || null === (n2 = n2.ssrcs[0]) || void 0 === n2 ? void 0 : n2.ssrcId.toString() : void 0 });
                  }
                  break;
                }
                case PM.SUBSCRIBE:
                  t2 && zN.subscribe(this._joinInfo.sid, { succ: false, ec: _w.TIMEOUT, audio: t2.stream_type === lU.AUDIO, video: t2.stream_type === lU.VIDEO, peerid: t2.stream_id, subscribeRequestid: t2.ssrcId, p2pid: this.store.p2pId, eventElapse: UV.measureFromSubscribeStart(this.store.clientId, t2.ssrcId), preSsrc: this._p2pChannel.isPreSubScribe(t2.ssrcId) });
              }
          }), this._gateway.signal.on(kM.ON_P2P_OK, (e2) => {
            this.uid, this._uid;
          }), this._gateway.signal.on(kM.ON_PUBLISHED_USER_LIST, (e2) => {
            if (null == e2 || !e2.users)
              return;
            dN("BLOCK_LOCAL_CLIENT") && (e2.users = e2.users.filter((e3) => !jk(e3.string_id || e3.stream_id, this.channelName)));
            const t2 = [], i3 = [];
            for (const n2 of e2.users) {
              let e3 = this._users.find((e4) => e4._uintid === n2.stream_id);
              e3 ? e3._trust_in_room_ = true : (e3 = new GV(n2.string_id || n2.stream_id, n2.stream_id), this._users.push(e3), 0 === this.getListeners(jw.PUBLISHED_USER_LIST).length && (BN.debug("[".concat(this._clientId, "] user online"), n2.stream_id), this.safeEmit(jw.USER_JOINED, e3)));
              const r2 = tU.Audio & n2.stream_type, o2 = (tU.Video | tU.LwoVideo) & n2.stream_type, s2 = 0 != (65280 & n2.stream_type), a2 = r2 && e3.hasAudio, c2 = o2 && e3.hasVideo;
              o2 && (e3._trust_video_stream_added_state_ = true, e3._video_added_ = true, e3._videoSSRC = n2.video_ssrc, e3._rtxSsrcId = n2.video_rtx), r2 && (e3._trust_audio_stream_added_state_ = true, e3._audio_added_ = true, e3._audioSSRC = n2.audio_ssrc), r2 && !a2 && 0 === this.getListeners(jw.PUBLISHED_USER_LIST).length && (BN.info("[".concat(this._clientId, "] remote user ").concat(e3.uid, " published audio")), this.safeEmit(jw.USER_PUBLISHED, e3, "audio")), o2 && !c2 && 0 === this.getListeners(jw.PUBLISHED_USER_LIST).length && (BN.info("[".concat(this._clientId, "] remote user ").concat(e3.uid, " published video")), this.safeEmit(jw.USER_PUBLISHED, e3, "video")), (r2 && !a2 || o2 && !c2 || s2) && t2.push(e3), o2 && this._p2pChannel.hasPendingRemoteMedia(e3, "video") && i3.push({ user: e3, mediaType: "video" }), r2 && this._p2pChannel.hasPendingRemoteMedia(e3, "audio") && i3.push({ user: e3, mediaType: "audio" });
            }
            i3.length > 0 && (BN.debug("[".concat(this._clientId, "] RE massSubscribe after reconnect ").concat(i3.map((e3) => "user: ".concat(e3.user.uid, ", mediaType: ").concat(e3.mediaType)).join("; "), " ")), this.massSubscribe(i3).catch((e3) => {
              BN.error("[".concat(this._clientId, "] mass resubscribe error"), e3.toString());
            })), this.getListeners(jw.PUBLISHED_USER_LIST).length > 0 ? dN("ENABLE_DATASTREAM_2") ? this._pendingPublishedUsers = t2 : (BN.info("[".concat(this._clientId, "] client emit user-list event, users: ").concat(t2.map((e3) => e3.uid).join(", "))), this.safeEmit(jw.PUBLISHED_USER_LIST, t2)) : BN.info("[".concat(this._clientId, "] client not emit user-list event case there is no user-list listener, users: ").concat(t2.map((e3) => e3.uid).join(", ")));
          }), this._gateway.signal.on(kM.ON_RTP_CAPABILITY_CHANGE, (e2) => {
            const { video_codec: t2 } = e2;
            this._p2pChannel instanceof JF && this._p2pChannel.updateRemoteRTPCapabilities(t2.map((e3) => e3.toLowerCase()).filter((e3) => {
              var t3;
              return Dn(t3 = Object.keys(hN)).call(t3, e3);
            }));
          });
        }
        _handleP2PEvents() {
          this._gateway.signal.on(kM.ON_USER_OFFLINE, () => {
            this._p2pChannel.disconnectForReconnect();
          }), this._gateway.signal.on(yU.PUBLISH, (e2, t2, i3) => {
            const { uid: n2 } = e2;
            e2.forEach((e3) => {
              const { kind: r2, ssrcs: o2, mid: s2, isMuted: a2 } = e3;
              this._handleP2PAddAudioOrVideoStream(r2, n2, o2[0].ssrcId, s2);
              const c2 = this._users.find((e4) => e4.uid === n2);
              return c2 && this.store.useP2P ? this._p2pChannel.mockSubscribe(c2, r2, o2[0].ssrcId, s2).then(() => {
                t2();
              }).catch(i3) : t2(), this._handleMuteStream(n2, r2, !!a2);
            });
          }), this._gateway.signal.on(yU.CALL, async (e2, t2, i3) => {
            if (this.store.useP2P)
              try {
                var n2;
                t2(await this._p2pChannel.startP2P({ turnServer: null === (n2 = this._joinInfo) || void 0 === n2 ? void 0 : n2.turnServer }, e2));
              } catch (e3) {
                i3(e3);
              }
          }), this._gateway.signal.on(DM.P2P_CONNECTION, async (e2) => {
            this.store.useP2P && (await this._p2pChannel).p2pConnect(e2);
          }), this._gateway.signal.on(yU.UNPUBLISH, async (e2, t2, i3) => {
            if (this.store.useP2P) {
              const { unpubMsg: n2, uid: r2 } = e2, o2 = this._users.find((e3) => e3.uid === r2);
              if (!o2)
                return BN.warning("[".concat(this._clientId, "] can not find remote user, ignore mute event, uid: ").concat(r2)), void t2();
              try {
                n2.forEach(async (e3) => {
                  let { stream_type: t3 } = e3;
                  const i4 = t3 === ZM.Audio ? lU.AUDIO : lU.VIDEO;
                  await this._p2pChannel.unsubscribe(o2, i4), this._handleMuteStream(r2, i4, true);
                }), t2();
              } catch (e3) {
                i3(e3);
              }
            }
          }), this._gateway.signal.on(yU.CONTROL, async (e2, t2) => {
            const { action: i3 } = e2;
            switch (i3) {
              case bU.MUTE_LOCAL_VIDEO:
                this._handleMuteStream(t2, lU.VIDEO, true);
                break;
              case bU.MUTE_LOCAL_AUDIO:
                this._handleMuteStream(t2, lU.AUDIO, true);
                break;
              case bU.UNMUTE_LOCAL_VIDEO:
                this._handleP2PAddAudioOrVideoStream("video", t2), this._handleMuteStream(t2, lU.VIDEO, false);
                break;
              case bU.UNMUTE_LOCAL_AUDIO:
                this._handleP2PAddAudioOrVideoStream("audio", t2), this._handleMuteStream(t2, lU.AUDIO, false);
            }
          }), this._gateway.signal.on(yU.RESTART_ICE, async (e2, t2, i3) => {
            if (this.store.useP2P)
              try {
                const { direction: i4, iceParameter: n2 } = e2;
                if (i4 !== MM.SEND_ONLY || n2) {
                  t2(await this._p2pChannel.restartICE(i4, n2));
                } else
                  this._p2pChannel.handleDisconnect(i4), t2();
              } catch (e3) {
                i3(e3);
              }
          }), this._gateway.signal.on(yU.CANDIDATE, (e2) => {
            if (this.store.useP2P) {
              const { candidate: t2, direction: i3 } = e2;
              this._p2pChannel.addRemoteCandidate(t2, i3);
            }
          }), this._p2pChannel.on(fU.RequestP2PRestartICE, async (e2, t2, i3) => {
            try {
              const { direction: i4 } = e2;
              t2(await this._gateway.sendExtensionMessage(yU.RESTART_ICE, e2, i4 === MM.SEND_ONLY));
            } catch (e3) {
              i3(e3);
            }
          }), this._p2pChannel.on(fU.LocalCandidate, (e2) => {
            this._gateway.sendExtensionMessage(yU.CANDIDATE, JSON.stringify(e2), true);
          }), this._p2pChannel.on(fU.RequestP2PMuteLocal, async (e2, t2, i3) => {
            try {
              await this._gateway.sendExtensionMessage(yU.CONTROL, e2, true), t2();
            } catch (e3) {
              i3(e3);
            }
          }), this._p2pChannel.on(fU.RequestP2PUnmuteRemote, async (e2, t2, i3) => {
            if (this._joinInfo)
              try {
                await this._gateway.unmuteRemote(e2, this._joinInfo.stringUid || this._joinInfo.uid), t2();
              } catch (e3) {
                e3.code === _w.DISCONNECT_P2P ? t2() : i3(e3);
              }
            else
              t2();
          }), this._p2pChannel.on(fU.RequestP2PMuteRemote, async (e2, t2, i3) => {
            if (this._joinInfo)
              try {
                await this._gateway.muteRemote(e2, this._joinInfo.stringUid || this._joinInfo.uid), t2();
              } catch (e3) {
                e3.code === _w.DISCONNECT_P2P ? t2() : i3(e3);
              }
            else
              t2();
          }), this._p2pChannel.on(fU.StateChange, (e2, t2) => {
            t2 === EU.Connected && this._p2pChannel.republish();
          });
        }
        _handleP2PChannelEvents() {
          this._p2pChannel.on(fU.PeerConnectionStateChange, (e2) => {
            const t2 = this._peerConnectionState;
            e2 !== t2 && (this.safeEmit(jw.PEERCONNECTION_STATE_CHANGE, e2, t2), this._peerConnectionState = e2);
          }), this._p2pChannel.on(fU.RequestMuteLocal, async (e2, t2, i3) => {
            if (this._joinInfo)
              try {
                await this._gateway.muteLocal(e2, this._joinInfo.stringUid || this._joinInfo.uid), t2();
              } catch (e3) {
                e3.code === _w.DISCONNECT_P2P ? t2() : i3(e3);
              }
            else
              t2();
          }), this._p2pChannel.on(fU.RequestUnmuteLocal, async (e2, t2, i3) => {
            if (this._joinInfo)
              try {
                await this._gateway.unmuteLocal(e2, this._joinInfo.stringUid || this._joinInfo.uid), t2();
              } catch (e3) {
                e3.code === _w.DISCONNECT_P2P ? t2() : i3(e3);
              }
            else
              t2();
          }), this._p2pChannel.on(fU.RequestRePublish, (e2, t2, i3) => {
            this.publish(e2, false).then(t2).catch(i3);
          }), this._p2pChannel.on(fU.RequestRePublishDataChannel, (e2, t2, i3) => {
            Wh.all(e2.map(async (e3) => {
              const t3 = await this._p2pChannel.publishDataChannel([e3]);
              try {
                t3.forEach((e4) => {
                  this._uid && this._gateway.publishDataChannel(this._uid, e4, true);
                });
              } catch (e4) {
                if (e4.code !== _w.DISCONNECT_P2P)
                  throw e4;
              }
            })).then(t2).catch(i3);
          }), this._p2pChannel.on(fU.RequestReSubscribe, async (e2, t2, i3) => {
            try {
              for (const { user: t3, kind: i4 } of e2)
                i4 === lU.VIDEO ? await this.subscribe(t3, "video") : await this.subscribe(t3, "audio");
              t2();
            } catch (e3) {
              i3(e3);
            }
          }), this._p2pChannel.on(fU.RequestUpload, (e2, t2) => {
            this._gateway.upload(e2, t2);
          }), this._p2pChannel.on(fU.RequestUploadStats, (e2) => {
            this._gateway.uploadWRTCStats(e2);
          }), this._p2pChannel.on(fU.MediaReconnectStart, (e2) => {
            this.safeEmit(jw.MEDIA_RECONNECT_START, e2);
          }), this._p2pChannel.on(fU.MediaReconnectEnd, (e2) => {
            this.safeEmit(jw.MEDIA_RECONNECT_END, e2);
          }), this._p2pChannel.on(fU.NeedSignalRTT, (e2) => {
            e2(this._gateway.getSignalRTT());
          }), this._p2pChannel.on(fU.RequestRestartICE, async (e2) => {
            if (this.store.useP2P)
              return;
            const t2 = await this._p2pChannel.restartICE(e2), i3 = await t2.next();
            if (i3.done)
              return;
            const n2 = i3.value;
            let r2;
            try {
              r2 = await this._gateway.restartICE({ iceParameters: n2 });
            } catch (e3) {
              return void t2.throw(e3);
            }
            const { iceParameters: o2 } = function(e3) {
              const t3 = e3.iceParameters;
              return { iceParameters: { iceUfrag: t3.iceUfrag, icePwd: t3.icePwd } };
            }(r2);
            await t2.next({ remoteIceParameters: o2 });
          }), this._p2pChannel.on(fU.RequestReconnect, async () => {
            this._gateway.reconnect();
          }), this._p2pChannel.on(fU.RequestReconnectPC, async () => {
            var e2;
            const { iceParameters: t2, dtlsParameters: i3, rtpCapabilities: n2 } = await this._p2pChannel.startP2PConnection({ turnServer: null === (e2 = this._joinInfo) || void 0 === e2 ? void 0 : e2.turnServer }), { gatewayEstablishParams: r2, gatewayAddress: o2 } = await this._gateway.reconnectPC({ iceParameters: t2, dtlsParameters: i3, rtpCapabilities: n2 }), s2 = fx(r2, o2);
            await this._p2pChannel.connect(s2), await this._p2pChannel.republish(), await this._p2pChannel.reSubscribe();
          }), this._p2pChannel.on(fU.RequestUnpublishForReconnectPC, async (e2, t2, i3) => {
            this._joinInfo && void 0 !== this._uid ? (await this._gateway.unpublish(e2, this._uid), t2()) : i3();
          }), this._p2pChannel.on(fU.P2PLost, () => {
            this.safeEmit(jw.P2P_LOST, this.store.uid);
          }), this._p2pChannel.on(fU.UpdateVideoEncoder, (e2) => {
            e2._encoderConfig && this._gateway.setVideoProfile(e2._encoderConfig);
          }), this._p2pChannel.on(fU.ConnectionTypeChange, (e2) => {
            this.safeEmit(jw.IS_USING_CLOUD_PROXY, e2);
          }), this._p2pChannel.on(fU.RequestLowStreamParameter, (e2) => {
            e2(this._lowStreamParameter || { width: 160, height: 120, framerate: 15, bitrate: 50 });
          }), this._p2pChannel.on(fU.QueryClientConnectionState, (e2) => {
            e2(this.connectionState);
          });
        }
        getKeyMetrics() {
          return this.store.keyMetrics;
        }
        async enableContentInspect(e2) {
          if (!this._joinInfo || "CONNECTED" !== this.connectionState)
            throw new XN(_w.INVALID_OPERATION, "[".concat(this._clientId, "] can not create content inspect, please join channel first"));
          if (this._inspect)
            throw new XN(_w.INVALID_OPERATION, "[".concat(this._clientId, "] Inspect content service already in connecting/connected state"));
          try {
            const i3 = (t2 = { config: e2 }, Gx("ContentInspect").create(t2));
            this._inspect = i3, this.handleVideoInspectEvents(i3);
            const { appId: n2, cname: r2, sid: o2, token: s2, uid: a2, cid: c2, vid: d2 } = this._joinInfo;
            await i3.init({ appId: n2, areaCode: "", cname: r2, sid: o2, token: s2, uid: a2, cid: c2, vid: d2 ? Number(d2) : 0 }, yO);
          } catch (e3) {
            throw Array.isArray(e3) ? e3[0] : e3;
          }
          var t2;
        }
        handleVideoInspectEvents(e2) {
          e2.on(SU.CONNECTION_STATE_CHANGE, (t2, i3) => {
            if (this.safeEmit(jw.CONTENT_INSPECT_CONNECTION_STATE_CHANGE, t2, i3), i3 === mU.CONNECTED) {
              if ("CONNECTED" !== this.connectionState)
                return void this.safeEmit(jw.CONTENT_INSPECT_ERROR, new XN(_w.OPERATION_ABORTED, "Content inspect was cancelled because it left the channel"));
              e2.inspectImage();
            }
          }), e2.on(SU.INSPECT_RESULT, (e3, t2) => {
            var i3;
            if ((null == t2 ? void 0 : t2.code) === _w.INVALID_OPERATION && "DISCONNECTED" === this.connectionState)
              return BN.debug("Stop inspect content because that has left channel"), null == this || null === (i3 = this._inspect) || void 0 === i3 || i3.close(), void (this._inspect = void 0);
            this.safeEmit(jw.CONTENT_INSPECT_RESULT, e3, t2);
          }), e2.on(SU.CLIENT_LOCAL_VIDEO_TRACK, (e3) => {
            e3(this.localTracks.filter((e4) => "video" === e4.trackMediaType)[0]);
          });
        }
        async disableContentInspect() {
          if (!this._inspect)
            throw new XN(_w.INVALID_OPERATION, "[".concat(this._clientId, "] inspectVideoContent not started"));
          try {
            this._inspect.close(), this._inspect = void 0;
          } catch (e2) {
            throw Array.isArray(e2) ? e2[0] : e2;
          }
        }
        async setImageModeration(e2, t2) {
          if (fw(e2, "enabled"), e2) {
            if (!t2)
              throw new XN(_w.INVALID_PARAMS, "config is required");
            if (dj(t2), !this._joinInfo)
              throw new XN(_w.INVALID_OPERATION, "can not create image moderation, please join channel first");
            try {
              if (this._moderation)
                this._moderation.updateConfig(t2);
              else {
                const e3 = (i3 = { config: t2 }, Gx("ImageModeration").create(i3));
                this._moderation = e3, this.handleImageModerationEvents(e3);
                const { appId: n2, cname: r2, sid: o2, token: s2, uid: a2, cid: c2, vid: d2 } = this._joinInfo;
                await e3.init({ appId: n2, areaCode: "", cname: r2, sid: o2, token: s2, uid: a2, cid: c2, vid: d2 ? Number(d2) : 0 }, yO);
              }
            } catch (e3) {
              throw Array.isArray(e3) ? e3[0] : e3;
            }
          } else {
            var i3;
            if (!this._moderation)
              throw new XN(_w.INVALID_OPERATION, "[".concat(this._clientId, "] image moderation not started"));
            try {
              this._moderation.close(), this._moderation.removeAllListeners(), this._moderation = void 0;
            } catch (e3) {
              throw Array.isArray(e3) ? e3[0] : e3;
            }
          }
        }
        handleImageModerationEvents(e2) {
          e2.on(vU.CONNECTION_STATE_CHANGE, (t2, i3) => {
            if (this.safeEmit(jw.IMAGE_MODERATION_CONNECTION_STATE_CHANGE, t2, i3), t2 === CU.CONNECTED) {
              if ("CONNECTED" !== this.connectionState)
                throw this.setImageModeration(false), new XN(_w.OPERATION_ABORTED, "Image moderation was cancelled because it left the channel");
              e2.inspectImage();
            }
          }), e2.on(vU.CLIENT_LOCAL_VIDEO_TRACK, (e3) => {
            e3(this.localTracks.filter((e4) => "video" === e4.trackMediaType)[0]);
          });
        }
        setP2PTransport(e2) {
          if (function(e3) {
            mw(e3, "transport", ["default", "auto", "relay", "sd-rtn"]);
          }(e2), "p2p" !== this.mode)
            throw new XN(_w.INVALID_OPERATION, "only p2p mode can set p2pTransport");
          this.store.p2pTransport = e2, BN.info("[".concat(this._clientId, "] set client p2pTransport to ").concat(e2));
        }
        getJoinChannelServiceRecords() {
          return BN.debug("getJoinChannelServiceRecords"), this.store.joinChannelServiceRecords;
        }
        async setPublishAudioFilterEnabled(e2) {
          fw(e2, "enabled"), cN("ENABLE_PUBLISH_AUDIO_FILTER", e2), this._joinInfo && await this._gateway.setPublishAudioFilterEnabled(e2);
        }
        _handleResetAddStream(e2, t2) {
          switch (t2) {
            case "audio":
              e2._audio_added_ = false, e2._trust_audio_stream_added_state_ = true;
              break;
            case "video":
              e2._video_added_ = false, e2._trust_video_stream_added_state_ = true;
          }
        }
      }, IM(Zj.prototype, "leave", [uj], Object.getOwnPropertyDescriptor(Zj.prototype, "leave"), Zj.prototype), IM(Zj.prototype, "publish", [hj], Object.getOwnPropertyDescriptor(Zj.prototype, "publish"), Zj.prototype), IM(Zj.prototype, "unpublish", [pj], Object.getOwnPropertyDescriptor(Zj.prototype, "unpublish"), Zj.prototype), IM(Zj.prototype, "subscribe", [_j], Object.getOwnPropertyDescriptor(Zj.prototype, "subscribe"), Zj.prototype), IM(Zj.prototype, "presubscribe", [Ej], Object.getOwnPropertyDescriptor(Zj.prototype, "presubscribe"), Zj.prototype), IM(Zj.prototype, "massSubscribe", [fj], Object.getOwnPropertyDescriptor(Zj.prototype, "massSubscribe"), Zj.prototype), IM(Zj.prototype, "unsubscribe", [mj], Object.getOwnPropertyDescriptor(Zj.prototype, "unsubscribe"), Zj.prototype), IM(Zj.prototype, "massUnsubscribe", [Tj], Object.getOwnPropertyDescriptor(Zj.prototype, "massUnsubscribe"), Zj.prototype), IM(Zj.prototype, "setLowStreamParameter", [Sj], Object.getOwnPropertyDescriptor(Zj.prototype, "setLowStreamParameter"), Zj.prototype), IM(Zj.prototype, "enableDualStream", [gj], Object.getOwnPropertyDescriptor(Zj.prototype, "enableDualStream"), Zj.prototype), IM(Zj.prototype, "disableDualStream", [Rj], Object.getOwnPropertyDescriptor(Zj.prototype, "disableDualStream"), Zj.prototype), IM(Zj.prototype, "setClientRole", [Cj], Object.getOwnPropertyDescriptor(Zj.prototype, "setClientRole"), Zj.prototype), IM(Zj.prototype, "_setClientRoleOptions", [vj], Object.getOwnPropertyDescriptor(Zj.prototype, "_setClientRoleOptions"), Zj.prototype), IM(Zj.prototype, "setProxyServer", [Ij], Object.getOwnPropertyDescriptor(Zj.prototype, "setProxyServer"), Zj.prototype), IM(Zj.prototype, "setTurnServer", [yj], Object.getOwnPropertyDescriptor(Zj.prototype, "setTurnServer"), Zj.prototype), IM(Zj.prototype, "setLicense", [Aj], Object.getOwnPropertyDescriptor(Zj.prototype, "setLicense"), Zj.prototype), IM(Zj.prototype, "startProxyServer", [bj], Object.getOwnPropertyDescriptor(Zj.prototype, "startProxyServer"), Zj.prototype), IM(Zj.prototype, "stopProxyServer", [wj], Object.getOwnPropertyDescriptor(Zj.prototype, "stopProxyServer"), Zj.prototype), IM(Zj.prototype, "setLocalAccessPointsV2", [Oj], Object.getOwnPropertyDescriptor(Zj.prototype, "setLocalAccessPointsV2"), Zj.prototype), IM(Zj.prototype, "setLocalAccessPoints", [Nj], Object.getOwnPropertyDescriptor(Zj.prototype, "setLocalAccessPoints"), Zj.prototype), IM(Zj.prototype, "setRemoteDefaultVideoStreamType", [Dj], Object.getOwnPropertyDescriptor(Zj.prototype, "setRemoteDefaultVideoStreamType"), Zj.prototype), IM(Zj.prototype, "setRemoteVideoStreamType", [Pj], Object.getOwnPropertyDescriptor(Zj.prototype, "setRemoteVideoStreamType"), Zj.prototype), IM(Zj.prototype, "setStreamFallbackOption", [Lj], Object.getOwnPropertyDescriptor(Zj.prototype, "setStreamFallbackOption"), Zj.prototype), IM(Zj.prototype, "setEncryptionConfig", [kj], Object.getOwnPropertyDescriptor(Zj.prototype, "setEncryptionConfig"), Zj.prototype), IM(Zj.prototype, "renewToken", [Mj], Object.getOwnPropertyDescriptor(Zj.prototype, "renewToken"), Zj.prototype), IM(Zj.prototype, "enableAudioVolumeIndicator", [Uj], Object.getOwnPropertyDescriptor(Zj.prototype, "enableAudioVolumeIndicator"), Zj.prototype), IM(Zj.prototype, "startLiveStreaming", [xj], Object.getOwnPropertyDescriptor(Zj.prototype, "startLiveStreaming"), Zj.prototype), IM(Zj.prototype, "setLiveTranscoding", [Vj], Object.getOwnPropertyDescriptor(Zj.prototype, "setLiveTranscoding"), Zj.prototype), IM(Zj.prototype, "stopLiveStreaming", [Fj], Object.getOwnPropertyDescriptor(Zj.prototype, "stopLiveStreaming"), Zj.prototype), IM(Zj.prototype, "startChannelMediaRelay", [Bj], Object.getOwnPropertyDescriptor(Zj.prototype, "startChannelMediaRelay"), Zj.prototype), IM(Zj.prototype, "updateChannelMediaRelay", [jj], Object.getOwnPropertyDescriptor(Zj.prototype, "updateChannelMediaRelay"), Zj.prototype), IM(Zj.prototype, "stopChannelMediaRelay", [Gj], Object.getOwnPropertyDescriptor(Zj.prototype, "stopChannelMediaRelay"), Zj.prototype), IM(Zj.prototype, "sendCustomReportMessage", [Wj], Object.getOwnPropertyDescriptor(Zj.prototype, "sendCustomReportMessage"), Zj.prototype), IM(Zj.prototype, "pickSVCLayer", [Hj], Object.getOwnPropertyDescriptor(Zj.prototype, "pickSVCLayer"), Zj.prototype), IM(Zj.prototype, "setRTMConfig", [Kj], Object.getOwnPropertyDescriptor(Zj.prototype, "setRTMConfig"), Zj.prototype), IM(Zj.prototype, "enableContentInspect", [Yj], Object.getOwnPropertyDescriptor(Zj.prototype, "enableContentInspect"), Zj.prototype), IM(Zj.prototype, "disableContentInspect", [qj], Object.getOwnPropertyDescriptor(Zj.prototype, "disableContentInspect"), Zj.prototype), IM(Zj.prototype, "setImageModeration", [zj], Object.getOwnPropertyDescriptor(Zj.prototype, "setImageModeration"), Zj.prototype), IM(Zj.prototype, "setP2PTransport", [Xj], Object.getOwnPropertyDescriptor(Zj.prototype, "setP2PTransport"), Zj.prototype), IM(Zj.prototype, "getJoinChannelServiceRecords", [Jj], Object.getOwnPropertyDescriptor(Zj.prototype, "getJoinChannelServiceRecords"), Zj.prototype), IM(Zj.prototype, "setPublishAudioFilterEnabled", [Qj], Object.getOwnPropertyDescriptor(Zj.prototype, "setPublishAudioFilterEnabled"), Zj.prototype), Zj);
      class iG {
        constructor(e2, t2) {
          QI(this, "id", 0), QI(this, "element", void 0), QI(this, "peerPair", void 0), QI(this, "context", void 0), QI(this, "audioPlayerElement", void 0), QI(this, "audioTrack", void 0), iG.count += 1, this.id = iG.count, this.element = e2, this.context = t2;
        }
        initPeers() {
          this.peerPair = [new RTCPeerConnection(), new RTCPeerConnection()], this.peerPair[1].ontrack = (e2) => {
            const t2 = document.createElement("audio");
            t2.srcObject = new MediaStream([e2.track]), t2.play(), this.audioPlayerElement = t2;
          };
        }
        async switchSdp() {
          if (!this.peerPair)
            return;
          const e2 = async (e3, t3) => {
            const i3 = "offer" === t3 ? await e3.createOffer() : await e3.createAnswer();
            return await e3.setLocalDescription(i3), "complete" === e3.iceGatheringState ? e3.localDescription : new Wh((t4) => {
              e3.onicegatheringstatechange = () => {
                "complete" === e3.iceGatheringState && t4(e3.localDescription);
              };
            });
          }, t2 = async (e3, t3) => await e3.setRemoteDescription(t3);
          try {
            const i3 = await e2(this.peerPair[0], "offer");
            await t2(this.peerPair[1], i3);
            const n2 = await e2(this.peerPair[1], "answer");
            await t2(this.peerPair[0], n2);
          } catch (e3) {
            throw new XN(_w.LOCAL_AEC_ERROR, e3.toString()).print();
          }
        }
        async getTracksFromMediaElement(e2) {
          if (this.audioTrack)
            return this.audioTrack;
          let t2;
          try {
            e2 instanceof HTMLVideoElement && (e2.captureStream ? e2.captureStream() : e2.mozCaptureStream()), t2 = this.context.createMediaStreamDestination();
            this.context.createMediaElementSource(e2).connect(t2);
          } catch (e3) {
            throw new XN(_w.LOCAL_AEC_ERROR, e3.toString()).print();
          }
          if (!t2) {
            throw new XN(_w.LOCAL_AEC_ERROR, "no dest node when local aec").print();
          }
          const i3 = t2.stream.getAudioTracks()[0];
          return this.audioTrack = i3, i3;
        }
        getElement() {
          return this.element;
        }
        async startEchoCancellation() {
          this.context.resume(), this.peerPair && this.close(), this.initPeers();
          const e2 = this.element, t2 = await this.getTracksFromMediaElement(e2);
          this.peerPair && this.peerPair[0].addTrack(t2), await this.switchSdp();
        }
        close() {
          BN.debug("close echo cancellation unit, id is", this.id), this.audioPlayerElement && this.audioPlayerElement.pause(), this.peerPair && this.peerPair.forEach((e2) => {
            e2.close();
          }), this.peerPair = void 0, this.audioPlayerElement = void 0;
        }
      }
      var nG, rG;
      QI(iG, "count", 0);
      const oG = window.AudioContext || window.webkitAudioContext;
      const sG = new (nG = qN({ report: zN }), IM((rG = class {
        constructor() {
          QI(this, "units", []), QI(this, "context", void 0);
        }
        processExternalMediaAEC(e2) {
          if (!this._doesEnvironmentNeedAEC())
            return BN.debug("the system does not need to process local aec"), -1;
          this.context || (this.context = new oG());
          let t2 = this.units.find((t3) => t3 && t3.getElement() === e2);
          return t2 || (t2 = new iG(e2, this.context), this.units.push(t2)), t2.startEchoCancellation(), BN.debug("start processing local audio echo cancellation, id is", t2.id), t2.id;
        }
        _doesEnvironmentNeedAEC() {
          return xb().name !== Lb.SAFARI;
        }
      }).prototype, "processExternalMediaAEC", [nG], Object.getOwnPropertyDescriptor(rG.prototype, "processExternalMediaAEC"), rG.prototype), rG)();
      function aG(e2, t2) {
        var i3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i3.push.apply(i3, n2);
        }
        return i3;
      }
      function cG(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i3 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? aG(Object(i3), true).forEach(function(t3) {
            QI(e2, t3, i3[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : aG(Object(i3)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
          });
        }
        return e2;
      }
      const dG = window || document;
      function lG(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        if (!dG)
          return;
        const i3 = wq._cspEventHandlerPointer;
        if (i3 && t2)
          return void console.error(i3, t2);
        const n2 = (e3) => {
          if (!(e3 && e3.blockedURI && (wq.onSecurityPolicyViolation || wq.getListeners(RU.SECURITY_POLICY_VIOLATION).length > 0)))
            return;
          const t3 = e3.blockedURI;
          dN("CSP_DETECTED_HOSTNAME_LIST").some((e4) => Dn(t3).call(t3, e4)) && (wq.onSecurityPolicyViolation && "function" == typeof wq.onSecurityPolicyViolation && wq.onSecurityPolicyViolation(e3), wq.getListeners(RU.SECURITY_POLICY_VIOLATION).length > 0 && wq.safeEmit(RU.SECURITY_POLICY_VIOLATION, e3));
        };
        i3 && dG.removeEventListener("securitypolicyviolation", i3), (t2 || e2 && "function" == typeof e2 || wq.getListeners(RU.SECURITY_POLICY_VIOLATION).length > 0) && dG.addEventListener("securitypolicyviolation", n2), wq._cspEventHandlerPointer = n2;
      }
      var uG = l, hG = _y, pG = RegExp.prototype, _G = function(e2) {
        return e2 === pG || uG(pG, e2) ? hG(e2) : e2.flags;
      }, EG = i2(_G);
      function fG(e2) {
        let t2 = e2.length;
        for (; --t2 >= 0; )
          e2[t2] = 0;
      }
      const mG = 256, TG = 286, SG = 30, gG = 15, RG = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]), CG = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]), vG = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]), IG = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), yG = new Array(576);
      fG(yG);
      const AG = new Array(60);
      fG(AG);
      const bG = new Array(512);
      fG(bG);
      const wG = new Array(256);
      fG(wG);
      const OG = new Array(29);
      fG(OG);
      const NG = new Array(SG);
      function DG(e2, t2, i3, n2, r2) {
        this.static_tree = e2, this.extra_bits = t2, this.extra_base = i3, this.elems = n2, this.max_length = r2, this.has_stree = e2 && e2.length;
      }
      let PG, LG, kG;
      function MG(e2, t2) {
        this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t2;
      }
      fG(NG);
      const UG = (e2) => e2 < 256 ? bG[e2] : bG[256 + (e2 >>> 7)], xG = (e2, t2) => {
        e2.pending_buf[e2.pending++] = 255 & t2, e2.pending_buf[e2.pending++] = t2 >>> 8 & 255;
      }, VG = (e2, t2, i3) => {
        e2.bi_valid > 16 - i3 ? (e2.bi_buf |= t2 << e2.bi_valid & 65535, xG(e2, e2.bi_buf), e2.bi_buf = t2 >> 16 - e2.bi_valid, e2.bi_valid += i3 - 16) : (e2.bi_buf |= t2 << e2.bi_valid & 65535, e2.bi_valid += i3);
      }, FG = (e2, t2, i3) => {
        VG(e2, i3[2 * t2], i3[2 * t2 + 1]);
      }, BG = (e2, t2) => {
        let i3 = 0;
        do {
          i3 |= 1 & e2, e2 >>>= 1, i3 <<= 1;
        } while (--t2 > 0);
        return i3 >>> 1;
      }, jG = (e2, t2, i3) => {
        const n2 = new Array(16);
        let r2, o2, s2 = 0;
        for (r2 = 1; r2 <= gG; r2++)
          s2 = s2 + i3[r2 - 1] << 1, n2[r2] = s2;
        for (o2 = 0; o2 <= t2; o2++) {
          let t3 = e2[2 * o2 + 1];
          0 !== t3 && (e2[2 * o2] = BG(n2[t3]++, t3));
        }
      }, GG = (e2) => {
        let t2;
        for (t2 = 0; t2 < TG; t2++)
          e2.dyn_ltree[2 * t2] = 0;
        for (t2 = 0; t2 < SG; t2++)
          e2.dyn_dtree[2 * t2] = 0;
        for (t2 = 0; t2 < 19; t2++)
          e2.bl_tree[2 * t2] = 0;
        e2.dyn_ltree[512] = 1, e2.opt_len = e2.static_len = 0, e2.sym_next = e2.matches = 0;
      }, WG = (e2) => {
        e2.bi_valid > 8 ? xG(e2, e2.bi_buf) : e2.bi_valid > 0 && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
      }, HG = (e2, t2, i3, n2) => {
        const r2 = 2 * t2, o2 = 2 * i3;
        return e2[r2] < e2[o2] || e2[r2] === e2[o2] && n2[t2] <= n2[i3];
      }, KG = (e2, t2, i3) => {
        const n2 = e2.heap[i3];
        let r2 = i3 << 1;
        for (; r2 <= e2.heap_len && (r2 < e2.heap_len && HG(t2, e2.heap[r2 + 1], e2.heap[r2], e2.depth) && r2++, !HG(t2, n2, e2.heap[r2], e2.depth)); )
          e2.heap[i3] = e2.heap[r2], i3 = r2, r2 <<= 1;
        e2.heap[i3] = n2;
      }, YG = (e2, t2, i3) => {
        let n2, r2, o2, s2, a2 = 0;
        if (0 !== e2.sym_next)
          do {
            n2 = 255 & e2.pending_buf[e2.sym_buf + a2++], n2 += (255 & e2.pending_buf[e2.sym_buf + a2++]) << 8, r2 = e2.pending_buf[e2.sym_buf + a2++], 0 === n2 ? FG(e2, r2, t2) : (o2 = wG[r2], FG(e2, o2 + mG + 1, t2), s2 = RG[o2], 0 !== s2 && (r2 -= OG[o2], VG(e2, r2, s2)), n2--, o2 = UG(n2), FG(e2, o2, i3), s2 = CG[o2], 0 !== s2 && (n2 -= NG[o2], VG(e2, n2, s2)));
          } while (a2 < e2.sym_next);
        FG(e2, 256, t2);
      }, qG = (e2, t2) => {
        const i3 = t2.dyn_tree, n2 = t2.stat_desc.static_tree, r2 = t2.stat_desc.has_stree, o2 = t2.stat_desc.elems;
        let s2, a2, c2, d2 = -1;
        for (e2.heap_len = 0, e2.heap_max = 573, s2 = 0; s2 < o2; s2++)
          0 !== i3[2 * s2] ? (e2.heap[++e2.heap_len] = d2 = s2, e2.depth[s2] = 0) : i3[2 * s2 + 1] = 0;
        for (; e2.heap_len < 2; )
          c2 = e2.heap[++e2.heap_len] = d2 < 2 ? ++d2 : 0, i3[2 * c2] = 1, e2.depth[c2] = 0, e2.opt_len--, r2 && (e2.static_len -= n2[2 * c2 + 1]);
        for (t2.max_code = d2, s2 = e2.heap_len >> 1; s2 >= 1; s2--)
          KG(e2, i3, s2);
        c2 = o2;
        do {
          s2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], KG(e2, i3, 1), a2 = e2.heap[1], e2.heap[--e2.heap_max] = s2, e2.heap[--e2.heap_max] = a2, i3[2 * c2] = i3[2 * s2] + i3[2 * a2], e2.depth[c2] = (e2.depth[s2] >= e2.depth[a2] ? e2.depth[s2] : e2.depth[a2]) + 1, i3[2 * s2 + 1] = i3[2 * a2 + 1] = c2, e2.heap[1] = c2++, KG(e2, i3, 1);
        } while (e2.heap_len >= 2);
        e2.heap[--e2.heap_max] = e2.heap[1], ((e3, t3) => {
          const i4 = t3.dyn_tree, n3 = t3.max_code, r3 = t3.stat_desc.static_tree, o3 = t3.stat_desc.has_stree, s3 = t3.stat_desc.extra_bits, a3 = t3.stat_desc.extra_base, c3 = t3.stat_desc.max_length;
          let d3, l2, u2, h2, p3, _2, E2 = 0;
          for (h2 = 0; h2 <= gG; h2++)
            e3.bl_count[h2] = 0;
          for (i4[2 * e3.heap[e3.heap_max] + 1] = 0, d3 = e3.heap_max + 1; d3 < 573; d3++)
            l2 = e3.heap[d3], h2 = i4[2 * i4[2 * l2 + 1] + 1] + 1, h2 > c3 && (h2 = c3, E2++), i4[2 * l2 + 1] = h2, l2 > n3 || (e3.bl_count[h2]++, p3 = 0, l2 >= a3 && (p3 = s3[l2 - a3]), _2 = i4[2 * l2], e3.opt_len += _2 * (h2 + p3), o3 && (e3.static_len += _2 * (r3[2 * l2 + 1] + p3)));
          if (0 !== E2) {
            do {
              for (h2 = c3 - 1; 0 === e3.bl_count[h2]; )
                h2--;
              e3.bl_count[h2]--, e3.bl_count[h2 + 1] += 2, e3.bl_count[c3]--, E2 -= 2;
            } while (E2 > 0);
            for (h2 = c3; 0 !== h2; h2--)
              for (l2 = e3.bl_count[h2]; 0 !== l2; )
                u2 = e3.heap[--d3], u2 > n3 || (i4[2 * u2 + 1] !== h2 && (e3.opt_len += (h2 - i4[2 * u2 + 1]) * i4[2 * u2], i4[2 * u2 + 1] = h2), l2--);
          }
        })(e2, t2), jG(i3, d2, e2.bl_count);
      }, zG = (e2, t2, i3) => {
        let n2, r2, o2 = -1, s2 = t2[1], a2 = 0, c2 = 7, d2 = 4;
        for (0 === s2 && (c2 = 138, d2 = 3), t2[2 * (i3 + 1) + 1] = 65535, n2 = 0; n2 <= i3; n2++)
          r2 = s2, s2 = t2[2 * (n2 + 1) + 1], ++a2 < c2 && r2 === s2 || (a2 < d2 ? e2.bl_tree[2 * r2] += a2 : 0 !== r2 ? (r2 !== o2 && e2.bl_tree[2 * r2]++, e2.bl_tree[32]++) : a2 <= 10 ? e2.bl_tree[34]++ : e2.bl_tree[36]++, a2 = 0, o2 = r2, 0 === s2 ? (c2 = 138, d2 = 3) : r2 === s2 ? (c2 = 6, d2 = 3) : (c2 = 7, d2 = 4));
      }, XG = (e2, t2, i3) => {
        let n2, r2, o2 = -1, s2 = t2[1], a2 = 0, c2 = 7, d2 = 4;
        for (0 === s2 && (c2 = 138, d2 = 3), n2 = 0; n2 <= i3; n2++)
          if (r2 = s2, s2 = t2[2 * (n2 + 1) + 1], !(++a2 < c2 && r2 === s2)) {
            if (a2 < d2)
              do {
                FG(e2, r2, e2.bl_tree);
              } while (0 != --a2);
            else
              0 !== r2 ? (r2 !== o2 && (FG(e2, r2, e2.bl_tree), a2--), FG(e2, 16, e2.bl_tree), VG(e2, a2 - 3, 2)) : a2 <= 10 ? (FG(e2, 17, e2.bl_tree), VG(e2, a2 - 3, 3)) : (FG(e2, 18, e2.bl_tree), VG(e2, a2 - 11, 7));
            a2 = 0, o2 = r2, 0 === s2 ? (c2 = 138, d2 = 3) : r2 === s2 ? (c2 = 6, d2 = 3) : (c2 = 7, d2 = 4);
          }
      };
      let JG = false;
      const QG = (e2, t2, i3, n2) => {
        VG(e2, 0 + (n2 ? 1 : 0), 3), WG(e2), xG(e2, i3), xG(e2, ~i3), i3 && e2.pending_buf.set(e2.window.subarray(t2, t2 + i3), e2.pending), e2.pending += i3;
      };
      var ZG = (e2) => {
        JG || ((() => {
          let e3, t2, i3, n2, r2;
          const o2 = new Array(16);
          for (i3 = 0, n2 = 0; n2 < 28; n2++)
            for (OG[n2] = i3, e3 = 0; e3 < 1 << RG[n2]; e3++)
              wG[i3++] = n2;
          for (wG[i3 - 1] = n2, r2 = 0, n2 = 0; n2 < 16; n2++)
            for (NG[n2] = r2, e3 = 0; e3 < 1 << CG[n2]; e3++)
              bG[r2++] = n2;
          for (r2 >>= 7; n2 < SG; n2++)
            for (NG[n2] = r2 << 7, e3 = 0; e3 < 1 << CG[n2] - 7; e3++)
              bG[256 + r2++] = n2;
          for (t2 = 0; t2 <= gG; t2++)
            o2[t2] = 0;
          for (e3 = 0; e3 <= 143; )
            yG[2 * e3 + 1] = 8, e3++, o2[8]++;
          for (; e3 <= 255; )
            yG[2 * e3 + 1] = 9, e3++, o2[9]++;
          for (; e3 <= 279; )
            yG[2 * e3 + 1] = 7, e3++, o2[7]++;
          for (; e3 <= 287; )
            yG[2 * e3 + 1] = 8, e3++, o2[8]++;
          for (jG(yG, 287, o2), e3 = 0; e3 < SG; e3++)
            AG[2 * e3 + 1] = 5, AG[2 * e3] = BG(e3, 5);
          PG = new DG(yG, RG, 257, TG, gG), LG = new DG(AG, CG, 0, SG, gG), kG = new DG(new Array(0), vG, 0, 19, 7);
        })(), JG = true), e2.l_desc = new MG(e2.dyn_ltree, PG), e2.d_desc = new MG(e2.dyn_dtree, LG), e2.bl_desc = new MG(e2.bl_tree, kG), e2.bi_buf = 0, e2.bi_valid = 0, GG(e2);
      }, $G = (e2, t2, i3, n2) => {
        let r2, o2, s2 = 0;
        e2.level > 0 ? (2 === e2.strm.data_type && (e2.strm.data_type = ((e3) => {
          let t3, i4 = 4093624447;
          for (t3 = 0; t3 <= 31; t3++, i4 >>>= 1)
            if (1 & i4 && 0 !== e3.dyn_ltree[2 * t3])
              return 0;
          if (0 !== e3.dyn_ltree[18] || 0 !== e3.dyn_ltree[20] || 0 !== e3.dyn_ltree[26])
            return 1;
          for (t3 = 32; t3 < mG; t3++)
            if (0 !== e3.dyn_ltree[2 * t3])
              return 1;
          return 0;
        })(e2)), qG(e2, e2.l_desc), qG(e2, e2.d_desc), s2 = ((e3) => {
          let t3;
          for (zG(e3, e3.dyn_ltree, e3.l_desc.max_code), zG(e3, e3.dyn_dtree, e3.d_desc.max_code), qG(e3, e3.bl_desc), t3 = 18; t3 >= 3 && 0 === e3.bl_tree[2 * IG[t3] + 1]; t3--)
            ;
          return e3.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
        })(e2), r2 = e2.opt_len + 3 + 7 >>> 3, o2 = e2.static_len + 3 + 7 >>> 3, o2 <= r2 && (r2 = o2)) : r2 = o2 = i3 + 5, i3 + 4 <= r2 && -1 !== t2 ? QG(e2, t2, i3, n2) : 4 === e2.strategy || o2 === r2 ? (VG(e2, 2 + (n2 ? 1 : 0), 3), YG(e2, yG, AG)) : (VG(e2, 4 + (n2 ? 1 : 0), 3), ((e3, t3, i4, n3) => {
          let r3;
          for (VG(e3, t3 - 257, 5), VG(e3, i4 - 1, 5), VG(e3, n3 - 4, 4), r3 = 0; r3 < n3; r3++)
            VG(e3, e3.bl_tree[2 * IG[r3] + 1], 3);
          XG(e3, e3.dyn_ltree, t3 - 1), XG(e3, e3.dyn_dtree, i4 - 1);
        })(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, s2 + 1), YG(e2, e2.dyn_ltree, e2.dyn_dtree)), GG(e2), n2 && WG(e2);
      }, eW = (e2, t2, i3) => (e2.pending_buf[e2.sym_buf + e2.sym_next++] = t2, e2.pending_buf[e2.sym_buf + e2.sym_next++] = t2 >> 8, e2.pending_buf[e2.sym_buf + e2.sym_next++] = i3, 0 === t2 ? e2.dyn_ltree[2 * i3]++ : (e2.matches++, t2--, e2.dyn_ltree[2 * (wG[i3] + mG + 1)]++, e2.dyn_dtree[2 * UG(t2)]++), e2.sym_next === e2.sym_end), tW = (e2) => {
        VG(e2, 2, 3), FG(e2, 256, yG), ((e3) => {
          16 === e3.bi_valid ? (xG(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : e3.bi_valid >= 8 && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
        })(e2);
      }, iW = { _tr_init: ZG, _tr_stored_block: QG, _tr_flush_block: $G, _tr_tally: eW, _tr_align: tW };
      var nW = (e2, t2, i3, n2) => {
        let r2 = 65535 & e2 | 0, o2 = e2 >>> 16 & 65535 | 0, s2 = 0;
        for (; 0 !== i3; ) {
          s2 = i3 > 2e3 ? 2e3 : i3, i3 -= s2;
          do {
            r2 = r2 + t2[n2++] | 0, o2 = o2 + r2 | 0;
          } while (--s2);
          r2 %= 65521, o2 %= 65521;
        }
        return r2 | o2 << 16 | 0;
      };
      const rW = new Uint32Array((() => {
        let e2, t2 = [];
        for (var i3 = 0; i3 < 256; i3++) {
          e2 = i3;
          for (var n2 = 0; n2 < 8; n2++)
            e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
          t2[i3] = e2;
        }
        return t2;
      })());
      var oW = (e2, t2, i3, n2) => {
        const r2 = rW, o2 = n2 + i3;
        e2 ^= -1;
        for (let i4 = n2; i4 < o2; i4++)
          e2 = e2 >>> 8 ^ r2[255 & (e2 ^ t2[i4])];
        return -1 ^ e2;
      }, sW = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" }, aW = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_MEM_ERROR: -4, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      const { _tr_init: cW, _tr_stored_block: dW, _tr_flush_block: lW, _tr_tally: uW, _tr_align: hW } = iW, { Z_NO_FLUSH: pW, Z_PARTIAL_FLUSH: _W, Z_FULL_FLUSH: EW, Z_FINISH: fW, Z_BLOCK: mW, Z_OK: TW, Z_STREAM_END: SW, Z_STREAM_ERROR: gW, Z_DATA_ERROR: RW, Z_BUF_ERROR: CW, Z_DEFAULT_COMPRESSION: vW, Z_FILTERED: IW, Z_HUFFMAN_ONLY: yW, Z_RLE: AW, Z_FIXED: bW, Z_DEFAULT_STRATEGY: wW, Z_UNKNOWN: OW, Z_DEFLATED: NW } = aW, DW = 286, PW = 30, LW = 19, kW = 2 * DW + 1, MW = 15, UW = 258, xW = 262, VW = 42, FW = 113, BW = 666, jW = (e2, t2) => (e2.msg = sW[t2], t2), GW = (e2) => 2 * e2 - (e2 > 4 ? 9 : 0), WW = (e2) => {
        let t2 = e2.length;
        for (; --t2 >= 0; )
          e2[t2] = 0;
      }, HW = (e2) => {
        let t2, i3, n2, r2 = e2.w_size;
        t2 = e2.hash_size, n2 = t2;
        do {
          i3 = e2.head[--n2], e2.head[n2] = i3 >= r2 ? i3 - r2 : 0;
        } while (--t2);
        t2 = r2, n2 = t2;
        do {
          i3 = e2.prev[--n2], e2.prev[n2] = i3 >= r2 ? i3 - r2 : 0;
        } while (--t2);
      };
      let KW = (e2, t2, i3) => (t2 << e2.hash_shift ^ i3) & e2.hash_mask;
      const YW = (e2) => {
        const t2 = e2.state;
        let i3 = t2.pending;
        i3 > e2.avail_out && (i3 = e2.avail_out), 0 !== i3 && (e2.output.set(t2.pending_buf.subarray(t2.pending_out, t2.pending_out + i3), e2.next_out), e2.next_out += i3, t2.pending_out += i3, e2.total_out += i3, e2.avail_out -= i3, t2.pending -= i3, 0 === t2.pending && (t2.pending_out = 0));
      }, qW = (e2, t2) => {
        lW(e2, e2.block_start >= 0 ? e2.block_start : -1, e2.strstart - e2.block_start, t2), e2.block_start = e2.strstart, YW(e2.strm);
      }, zW = (e2, t2) => {
        e2.pending_buf[e2.pending++] = t2;
      }, XW = (e2, t2) => {
        e2.pending_buf[e2.pending++] = t2 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t2;
      }, JW = (e2, t2, i3, n2) => {
        let r2 = e2.avail_in;
        return r2 > n2 && (r2 = n2), 0 === r2 ? 0 : (e2.avail_in -= r2, t2.set(e2.input.subarray(e2.next_in, e2.next_in + r2), i3), 1 === e2.state.wrap ? e2.adler = nW(e2.adler, t2, r2, i3) : 2 === e2.state.wrap && (e2.adler = oW(e2.adler, t2, r2, i3)), e2.next_in += r2, e2.total_in += r2, r2);
      }, QW = (e2, t2) => {
        let i3, n2, r2 = e2.max_chain_length, o2 = e2.strstart, s2 = e2.prev_length, a2 = e2.nice_match;
        const c2 = e2.strstart > e2.w_size - xW ? e2.strstart - (e2.w_size - xW) : 0, d2 = e2.window, l2 = e2.w_mask, u2 = e2.prev, h2 = e2.strstart + UW;
        let p3 = d2[o2 + s2 - 1], _2 = d2[o2 + s2];
        e2.prev_length >= e2.good_match && (r2 >>= 2), a2 > e2.lookahead && (a2 = e2.lookahead);
        do {
          if (i3 = t2, d2[i3 + s2] === _2 && d2[i3 + s2 - 1] === p3 && d2[i3] === d2[o2] && d2[++i3] === d2[o2 + 1]) {
            o2 += 2, i3++;
            do {
            } while (d2[++o2] === d2[++i3] && d2[++o2] === d2[++i3] && d2[++o2] === d2[++i3] && d2[++o2] === d2[++i3] && d2[++o2] === d2[++i3] && d2[++o2] === d2[++i3] && d2[++o2] === d2[++i3] && d2[++o2] === d2[++i3] && o2 < h2);
            if (n2 = UW - (h2 - o2), o2 = h2 - UW, n2 > s2) {
              if (e2.match_start = t2, s2 = n2, n2 >= a2)
                break;
              p3 = d2[o2 + s2 - 1], _2 = d2[o2 + s2];
            }
          }
        } while ((t2 = u2[t2 & l2]) > c2 && 0 != --r2);
        return s2 <= e2.lookahead ? s2 : e2.lookahead;
      }, ZW = (e2) => {
        const t2 = e2.w_size;
        let i3, n2, r2;
        do {
          if (n2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= t2 + (t2 - xW) && (e2.window.set(e2.window.subarray(t2, t2 + t2 - n2), 0), e2.match_start -= t2, e2.strstart -= t2, e2.block_start -= t2, e2.insert > e2.strstart && (e2.insert = e2.strstart), HW(e2), n2 += t2), 0 === e2.strm.avail_in)
            break;
          if (i3 = JW(e2.strm, e2.window, e2.strstart + e2.lookahead, n2), e2.lookahead += i3, e2.lookahead + e2.insert >= 3)
            for (r2 = e2.strstart - e2.insert, e2.ins_h = e2.window[r2], e2.ins_h = KW(e2, e2.ins_h, e2.window[r2 + 1]); e2.insert && (e2.ins_h = KW(e2, e2.ins_h, e2.window[r2 + 3 - 1]), e2.prev[r2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = r2, r2++, e2.insert--, !(e2.lookahead + e2.insert < 3)); )
              ;
        } while (e2.lookahead < xW && 0 !== e2.strm.avail_in);
      }, $W = (e2, t2) => {
        let i3, n2, r2, o2 = e2.pending_buf_size - 5 > e2.w_size ? e2.w_size : e2.pending_buf_size - 5, s2 = 0, a2 = e2.strm.avail_in;
        do {
          if (i3 = 65535, r2 = e2.bi_valid + 42 >> 3, e2.strm.avail_out < r2)
            break;
          if (r2 = e2.strm.avail_out - r2, n2 = e2.strstart - e2.block_start, i3 > n2 + e2.strm.avail_in && (i3 = n2 + e2.strm.avail_in), i3 > r2 && (i3 = r2), i3 < o2 && (0 === i3 && t2 !== fW || t2 === pW || i3 !== n2 + e2.strm.avail_in))
            break;
          s2 = t2 === fW && i3 === n2 + e2.strm.avail_in ? 1 : 0, dW(e2, 0, 0, s2), e2.pending_buf[e2.pending - 4] = i3, e2.pending_buf[e2.pending - 3] = i3 >> 8, e2.pending_buf[e2.pending - 2] = ~i3, e2.pending_buf[e2.pending - 1] = ~i3 >> 8, YW(e2.strm), n2 && (n2 > i3 && (n2 = i3), e2.strm.output.set(e2.window.subarray(e2.block_start, e2.block_start + n2), e2.strm.next_out), e2.strm.next_out += n2, e2.strm.avail_out -= n2, e2.strm.total_out += n2, e2.block_start += n2, i3 -= n2), i3 && (JW(e2.strm, e2.strm.output, e2.strm.next_out, i3), e2.strm.next_out += i3, e2.strm.avail_out -= i3, e2.strm.total_out += i3);
        } while (0 === s2);
        return a2 -= e2.strm.avail_in, a2 && (a2 >= e2.w_size ? (e2.matches = 2, e2.window.set(e2.strm.input.subarray(e2.strm.next_in - e2.w_size, e2.strm.next_in), 0), e2.strstart = e2.w_size, e2.insert = e2.strstart) : (e2.window_size - e2.strstart <= a2 && (e2.strstart -= e2.w_size, e2.window.set(e2.window.subarray(e2.w_size, e2.w_size + e2.strstart), 0), e2.matches < 2 && e2.matches++, e2.insert > e2.strstart && (e2.insert = e2.strstart)), e2.window.set(e2.strm.input.subarray(e2.strm.next_in - a2, e2.strm.next_in), e2.strstart), e2.strstart += a2, e2.insert += a2 > e2.w_size - e2.insert ? e2.w_size - e2.insert : a2), e2.block_start = e2.strstart), e2.high_water < e2.strstart && (e2.high_water = e2.strstart), s2 ? 4 : t2 !== pW && t2 !== fW && 0 === e2.strm.avail_in && e2.strstart === e2.block_start ? 2 : (r2 = e2.window_size - e2.strstart, e2.strm.avail_in > r2 && e2.block_start >= e2.w_size && (e2.block_start -= e2.w_size, e2.strstart -= e2.w_size, e2.window.set(e2.window.subarray(e2.w_size, e2.w_size + e2.strstart), 0), e2.matches < 2 && e2.matches++, r2 += e2.w_size, e2.insert > e2.strstart && (e2.insert = e2.strstart)), r2 > e2.strm.avail_in && (r2 = e2.strm.avail_in), r2 && (JW(e2.strm, e2.window, e2.strstart, r2), e2.strstart += r2, e2.insert += r2 > e2.w_size - e2.insert ? e2.w_size - e2.insert : r2), e2.high_water < e2.strstart && (e2.high_water = e2.strstart), r2 = e2.bi_valid + 42 >> 3, r2 = e2.pending_buf_size - r2 > 65535 ? 65535 : e2.pending_buf_size - r2, o2 = r2 > e2.w_size ? e2.w_size : r2, n2 = e2.strstart - e2.block_start, (n2 >= o2 || (n2 || t2 === fW) && t2 !== pW && 0 === e2.strm.avail_in && n2 <= r2) && (i3 = n2 > r2 ? r2 : n2, s2 = t2 === fW && 0 === e2.strm.avail_in && i3 === n2 ? 1 : 0, dW(e2, e2.block_start, i3, s2), e2.block_start += i3, YW(e2.strm)), s2 ? 3 : 1);
      }, eH = (e2, t2) => {
        let i3, n2;
        for (; ; ) {
          if (e2.lookahead < xW) {
            if (ZW(e2), e2.lookahead < xW && t2 === pW)
              return 1;
            if (0 === e2.lookahead)
              break;
          }
          if (i3 = 0, e2.lookahead >= 3 && (e2.ins_h = KW(e2, e2.ins_h, e2.window[e2.strstart + 3 - 1]), i3 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 !== i3 && e2.strstart - i3 <= e2.w_size - xW && (e2.match_length = QW(e2, i3)), e2.match_length >= 3)
            if (n2 = uW(e2, e2.strstart - e2.match_start, e2.match_length - 3), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= 3) {
              e2.match_length--;
              do {
                e2.strstart++, e2.ins_h = KW(e2, e2.ins_h, e2.window[e2.strstart + 3 - 1]), i3 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart;
              } while (0 != --e2.match_length);
              e2.strstart++;
            } else
              e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = KW(e2, e2.ins_h, e2.window[e2.strstart + 1]);
          else
            n2 = uW(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
          if (n2 && (qW(e2, false), 0 === e2.strm.avail_out))
            return 1;
        }
        return e2.insert = e2.strstart < 2 ? e2.strstart : 2, t2 === fW ? (qW(e2, true), 0 === e2.strm.avail_out ? 3 : 4) : e2.sym_next && (qW(e2, false), 0 === e2.strm.avail_out) ? 1 : 2;
      }, tH = (e2, t2) => {
        let i3, n2, r2;
        for (; ; ) {
          if (e2.lookahead < xW) {
            if (ZW(e2), e2.lookahead < xW && t2 === pW)
              return 1;
            if (0 === e2.lookahead)
              break;
          }
          if (i3 = 0, e2.lookahead >= 3 && (e2.ins_h = KW(e2, e2.ins_h, e2.window[e2.strstart + 3 - 1]), i3 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = 2, 0 !== i3 && e2.prev_length < e2.max_lazy_match && e2.strstart - i3 <= e2.w_size - xW && (e2.match_length = QW(e2, i3), e2.match_length <= 5 && (e2.strategy === IW || 3 === e2.match_length && e2.strstart - e2.match_start > 4096) && (e2.match_length = 2)), e2.prev_length >= 3 && e2.match_length <= e2.prev_length) {
            r2 = e2.strstart + e2.lookahead - 3, n2 = uW(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - 3), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2;
            do {
              ++e2.strstart <= r2 && (e2.ins_h = KW(e2, e2.ins_h, e2.window[e2.strstart + 3 - 1]), i3 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart);
            } while (0 != --e2.prev_length);
            if (e2.match_available = 0, e2.match_length = 2, e2.strstart++, n2 && (qW(e2, false), 0 === e2.strm.avail_out))
              return 1;
          } else if (e2.match_available) {
            if (n2 = uW(e2, 0, e2.window[e2.strstart - 1]), n2 && qW(e2, false), e2.strstart++, e2.lookahead--, 0 === e2.strm.avail_out)
              return 1;
          } else
            e2.match_available = 1, e2.strstart++, e2.lookahead--;
        }
        return e2.match_available && (n2 = uW(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < 2 ? e2.strstart : 2, t2 === fW ? (qW(e2, true), 0 === e2.strm.avail_out ? 3 : 4) : e2.sym_next && (qW(e2, false), 0 === e2.strm.avail_out) ? 1 : 2;
      };
      function iH(e2, t2, i3, n2, r2) {
        this.good_length = e2, this.max_lazy = t2, this.nice_length = i3, this.max_chain = n2, this.func = r2;
      }
      const nH = [new iH(0, 0, 0, 0, $W), new iH(4, 4, 8, 4, eH), new iH(4, 5, 16, 8, eH), new iH(4, 6, 32, 32, eH), new iH(4, 4, 16, 16, tH), new iH(8, 16, 32, 32, tH), new iH(8, 16, 128, 128, tH), new iH(8, 32, 128, 256, tH), new iH(32, 128, 258, 1024, tH), new iH(32, 258, 258, 4096, tH)];
      function rH() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = NW, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(2 * kW), this.dyn_dtree = new Uint16Array(2 * (2 * PW + 1)), this.bl_tree = new Uint16Array(2 * (2 * LW + 1)), WW(this.dyn_ltree), WW(this.dyn_dtree), WW(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(MW + 1), this.heap = new Uint16Array(2 * DW + 1), WW(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * DW + 1), WW(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      const oH = (e2) => {
        if (!e2)
          return 1;
        const t2 = e2.state;
        return !t2 || t2.strm !== e2 || t2.status !== VW && 57 !== t2.status && 69 !== t2.status && 73 !== t2.status && 91 !== t2.status && 103 !== t2.status && t2.status !== FW && t2.status !== BW ? 1 : 0;
      }, sH = (e2) => {
        if (oH(e2))
          return jW(e2, gW);
        e2.total_in = e2.total_out = 0, e2.data_type = OW;
        const t2 = e2.state;
        return t2.pending = 0, t2.pending_out = 0, t2.wrap < 0 && (t2.wrap = -t2.wrap), t2.status = 2 === t2.wrap ? 57 : t2.wrap ? VW : FW, e2.adler = 2 === t2.wrap ? 0 : 1, t2.last_flush = -2, cW(t2), TW;
      }, aH = (e2) => {
        const t2 = sH(e2);
        return t2 === TW && ((e3) => {
          e3.window_size = 2 * e3.w_size, WW(e3.head), e3.max_lazy_match = nH[e3.level].max_lazy, e3.good_match = nH[e3.level].good_length, e3.nice_match = nH[e3.level].nice_length, e3.max_chain_length = nH[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = 2, e3.match_available = 0, e3.ins_h = 0;
        })(e2.state), t2;
      }, cH = (e2, t2, i3, n2, r2, o2) => {
        if (!e2)
          return gW;
        let s2 = 1;
        if (t2 === vW && (t2 = 6), n2 < 0 ? (s2 = 0, n2 = -n2) : n2 > 15 && (s2 = 2, n2 -= 16), r2 < 1 || r2 > 9 || i3 !== NW || n2 < 8 || n2 > 15 || t2 < 0 || t2 > 9 || o2 < 0 || o2 > bW || 8 === n2 && 1 !== s2)
          return jW(e2, gW);
        8 === n2 && (n2 = 9);
        const a2 = new rH();
        return e2.state = a2, a2.strm = e2, a2.status = VW, a2.wrap = s2, a2.gzhead = null, a2.w_bits = n2, a2.w_size = 1 << a2.w_bits, a2.w_mask = a2.w_size - 1, a2.hash_bits = r2 + 7, a2.hash_size = 1 << a2.hash_bits, a2.hash_mask = a2.hash_size - 1, a2.hash_shift = ~~((a2.hash_bits + 3 - 1) / 3), a2.window = new Uint8Array(2 * a2.w_size), a2.head = new Uint16Array(a2.hash_size), a2.prev = new Uint16Array(a2.w_size), a2.lit_bufsize = 1 << r2 + 6, a2.pending_buf_size = 4 * a2.lit_bufsize, a2.pending_buf = new Uint8Array(a2.pending_buf_size), a2.sym_buf = a2.lit_bufsize, a2.sym_end = 3 * (a2.lit_bufsize - 1), a2.level = t2, a2.strategy = o2, a2.method = i3, aH(e2);
      };
      var dH = (e2, t2) => {
        if (oH(e2) || t2 > mW || t2 < 0)
          return e2 ? jW(e2, gW) : gW;
        const i3 = e2.state;
        if (!e2.output || 0 !== e2.avail_in && !e2.input || i3.status === BW && t2 !== fW)
          return jW(e2, 0 === e2.avail_out ? CW : gW);
        const n2 = i3.last_flush;
        if (i3.last_flush = t2, 0 !== i3.pending) {
          if (YW(e2), 0 === e2.avail_out)
            return i3.last_flush = -1, TW;
        } else if (0 === e2.avail_in && GW(t2) <= GW(n2) && t2 !== fW)
          return jW(e2, CW);
        if (i3.status === BW && 0 !== e2.avail_in)
          return jW(e2, CW);
        if (i3.status === VW && 0 === i3.wrap && (i3.status = FW), i3.status === VW) {
          let t3 = NW + (i3.w_bits - 8 << 4) << 8, n3 = -1;
          if (n3 = i3.strategy >= yW || i3.level < 2 ? 0 : i3.level < 6 ? 1 : 6 === i3.level ? 2 : 3, t3 |= n3 << 6, 0 !== i3.strstart && (t3 |= 32), t3 += 31 - t3 % 31, XW(i3, t3), 0 !== i3.strstart && (XW(i3, e2.adler >>> 16), XW(i3, 65535 & e2.adler)), e2.adler = 1, i3.status = FW, YW(e2), 0 !== i3.pending)
            return i3.last_flush = -1, TW;
        }
        if (57 === i3.status) {
          if (e2.adler = 0, zW(i3, 31), zW(i3, 139), zW(i3, 8), i3.gzhead)
            zW(i3, (i3.gzhead.text ? 1 : 0) + (i3.gzhead.hcrc ? 2 : 0) + (i3.gzhead.extra ? 4 : 0) + (i3.gzhead.name ? 8 : 0) + (i3.gzhead.comment ? 16 : 0)), zW(i3, 255 & i3.gzhead.time), zW(i3, i3.gzhead.time >> 8 & 255), zW(i3, i3.gzhead.time >> 16 & 255), zW(i3, i3.gzhead.time >> 24 & 255), zW(i3, 9 === i3.level ? 2 : i3.strategy >= yW || i3.level < 2 ? 4 : 0), zW(i3, 255 & i3.gzhead.os), i3.gzhead.extra && i3.gzhead.extra.length && (zW(i3, 255 & i3.gzhead.extra.length), zW(i3, i3.gzhead.extra.length >> 8 & 255)), i3.gzhead.hcrc && (e2.adler = oW(e2.adler, i3.pending_buf, i3.pending, 0)), i3.gzindex = 0, i3.status = 69;
          else if (zW(i3, 0), zW(i3, 0), zW(i3, 0), zW(i3, 0), zW(i3, 0), zW(i3, 9 === i3.level ? 2 : i3.strategy >= yW || i3.level < 2 ? 4 : 0), zW(i3, 3), i3.status = FW, YW(e2), 0 !== i3.pending)
            return i3.last_flush = -1, TW;
        }
        if (69 === i3.status) {
          if (i3.gzhead.extra) {
            let t3 = i3.pending, n3 = (65535 & i3.gzhead.extra.length) - i3.gzindex;
            for (; i3.pending + n3 > i3.pending_buf_size; ) {
              let r3 = i3.pending_buf_size - i3.pending;
              if (i3.pending_buf.set(i3.gzhead.extra.subarray(i3.gzindex, i3.gzindex + r3), i3.pending), i3.pending = i3.pending_buf_size, i3.gzhead.hcrc && i3.pending > t3 && (e2.adler = oW(e2.adler, i3.pending_buf, i3.pending - t3, t3)), i3.gzindex += r3, YW(e2), 0 !== i3.pending)
                return i3.last_flush = -1, TW;
              t3 = 0, n3 -= r3;
            }
            let r2 = new Uint8Array(i3.gzhead.extra);
            i3.pending_buf.set(r2.subarray(i3.gzindex, i3.gzindex + n3), i3.pending), i3.pending += n3, i3.gzhead.hcrc && i3.pending > t3 && (e2.adler = oW(e2.adler, i3.pending_buf, i3.pending - t3, t3)), i3.gzindex = 0;
          }
          i3.status = 73;
        }
        if (73 === i3.status) {
          if (i3.gzhead.name) {
            let t3, n3 = i3.pending;
            do {
              if (i3.pending === i3.pending_buf_size) {
                if (i3.gzhead.hcrc && i3.pending > n3 && (e2.adler = oW(e2.adler, i3.pending_buf, i3.pending - n3, n3)), YW(e2), 0 !== i3.pending)
                  return i3.last_flush = -1, TW;
                n3 = 0;
              }
              t3 = i3.gzindex < i3.gzhead.name.length ? 255 & i3.gzhead.name.charCodeAt(i3.gzindex++) : 0, zW(i3, t3);
            } while (0 !== t3);
            i3.gzhead.hcrc && i3.pending > n3 && (e2.adler = oW(e2.adler, i3.pending_buf, i3.pending - n3, n3)), i3.gzindex = 0;
          }
          i3.status = 91;
        }
        if (91 === i3.status) {
          if (i3.gzhead.comment) {
            let t3, n3 = i3.pending;
            do {
              if (i3.pending === i3.pending_buf_size) {
                if (i3.gzhead.hcrc && i3.pending > n3 && (e2.adler = oW(e2.adler, i3.pending_buf, i3.pending - n3, n3)), YW(e2), 0 !== i3.pending)
                  return i3.last_flush = -1, TW;
                n3 = 0;
              }
              t3 = i3.gzindex < i3.gzhead.comment.length ? 255 & i3.gzhead.comment.charCodeAt(i3.gzindex++) : 0, zW(i3, t3);
            } while (0 !== t3);
            i3.gzhead.hcrc && i3.pending > n3 && (e2.adler = oW(e2.adler, i3.pending_buf, i3.pending - n3, n3));
          }
          i3.status = 103;
        }
        if (103 === i3.status) {
          if (i3.gzhead.hcrc) {
            if (i3.pending + 2 > i3.pending_buf_size && (YW(e2), 0 !== i3.pending))
              return i3.last_flush = -1, TW;
            zW(i3, 255 & e2.adler), zW(i3, e2.adler >> 8 & 255), e2.adler = 0;
          }
          if (i3.status = FW, YW(e2), 0 !== i3.pending)
            return i3.last_flush = -1, TW;
        }
        if (0 !== e2.avail_in || 0 !== i3.lookahead || t2 !== pW && i3.status !== BW) {
          let n3 = 0 === i3.level ? $W(i3, t2) : i3.strategy === yW ? ((e3, t3) => {
            let i4;
            for (; ; ) {
              if (0 === e3.lookahead && (ZW(e3), 0 === e3.lookahead)) {
                if (t3 === pW)
                  return 1;
                break;
              }
              if (e3.match_length = 0, i4 = uW(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, i4 && (qW(e3, false), 0 === e3.strm.avail_out))
                return 1;
            }
            return e3.insert = 0, t3 === fW ? (qW(e3, true), 0 === e3.strm.avail_out ? 3 : 4) : e3.sym_next && (qW(e3, false), 0 === e3.strm.avail_out) ? 1 : 2;
          })(i3, t2) : i3.strategy === AW ? ((e3, t3) => {
            let i4, n4, r2, o2;
            const s2 = e3.window;
            for (; ; ) {
              if (e3.lookahead <= UW) {
                if (ZW(e3), e3.lookahead <= UW && t3 === pW)
                  return 1;
                if (0 === e3.lookahead)
                  break;
              }
              if (e3.match_length = 0, e3.lookahead >= 3 && e3.strstart > 0 && (r2 = e3.strstart - 1, n4 = s2[r2], n4 === s2[++r2] && n4 === s2[++r2] && n4 === s2[++r2])) {
                o2 = e3.strstart + UW;
                do {
                } while (n4 === s2[++r2] && n4 === s2[++r2] && n4 === s2[++r2] && n4 === s2[++r2] && n4 === s2[++r2] && n4 === s2[++r2] && n4 === s2[++r2] && n4 === s2[++r2] && r2 < o2);
                e3.match_length = UW - (o2 - r2), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
              }
              if (e3.match_length >= 3 ? (i4 = uW(e3, 1, e3.match_length - 3), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (i4 = uW(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), i4 && (qW(e3, false), 0 === e3.strm.avail_out))
                return 1;
            }
            return e3.insert = 0, t3 === fW ? (qW(e3, true), 0 === e3.strm.avail_out ? 3 : 4) : e3.sym_next && (qW(e3, false), 0 === e3.strm.avail_out) ? 1 : 2;
          })(i3, t2) : nH[i3.level].func(i3, t2);
          if (3 !== n3 && 4 !== n3 || (i3.status = BW), 1 === n3 || 3 === n3)
            return 0 === e2.avail_out && (i3.last_flush = -1), TW;
          if (2 === n3 && (t2 === _W ? hW(i3) : t2 !== mW && (dW(i3, 0, 0, false), t2 === EW && (WW(i3.head), 0 === i3.lookahead && (i3.strstart = 0, i3.block_start = 0, i3.insert = 0))), YW(e2), 0 === e2.avail_out))
            return i3.last_flush = -1, TW;
        }
        return t2 !== fW ? TW : i3.wrap <= 0 ? SW : (2 === i3.wrap ? (zW(i3, 255 & e2.adler), zW(i3, e2.adler >> 8 & 255), zW(i3, e2.adler >> 16 & 255), zW(i3, e2.adler >> 24 & 255), zW(i3, 255 & e2.total_in), zW(i3, e2.total_in >> 8 & 255), zW(i3, e2.total_in >> 16 & 255), zW(i3, e2.total_in >> 24 & 255)) : (XW(i3, e2.adler >>> 16), XW(i3, 65535 & e2.adler)), YW(e2), i3.wrap > 0 && (i3.wrap = -i3.wrap), 0 !== i3.pending ? TW : SW);
      }, lH = (e2, t2) => {
        let i3 = t2.length;
        if (oH(e2))
          return gW;
        const n2 = e2.state, r2 = n2.wrap;
        if (2 === r2 || 1 === r2 && n2.status !== VW || n2.lookahead)
          return gW;
        if (1 === r2 && (e2.adler = nW(e2.adler, t2, i3, 0)), n2.wrap = 0, i3 >= n2.w_size) {
          0 === r2 && (WW(n2.head), n2.strstart = 0, n2.block_start = 0, n2.insert = 0);
          let e3 = new Uint8Array(n2.w_size);
          e3.set(t2.subarray(i3 - n2.w_size, i3), 0), t2 = e3, i3 = n2.w_size;
        }
        const o2 = e2.avail_in, s2 = e2.next_in, a2 = e2.input;
        for (e2.avail_in = i3, e2.next_in = 0, e2.input = t2, ZW(n2); n2.lookahead >= 3; ) {
          let e3 = n2.strstart, t3 = n2.lookahead - 2;
          do {
            n2.ins_h = KW(n2, n2.ins_h, n2.window[e3 + 3 - 1]), n2.prev[e3 & n2.w_mask] = n2.head[n2.ins_h], n2.head[n2.ins_h] = e3, e3++;
          } while (--t3);
          n2.strstart = e3, n2.lookahead = 2, ZW(n2);
        }
        return n2.strstart += n2.lookahead, n2.block_start = n2.strstart, n2.insert = n2.lookahead, n2.lookahead = 0, n2.match_length = n2.prev_length = 2, n2.match_available = 0, e2.next_in = s2, e2.input = a2, e2.avail_in = o2, n2.wrap = r2, TW;
      }, uH = { deflateInit: (e2, t2) => cH(e2, t2, NW, 15, 8, wW), deflateInit2: cH, deflateReset: aH, deflateResetKeep: sH, deflateSetHeader: (e2, t2) => oH(e2) || 2 !== e2.state.wrap ? gW : (e2.state.gzhead = t2, TW), deflate: dH, deflateEnd: (e2) => {
        if (oH(e2))
          return gW;
        const t2 = e2.state.status;
        return e2.state = null, t2 === FW ? jW(e2, RW) : TW;
      }, deflateSetDictionary: lH, deflateInfo: "pako deflate (from Nodeca project)" };
      const hH = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2);
      var pH = { assign: function(e2) {
        const t2 = Array.prototype.slice.call(arguments, 1);
        for (; t2.length; ) {
          const i3 = t2.shift();
          if (i3) {
            if ("object" != typeof i3)
              throw new TypeError(i3 + "must be non-object");
            for (const t3 in i3)
              hH(i3, t3) && (e2[t3] = i3[t3]);
          }
        }
        return e2;
      }, flattenChunks: (e2) => {
        let t2 = 0;
        for (let i4 = 0, n2 = e2.length; i4 < n2; i4++)
          t2 += e2[i4].length;
        const i3 = new Uint8Array(t2);
        for (let t3 = 0, n2 = 0, r2 = e2.length; t3 < r2; t3++) {
          let r3 = e2[t3];
          i3.set(r3, n2), n2 += r3.length;
        }
        return i3;
      } };
      let _H = true;
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch (e2) {
        _H = false;
      }
      const EH = new Uint8Array(256);
      for (let e2 = 0; e2 < 256; e2++)
        EH[e2] = e2 >= 252 ? 6 : e2 >= 248 ? 5 : e2 >= 240 ? 4 : e2 >= 224 ? 3 : e2 >= 192 ? 2 : 1;
      EH[254] = EH[254] = 1;
      var fH = { string2buf: (e2) => {
        if ("function" == typeof TextEncoder && TextEncoder.prototype.encode)
          return new TextEncoder().encode(e2);
        let t2, i3, n2, r2, o2, s2 = e2.length, a2 = 0;
        for (r2 = 0; r2 < s2; r2++)
          i3 = e2.charCodeAt(r2), 55296 == (64512 & i3) && r2 + 1 < s2 && (n2 = e2.charCodeAt(r2 + 1), 56320 == (64512 & n2) && (i3 = 65536 + (i3 - 55296 << 10) + (n2 - 56320), r2++)), a2 += i3 < 128 ? 1 : i3 < 2048 ? 2 : i3 < 65536 ? 3 : 4;
        for (t2 = new Uint8Array(a2), o2 = 0, r2 = 0; o2 < a2; r2++)
          i3 = e2.charCodeAt(r2), 55296 == (64512 & i3) && r2 + 1 < s2 && (n2 = e2.charCodeAt(r2 + 1), 56320 == (64512 & n2) && (i3 = 65536 + (i3 - 55296 << 10) + (n2 - 56320), r2++)), i3 < 128 ? t2[o2++] = i3 : i3 < 2048 ? (t2[o2++] = 192 | i3 >>> 6, t2[o2++] = 128 | 63 & i3) : i3 < 65536 ? (t2[o2++] = 224 | i3 >>> 12, t2[o2++] = 128 | i3 >>> 6 & 63, t2[o2++] = 128 | 63 & i3) : (t2[o2++] = 240 | i3 >>> 18, t2[o2++] = 128 | i3 >>> 12 & 63, t2[o2++] = 128 | i3 >>> 6 & 63, t2[o2++] = 128 | 63 & i3);
        return t2;
      }, buf2string: (e2, t2) => {
        const i3 = t2 || e2.length;
        if ("function" == typeof TextDecoder && TextDecoder.prototype.decode)
          return new TextDecoder().decode(e2.subarray(0, t2));
        let n2, r2;
        const o2 = new Array(2 * i3);
        for (r2 = 0, n2 = 0; n2 < i3; ) {
          let t3 = e2[n2++];
          if (t3 < 128) {
            o2[r2++] = t3;
            continue;
          }
          let s2 = EH[t3];
          if (s2 > 4)
            o2[r2++] = 65533, n2 += s2 - 1;
          else {
            for (t3 &= 2 === s2 ? 31 : 3 === s2 ? 15 : 7; s2 > 1 && n2 < i3; )
              t3 = t3 << 6 | 63 & e2[n2++], s2--;
            s2 > 1 ? o2[r2++] = 65533 : t3 < 65536 ? o2[r2++] = t3 : (t3 -= 65536, o2[r2++] = 55296 | t3 >> 10 & 1023, o2[r2++] = 56320 | 1023 & t3);
          }
        }
        return ((e3, t3) => {
          if (t3 < 65534 && e3.subarray && _H)
            return String.fromCharCode.apply(null, e3.length === t3 ? e3 : e3.subarray(0, t3));
          let i4 = "";
          for (let n3 = 0; n3 < t3; n3++)
            i4 += String.fromCharCode(e3[n3]);
          return i4;
        })(o2, r2);
      }, utf8border: (e2, t2) => {
        (t2 = t2 || e2.length) > e2.length && (t2 = e2.length);
        let i3 = t2 - 1;
        for (; i3 >= 0 && 128 == (192 & e2[i3]); )
          i3--;
        return i3 < 0 || 0 === i3 ? t2 : i3 + EH[e2[i3]] > t2 ? i3 : t2;
      } };
      var mH = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
      const TH = Object.prototype.toString, { Z_NO_FLUSH: SH, Z_SYNC_FLUSH: gH, Z_FULL_FLUSH: RH, Z_FINISH: CH, Z_OK: vH, Z_STREAM_END: IH, Z_DEFAULT_COMPRESSION: yH, Z_DEFAULT_STRATEGY: AH, Z_DEFLATED: bH } = aW;
      function wH(e2) {
        this.options = pH.assign({ level: yH, method: bH, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: AH }, e2 || {});
        let t2 = this.options;
        t2.raw && t2.windowBits > 0 ? t2.windowBits = -t2.windowBits : t2.gzip && t2.windowBits > 0 && t2.windowBits < 16 && (t2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new mH(), this.strm.avail_out = 0;
        let i3 = uH.deflateInit2(this.strm, t2.level, t2.method, t2.windowBits, t2.memLevel, t2.strategy);
        if (i3 !== vH)
          throw new Error(sW[i3]);
        if (t2.header && uH.deflateSetHeader(this.strm, t2.header), t2.dictionary) {
          let e3;
          if (e3 = "string" == typeof t2.dictionary ? fH.string2buf(t2.dictionary) : "[object ArrayBuffer]" === TH.call(t2.dictionary) ? new Uint8Array(t2.dictionary) : t2.dictionary, i3 = uH.deflateSetDictionary(this.strm, e3), i3 !== vH)
            throw new Error(sW[i3]);
          this._dict_set = true;
        }
      }
      function OH(e2, t2) {
        const i3 = new wH(t2);
        if (i3.push(e2, true), i3.err)
          throw i3.msg || sW[i3.err];
        return i3.result;
      }
      wH.prototype.push = function(e2, t2) {
        const i3 = this.strm, n2 = this.options.chunkSize;
        let r2, o2;
        if (this.ended)
          return false;
        for (o2 = t2 === ~~t2 ? t2 : true === t2 ? CH : SH, "string" == typeof e2 ? i3.input = fH.string2buf(e2) : "[object ArrayBuffer]" === TH.call(e2) ? i3.input = new Uint8Array(e2) : i3.input = e2, i3.next_in = 0, i3.avail_in = i3.input.length; ; )
          if (0 === i3.avail_out && (i3.output = new Uint8Array(n2), i3.next_out = 0, i3.avail_out = n2), (o2 === gH || o2 === RH) && i3.avail_out <= 6)
            this.onData(i3.output.subarray(0, i3.next_out)), i3.avail_out = 0;
          else {
            if (r2 = uH.deflate(i3, o2), r2 === IH)
              return i3.next_out > 0 && this.onData(i3.output.subarray(0, i3.next_out)), r2 = uH.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === vH;
            if (0 !== i3.avail_out) {
              if (o2 > 0 && i3.next_out > 0)
                this.onData(i3.output.subarray(0, i3.next_out)), i3.avail_out = 0;
              else if (0 === i3.avail_in)
                break;
            } else
              this.onData(i3.output);
          }
        return true;
      }, wH.prototype.onData = function(e2) {
        this.chunks.push(e2);
      }, wH.prototype.onEnd = function(e2) {
        e2 === vH && (this.result = pH.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
      };
      var NH = { Deflate: wH, deflate: OH, deflateRaw: function(e2, t2) {
        return (t2 = t2 || {}).raw = true, OH(e2, t2);
      }, gzip: function(e2, t2) {
        return (t2 = t2 || {}).gzip = true, OH(e2, t2);
      }, constants: aW };
      const DH = 16209;
      var PH = function(e2, t2) {
        let i3, n2, r2, o2, s2, a2, c2, d2, l2, u2, h2, p3, _2, E2, f2, m2, T2, S2, g2, R3, C2, v2, I2, y2;
        const A2 = e2.state;
        i3 = e2.next_in, I2 = e2.input, n2 = i3 + (e2.avail_in - 5), r2 = e2.next_out, y2 = e2.output, o2 = r2 - (t2 - e2.avail_out), s2 = r2 + (e2.avail_out - 257), a2 = A2.dmax, c2 = A2.wsize, d2 = A2.whave, l2 = A2.wnext, u2 = A2.window, h2 = A2.hold, p3 = A2.bits, _2 = A2.lencode, E2 = A2.distcode, f2 = (1 << A2.lenbits) - 1, m2 = (1 << A2.distbits) - 1;
        e:
          do {
            p3 < 15 && (h2 += I2[i3++] << p3, p3 += 8, h2 += I2[i3++] << p3, p3 += 8), T2 = _2[h2 & f2];
            t:
              for (; ; ) {
                if (S2 = T2 >>> 24, h2 >>>= S2, p3 -= S2, S2 = T2 >>> 16 & 255, 0 === S2)
                  y2[r2++] = 65535 & T2;
                else {
                  if (!(16 & S2)) {
                    if (0 == (64 & S2)) {
                      T2 = _2[(65535 & T2) + (h2 & (1 << S2) - 1)];
                      continue t;
                    }
                    if (32 & S2) {
                      A2.mode = 16191;
                      break e;
                    }
                    e2.msg = "invalid literal/length code", A2.mode = DH;
                    break e;
                  }
                  g2 = 65535 & T2, S2 &= 15, S2 && (p3 < S2 && (h2 += I2[i3++] << p3, p3 += 8), g2 += h2 & (1 << S2) - 1, h2 >>>= S2, p3 -= S2), p3 < 15 && (h2 += I2[i3++] << p3, p3 += 8, h2 += I2[i3++] << p3, p3 += 8), T2 = E2[h2 & m2];
                  i:
                    for (; ; ) {
                      if (S2 = T2 >>> 24, h2 >>>= S2, p3 -= S2, S2 = T2 >>> 16 & 255, !(16 & S2)) {
                        if (0 == (64 & S2)) {
                          T2 = E2[(65535 & T2) + (h2 & (1 << S2) - 1)];
                          continue i;
                        }
                        e2.msg = "invalid distance code", A2.mode = DH;
                        break e;
                      }
                      if (R3 = 65535 & T2, S2 &= 15, p3 < S2 && (h2 += I2[i3++] << p3, p3 += 8, p3 < S2 && (h2 += I2[i3++] << p3, p3 += 8)), R3 += h2 & (1 << S2) - 1, R3 > a2) {
                        e2.msg = "invalid distance too far back", A2.mode = DH;
                        break e;
                      }
                      if (h2 >>>= S2, p3 -= S2, S2 = r2 - o2, R3 > S2) {
                        if (S2 = R3 - S2, S2 > d2 && A2.sane) {
                          e2.msg = "invalid distance too far back", A2.mode = DH;
                          break e;
                        }
                        if (C2 = 0, v2 = u2, 0 === l2) {
                          if (C2 += c2 - S2, S2 < g2) {
                            g2 -= S2;
                            do {
                              y2[r2++] = u2[C2++];
                            } while (--S2);
                            C2 = r2 - R3, v2 = y2;
                          }
                        } else if (l2 < S2) {
                          if (C2 += c2 + l2 - S2, S2 -= l2, S2 < g2) {
                            g2 -= S2;
                            do {
                              y2[r2++] = u2[C2++];
                            } while (--S2);
                            if (C2 = 0, l2 < g2) {
                              S2 = l2, g2 -= S2;
                              do {
                                y2[r2++] = u2[C2++];
                              } while (--S2);
                              C2 = r2 - R3, v2 = y2;
                            }
                          }
                        } else if (C2 += l2 - S2, S2 < g2) {
                          g2 -= S2;
                          do {
                            y2[r2++] = u2[C2++];
                          } while (--S2);
                          C2 = r2 - R3, v2 = y2;
                        }
                        for (; g2 > 2; )
                          y2[r2++] = v2[C2++], y2[r2++] = v2[C2++], y2[r2++] = v2[C2++], g2 -= 3;
                        g2 && (y2[r2++] = v2[C2++], g2 > 1 && (y2[r2++] = v2[C2++]));
                      } else {
                        C2 = r2 - R3;
                        do {
                          y2[r2++] = y2[C2++], y2[r2++] = y2[C2++], y2[r2++] = y2[C2++], g2 -= 3;
                        } while (g2 > 2);
                        g2 && (y2[r2++] = y2[C2++], g2 > 1 && (y2[r2++] = y2[C2++]));
                      }
                      break;
                    }
                }
                break;
              }
          } while (i3 < n2 && r2 < s2);
        g2 = p3 >> 3, i3 -= g2, p3 -= g2 << 3, h2 &= (1 << p3) - 1, e2.next_in = i3, e2.next_out = r2, e2.avail_in = i3 < n2 ? n2 - i3 + 5 : 5 - (i3 - n2), e2.avail_out = r2 < s2 ? s2 - r2 + 257 : 257 - (r2 - s2), A2.hold = h2, A2.bits = p3;
      };
      const LH = 15, kH = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]), MH = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]), UH = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]), xH = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]);
      var VH = (e2, t2, i3, n2, r2, o2, s2, a2) => {
        const c2 = a2.bits;
        let d2, l2, u2, h2, p3, _2, E2 = 0, f2 = 0, m2 = 0, T2 = 0, S2 = 0, g2 = 0, R3 = 0, C2 = 0, v2 = 0, I2 = 0, y2 = null;
        const A2 = new Uint16Array(16), b2 = new Uint16Array(16);
        let w2, O2, N2, D2 = null;
        for (E2 = 0; E2 <= LH; E2++)
          A2[E2] = 0;
        for (f2 = 0; f2 < n2; f2++)
          A2[t2[i3 + f2]]++;
        for (S2 = c2, T2 = LH; T2 >= 1 && 0 === A2[T2]; T2--)
          ;
        if (S2 > T2 && (S2 = T2), 0 === T2)
          return r2[o2++] = 20971520, r2[o2++] = 20971520, a2.bits = 1, 0;
        for (m2 = 1; m2 < T2 && 0 === A2[m2]; m2++)
          ;
        for (S2 < m2 && (S2 = m2), C2 = 1, E2 = 1; E2 <= LH; E2++)
          if (C2 <<= 1, C2 -= A2[E2], C2 < 0)
            return -1;
        if (C2 > 0 && (0 === e2 || 1 !== T2))
          return -1;
        for (b2[1] = 0, E2 = 1; E2 < LH; E2++)
          b2[E2 + 1] = b2[E2] + A2[E2];
        for (f2 = 0; f2 < n2; f2++)
          0 !== t2[i3 + f2] && (s2[b2[t2[i3 + f2]]++] = f2);
        if (0 === e2 ? (y2 = D2 = s2, _2 = 20) : 1 === e2 ? (y2 = kH, D2 = MH, _2 = 257) : (y2 = UH, D2 = xH, _2 = 0), I2 = 0, f2 = 0, E2 = m2, p3 = o2, g2 = S2, R3 = 0, u2 = -1, v2 = 1 << S2, h2 = v2 - 1, 1 === e2 && v2 > 852 || 2 === e2 && v2 > 592)
          return 1;
        for (; ; ) {
          w2 = E2 - R3, s2[f2] + 1 < _2 ? (O2 = 0, N2 = s2[f2]) : s2[f2] >= _2 ? (O2 = D2[s2[f2] - _2], N2 = y2[s2[f2] - _2]) : (O2 = 96, N2 = 0), d2 = 1 << E2 - R3, l2 = 1 << g2, m2 = l2;
          do {
            l2 -= d2, r2[p3 + (I2 >> R3) + l2] = w2 << 24 | O2 << 16 | N2 | 0;
          } while (0 !== l2);
          for (d2 = 1 << E2 - 1; I2 & d2; )
            d2 >>= 1;
          if (0 !== d2 ? (I2 &= d2 - 1, I2 += d2) : I2 = 0, f2++, 0 == --A2[E2]) {
            if (E2 === T2)
              break;
            E2 = t2[i3 + s2[f2]];
          }
          if (E2 > S2 && (I2 & h2) !== u2) {
            for (0 === R3 && (R3 = S2), p3 += m2, g2 = E2 - R3, C2 = 1 << g2; g2 + R3 < T2 && (C2 -= A2[g2 + R3], !(C2 <= 0)); )
              g2++, C2 <<= 1;
            if (v2 += 1 << g2, 1 === e2 && v2 > 852 || 2 === e2 && v2 > 592)
              return 1;
            u2 = I2 & h2, r2[u2] = S2 << 24 | g2 << 16 | p3 - o2 | 0;
          }
        }
        return 0 !== I2 && (r2[p3 + I2] = E2 - R3 << 24 | 64 << 16 | 0), a2.bits = S2, 0;
      };
      const { Z_FINISH: FH, Z_BLOCK: BH, Z_TREES: jH, Z_OK: GH, Z_STREAM_END: WH, Z_NEED_DICT: HH, Z_STREAM_ERROR: KH, Z_DATA_ERROR: YH, Z_MEM_ERROR: qH, Z_BUF_ERROR: zH, Z_DEFLATED: XH } = aW, JH = 16180, QH = 16190, ZH = 16191, $H = 16192, eK = 16194, tK = 16199, iK = 16200, nK = 16206, rK = 16209, oK = (e2) => (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
      function sK() {
        this.strm = null, this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      const aK = (e2) => {
        if (!e2)
          return 1;
        const t2 = e2.state;
        return !t2 || t2.strm !== e2 || t2.mode < JH || t2.mode > 16211 ? 1 : 0;
      }, cK = (e2) => {
        if (aK(e2))
          return KH;
        const t2 = e2.state;
        return e2.total_in = e2.total_out = t2.total = 0, e2.msg = "", t2.wrap && (e2.adler = 1 & t2.wrap), t2.mode = JH, t2.last = 0, t2.havedict = 0, t2.flags = -1, t2.dmax = 32768, t2.head = null, t2.hold = 0, t2.bits = 0, t2.lencode = t2.lendyn = new Int32Array(852), t2.distcode = t2.distdyn = new Int32Array(592), t2.sane = 1, t2.back = -1, GH;
      }, dK = (e2) => {
        if (aK(e2))
          return KH;
        const t2 = e2.state;
        return t2.wsize = 0, t2.whave = 0, t2.wnext = 0, cK(e2);
      }, lK = (e2, t2) => {
        let i3;
        if (aK(e2))
          return KH;
        const n2 = e2.state;
        return t2 < 0 ? (i3 = 0, t2 = -t2) : (i3 = 5 + (t2 >> 4), t2 < 48 && (t2 &= 15)), t2 && (t2 < 8 || t2 > 15) ? KH : (null !== n2.window && n2.wbits !== t2 && (n2.window = null), n2.wrap = i3, n2.wbits = t2, dK(e2));
      }, uK = (e2, t2) => {
        if (!e2)
          return KH;
        const i3 = new sK();
        e2.state = i3, i3.strm = e2, i3.window = null, i3.mode = JH;
        const n2 = lK(e2, t2);
        return n2 !== GH && (e2.state = null), n2;
      };
      let hK, pK, _K = true;
      const EK = (e2) => {
        if (_K) {
          hK = new Int32Array(512), pK = new Int32Array(32);
          let t2 = 0;
          for (; t2 < 144; )
            e2.lens[t2++] = 8;
          for (; t2 < 256; )
            e2.lens[t2++] = 9;
          for (; t2 < 280; )
            e2.lens[t2++] = 7;
          for (; t2 < 288; )
            e2.lens[t2++] = 8;
          for (VH(1, e2.lens, 0, 288, hK, 0, e2.work, { bits: 9 }), t2 = 0; t2 < 32; )
            e2.lens[t2++] = 5;
          VH(2, e2.lens, 0, 32, pK, 0, e2.work, { bits: 5 }), _K = false;
        }
        e2.lencode = hK, e2.lenbits = 9, e2.distcode = pK, e2.distbits = 5;
      }, fK = (e2, t2, i3, n2) => {
        let r2;
        const o2 = e2.state;
        return null === o2.window && (o2.wsize = 1 << o2.wbits, o2.wnext = 0, o2.whave = 0, o2.window = new Uint8Array(o2.wsize)), n2 >= o2.wsize ? (o2.window.set(t2.subarray(i3 - o2.wsize, i3), 0), o2.wnext = 0, o2.whave = o2.wsize) : (r2 = o2.wsize - o2.wnext, r2 > n2 && (r2 = n2), o2.window.set(t2.subarray(i3 - n2, i3 - n2 + r2), o2.wnext), (n2 -= r2) ? (o2.window.set(t2.subarray(i3 - n2, i3), 0), o2.wnext = n2, o2.whave = o2.wsize) : (o2.wnext += r2, o2.wnext === o2.wsize && (o2.wnext = 0), o2.whave < o2.wsize && (o2.whave += r2))), 0;
      };
      var mK = (e2, t2) => {
        let i3, n2, r2, o2, s2, a2, c2, d2, l2, u2, h2, p3, _2, E2, f2, m2, T2, S2, g2, R3, C2, v2, I2 = 0;
        const y2 = new Uint8Array(4);
        let A2, b2;
        const w2 = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
        if (aK(e2) || !e2.output || !e2.input && 0 !== e2.avail_in)
          return KH;
        i3 = e2.state, i3.mode === ZH && (i3.mode = $H), s2 = e2.next_out, r2 = e2.output, c2 = e2.avail_out, o2 = e2.next_in, n2 = e2.input, a2 = e2.avail_in, d2 = i3.hold, l2 = i3.bits, u2 = a2, h2 = c2, v2 = GH;
        e:
          for (; ; )
            switch (i3.mode) {
              case JH:
                if (0 === i3.wrap) {
                  i3.mode = $H;
                  break;
                }
                for (; l2 < 16; ) {
                  if (0 === a2)
                    break e;
                  a2--, d2 += n2[o2++] << l2, l2 += 8;
                }
                if (2 & i3.wrap && 35615 === d2) {
                  0 === i3.wbits && (i3.wbits = 15), i3.check = 0, y2[0] = 255 & d2, y2[1] = d2 >>> 8 & 255, i3.check = oW(i3.check, y2, 2, 0), d2 = 0, l2 = 0, i3.mode = 16181;
                  break;
                }
                if (i3.head && (i3.head.done = false), !(1 & i3.wrap) || (((255 & d2) << 8) + (d2 >> 8)) % 31) {
                  e2.msg = "incorrect header check", i3.mode = rK;
                  break;
                }
                if ((15 & d2) !== XH) {
                  e2.msg = "unknown compression method", i3.mode = rK;
                  break;
                }
                if (d2 >>>= 4, l2 -= 4, C2 = 8 + (15 & d2), 0 === i3.wbits && (i3.wbits = C2), C2 > 15 || C2 > i3.wbits) {
                  e2.msg = "invalid window size", i3.mode = rK;
                  break;
                }
                i3.dmax = 1 << i3.wbits, i3.flags = 0, e2.adler = i3.check = 1, i3.mode = 512 & d2 ? 16189 : ZH, d2 = 0, l2 = 0;
                break;
              case 16181:
                for (; l2 < 16; ) {
                  if (0 === a2)
                    break e;
                  a2--, d2 += n2[o2++] << l2, l2 += 8;
                }
                if (i3.flags = d2, (255 & EG(i3)) !== XH) {
                  e2.msg = "unknown compression method", i3.mode = rK;
                  break;
                }
                if (57344 & EG(i3)) {
                  e2.msg = "unknown header flags set", i3.mode = rK;
                  break;
                }
                i3.head && (i3.head.text = d2 >> 8 & 1), 512 & EG(i3) && 4 & i3.wrap && (y2[0] = 255 & d2, y2[1] = d2 >>> 8 & 255, i3.check = oW(i3.check, y2, 2, 0)), d2 = 0, l2 = 0, i3.mode = 16182;
              case 16182:
                for (; l2 < 32; ) {
                  if (0 === a2)
                    break e;
                  a2--, d2 += n2[o2++] << l2, l2 += 8;
                }
                i3.head && (i3.head.time = d2), 512 & EG(i3) && 4 & i3.wrap && (y2[0] = 255 & d2, y2[1] = d2 >>> 8 & 255, y2[2] = d2 >>> 16 & 255, y2[3] = d2 >>> 24 & 255, i3.check = oW(i3.check, y2, 4, 0)), d2 = 0, l2 = 0, i3.mode = 16183;
              case 16183:
                for (; l2 < 16; ) {
                  if (0 === a2)
                    break e;
                  a2--, d2 += n2[o2++] << l2, l2 += 8;
                }
                i3.head && (i3.head.xflags = 255 & d2, i3.head.os = d2 >> 8), 512 & EG(i3) && 4 & i3.wrap && (y2[0] = 255 & d2, y2[1] = d2 >>> 8 & 255, i3.check = oW(i3.check, y2, 2, 0)), d2 = 0, l2 = 0, i3.mode = 16184;
              case 16184:
                if (1024 & EG(i3)) {
                  for (; l2 < 16; ) {
                    if (0 === a2)
                      break e;
                    a2--, d2 += n2[o2++] << l2, l2 += 8;
                  }
                  i3.length = d2, i3.head && (i3.head.extra_len = d2), 512 & EG(i3) && 4 & i3.wrap && (y2[0] = 255 & d2, y2[1] = d2 >>> 8 & 255, i3.check = oW(i3.check, y2, 2, 0)), d2 = 0, l2 = 0;
                } else
                  i3.head && (i3.head.extra = null);
                i3.mode = 16185;
              case 16185:
                if (1024 & EG(i3) && (p3 = i3.length, p3 > a2 && (p3 = a2), p3 && (i3.head && (C2 = i3.head.extra_len - i3.length, i3.head.extra || (i3.head.extra = new Uint8Array(i3.head.extra_len)), i3.head.extra.set(n2.subarray(o2, o2 + p3), C2)), 512 & EG(i3) && 4 & i3.wrap && (i3.check = oW(i3.check, n2, p3, o2)), a2 -= p3, o2 += p3, i3.length -= p3), i3.length))
                  break e;
                i3.length = 0, i3.mode = 16186;
              case 16186:
                if (2048 & EG(i3)) {
                  if (0 === a2)
                    break e;
                  p3 = 0;
                  do {
                    C2 = n2[o2 + p3++], i3.head && C2 && i3.length < 65536 && (i3.head.name += String.fromCharCode(C2));
                  } while (C2 && p3 < a2);
                  if (512 & EG(i3) && 4 & i3.wrap && (i3.check = oW(i3.check, n2, p3, o2)), a2 -= p3, o2 += p3, C2)
                    break e;
                } else
                  i3.head && (i3.head.name = null);
                i3.length = 0, i3.mode = 16187;
              case 16187:
                if (4096 & EG(i3)) {
                  if (0 === a2)
                    break e;
                  p3 = 0;
                  do {
                    C2 = n2[o2 + p3++], i3.head && C2 && i3.length < 65536 && (i3.head.comment += String.fromCharCode(C2));
                  } while (C2 && p3 < a2);
                  if (512 & EG(i3) && 4 & i3.wrap && (i3.check = oW(i3.check, n2, p3, o2)), a2 -= p3, o2 += p3, C2)
                    break e;
                } else
                  i3.head && (i3.head.comment = null);
                i3.mode = 16188;
              case 16188:
                if (512 & EG(i3)) {
                  for (; l2 < 16; ) {
                    if (0 === a2)
                      break e;
                    a2--, d2 += n2[o2++] << l2, l2 += 8;
                  }
                  if (4 & i3.wrap && d2 !== (65535 & i3.check)) {
                    e2.msg = "header crc mismatch", i3.mode = rK;
                    break;
                  }
                  d2 = 0, l2 = 0;
                }
                i3.head && (i3.head.hcrc = EG(i3) >> 9 & 1, i3.head.done = true), e2.adler = i3.check = 0, i3.mode = ZH;
                break;
              case 16189:
                for (; l2 < 32; ) {
                  if (0 === a2)
                    break e;
                  a2--, d2 += n2[o2++] << l2, l2 += 8;
                }
                e2.adler = i3.check = oK(d2), d2 = 0, l2 = 0, i3.mode = QH;
              case QH:
                if (0 === i3.havedict)
                  return e2.next_out = s2, e2.avail_out = c2, e2.next_in = o2, e2.avail_in = a2, i3.hold = d2, i3.bits = l2, HH;
                e2.adler = i3.check = 1, i3.mode = ZH;
              case ZH:
                if (t2 === BH || t2 === jH)
                  break e;
              case $H:
                if (i3.last) {
                  d2 >>>= 7 & l2, l2 -= 7 & l2, i3.mode = nK;
                  break;
                }
                for (; l2 < 3; ) {
                  if (0 === a2)
                    break e;
                  a2--, d2 += n2[o2++] << l2, l2 += 8;
                }
                switch (i3.last = 1 & d2, d2 >>>= 1, l2 -= 1, 3 & d2) {
                  case 0:
                    i3.mode = 16193;
                    break;
                  case 1:
                    if (EK(i3), i3.mode = tK, t2 === jH) {
                      d2 >>>= 2, l2 -= 2;
                      break e;
                    }
                    break;
                  case 2:
                    i3.mode = 16196;
                    break;
                  case 3:
                    e2.msg = "invalid block type", i3.mode = rK;
                }
                d2 >>>= 2, l2 -= 2;
                break;
              case 16193:
                for (d2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
                  if (0 === a2)
                    break e;
                  a2--, d2 += n2[o2++] << l2, l2 += 8;
                }
                if ((65535 & d2) != (d2 >>> 16 ^ 65535)) {
                  e2.msg = "invalid stored block lengths", i3.mode = rK;
                  break;
                }
                if (i3.length = 65535 & d2, d2 = 0, l2 = 0, i3.mode = eK, t2 === jH)
                  break e;
              case eK:
                i3.mode = 16195;
              case 16195:
                if (p3 = i3.length, p3) {
                  if (p3 > a2 && (p3 = a2), p3 > c2 && (p3 = c2), 0 === p3)
                    break e;
                  r2.set(n2.subarray(o2, o2 + p3), s2), a2 -= p3, o2 += p3, c2 -= p3, s2 += p3, i3.length -= p3;
                  break;
                }
                i3.mode = ZH;
                break;
              case 16196:
                for (; l2 < 14; ) {
                  if (0 === a2)
                    break e;
                  a2--, d2 += n2[o2++] << l2, l2 += 8;
                }
                if (i3.nlen = 257 + (31 & d2), d2 >>>= 5, l2 -= 5, i3.ndist = 1 + (31 & d2), d2 >>>= 5, l2 -= 5, i3.ncode = 4 + (15 & d2), d2 >>>= 4, l2 -= 4, i3.nlen > 286 || i3.ndist > 30) {
                  e2.msg = "too many length or distance symbols", i3.mode = rK;
                  break;
                }
                i3.have = 0, i3.mode = 16197;
              case 16197:
                for (; i3.have < i3.ncode; ) {
                  for (; l2 < 3; ) {
                    if (0 === a2)
                      break e;
                    a2--, d2 += n2[o2++] << l2, l2 += 8;
                  }
                  i3.lens[w2[i3.have++]] = 7 & d2, d2 >>>= 3, l2 -= 3;
                }
                for (; i3.have < 19; )
                  i3.lens[w2[i3.have++]] = 0;
                if (i3.lencode = i3.lendyn, i3.lenbits = 7, A2 = { bits: i3.lenbits }, v2 = VH(0, i3.lens, 0, 19, i3.lencode, 0, i3.work, A2), i3.lenbits = A2.bits, v2) {
                  e2.msg = "invalid code lengths set", i3.mode = rK;
                  break;
                }
                i3.have = 0, i3.mode = 16198;
              case 16198:
                for (; i3.have < i3.nlen + i3.ndist; ) {
                  for (; I2 = i3.lencode[d2 & (1 << i3.lenbits) - 1], f2 = I2 >>> 24, m2 = I2 >>> 16 & 255, T2 = 65535 & I2, !(f2 <= l2); ) {
                    if (0 === a2)
                      break e;
                    a2--, d2 += n2[o2++] << l2, l2 += 8;
                  }
                  if (T2 < 16)
                    d2 >>>= f2, l2 -= f2, i3.lens[i3.have++] = T2;
                  else {
                    if (16 === T2) {
                      for (b2 = f2 + 2; l2 < b2; ) {
                        if (0 === a2)
                          break e;
                        a2--, d2 += n2[o2++] << l2, l2 += 8;
                      }
                      if (d2 >>>= f2, l2 -= f2, 0 === i3.have) {
                        e2.msg = "invalid bit length repeat", i3.mode = rK;
                        break;
                      }
                      C2 = i3.lens[i3.have - 1], p3 = 3 + (3 & d2), d2 >>>= 2, l2 -= 2;
                    } else if (17 === T2) {
                      for (b2 = f2 + 3; l2 < b2; ) {
                        if (0 === a2)
                          break e;
                        a2--, d2 += n2[o2++] << l2, l2 += 8;
                      }
                      d2 >>>= f2, l2 -= f2, C2 = 0, p3 = 3 + (7 & d2), d2 >>>= 3, l2 -= 3;
                    } else {
                      for (b2 = f2 + 7; l2 < b2; ) {
                        if (0 === a2)
                          break e;
                        a2--, d2 += n2[o2++] << l2, l2 += 8;
                      }
                      d2 >>>= f2, l2 -= f2, C2 = 0, p3 = 11 + (127 & d2), d2 >>>= 7, l2 -= 7;
                    }
                    if (i3.have + p3 > i3.nlen + i3.ndist) {
                      e2.msg = "invalid bit length repeat", i3.mode = rK;
                      break;
                    }
                    for (; p3--; )
                      i3.lens[i3.have++] = C2;
                  }
                }
                if (i3.mode === rK)
                  break;
                if (0 === i3.lens[256]) {
                  e2.msg = "invalid code -- missing end-of-block", i3.mode = rK;
                  break;
                }
                if (i3.lenbits = 9, A2 = { bits: i3.lenbits }, v2 = VH(1, i3.lens, 0, i3.nlen, i3.lencode, 0, i3.work, A2), i3.lenbits = A2.bits, v2) {
                  e2.msg = "invalid literal/lengths set", i3.mode = rK;
                  break;
                }
                if (i3.distbits = 6, i3.distcode = i3.distdyn, A2 = { bits: i3.distbits }, v2 = VH(2, i3.lens, i3.nlen, i3.ndist, i3.distcode, 0, i3.work, A2), i3.distbits = A2.bits, v2) {
                  e2.msg = "invalid distances set", i3.mode = rK;
                  break;
                }
                if (i3.mode = tK, t2 === jH)
                  break e;
              case tK:
                i3.mode = iK;
              case iK:
                if (a2 >= 6 && c2 >= 258) {
                  e2.next_out = s2, e2.avail_out = c2, e2.next_in = o2, e2.avail_in = a2, i3.hold = d2, i3.bits = l2, PH(e2, h2), s2 = e2.next_out, r2 = e2.output, c2 = e2.avail_out, o2 = e2.next_in, n2 = e2.input, a2 = e2.avail_in, d2 = i3.hold, l2 = i3.bits, i3.mode === ZH && (i3.back = -1);
                  break;
                }
                for (i3.back = 0; I2 = i3.lencode[d2 & (1 << i3.lenbits) - 1], f2 = I2 >>> 24, m2 = I2 >>> 16 & 255, T2 = 65535 & I2, !(f2 <= l2); ) {
                  if (0 === a2)
                    break e;
                  a2--, d2 += n2[o2++] << l2, l2 += 8;
                }
                if (m2 && 0 == (240 & m2)) {
                  for (S2 = f2, g2 = m2, R3 = T2; I2 = i3.lencode[R3 + ((d2 & (1 << S2 + g2) - 1) >> S2)], f2 = I2 >>> 24, m2 = I2 >>> 16 & 255, T2 = 65535 & I2, !(S2 + f2 <= l2); ) {
                    if (0 === a2)
                      break e;
                    a2--, d2 += n2[o2++] << l2, l2 += 8;
                  }
                  d2 >>>= S2, l2 -= S2, i3.back += S2;
                }
                if (d2 >>>= f2, l2 -= f2, i3.back += f2, i3.length = T2, 0 === m2) {
                  i3.mode = 16205;
                  break;
                }
                if (32 & m2) {
                  i3.back = -1, i3.mode = ZH;
                  break;
                }
                if (64 & m2) {
                  e2.msg = "invalid literal/length code", i3.mode = rK;
                  break;
                }
                i3.extra = 15 & m2, i3.mode = 16201;
              case 16201:
                if (i3.extra) {
                  for (b2 = i3.extra; l2 < b2; ) {
                    if (0 === a2)
                      break e;
                    a2--, d2 += n2[o2++] << l2, l2 += 8;
                  }
                  i3.length += d2 & (1 << i3.extra) - 1, d2 >>>= i3.extra, l2 -= i3.extra, i3.back += i3.extra;
                }
                i3.was = i3.length, i3.mode = 16202;
              case 16202:
                for (; I2 = i3.distcode[d2 & (1 << i3.distbits) - 1], f2 = I2 >>> 24, m2 = I2 >>> 16 & 255, T2 = 65535 & I2, !(f2 <= l2); ) {
                  if (0 === a2)
                    break e;
                  a2--, d2 += n2[o2++] << l2, l2 += 8;
                }
                if (0 == (240 & m2)) {
                  for (S2 = f2, g2 = m2, R3 = T2; I2 = i3.distcode[R3 + ((d2 & (1 << S2 + g2) - 1) >> S2)], f2 = I2 >>> 24, m2 = I2 >>> 16 & 255, T2 = 65535 & I2, !(S2 + f2 <= l2); ) {
                    if (0 === a2)
                      break e;
                    a2--, d2 += n2[o2++] << l2, l2 += 8;
                  }
                  d2 >>>= S2, l2 -= S2, i3.back += S2;
                }
                if (d2 >>>= f2, l2 -= f2, i3.back += f2, 64 & m2) {
                  e2.msg = "invalid distance code", i3.mode = rK;
                  break;
                }
                i3.offset = T2, i3.extra = 15 & m2, i3.mode = 16203;
              case 16203:
                if (i3.extra) {
                  for (b2 = i3.extra; l2 < b2; ) {
                    if (0 === a2)
                      break e;
                    a2--, d2 += n2[o2++] << l2, l2 += 8;
                  }
                  i3.offset += d2 & (1 << i3.extra) - 1, d2 >>>= i3.extra, l2 -= i3.extra, i3.back += i3.extra;
                }
                if (i3.offset > i3.dmax) {
                  e2.msg = "invalid distance too far back", i3.mode = rK;
                  break;
                }
                i3.mode = 16204;
              case 16204:
                if (0 === c2)
                  break e;
                if (p3 = h2 - c2, i3.offset > p3) {
                  if (p3 = i3.offset - p3, p3 > i3.whave && i3.sane) {
                    e2.msg = "invalid distance too far back", i3.mode = rK;
                    break;
                  }
                  p3 > i3.wnext ? (p3 -= i3.wnext, _2 = i3.wsize - p3) : _2 = i3.wnext - p3, p3 > i3.length && (p3 = i3.length), E2 = i3.window;
                } else
                  E2 = r2, _2 = s2 - i3.offset, p3 = i3.length;
                p3 > c2 && (p3 = c2), c2 -= p3, i3.length -= p3;
                do {
                  r2[s2++] = E2[_2++];
                } while (--p3);
                0 === i3.length && (i3.mode = iK);
                break;
              case 16205:
                if (0 === c2)
                  break e;
                r2[s2++] = i3.length, c2--, i3.mode = iK;
                break;
              case nK:
                if (i3.wrap) {
                  for (; l2 < 32; ) {
                    if (0 === a2)
                      break e;
                    a2--, d2 |= n2[o2++] << l2, l2 += 8;
                  }
                  if (h2 -= c2, e2.total_out += h2, i3.total += h2, 4 & i3.wrap && h2 && (e2.adler = i3.check = EG(i3) ? oW(i3.check, r2, h2, s2 - h2) : nW(i3.check, r2, h2, s2 - h2)), h2 = c2, 4 & i3.wrap && (EG(i3) ? d2 : oK(d2)) !== i3.check) {
                    e2.msg = "incorrect data check", i3.mode = rK;
                    break;
                  }
                  d2 = 0, l2 = 0;
                }
                i3.mode = 16207;
              case 16207:
                if (i3.wrap && EG(i3)) {
                  for (; l2 < 32; ) {
                    if (0 === a2)
                      break e;
                    a2--, d2 += n2[o2++] << l2, l2 += 8;
                  }
                  if (4 & i3.wrap && d2 !== (4294967295 & i3.total)) {
                    e2.msg = "incorrect length check", i3.mode = rK;
                    break;
                  }
                  d2 = 0, l2 = 0;
                }
                i3.mode = 16208;
              case 16208:
                v2 = WH;
                break e;
              case rK:
                v2 = YH;
                break e;
              case 16210:
                return qH;
              default:
                return KH;
            }
        return e2.next_out = s2, e2.avail_out = c2, e2.next_in = o2, e2.avail_in = a2, i3.hold = d2, i3.bits = l2, (i3.wsize || h2 !== e2.avail_out && i3.mode < rK && (i3.mode < nK || t2 !== FH)) && fK(e2, e2.output, e2.next_out, h2 - e2.avail_out), u2 -= e2.avail_in, h2 -= e2.avail_out, e2.total_in += u2, e2.total_out += h2, i3.total += h2, 4 & i3.wrap && h2 && (e2.adler = i3.check = EG(i3) ? oW(i3.check, r2, h2, e2.next_out - h2) : nW(i3.check, r2, h2, e2.next_out - h2)), e2.data_type = i3.bits + (i3.last ? 64 : 0) + (i3.mode === ZH ? 128 : 0) + (i3.mode === tK || i3.mode === eK ? 256 : 0), (0 === u2 && 0 === h2 || t2 === FH) && v2 === GH && (v2 = zH), v2;
      }, TK = { inflateReset: dK, inflateReset2: lK, inflateResetKeep: cK, inflateInit: (e2) => uK(e2, 15), inflateInit2: uK, inflate: mK, inflateEnd: (e2) => {
        if (aK(e2))
          return KH;
        let t2 = e2.state;
        return t2.window && (t2.window = null), e2.state = null, GH;
      }, inflateGetHeader: (e2, t2) => {
        if (aK(e2))
          return KH;
        const i3 = e2.state;
        return 0 == (2 & i3.wrap) ? KH : (i3.head = t2, t2.done = false, GH);
      }, inflateSetDictionary: (e2, t2) => {
        const i3 = t2.length;
        let n2, r2, o2;
        return aK(e2) ? KH : (n2 = e2.state, 0 !== n2.wrap && n2.mode !== QH ? KH : n2.mode === QH && (r2 = 1, r2 = nW(r2, t2, i3, 0), r2 !== n2.check) ? YH : (o2 = fK(e2, t2, i3, i3), o2 ? (n2.mode = 16210, qH) : (n2.havedict = 1, GH)));
      }, inflateInfo: "pako inflate (from Nodeca project)" };
      var SK = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
      };
      const gK = Object.prototype.toString, { Z_NO_FLUSH: RK, Z_FINISH: CK, Z_OK: vK, Z_STREAM_END: IK, Z_NEED_DICT: yK, Z_STREAM_ERROR: AK, Z_DATA_ERROR: bK, Z_MEM_ERROR: wK } = aW;
      function OK(e2) {
        this.options = pH.assign({ chunkSize: 65536, windowBits: 15, to: "" }, e2 || {});
        const t2 = this.options;
        t2.raw && t2.windowBits >= 0 && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, 0 === t2.windowBits && (t2.windowBits = -15)), !(t2.windowBits >= 0 && t2.windowBits < 16) || e2 && e2.windowBits || (t2.windowBits += 32), t2.windowBits > 15 && t2.windowBits < 48 && 0 == (15 & t2.windowBits) && (t2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new mH(), this.strm.avail_out = 0;
        let i3 = TK.inflateInit2(this.strm, t2.windowBits);
        if (i3 !== vK)
          throw new Error(sW[i3]);
        if (this.header = new SK(), TK.inflateGetHeader(this.strm, this.header), t2.dictionary && ("string" == typeof t2.dictionary ? t2.dictionary = fH.string2buf(t2.dictionary) : "[object ArrayBuffer]" === gK.call(t2.dictionary) && (t2.dictionary = new Uint8Array(t2.dictionary)), t2.raw && (i3 = TK.inflateSetDictionary(this.strm, t2.dictionary), i3 !== vK)))
          throw new Error(sW[i3]);
      }
      function NK(e2, t2) {
        const i3 = new OK(t2);
        if (i3.push(e2), i3.err)
          throw i3.msg || sW[i3.err];
        return i3.result;
      }
      OK.prototype.push = function(e2, t2) {
        const i3 = this.strm, n2 = this.options.chunkSize, r2 = this.options.dictionary;
        let o2, s2, a2;
        if (this.ended)
          return false;
        for (s2 = t2 === ~~t2 ? t2 : true === t2 ? CK : RK, "[object ArrayBuffer]" === gK.call(e2) ? i3.input = new Uint8Array(e2) : i3.input = e2, i3.next_in = 0, i3.avail_in = i3.input.length; ; ) {
          for (0 === i3.avail_out && (i3.output = new Uint8Array(n2), i3.next_out = 0, i3.avail_out = n2), o2 = TK.inflate(i3, s2), o2 === yK && r2 && (o2 = TK.inflateSetDictionary(i3, r2), o2 === vK ? o2 = TK.inflate(i3, s2) : o2 === bK && (o2 = yK)); i3.avail_in > 0 && o2 === IK && i3.state.wrap > 0 && 0 !== e2[i3.next_in]; )
            TK.inflateReset(i3), o2 = TK.inflate(i3, s2);
          switch (o2) {
            case AK:
            case bK:
            case yK:
            case wK:
              return this.onEnd(o2), this.ended = true, false;
          }
          if (a2 = i3.avail_out, i3.next_out && (0 === i3.avail_out || o2 === IK))
            if ("string" === this.options.to) {
              let e3 = fH.utf8border(i3.output, i3.next_out), t3 = i3.next_out - e3, r3 = fH.buf2string(i3.output, e3);
              i3.next_out = t3, i3.avail_out = n2 - t3, t3 && i3.output.set(i3.output.subarray(e3, e3 + t3), 0), this.onData(r3);
            } else
              this.onData(i3.output.length === i3.next_out ? i3.output : i3.output.subarray(0, i3.next_out));
          if (o2 !== vK || 0 !== a2) {
            if (o2 === IK)
              return o2 = TK.inflateEnd(this.strm), this.onEnd(o2), this.ended = true, true;
            if (0 === i3.avail_in)
              break;
          }
        }
        return true;
      }, OK.prototype.onData = function(e2) {
        this.chunks.push(e2);
      }, OK.prototype.onEnd = function(e2) {
        e2 === vK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = pH.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
      };
      var DK = { Inflate: OK, inflate: NK, inflateRaw: function(e2, t2) {
        return (t2 = t2 || {}).raw = true, NK(e2, t2);
      }, ungzip: NK, constants: aW };
      const { Deflate: PK, deflate: LK, deflateRaw: kK, gzip: MK } = NH, { Inflate: UK, inflate: xK, inflateRaw: VK, ungzip: FK } = DK;
      var BK = LK, jK = xK, GK = function(e2) {
        return e2[e2.ONE_BYTE = 0] = "ONE_BYTE", e2[e2.TWO_BYTE = 1] = "TWO_BYTE", e2;
      }(GK || {});
      class WK {
        constructor() {
          QI(this, "_sequence", 0), QI(this, "_startTime", Date.now()), QI(this, "isUseOneByte", true);
        }
        get startTime() {
          const e2 = Date.now() - this._startTime;
          return e2 < Math.pow(2, 16) ? e2 : (this._startTime += Math.pow(2, 16), this.startTime);
        }
        get sequence() {
          return this._sequence < Math.pow(2, 32) ? this._sequence++ : (this._sequence -= Math.pow(2, 32), this.sequence);
        }
        serialize(e2) {
          const t2 = { commonPacketHeader: { length: 0, reserved: 0, extension: 0, sequence: this.sequence }, commonStreamHeader: this.startTime, extension: void 0, payload: e2 };
          if (e2.byteLength > 128) {
            const i4 = new Uint8Array(4);
            i4.set([1, 0, 0, 0]);
            const n3 = { id: 0, length: 4, data: i4.buffer }, r3 = { profile: this.isUseOneByte ? 0 : 1, length: this.isUseOneByte ? 5 : 6, datas: [n3] };
            t2.commonPacketHeader.extension = 1, t2.extension = r3, t2.payload = this.compress(e2), t2.commonPacketHeader.length = 8 + (t2.extension.length + 2) + t2.payload.byteLength;
          } else
            t2.commonPacketHeader.length = 8 + t2.payload.byteLength;
          dN("SHOW_DATASTREAM2_LOG") && BN.debug("send data header: ".concat(JSON.stringify(t2.commonPacketHeader)));
          const i3 = new ArrayBuffer(t2.commonPacketHeader.length), n2 = new Uint8Array(i3), r2 = new DataView(i3);
          let o2 = 0;
          if (r2.setUint16(o2, t2.commonPacketHeader.extension << 15 | t2.commonPacketHeader.reserved << 14 | t2.commonPacketHeader.length, true), o2 += 2, r2.setUint32(o2, t2.commonPacketHeader.sequence, true), o2 += 4, r2.setUint16(o2, t2.commonStreamHeader, true), o2 += 2, t2.extension) {
            const e3 = this.serializeExtension(t2.extension);
            n2.set(new Uint8Array(e3), o2), o2 += e3.byteLength;
          }
          if (n2.set(new Uint8Array(t2.payload), o2), o2 += t2.payload.byteLength, o2 !== t2.commonPacketHeader.length)
            throw Error("serialize error!");
          return i3;
        }
        deserialize(e2) {
          if (e2.byteLength < 4)
            return new ArrayBuffer(0);
          const t2 = new DataView(e2);
          let i3 = 0;
          const n2 = t2.getUint16(i3, true);
          i3 += 2;
          const r2 = { length: 16383 & n2, reserved: (16384 & n2) >> 14, extension: (32768 & n2) >> 15, sequence: t2.getUint16(i3 + 2, true) << 16 | t2.getUint16(i3, true) };
          let o2, s2;
          if (i3 += 4, dN("SHOW_DATASTREAM2_LOG") && BN.debug("receive data header: ".concat(JSON.stringify(r2))), t2.getUint16(i3, true), i3 += 2, r2.extension) {
            s2 = this.deserializeExtension(e2.slice(i3)), i3 += 2 + s2.length, o2 = e2.slice(i3);
            let t3 = false;
            if (s2.datas.length > 0) {
              const e3 = s2.datas.find((e4) => 0 === e4.id);
              if (e3) {
                t3 = 1 == (1 & new DataView(e3.data).getUint32(0, true));
              }
            }
            o2 = t3 ? this.decompress(o2) : o2;
          } else
            o2 = e2.slice(8);
          return o2;
        }
        serializeExtension(e2) {
          const { profile: t2, length: i3, datas: n2 } = e2, r2 = new ArrayBuffer(i3 + 2), o2 = new Uint8Array(r2), s2 = new DataView(r2);
          let a2 = 0;
          if (s2.setUint8(a2++, t2), s2.setUint8(a2++, i3), n2.forEach((e3) => {
            t2 ? (s2.setUint8(a2++, e3.id), s2.setUint8(a2++, e3.length), o2.set(new Uint8Array(e3.data), a2), a2 += e3.data.byteLength) : (s2.setUint8(a2++, e3.id | e3.length << 4), o2.set(new Uint8Array(e3.data), a2), a2 += e3.data.byteLength);
          }), a2 !== i3 + 2)
            throw Error("serialize extension error, is ".concat(a2, "!==").concat(i3 + 2));
          return r2;
        }
        deserializeExtension(e2) {
          const t2 = new DataView(e2);
          let i3 = 0;
          const n2 = t2.getUint8(i3);
          i3++;
          const r2 = t2.getUint8(i3);
          i3++;
          const o2 = n2 === GK.TWO_BYTE, s2 = [], a2 = new DataView(e2, 2);
          let c2 = 0;
          for (; c2 < r2; ) {
            let e3 = 0, t3 = 0, i4 = new ArrayBuffer(0);
            o2 ? (e3 = a2.getUint8(c2), c2++, t3 = a2.getUint8(c2), c2++) : (e3 = 15 & a2.getUint8(c2), t3 = a2.getUint8(c2) >> 4, c2++), t3 > 0 && (i4 = a2.buffer.slice(c2 + 2, c2 + 2 + t3), c2 += i4.byteLength), s2.push({ id: e3, length: t3, data: i4 });
          }
          if (c2 !== r2)
            throw Error("parse error");
          return { profile: n2, length: r2, datas: s2 };
        }
        decompress(e2) {
          return jK(new Uint8Array(e2));
        }
        compress(e2) {
          return BK(new Uint8Array(e2));
        }
      }
      const HK = { name: "DataStream", create: (e2, t2) => {
        const i3 = t2 ? new bk(e2) : new wk(e2);
        return i3.useDataStream(new WK()), i3;
      } };
      class KK extends Nw {
        constructor(e2, t2, i3) {
          super(), QI(this, "ws", void 0), QI(this, "requestId", 1), QI(this, "heartBeatTimer", void 0), QI(this, "joinInfo", void 0), QI(this, "clientId", void 0), QI(this, "onOpen", () => {
            this.emit("open"), this.startHeartBeatCheck();
          }), QI(this, "onClose", (e3) => {
            this.emit("close"), this.dispose();
          }), QI(this, "onMessage", (e3) => {
            const t3 = JSON.parse(e3.data);
            if (!t3 || "serverResponse" !== t3.command || !t3.requestId)
              return t3 && "serverStatus" === t3.command && t3.serverStatus && t3.serverStatus.command ? (this.emit("status", t3.serverStatus), void this.emit(t3.serverStatus.command, t3.serverStatus)) : void 0;
            this.emit("req_".concat(t3.requestId), t3);
          }), this.joinInfo = e2, this.clientId = t2, this.ws = new KU("cross-channel-".concat(this.clientId), i3), this.ws.on(UM.RECONNECTING, () => {
            this.ws.reconnectMode = "retry", this.emit("reconnecting");
          }), this.ws.on(UM.CONNECTED, this.onOpen), this.ws.on(UM.ON_MESSAGE, this.onMessage), this.ws.on(UM.CLOSED, this.onClose);
        }
        isConnect() {
          return "connected" === this.ws.state;
        }
        sendMessage(e2) {
          const t2 = this.requestId++;
          return e2.requestId = t2, e2.seq = t2, this.ws.sendMessage(e2), t2;
        }
        waitStatus(e2) {
          return new Wh((t2, i3) => {
            const n2 = window.setTimeout(() => {
              i3(new XN(_w.TIMEOUT, "wait status timeout, status: ".concat(e2)));
            }, 5e3);
            this.once(e2, (r2) => {
              window.clearTimeout(n2), r2.state && 0 !== r2.state ? i3(new XN(_w.CROSS_CHANNEL_WAIT_STATUS_ERROR, "wait status error, status: ".concat(e2))) : t2(void 0);
            }), this.once("dispose", () => {
              window.clearTimeout(n2), i3(new XN(_w.WS_ABORT));
            });
          });
        }
        async request(e2) {
          if ("closed" === this.ws.state)
            throw new XN(_w.WS_DISCONNECT);
          const t2 = () => new Wh((e3, t3) => {
            this.ws.once(UM.CLOSED, () => t3(new XN(_w.WS_ABORT))), this.ws.once(UM.CONNECTED, e3);
          });
          "connected" !== this.ws.state && await t2();
          const i3 = this.sendMessage(e2), n2 = new Wh((e3, t3) => {
            const n3 = () => {
              t3(new XN(_w.WS_ABORT));
            };
            this.ws.once(UM.RECONNECTING, n3), this.ws.once(UM.CLOSED, n3), this.once("req_".concat(i3), e3), lO(3e3).then(() => {
              this.removeAllListeners("req_".concat(i3)), this.ws.off(UM.RECONNECTING, n3), this.ws.off(UM.CLOSED, n3), t3(new XN(_w.TIMEOUT, "cross channel ws request timeout"));
            });
          }), r2 = await n2;
          if (!r2 || 200 !== r2.code)
            throw new XN(_w.CROSS_CHANNEL_SERVER_ERROR_RESPONSE, "response: ".concat(JSON.stringify(r2)));
          return r2;
        }
        async connect(e2) {
          this.ws.removeAllListeners(UM.REQUEST_NEW_URLS), this.ws.on(UM.REQUEST_NEW_URLS, (t2) => {
            t2(e2);
          }), await this.ws.init(e2);
        }
        dispose() {
          this.clearHeartBeatCheck(), this.emit("dispose"), this.removeAllListeners(), this.ws.close();
        }
        sendPing(e2) {
          const t2 = this.requestId++;
          return e2.requestId = t2, this.ws.sendMessage(e2), t2;
        }
        startHeartBeatCheck() {
          this.heartBeatTimer && window.clearInterval(this.heartBeatTimer), this.heartBeatTimer = window.setInterval(() => {
            this.sendPing({ command: "ping", appId: this.joinInfo.appId, cname: this.joinInfo.cname, uid: this.joinInfo.uid.toString(), sid: this.joinInfo.sid, ts: +/* @__PURE__ */ new Date(), requestId: 0 });
          }, 3e3);
        }
        clearHeartBeatCheck() {
          window.clearInterval(this.heartBeatTimer), this.heartBeatTimer = void 0;
        }
      }
      class YK extends Nw {
        set state(e2) {
          e2 !== this._state && (e2 !== JM.RELAY_STATE_FAILURE && (this.errorCode = QM.RELAY_OK), this.emit("state", e2, this.errorCode), this._state = e2);
        }
        get state() {
          return this._state;
        }
        constructor(e2, t2, i3, n2, r2) {
          super(), QI(this, "joinInfo", void 0), QI(this, "sid", void 0), QI(this, "clientId", void 0), QI(this, "cancelToken", Ab.CancelToken.source()), QI(this, "workerToken", void 0), QI(this, "requestId", 0), QI(this, "signal", void 0), QI(this, "prevChannelMediaConfig", void 0), QI(this, "httpRetryConfig", void 0), QI(this, "_resolution", void 0), QI(this, "_state", JM.RELAY_STATE_IDLE), QI(this, "errorCode", QM.RELAY_OK), QI(this, "onStatus", (e3) => {
            BN.debug("[".concat(this.clientId, "] ChannelMediaStatus: ").concat(JSON.stringify(e3))), e3 && e3.command && ("onAudioPacketReceived" === e3.command && this.emit("event", XM.PACKET_RECEIVED_AUDIO_FROM_SRC), "onVideoPacketReceived" === e3.command && this.emit("event", XM.PACKET_RECEIVED_VIDEO_FROM_SRC), "onSrcTokenPrivilegeDidExpire" === e3.command && (this.errorCode = QM.SRC_TOKEN_EXPIRED, this.state = JM.RELAY_STATE_FAILURE), "onDestTokenPrivilegeDidExpire" === e3.command && (this.errorCode = QM.DEST_TOKEN_EXPIRED, this.state = JM.RELAY_STATE_FAILURE));
          }), QI(this, "onReconnect", async () => {
            BN.debug("[".concat(this.clientId, "] ChannelMediaSocket disconnect, reconnecting")), this.emit("event", XM.NETWORK_DISCONNECTED), this.state = JM.RELAY_STATE_IDLE, this.prevChannelMediaConfig && this.sendStartRelayMessage(this.prevChannelMediaConfig).catch((e3) => {
              this.state !== JM.RELAY_STATE_IDLE && (BN.error("auto restart channel media relay failed", e3.toString()), this.errorCode = QM.SERVER_CONNECTION_LOST, this.state = JM.RELAY_STATE_FAILURE);
            });
          }), this.joinInfo = e2, this.clientId = t2, this.sid = hO(), this.signal = new KK(this.joinInfo, this.clientId, i3), this.httpRetryConfig = n2, this._resolution = r2;
        }
        async startChannelMediaRelay(e2) {
          if (this.state !== JM.RELAY_STATE_IDLE)
            throw new XN(_w.INVALID_OPERATION);
          this.state = JM.RELAY_STATE_CONNECTING, await this.connect(), BN.debug("[".concat(this.clientId, "] startChannelMediaRelay: connect success"));
          try {
            await this.sendStartRelayMessage(e2);
          } catch (e3) {
            if (e3.data && e3.data.serverResponse && "SetSourceChannel" === e3.data.serverResponse.command)
              throw new XN(_w.CROSS_CHANNEL_FAILED_JOIN_SRC);
            if (e3.data && e3.data.serverResponse && "SetDestChannelStatus" === e3.serverResponse.command)
              throw new XN(_w.CROSS_CHANNEL_FAILED_JOIN_DEST);
            if (e3.data && e3.data.serverResponse && "StartPacketTransfer" === e3.serverResponse.command)
              throw new XN(_w.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST);
            throw e3;
          }
          this.prevChannelMediaConfig = e2;
        }
        async updateChannelMediaRelay(e2) {
          if (this.state !== JM.RELAY_STATE_RUNNING)
            throw new XN(_w.INVALID_OPERATION);
          await this.sendUpdateMessage(e2), this.prevChannelMediaConfig = e2;
        }
        async setVideoProfile(e2) {
          if (this._resolution = e2, this.state !== JM.RELAY_STATE_RUNNING)
            throw new XN(_w.INVALID_OPERATION);
          const t2 = this.genMessage(zM.SetVideoProfile);
          await this.signal.request(t2), BN.debug("[".concat(this.clientId, "] startChannelMediaRelay: setVideoProfile success"));
        }
        async stopChannelMediaRelay() {
          await this.sendStopRelayMessage(), BN.debug("[".concat(this.clientId, "] stopChannelMediaRelay: send stop message success")), this.state = JM.RELAY_STATE_IDLE, this.dispose();
        }
        dispose() {
          BN.debug("[".concat(this.clientId, "] disposeChannelMediaRelay")), this.cancelToken.cancel(), this.cancelToken = Ab.CancelToken.source(), this.state = JM.RELAY_STATE_IDLE, this.emit("dispose"), this.signal.dispose(), this.prevChannelMediaConfig = void 0;
        }
        async connect() {
          const e2 = await OV(this.joinInfo, this.cancelToken.token, this.httpRetryConfig);
          this.workerToken = e2.workerToken, await this.signal.connect(e2.addressList), this.emit("event", XM.NETWORK_CONNECTED), this.signal.on("status", this.onStatus), this.signal.on("reconnecting", this.onReconnect);
        }
        async sendStartRelayMessage(e2) {
          const t2 = this.genMessage(zM.StopPacketTransfer);
          await this.signal.request(t2), await this.signal.waitStatus("Normal Quit"), BN.debug("[".concat(this.clientId, "] startChannelMediaRelay: StopPacketTransfer success"));
          const i3 = this.genMessage(zM.SetSdkProfile, e2);
          await this.signal.request(i3), BN.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSdkProfile success"));
          const n2 = this.genMessage(zM.SetSourceChannel, e2);
          await this.signal.request(n2), await this.signal.waitStatus("SetSourceChannelStatus"), this.emit("event", XM.PACKET_JOINED_SRC_CHANNEL), BN.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSourceChannel success"));
          const r2 = this.genMessage(zM.SetSourceUserId, e2);
          await this.signal.request(r2), BN.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSourceUserId success"));
          const o2 = this.genMessage(zM.SetDestChannel, e2);
          await this.signal.request(o2), await this.signal.waitStatus("SetDestChannelStatus"), this.emit("event", XM.PACKET_JOINED_DEST_CHANNEL), BN.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetDestChannel success"));
          const s2 = this.genMessage(zM.StartPacketTransfer, e2);
          await this.signal.request(s2), this.emit("event", XM.PACKET_SENT_TO_DEST_CHANNEL), this.state = JM.RELAY_STATE_RUNNING, BN.debug("[".concat(this.clientId, "] startChannelMediaRelay: StartPacketTransfer success")), this.setVideoProfile(this._resolution);
        }
        async sendUpdateMessage(e2) {
          const t2 = this.genMessage(zM.UpdateDestChannel, e2);
          await this.signal.request(t2), this.emit("event", XM.PACKET_UPDATE_DEST_CHANNEL), BN.debug("[".concat(this.clientId, "] sendUpdateMessage: UpdateDestChannel success"));
        }
        async sendStopRelayMessage() {
          const e2 = this.genMessage(zM.StopPacketTransfer);
          await this.signal.request(e2), BN.debug("[".concat(this.clientId, "] sendStopRelayMessage: StopPacketTransfer success"));
        }
        genMessage(e2, t2) {
          const i3 = [], n2 = [], r2 = [];
          this.requestId += 1;
          const o2 = { appId: this.joinInfo.appId, cname: this.joinInfo.cname, uid: this.joinInfo.uid.toString(), sdkVersion: tN, sid: this.sid, ts: Date.now(), requestId: this.requestId, seq: this.requestId, allocate: true, clientRequest: {} };
          "4.23.0" === o2.sdkVersion && (o2.sdkVersion = "0.0.1");
          let s2 = null, a2 = null;
          switch (e2) {
            case zM.SetSdkProfile:
              return o2.clientRequest = { command: "SetSdkProfile", type: "multi_channel" }, o2;
            case zM.SetSourceChannel:
              if (a2 = t2 && t2.getSrcChannelMediaInfo(), !a2)
                throw new XN(_w.UNEXPECTED_ERROR, "can not find source config");
              return o2.clientRequest = { command: "SetSourceChannel", uid: "0", channelName: a2.channelName, token: a2.token || this.joinInfo.appId }, o2;
            case zM.SetSourceUserId:
              if (a2 = t2 && t2.getSrcChannelMediaInfo(), !a2)
                throw new XN(_w.UNEXPECTED_ERROR, "can not find source config");
              return o2.clientRequest = { command: "SetSourceUserId", uid: a2.uid + "" }, o2;
            case zM.SetDestChannel:
              if (s2 = t2 && t2.getDestChannelMediaInfo(), !s2)
                throw new XN(_w.UNEXPECTED_ERROR, "can not find dest config");
              return s2.forEach((e3) => {
                i3.push(e3.channelName), n2.push(e3.uid + ""), r2.push(e3.token || this.joinInfo.appId);
              }), o2.clientRequest = { command: "SetDestChannel", channelName: i3, uid: n2, token: r2 }, o2;
            case zM.StartPacketTransfer:
              return o2.clientRequest = { command: "StartPacketTransfer" }, o2;
            case zM.Reconnect:
              return o2.clientRequest = { command: "Reconnect" }, o2;
            case zM.StopPacketTransfer:
              return o2.clientRequest = { command: "StopPacketTransfer" }, o2;
            case zM.UpdateDestChannel:
              if (s2 = t2 && t2.getDestChannelMediaInfo(), !s2)
                throw new XN(_w.UNEXPECTED_ERROR, "can not find dest config");
              return s2.forEach((e3) => {
                i3.push(e3.channelName), n2.push(e3.uid + ""), r2.push(e3.token || this.joinInfo.appId);
              }), o2.clientRequest = { command: "UpdateDestChannel", channelName: i3, uid: n2, token: r2 }, o2;
            case zM.SetVideoProfile:
              o2.clientRequest = { command: "SetVideoProfile", width: this._resolution.width, height: this._resolution.height };
          }
          return o2;
        }
      }
      const qK = { name: "ChannelMediaRelay", create: function(e2) {
        return new YK(e2.joinInfo, e2.clientId, e2.websocketRetryConfig || yO, e2.httpRetryConfig || yO, e2.resolution);
      } };
      function zK(e2, t2) {
        var i3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i3.push.apply(i3, n2);
        }
        return i3;
      }
      function XK(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i3 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? zK(Object(i3), true).forEach(function(t3) {
            QI(e2, t3, i3[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : zK(Object(i3)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
          });
        }
        return e2;
      }
      class JK extends Nw {
        constructor(e2, t2, i3, n2) {
          super(), QI(this, "spec", void 0), QI(this, "token", void 0), QI(this, "websocket", void 0), QI(this, "pingpongTimer", void 0), QI(this, "reconnectMode", "retry"), QI(this, "serviceMode", void 0), QI(this, "reqId", 0), QI(this, "commandReqId", 0), QI(this, "handleWebSocketOpen", () => {
            this.reconnectMode = "retry", this.startPingPong();
          }), QI(this, "handleWebSocketMessage", (e3) => {
            if (!e3.data)
              return;
            const t3 = JSON.parse(e3.data);
            t3.requestId ? this.emit("@".concat(t3.requestId, "-").concat(t3.sid), t3) : (zN.workerEvent(this.spec.sid, { actionType: "status", serverCode: t3.code, workerType: this.serviceMode === FM.TRANSCODE ? 1 : 2 }), this.emit(HM.PUBLISH_STREAM_STATUS, t3));
          }), this.spec = t2, this.token = e2, this.serviceMode = n2, this.websocket = new KU("live-streaming", i3), this.websocket.on(UM.CONNECTED, this.handleWebSocketOpen), this.websocket.on(UM.ON_MESSAGE, this.handleWebSocketMessage), this.websocket.on(UM.REQUEST_NEW_URLS, (e3, t3) => {
            Kw(this, HM.REQUEST_NEW_ADDRESS).then(e3).catch(t3);
          }), this.websocket.on(UM.RECONNECTING, () => {
            this.websocket.reconnectMode = this.reconnectMode;
          });
        }
        init(e2) {
          return this.websocket.init(e2);
        }
        async request(e2, t2, i3, n2) {
          this.reqId += 1, "request" === e2 && (this.commandReqId += 1);
          const r2 = this.commandReqId, o2 = this.reqId;
          if (!o2 || !this.websocket)
            throw new XN(_w.UNEXPECTED_ERROR);
          const s2 = XK({ command: e2, sdkVersion: "4.23.0" === tN ? "0.0.1" : tN, seq: o2, requestId: o2, allocate: i3, cname: this.spec.cname, appId: this.spec.appId, sid: this.spec.sid, uid: this.spec.uid.toString(), ts: Math.floor(Date.now() / 1e3) }, t2);
          if ("closed" === this.websocket.state)
            throw new XN(_w.WS_DISCONNECT);
          const a2 = () => new Wh((e3, t3) => {
            this.websocket.once(UM.CLOSED, () => t3(new XN(_w.WS_ABORT))), this.websocket.once(UM.CONNECTED, e3);
          });
          "connected" !== this.websocket.state && await a2(), s2.clientRequest && (s2.clientRequest.workerToken = this.token);
          const c2 = new Wh((e3, t3) => {
            const i4 = () => {
              t3(new XN(_w.WS_ABORT));
            };
            this.websocket.once(UM.RECONNECTING, i4), this.websocket.once(UM.CLOSED, i4), this.once("@".concat(o2, "-").concat(this.spec.sid), (t4) => {
              e3(t4);
            });
          });
          n2 && zN.workerEvent(this.spec.sid, XK(XK({}, n2), {}, { requestId: r2, actionType: "request", payload: JSON.stringify(t2.clientRequest), serverCode: 0, code: 0 }));
          const d2 = Date.now();
          this.websocket.sendMessage(s2);
          let l2 = null;
          try {
            l2 = await c2;
          } catch (n3) {
            if ("closed" === this.websocket.state)
              throw n3;
            return await a2(), await this.request(e2, t2, i3);
          }
          return n2 && zN.workerEvent(this.spec.sid, XK(XK({}, n2), {}, { requestId: r2, actionType: "response", payload: JSON.stringify(l2.serverResponse), serverCode: l2.code, success: 200 === l2.code, responseTime: Date.now() - d2 })), 200 !== l2.code && this.handleResponseError(l2), l2;
        }
        tryNextAddress() {
          this.reconnectMode = "tryNext", this.websocket.reconnect("tryNext");
        }
        close() {
          const e2 = "4.23.0" === tN ? "0.0.1" : tN;
          this.reqId += 1, "connected" === this.websocket.state ? (this.websocket.sendMessage({ command: "request", appId: this.spec.appId, cname: this.spec.cname, uid: this.spec.uid.toString(), sdkVersion: e2, sid: this.spec.sid, seq: this.reqId, ts: Math.floor(Date.now() / 1e3), requestId: this.reqId, clientRequest: { command: "DestroyWorker" } }), this.websocket.close(false, true)) : this.websocket.close(false), this.pingpongTimer && (window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0);
        }
        handleResponseError(e2) {
          switch (e2.code) {
            case YM.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM:
              return void BN.warning("live stream response already exists stream");
            case YM.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR:
            case YM.LIVE_STREAM_RESPONSE_BAD_STREAM:
            case YM.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR:
              return new XN(_w.LIVE_STREAMING_INVALID_ARGUMENT, "", { code: e2.code }).throw();
            case YM.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST:
              if ("UnpublishStream" === e2.serverResponse.command)
                return;
              throw new XN(_w.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream response wm worker not exist", { retry: true });
            case YM.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED:
              return new XN(_w.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED, "", { code: e2.code }).throw();
            case YM.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE: {
              const t2 = new XN(_w.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE);
              return this.emit(HM.WARNING, t2, e2.serverResponse.url);
            }
            case YM.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN: {
              const t2 = new XN(_w.LIVE_STREAMING_WARN_FREQUENT_REQUEST);
              return this.emit(HM.WARNING, t2, e2.serverResponse.url);
            }
            case YM.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH:
              throw new XN(_w.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream response wm worker not exist", { retry: true });
            case YM.LIVE_STREAM_RESPONSE_NOT_SUPPORTED:
              return new XN(_w.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED, "", { code: e2.code }).throw();
            case YM.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM: {
              const t2 = new XN(_w.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT);
              return this.emit(HM.WARNING, t2, e2.serverResponse.url);
            }
            case YM.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR:
              return new XN(_w.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "", { code: e2.code }).throw();
            case YM.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT:
              throw new XN(_w.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream resource limit", { retry: true, changeAddress: true });
            case YM.LIVE_STREAM_RESPONSE_WORKER_LOST:
            case YM.LIVE_STREAM_RESPONSE_WORKER_QUIT:
              if ("UnpublishStream" === e2.serverResponse.command)
                return;
              throw new XN(_w.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { retry: true, changeAddress: true });
            case YM.ERROR_FAIL_SEND_MESSAGE:
              if ("UnpublishStream" === e2.serverResponse.command)
                return;
              if ("UpdateTranscoding" === e2.serverResponse.command || "ControlStream" === e2.serverResponse.command)
                return new XN(_w.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { code: e2.code }).throw();
              throw new XN(_w.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { retry: true, changeAddress: true });
            case YM.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:
            case YM.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:
            case YM.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:
            case YM.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH:
              return new XN(_w.LIVE_STREAMING_CDN_ERROR, "", { code: e2.code }).throw();
          }
        }
        startPingPong() {
          this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(() => {
            "connected" === this.websocket.state && this.request("ping", {}).catch(pO);
          }, 6e3);
        }
      }
      function QK(e2, t2) {
        var i3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i3.push.apply(i3, n2);
        }
        return i3;
      }
      function ZK(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i3 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? QK(Object(i3), true).forEach(function(t3) {
            QI(e2, t3, i3[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : QK(Object(i3)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
          });
        }
        return e2;
      }
      class $K extends Nw {
        constructor(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : yO, i3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : yO;
          super(), QI(this, "onLiveStreamWarning", void 0), QI(this, "onLiveStreamError", void 0), QI(this, "spec", void 0), QI(this, "retryTimeout", 1e4), QI(this, "connection", void 0), QI(this, "httpRetryConfig", void 0), QI(this, "wsRetryConfig", void 0), QI(this, "streamingTasks", /* @__PURE__ */ new Map()), QI(this, "isStartingStreamingTask", false), QI(this, "taskMutex", new vO("live-streaming")), QI(this, "cancelToken", Ab.CancelToken.source()), QI(this, "transcodingConfig", void 0), QI(this, "uapResponse", void 0), QI(this, "lastTaskId", 1), QI(this, "statusError", /* @__PURE__ */ new Map()), this.spec = e2, this.httpRetryConfig = i3, this.wsRetryConfig = t2;
        }
        async setTranscodingConfig(e2) {
          const t2 = ZK(ZK({}, WM), e2);
          66 !== t2.videoCodecProfile && 77 !== t2.videoCodecProfile && 100 !== t2.videoCodecProfile && (BN.debug("[".concat(this.spec.clientId, "] set transcoding config, fix video codec profile: ").concat(t2.videoCodecProfile, " -> 100")), t2.videoCodecProfile = 100), t2.transcodingUsers || (t2.transcodingUsers = t2.userConfigs), t2.transcodingUsers && (t2.transcodingUsers = t2.transcodingUsers.map((e3) => ZK(ZK(ZK({}, BM), e3), {}, { zOrder: e3.zOrder ? e3.zOrder + 1 : 1 }))), function(e3) {
            Cw(e3.width) || Tw(e3.width, "config.width", 0, 1e4), Cw(e3.height) || Tw(e3.height, "config.height", 0, 1e4), Cw(e3.videoBitrate) || Tw(e3.videoBitrate, "config.videoBitrate", 1, 1e6), Cw(e3.videoFrameRate) || Tw(e3.videoFrameRate, "config.videoFrameRate"), Cw(e3.lowLatency) || fw(e3.lowLatency, "config.lowLatency"), Cw(e3.audioSampleRate) || mw(e3.audioSampleRate, "config.audioSampleRate", [32e3, 44100, 48e3]), Cw(e3.audioBitrate) || Tw(e3.audioBitrate, "config.audioBitrate", 1, 128), Cw(e3.audioChannels) || mw(e3.audioChannels, "config.audioChannels", [1, 2, 3, 4, 5]), Cw(e3.videoGop) || Tw(e3.videoGop, "config.videoGop"), Cw(e3.videoCodecProfile) || mw(e3.videoCodecProfile, "config.videoCodecProfile", [66, 77, 100]), Cw(e3.userCount) || Tw(e3.userCount, "config.userCount", 0, 17), Cw(e3.backgroundColor) || Tw(e3.backgroundColor, "config.backgroundColor", 0, 16777215), Cw(e3.userConfigExtraInfo) || gw(e3.userConfigExtraInfo, "config.userConfigExtraInfo", 0, 4096, false), e3.transcodingUsers && !Cw(e3.transcodingUsers) && (Rw(e3.transcodingUsers, "config.transcodingUsers"), e3.transcodingUsers.forEach((e4, t3) => {
              VM(e4.uid), Cw(e4.x) || Tw(e4.x, "transcodingUser[".concat(t3, "].x"), 0, 1e4), Cw(e4.y) || Tw(e4.y, "transcodingUser[".concat(t3, "].y"), 0, 1e4), Cw(e4.width) || Tw(e4.width, "transcodingUser[".concat(t3, "].width"), 0, 1e4), Cw(e4.height) || Tw(e4.height, "transcodingUser[".concat(t3, "].height"), 0, 1e4), Cw(e4.zOrder) || Tw(e4.zOrder - 1, "transcodingUser[".concat(t3, "].zOrder"), 0, 100), Cw(e4.alpha) || Tw(e4.alpha, "transcodingUser[".concat(t3, "].alpha"), 0, 1, false);
            })), Cw(e3.watermark) || GM(e3.watermark, "watermark"), Cw(e3.backgroundImage) || GM(e3.backgroundImage, "backgroundImage"), e3.images && !Cw(e3.images) && (Rw(e3.images, "config.images"), e3.images.forEach((e4, t3) => {
              GM(e4, "images[".concat(t3, "]"));
            }));
          }(t2);
          const i3 = [];
          t2.images && i3.push(...t2.images.map((e3) => ZK(ZK(ZK({}, jM), e3), {}, { zOrder: 255 }))), t2.backgroundImage && (i3.push(ZK(ZK(ZK({}, jM), t2.backgroundImage), {}, { zOrder: 0 })), delete t2.backgroundImage), t2.watermark && (i3.push(ZK(ZK(ZK({}, jM), t2.watermark), {}, { zOrder: 255 })), delete t2.watermark), t2.images = i3, t2.transcodingUsers && (t2.userConfigs = t2.transcodingUsers.map((e3) => ZK({}, e3)), t2.userCount = t2.transcodingUsers.length, delete t2.transcodingUsers);
          const n2 = (t2.userConfigs || []).map((e3) => "number" == typeof e3.uid ? Wh.resolve(e3.uid) : IV(e3.uid, this.spec, this.cancelToken.token, this.httpRetryConfig));
          if ((await Wh.all(n2)).forEach((e3, i4) => {
            t2.userConfigs && t2.userConfigs[i4] && (t2.userConfigs[i4].uid = e3);
          }), this.transcodingConfig = t2, this.connection)
            try {
              var r2;
              const e3 = await this.connection.request("request", { clientRequest: { command: "UpdateTranscoding", transcodingConfig: this.transcodingConfig } }, false, { command: "UpdateTranscoding", workerType: 1, requestByUser: true, tid: Array.from(Zh(r2 = this.streamingTasks).call(r2)).map((e4) => e4.taskId).join("#") });
              BN.debug("[".concat(this.spec.clientId, "] update live transcoding config success, code: ").concat(e3.code, ", config:"), JSON.stringify(this.transcodingConfig));
            } catch (e3) {
              if (!e3.data || !e3.data.retry)
                throw e3;
              e3.data.changeAddress && this.connection.tryNextAddress(), this.streamingTasks.forEach((t3) => {
                BN.warning("[".concat(this.spec.clientId, "] live streaming receive error"), e3.toString(), "try to republish", t3.url), this.startLiveStreamingTask(t3.url, t3.mode, e3).then(() => {
                  BN.debug("[".concat(this.spec.clientId, "] live streaming republish ").concat(t3.url, " success"));
                }).catch((e4) => {
                  BN.error("[".concat(this.spec.clientId, "] live streaming republish failed"), t3.url, e4.toString()), this.onLiveStreamError && this.onLiveStreamError(t3.url, e4);
                });
              });
            }
        }
        async startLiveStreamingTask(e2, t2, i3) {
          if (!this.transcodingConfig && t2 === FM.TRANSCODE)
            throw new XN(_w.INVALID_OPERATION, "[LiveStreaming] no transcoding config found, can not start transcoding streaming task");
          const n2 = { command: "PublishStream", ts: Date.now(), url: e2, uid: this.spec.uid.toString(), autoDestroyTime: 100, acceptImageTimeout: true };
          BN.debug("[".concat(this.spec.clientId, "] start live streaming ").concat(e2, ", mode: ").concat(t2));
          const r2 = await this.taskMutex.lock();
          if (!this.connection && i3)
            return void r2();
          if (this.streamingTasks.get(e2) && !i3)
            return r2(), new XN(_w.LIVE_STREAMING_TASK_CONFLICT).throw();
          try {
            this.connection || (this.connection = await this.connect(t2));
          } catch (e3) {
            throw r2(), e3;
          }
          switch (t2) {
            case FM.TRANSCODE:
              n2.transcodingConfig = ZK({}, this.transcodingConfig);
            case FM.RAW:
          }
          this.uapResponse && this.uapResponse.vid && (n2.vid = this.uapResponse.vid), this.isStartingStreamingTask = true;
          const o2 = this.lastTaskId++;
          try {
            const s2 = new Wh((t3, n3) => {
              lO(this.retryTimeout).then(() => {
                if (i3)
                  return n3(i3);
                const t4 = this.statusError.get(e2);
                return t4 ? (this.statusError.delete(e2), n3(t4)) : void 0;
              });
            }), a2 = await Wh.race([this.connection.request("request", { clientRequest: n2 }, true, { url: e2, command: "PublishStream", workerType: t2 === FM.TRANSCODE ? 1 : 2, requestByUser: !i3, tid: o2.toString() }), s2]);
            this.isStartingStreamingTask = false, BN.debug("[".concat(this.spec.clientId, "] live streaming started, code: ").concat(a2.code)), this.streamingTasks.set(e2, { clientRequest: n2, mode: t2, url: e2, taskId: o2 }), r2();
          } catch (n3) {
            if (r2(), this.isStartingStreamingTask = false, !n3.data || !n3.data.retry || i3)
              throw n3;
            return n3.data.changeAddress ? (this.connection.tryNextAddress(), await this.startLiveStreamingTask(e2, t2, n3)) : await this.startLiveStreamingTask(e2, t2, n3);
          }
        }
        stopLiveStreamingTask(e2) {
          return new Wh((t2, i3) => {
            const n2 = this.streamingTasks.get(e2);
            if (!n2 || !this.connection)
              return new XN(_w.UNEXPECTED_ERROR, "can not find streaming task to stop").throw();
            const r2 = n2.mode;
            n2.abortTask = () => {
              BN.debug("[".concat(this.spec.clientId, "] stop live streaming success(worker exception)")), this.streamingTasks.delete(e2), t2();
            }, this.connection.request("request", { clientRequest: { command: "UnpublishStream", url: n2.url } }, false, { url: e2, command: "UnPublishStream", workerType: r2 === FM.TRANSCODE ? 1 : 2, requestByUser: true, tid: (this.lastTaskId++).toString() }).then((i4) => {
              BN.debug("[".concat(this.spec.clientId, "] stop live streaming success, code: ").concat(i4.code)), this.streamingTasks.delete(e2), 0 === this.streamingTasks.size && (this.connection && this.connection.close(), this.connection = void 0), t2();
            }).catch(i3);
          });
        }
        resetAllTask() {
          var e2;
          const t2 = Array.from(Zh(e2 = this.streamingTasks).call(e2));
          this.terminate();
          for (const e3 of t2)
            this.startLiveStreamingTask(e3.url, e3.mode).catch((t3) => {
              this.onLiveStreamError && this.onLiveStreamError(e3.url, t3);
            });
        }
        terminate() {
          this.cancelToken && this.cancelToken.cancel(), this.streamingTasks = /* @__PURE__ */ new Map(), this.isStartingStreamingTask = false, this.statusError = /* @__PURE__ */ new Map(), this.cancelToken = Ab.CancelToken.source(), this.uapResponse = void 0, this.connection && this.connection.close(), this.connection = void 0;
        }
        async connect(e2) {
          if (this.connection)
            throw new XN(_w.UNEXPECTED_ERROR, "live streaming connection has already connected");
          const t2 = await Kw(this, KM.REQUEST_WORKER_MANAGER_LIST, e2);
          return this.uapResponse = t2, this.connection = new JK(t2.workerToken, this.spec, this.wsRetryConfig, e2), this.connection.on(HM.WARNING, (e3, t3) => this.onLiveStreamWarning && this.onLiveStreamWarning(t3, e3)), this.connection.on(HM.PUBLISH_STREAM_STATUS, (e3) => this.handlePublishStreamServer(e3)), this.connection.on(HM.REQUEST_NEW_ADDRESS, (t3, i3) => {
            if (!this.connection)
              return i3(new XN(_w.UNEXPECTED_ERROR, "can not get new live streaming address list"));
            Kw(this, KM.REQUEST_WORKER_MANAGER_LIST, e2).then((e3) => {
              this.uapResponse = e3, t3(e3.addressList);
            }).catch(i3);
          }), await this.connection.init(t2.addressList), this.connection;
        }
        handlePublishStreamServer(e2) {
          const t2 = e2.serverStatus && e2.serverStatus.url || "empty_url", i3 = this.streamingTasks.get(t2), n2 = e2.reason;
          switch (e2.code) {
            case YM.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:
            case YM.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:
            case YM.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:
            case YM.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH: {
              const n3 = new XN(_w.LIVE_STREAMING_CDN_ERROR, "", { code: e2.code });
              if (i3)
                return BN.error(n3.toString()), this.onLiveStreamError && this.onLiveStreamError(t2, n3);
              if (!this.isStartingStreamingTask)
                return;
              this.statusError.set(t2, n3);
            }
            case YM.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE: {
              const e3 = new XN(_w.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE, n2);
              return this.onLiveStreamWarning && this.onLiveStreamWarning(t2, e3);
            }
            case YM.LIVE_STREAM_RESPONSE_WORKER_LOST:
            case YM.LIVE_STREAM_RESPONSE_WORKER_QUIT: {
              var r2;
              if (!this.connection)
                return;
              this.connection.tryNextAddress();
              const t3 = Array.from(Zh(r2 = this.streamingTasks).call(r2));
              for (const i4 of t3)
                i4.abortTask ? i4.abortTask() : (BN.warning("[".concat(this.spec.clientId, "] publish stream status code"), e2.code, "try to republish", i4.url), this.startLiveStreamingTask(i4.url, i4.mode, new XN(_w.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "", { code: e2.code })).then(() => {
                  BN.debug("[".concat(this.spec.clientId, "] republish live stream success"), i4.url);
                }).catch((e3) => {
                  BN.error(e3.toString()), this.onLiveStreamError && this.onLiveStreamError(i4.url, e3);
                }));
              return;
            }
          }
        }
        hasUrl(e2) {
          return this.streamingTasks.has(e2);
        }
      }
      const eY = { name: "LiveStreaming", create: function(e2) {
        return new $K(e2.joinInfo, e2.websocketRetryConfig || yO, e2.httpRetryConfig || yO);
      } };
      function tY(e2) {
        let t2 = hY();
        return function(e3, t3) {
          let i3 = e3.appId;
          void 0 !== i3 && (AY(t3, 10), SY(t3, i3));
          let n2 = e3.cid;
          void 0 !== n2 && (AY(t3, 16), AY(t3, n2));
          let r2 = e3.cname;
          void 0 !== r2 && (AY(t3, 26), SY(t3, r2));
          let o2 = e3.deviceId;
          void 0 !== o2 && (AY(t3, 34), SY(t3, o2));
          let s2 = e3.elapse;
          void 0 !== s2 && (AY(t3, 40), bY(t3, s2));
          let a2 = e3.fileSize;
          void 0 !== a2 && (AY(t3, 48), bY(t3, lY(a2)));
          let c2 = e3.height;
          void 0 !== c2 && (AY(t3, 56), bY(t3, lY(c2)));
          let d2 = e3.jpg;
          void 0 !== d2 && (AY(t3, 66), AY(t3, d2.length), function(e4, t4) {
            let i4 = fY(e4, t4.length);
            e4.bytes.set(t4, i4);
          }(t3, d2));
          let l2 = e3.networkType;
          void 0 !== l2 && (AY(t3, 72), bY(t3, lY(l2)));
          let u2 = e3.osType;
          void 0 !== u2 && (AY(t3, 80), bY(t3, lY(u2)));
          let h2 = e3.requestId;
          void 0 !== h2 && (AY(t3, 90), SY(t3, h2));
          let p3 = e3.sdkVersion;
          void 0 !== p3 && (AY(t3, 98), SY(t3, p3));
          let _2 = e3.sequence;
          void 0 !== _2 && (AY(t3, 104), bY(t3, lY(_2)));
          let E2 = e3.sid;
          void 0 !== E2 && (AY(t3, 114), SY(t3, E2));
          let f2 = e3.timestamp;
          void 0 !== f2 && (AY(t3, 120), bY(t3, f2));
          let m2 = e3.uid;
          void 0 !== m2 && (AY(t3, 128), AY(t3, m2));
          let T2 = e3.vid;
          void 0 !== T2 && (AY(t3, 136), AY(t3, T2));
          let S2 = e3.width;
          void 0 !== S2 && (AY(t3, 144), bY(t3, lY(S2)));
          let g2 = e3.service;
          void 0 !== g2 && (AY(t3, 152), AY(t3, g2));
          let R3 = e3.callbackData;
          void 0 !== R3 && (AY(t3, 162), SY(t3, R3));
          let C2 = e3.jpgEncryption;
          void 0 !== C2 && (AY(t3, 168), AY(t3, C2));
          let v2 = e3.requestType;
          void 0 !== v2 && (AY(t3, 176), AY(t3, v2));
          let I2 = e3.scorePorn;
          void 0 !== I2 && (AY(t3, 185), IY(t3, I2));
          let y2 = e3.scoreSexy;
          void 0 !== y2 && (AY(t3, 193), IY(t3, y2));
          let A2 = e3.scoreNeutral;
          void 0 !== A2 && (AY(t3, 201), IY(t3, A2));
          let b2 = e3.scene;
          void 0 !== b2 && (AY(t3, 208), AY(t3, b2));
          let w2 = e3.ossFilePrefix;
          void 0 !== w2 && (AY(t3, 218), SY(t3, w2));
          let O2 = e3.serviceVendor;
          if (void 0 !== O2)
            for (let e4 of O2) {
              AY(t3, 226);
              let i4 = hY();
              rY(e4, i4), AY(t3, i4.limit), gY(t3, i4), pY(i4);
            }
        }(e2, t2), function(e3) {
          let t3 = e3.bytes, i3 = e3.limit;
          return t3.length === i3 ? t3 : t3.subarray(0, i3);
        }(t2);
      }
      function iY(e2) {
        return function(e3) {
          let t3 = {};
          e:
            for (; !EY(e3); ) {
              let i3 = yY(e3);
              switch (i3 >>> 3) {
                case 0:
                  break e;
                case 1:
                  t3.code = yY(e3);
                  break;
                case 2:
                  t3.msg = TY(e3, yY(e3));
                  break;
                case 3: {
                  let i4 = oY(e3);
                  t3.data = nY(e3), e3.limit = i4;
                  break;
                }
                default:
                  sY(e3, 7 & i3);
              }
            }
          return t3;
        }({ bytes: t2 = e2, offset: 0, limit: t2.length });
        var t2;
      }
      function nY(e2) {
        let t2 = {};
        e:
          for (; !EY(e2); ) {
            let i3 = yY(e2);
            switch (i3 >>> 3) {
              case 0:
                break e;
              case 1:
                t2.requestId = TY(e2, yY(e2));
                break;
              case 2:
                t2.requestType = yY(e2) >>> 0;
                break;
              case 3:
                t2.scorePorn = vY(e2);
                break;
              case 4:
                t2.scoreSexy = vY(e2);
                break;
              case 5:
                t2.scoreNeutral = vY(e2);
                break;
              case 6:
                t2.requestScene = yY(e2) >>> 0;
                break;
              case 7:
                t2.scene = yY(e2) >>> 0;
                break;
              default:
                sY(e2, 7 & i3);
            }
          }
        return t2;
      }
      function rY(e2, t2) {
        let i3 = e2.service;
        void 0 !== i3 && (AY(t2, 8), AY(t2, i3));
        let n2 = e2.vendor;
        void 0 !== n2 && (AY(t2, 16), AY(t2, n2));
        let r2 = e2.token;
        void 0 !== r2 && (AY(t2, 26), SY(t2, r2));
        let o2 = e2.callbackUrl;
        void 0 !== o2 && (AY(t2, 34), SY(t2, o2));
      }
      function oY(e2) {
        let t2 = yY(e2), i3 = e2.limit;
        return e2.limit = e2.offset + t2, i3;
      }
      function sY(e2, t2) {
        switch (t2) {
          case 0:
            for (; 128 & RY(e2); )
              ;
            break;
          case 2:
            _Y(e2, yY(e2));
            break;
          case 5:
            _Y(e2, 4);
            break;
          case 1:
            _Y(e2, 8);
            break;
          default:
            throw new Error("Unimplemented type: " + t2);
        }
      }
      let aY = new Float32Array(1);
      new Uint8Array(aY.buffer);
      let cY = new Float64Array(1), dY = new Uint8Array(cY.buffer);
      function lY(e2) {
        return { low: e2 |= 0, high: e2 >> 31, unsigned: e2 >= 0 };
      }
      let uY = [];
      function hY() {
        const e2 = uY.pop();
        return e2 ? (e2.offset = e2.limit = 0, e2) : { bytes: new Uint8Array(64), offset: 0, limit: 0 };
      }
      function pY(e2) {
        uY.push(e2);
      }
      function _Y(e2, t2) {
        if (e2.offset + t2 > e2.limit)
          throw new Error("Skip past limit");
        e2.offset += t2;
      }
      function EY(e2) {
        return e2.offset >= e2.limit;
      }
      function fY(e2, t2) {
        let i3 = e2.bytes, n2 = e2.offset, r2 = e2.limit, o2 = n2 + t2;
        if (o2 > i3.length) {
          let t3 = new Uint8Array(2 * o2);
          t3.set(i3), e2.bytes = t3;
        }
        return e2.offset = o2, o2 > r2 && (e2.limit = o2), n2;
      }
      function mY(e2, t2) {
        let i3 = e2.offset;
        if (i3 + t2 > e2.limit)
          throw new Error("Read past limit");
        return e2.offset += t2, i3;
      }
      function TY(e2, t2) {
        let i3 = mY(e2, t2), n2 = String.fromCharCode, r2 = e2.bytes, o2 = "ï¿½", s2 = "";
        for (let e3 = 0; e3 < t2; e3++) {
          let a2, c2, d2, l2, u2 = r2[e3 + i3];
          0 == (128 & u2) ? s2 += n2(u2) : 192 == (224 & u2) ? e3 + 1 >= t2 ? s2 += o2 : (a2 = r2[e3 + i3 + 1], 128 != (192 & a2) ? s2 += o2 : (l2 = (31 & u2) << 6 | 63 & a2, l2 < 128 ? s2 += o2 : (s2 += n2(l2), e3++))) : 224 == (240 & u2) ? e3 + 2 >= t2 ? s2 += o2 : (a2 = r2[e3 + i3 + 1], c2 = r2[e3 + i3 + 2], 32896 != (49344 & (a2 | c2 << 8)) ? s2 += o2 : (l2 = (15 & u2) << 12 | (63 & a2) << 6 | 63 & c2, l2 < 2048 || l2 >= 55296 && l2 <= 57343 ? s2 += o2 : (s2 += n2(l2), e3 += 2))) : 240 == (248 & u2) ? e3 + 3 >= t2 ? s2 += o2 : (a2 = r2[e3 + i3 + 1], c2 = r2[e3 + i3 + 2], d2 = r2[e3 + i3 + 3], 8421504 != (12632256 & (a2 | c2 << 8 | d2 << 16)) ? s2 += o2 : (l2 = (7 & u2) << 18 | (63 & a2) << 12 | (63 & c2) << 6 | 63 & d2, l2 < 65536 || l2 > 1114111 ? s2 += o2 : (l2 -= 65536, s2 += n2(55296 + (l2 >> 10), 56320 + (1023 & l2)), e3 += 3))) : s2 += o2;
        }
        return s2;
      }
      function SY(e2, t2) {
        let i3 = t2.length, n2 = 0;
        for (let e3 = 0; e3 < i3; e3++) {
          let r3 = t2.charCodeAt(e3);
          r3 >= 55296 && r3 <= 56319 && e3 + 1 < i3 && (r3 = (r3 << 10) + t2.charCodeAt(++e3) - 56613888), n2 += r3 < 128 ? 1 : r3 < 2048 ? 2 : r3 < 65536 ? 3 : 4;
        }
        AY(e2, n2);
        let r2 = fY(e2, n2), o2 = e2.bytes;
        for (let e3 = 0; e3 < i3; e3++) {
          let n3 = t2.charCodeAt(e3);
          n3 >= 55296 && n3 <= 56319 && e3 + 1 < i3 && (n3 = (n3 << 10) + t2.charCodeAt(++e3) - 56613888), n3 < 128 ? o2[r2++] = n3 : (n3 < 2048 ? o2[r2++] = n3 >> 6 & 31 | 192 : (n3 < 65536 ? o2[r2++] = n3 >> 12 & 15 | 224 : (o2[r2++] = n3 >> 18 & 7 | 240, o2[r2++] = n3 >> 12 & 63 | 128), o2[r2++] = n3 >> 6 & 63 | 128), o2[r2++] = 63 & n3 | 128);
        }
      }
      function gY(e2, t2) {
        let i3 = fY(e2, t2.limit), n2 = e2.bytes, r2 = t2.bytes;
        for (let e3 = 0, o2 = t2.limit; e3 < o2; e3++)
          n2[e3 + i3] = r2[e3];
      }
      function RY(e2) {
        return e2.bytes[mY(e2, 1)];
      }
      function CY(e2, t2) {
        let i3 = fY(e2, 1);
        e2.bytes[i3] = t2;
      }
      function vY(e2) {
        let t2 = mY(e2, 8), i3 = e2.bytes;
        return dY[0] = i3[t2++], dY[1] = i3[t2++], dY[2] = i3[t2++], dY[3] = i3[t2++], dY[4] = i3[t2++], dY[5] = i3[t2++], dY[6] = i3[t2++], dY[7] = i3[t2++], cY[0];
      }
      function IY(e2, t2) {
        let i3 = fY(e2, 8), n2 = e2.bytes;
        cY[0] = t2, n2[i3++] = dY[0], n2[i3++] = dY[1], n2[i3++] = dY[2], n2[i3++] = dY[3], n2[i3++] = dY[4], n2[i3++] = dY[5], n2[i3++] = dY[6], n2[i3++] = dY[7];
      }
      function yY(e2) {
        let t2, i3 = 0, n2 = 0;
        do {
          t2 = RY(e2), i3 < 32 && (n2 |= (127 & t2) << i3), i3 += 7;
        } while (128 & t2);
        return n2;
      }
      function AY(e2, t2) {
        for (t2 >>>= 0; t2 >= 128; )
          CY(e2, 127 & t2 | 128), t2 >>>= 7;
        CY(e2, t2);
      }
      function bY(e2, t2) {
        let i3 = t2.low >>> 0, n2 = (t2.low >>> 28 | t2.high << 4) >>> 0, r2 = t2.high >>> 24, o2 = 0 === r2 ? 0 === n2 ? i3 < 16384 ? i3 < 128 ? 1 : 2 : i3 < 1 << 21 ? 3 : 4 : n2 < 16384 ? n2 < 128 ? 5 : 6 : n2 < 1 << 21 ? 7 : 8 : r2 < 128 ? 9 : 10, s2 = fY(e2, o2), a2 = e2.bytes;
        switch (o2) {
          case 10:
            a2[s2 + 9] = r2 >>> 7 & 1;
          case 9:
            a2[s2 + 8] = 9 !== o2 ? 128 | r2 : 127 & r2;
          case 8:
            a2[s2 + 7] = 8 !== o2 ? n2 >>> 21 | 128 : n2 >>> 21 & 127;
          case 7:
            a2[s2 + 6] = 7 !== o2 ? n2 >>> 14 | 128 : n2 >>> 14 & 127;
          case 6:
            a2[s2 + 5] = 6 !== o2 ? n2 >>> 7 | 128 : n2 >>> 7 & 127;
          case 5:
            a2[s2 + 4] = 5 !== o2 ? 128 | n2 : 127 & n2;
          case 4:
            a2[s2 + 3] = 4 !== o2 ? i3 >>> 21 | 128 : i3 >>> 21 & 127;
          case 3:
            a2[s2 + 2] = 3 !== o2 ? i3 >>> 14 | 128 : i3 >>> 14 & 127;
          case 2:
            a2[s2 + 1] = 2 !== o2 ? i3 >>> 7 | 128 : i3 >>> 7 & 127;
          case 1:
            a2[s2] = 1 !== o2 ? 128 | i3 : 127 & i3;
        }
      }
      function wY(e2, t2) {
        var i3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i3.push.apply(i3, n2);
        }
        return i3;
      }
      const OY = /* @__PURE__ */ new Map([["moderation", 1], ["supervise", 2]]);
      class NY extends Nw {
        get connectionState() {
          return this._connectionState;
        }
        set connectionState(e2) {
          if (this._connectionState === e2)
            return;
          const t2 = this._connectionState;
          this._connectionState = e2, this.emit(SU.CONNECTION_STATE_CHANGE, t2, e2);
        }
        get inspectType() {
          return this._inspectType;
        }
        set inspectType(e2) {
          var t2;
          this._inspectMode = Xn(t2 = e2.map((e3) => OY.get(e3) || 0)).call(t2, (e3, t3) => e3 + t3), this._inspectType = e2;
        }
        get quality() {
          return this._quality;
        }
        set quality(e2) {
          this._quality = e2 > 1 ? 1 : e2 < 0.1 ? 0.1 : e2, this.qualityTimer && (window.clearTimeout(this.qualityTimer), this.qualityTimer = null), this._quality >= 1 || (this.qualityTimer = window.setTimeout(() => {
            this.quality = this._quality / this.qualityRatio;
          }, 6e4));
        }
        constructor(e2) {
          super(), QI(this, "name", "AgoraRTCVideoContentInspect"), QI(this, "_connectionState", mU.CONNECTING), QI(this, "_innerConnectionState", void 0), QI(this, "sequence", 0), QI(this, "inspectStartTime", void 0), QI(this, "workerManagerConnection", void 0), QI(this, "workerConnection", void 0), QI(this, "workerMessageLengthLimit", void 0), QI(this, "inspectIntervalMinimum", void 0), QI(this, "qualityRatio", void 0), QI(this, "_connectInfo", void 0), QI(this, "_cancelTokenSource", Ab.CancelToken.source()), QI(this, "_retryConfig", void 0), QI(this, "wmSequence", 0), QI(this, "inspectInterval", void 0), QI(this, "inspectTimer", null), QI(this, "ossFilePrefix", void 0), QI(this, "extraInfo", void 0), QI(this, "_inspectType", void 0), QI(this, "_inspectMode", void 0), QI(this, "_quality", 1), QI(this, "qualityTimer", null), QI(this, "_inspectId", void 0), QI(this, "_needWorkUrlOnly", false), QI(this, "inspectImage", () => {
            if (this.connectionState !== mU.CONNECTED)
              throw new XN(_w.OPERATION_ABORTED, "content inspect service connection status is ".concat(this.connectionState));
            this.inspectTimer && (window.clearInterval(this.inspectTimer), this.inspectTimer = null), this.inspectTimer = window.setInterval(() => {
              this.connectionState === mU.CONNECTED ? this.requestToInspectImage() : BN.debug("[".concat(this._inspectId, "] Inspect State is not connected , "), this.connectionState);
            }, this.inspectInterval < this.inspectIntervalMinimum ? this.inspectIntervalMinimum : this.inspectInterval), this.requestToInspectImage();
          }), this._inspectId = uO(5, "inspect-"), this.workerMessageLengthLimit = dN("VIDEO_INSPECT_WORKER_MESSAGE_LENGTH_LIMIT"), this.inspectIntervalMinimum = dN("VIDEO_INSPECT_INTERVAL_MINIMUM"), this.qualityRatio = dN("VIDEO_INSPECT_QUALITY_RATIO"), this.inspectInterval = e2.interval, this.ossFilePrefix = e2.ossFilePrefix, this.extraInfo = e2.extraInfo, this.inspectType = e2.inspectType, this.inspectStartTime = Number(Date.now()), this.workerManagerConnection = new KU("worker-manager-" + this._inspectId, yO), this.on(SU.STATE_CHANGE, (e3, t2) => {
            this._innerConnectionState = e3, BN.debug("[".concat(this._inspectId, "] Inspect operation :").concat(TU[e3], " ").concat(t2 || ""));
          }), this.handleWorkerManagerEvents(), this.workerConnection = new KU("worker-" + this._inspectId, yO), this.handleWorkerEvents();
        }
        async init(e2, t2) {
          this.emit(SU.STATE_CHANGE, TU.CONNECT_AP), this._connectInfo = e2;
          const i3 = this._cancelTokenSource.token;
          return this._retryConfig = t2, new Wh((n2, r2) => {
            this.on(SU.CONNECTION_STATE_CHANGE, (e3, t3) => {
              t3 === mU.CONNECTED && n2();
            }), this.requestAP(e2, i3, t2).then((e3) => {
              this.connectWorkerManager(e3);
            }).catch((e3) => {
              r2(e3);
            });
          });
        }
        async requestAP(e2, t2, i3) {
          const n2 = dN("WEBCS_DOMAIN").map((e3) => "https://".concat(e3, "/api/v1")), r2 = await function(e3, t3, i4, n3) {
            let { appId: r3, areaCode: o3, cname: s2, sid: a2, token: c2, uid: d2 } = t3;
            TV++;
            const l2 = "image_moderation_api", u2 = { service_name: l2, json_body: JSON.stringify({ appId: r3, areaCode: o3, cname: s2, command: "allocateEdge", requestId: TV, seq: TV, sid: a2, token: c2, ts: Date.now(), uid: d2 + "" }) };
            let h2, p3, _2 = e3[0];
            return bO(async () => {
              h2 = Date.now();
              const e4 = await Jx(_2, { data: u2, cancelToken: i4, headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "61" }, params: { action: "wrtc_gateway" } });
              if (p3 = Date.now() - h2, 0 !== e4.code) {
                const t5 = new XN(_w.UNEXPECTED_RESPONSE, "image inspect ap error, code" + e4.code, { retry: true, responseTime: p3 });
                throw BN.error(t5.toString()), t5;
              }
              const t4 = JSON.parse(e4.json_body);
              if (200 !== t4.code) {
                const e5 = new XN(_w.UNEXPECTED_RESPONSE, "image inspect ap error, code: ".concat(t4.code, ", reason: ").concat(t4.reason), { code: t4.code, responseTime: p3 });
                throw BN.error(e5.toString()), e5;
              }
              if (!t4.servers || !Array.isArray(t4.servers) || 0 === t4.servers.length) {
                const e5 = new XN(_w.UNEXPECTED_RESPONSE, "image inspect ap empty server", { code: t4.code, responseTime: p3 });
                throw BN.error(e5.toString()), e5;
              }
              const n4 = dN("VIDEO_INSPECT_WORKER_MANAGER_HOST"), r4 = dN("VIDEO_INSPECT_WORKER_MANAGER_PORT");
              return { addressList: t4.servers.map((e5) => {
                let { address: t5, wss: i5 } = e5;
                if (t5 && i5)
                  return "wss://".concat(t5.replace(/\./g, "-"), ".").concat(n4, ":").concat(r4 || i5);
              }).filter((e5) => !!e5), workerToken: t4.workerToken, vid: t4.vid, responseTime: p3 };
            }, (t4, i5) => (zN.apworkerEvent(a2, { success: true, sc: 200, serviceName: l2, responseDetail: JSON.stringify(t4.addressList), firstSuccess: 0 === i5, responseTime: p3, serverIp: e3[i5 % e3.length] }), false), (t4, i5) => (zN.apworkerEvent(a2, { success: false, sc: t4.data && t4.data.code || 200, serviceName: l2, responseTime: p3, serverIp: e3[i5 % e3.length] }), !!(t4.code !== _w.OPERATION_ABORTED && t4.code !== _w.UNEXPECTED_RESPONSE || t4.data && t4.data.retry) && (_2 = e3[(i5 + 1) % e3.length], true)), n3);
          }(n2, e2, t2, i3);
          this.emit(SU.STATE_CHANGE, TU.AP_CONNECTED);
          const { addressList: o2 } = r2;
          return this.wmSequence++, o2;
        }
        async connectWorkerManager(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          this._needWorkUrlOnly = t2, this.emit(SU.STATE_CHANGE, TU.CONNECT_WORKER_MANAGER), await this.workerManagerConnection.init(e2, 1e4);
        }
        async connectWorker(e2) {
          await this.workerConnection.init([e2]);
        }
        handleWorkerManagerEvents() {
          this.workerManagerConnection.on(UM.CONNECTED, async () => {
            this.emit(SU.STATE_CHANGE, TU.WORKER_MANAGER_CONNECTED, this.workerManagerConnection.url), this.workerManagerConnection.sendMessage({ appId: this._connectInfo.appId, cname: this._connectInfo.cname, uid: this._connectInfo.uid + "", sdkVersion: "4.23.0", sid: this._connectInfo.sid, seq: this.wmSequence, ts: Number(Date.now()), requestId: Math.floor(1e12 * Math.random()), allocate: true, clientRequest: { command: "join" } }, true);
          }), this.workerManagerConnection.on(UM.CLOSED, () => {
            this._innerConnectionState < TU.GET_WORKER_MANAGER_RESPONSE && BN.debug("[".concat(this._inspectId, "] Inspect worker manager is closed before connecting worker"));
          }), this.workerManagerConnection.on(UM.FAILED, () => {
            this._innerConnectionState < TU.GET_WORKER_MANAGER_RESPONSE && BN.debug("[".concat(this._inspectId, "] Connecting inspect worker manager is failed before connecting worker"));
          }), this.workerManagerConnection.on(UM.RECONNECTING, () => {
            this._innerConnectionState < TU.GET_WORKER_MANAGER_RESPONSE && BN.debug("[".concat(this._inspectId, "] Inspect worker manager is reconnecting before connecting worker"));
          }), this.workerManagerConnection.on(UM.ON_MESSAGE, async (e2) => {
            this.emit(SU.STATE_CHANGE, TU.GET_WORKER_MANAGER_RESPONSE);
            const t2 = this.workerManagerConnection.url;
            this.workerManagerConnection.close();
            const i3 = JSON.parse(e2.data);
            if (200 !== i3.code)
              throw BN.error("[".concat(this._inspectId, "] Unexpected code ").concat(i3.code, " from worker manager")), new XN(_w.UNEXPECTED_RESPONSE, "response code of worker is unexpected", i3);
            if (!(i3.serverResponse && i3.serverResponse.portWss && t2))
              throw BN.error("[".concat(this._inspectId, "] Unexpected content from worker manager : ").concat(JSON.stringify(i3))), new XN(_w.UNEXPECTED_RESPONSE, "response content of worker is unexpected", i3);
            {
              const e3 = dN("VIDEO_INSPECT_WORKER_PORT") || i3.serverResponse.portWss, n2 = t2.replace(/:\d+\/?$/, ":".concat(e3));
              this.emit(SU.STATE_CHANGE, TU.CONNECT_WORKER, n2), this._needWorkUrlOnly ? this.emit(SU.REQUEST_NEW_WORKER_URL, n2) : await this.connectWorker(n2);
            }
          }), this.workerManagerConnection.on(UM.WILL_RECONNECT, (e2, t2, i3) => {
            i3(e2);
          }), this.workerManagerConnection.on(UM.REQUEST_NEW_URLS, (e2, t2) => {
            this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then(e2).catch(t2);
          });
        }
        handleWorkerEvents() {
          this.workerConnection.on(UM.CONNECTED, async () => {
            this.emit(SU.STATE_CHANGE, TU.WORKER_CONNECTED, this.workerConnection.url), this.connectionState = mU.CONNECTED;
          }), this.workerConnection.on(UM.ON_MESSAGE, async (e2) => {
            if (e2.data instanceof ArrayBuffer) {
              const i3 = iY(new Uint8Array(e2.data));
              if (dN("SHOW_VIDEO_INSPECT_WORKER_MESSAGE") && BN.debug("[".concat(this._inspectId, "] Response message for worker of inspect content "), JSON.stringify(i3)), 200 === i3.code) {
                if (Array.isArray(this.inspectType) && 1 === this.inspectType.length && "supervise" === this.inspectType[0])
                  return void this.emit(SU.INSPECT_RESULT, void 0, void 0);
                if (i3.data && i3.data.scorePorn && i3.data.scoreSexy && i3.data.scoreNeutral) {
                  var t2;
                  const e3 = { porn: i3.data.scorePorn, sexy: i3.data.scoreSexy, neutral: i3.data.scoreNeutral }, n2 = Xn(t2 = Object.keys(e3)).call(t2, (t3, i4) => e3[t3] > e3[i4] ? t3 : i4, "porn"), r2 = Object.keys(e3).find((e4) => e4 === n2);
                  this.emit(SU.INSPECT_RESULT, r2);
                } else
                  this.emit(SU.INSPECT_RESULT, void 0, new XN(_w.UNEXPECTED_RESPONSE, i3.code + "", "There is an unexpected data on message"));
              } else
                this.emit(SU.INSPECT_RESULT, void 0, new XN(_w.UNEXPECTED_RESPONSE, i3.code + "", i3.msg));
            } else
              BN.error("[".concat(this._inspectId, "] Unexpected message type from worker")), this.emit(SU.INSPECT_RESULT, void 0, new XN(_w.UNEXPECTED_RESPONSE, "invalid worker message type"));
          }), this.workerConnection.on(UM.CLOSED, () => {
            this.connectionState = mU.CLOSED;
          }), this.workerConnection.on(UM.FAILED, () => {
            this.connectionState = mU.CLOSED;
          }), this.workerConnection.on(UM.RECONNECTING, () => {
            this.connectionState = this.connectionState === mU.CONNECTED ? mU.RECONNECTING : mU.CONNECTING;
          }), this.workerConnection.on(UM.WILL_RECONNECT, (e2, t2, i3) => {
            "recover" === e2 && i3(e2), i3("tryNext");
          }), this.workerConnection.on(UM.REQUEST_NEW_URLS, (e2, t2) => {
            this.workerManagerConnection.close(), this.once(SU.REQUEST_NEW_WORKER_URL, (t3) => {
              e2([t3]);
            }), this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then((e3) => {
              this.connectWorkerManager(e3, true);
            }).catch((e3) => {
              t2(e3);
            });
          });
        }
        async requestToInspectImage() {
          this.sequence++;
          const e2 = qw(this, SU.CLIENT_LOCAL_VIDEO_TRACK), t2 = { appId: this._connectInfo.appId, cname: this._connectInfo.cname, cid: this._connectInfo.cid, sid: this._connectInfo.sid, uid: this._connectInfo.uid, vid: this._connectInfo.vid };
          if (e2) {
            if (!e2.isPlaying)
              return void this.emit(SU.INSPECT_RESULT, void 0, new XN(_w.INVALID_OPERATION, "Only the track being played can be inspected"));
            const i3 = await this.generateRequestData(e2, t2);
            this.workerConnection.sendMessage(i3, true, true);
          } else
            this.emit(SU.INSPECT_RESULT, void 0, new XN(_w.INVALID_OPERATION, "Only the track being published can be inspected"));
        }
        async generateRequestData(e2, t2) {
          let { appId: i3, cname: n2, cid: r2, vid: o2, sid: s2, uid: a2 } = t2;
          const c2 = Date.now(), d2 = await e2.getCurrentFrameImage("image/jpeg", this.quality), l2 = await OP(d2, i3, n2), u2 = this.sequence + "-" + r2 + "-" + a2 + "-" + c2 + "-" + uO(12, ""), h2 = { appId: i3, cid: r2, cname: n2, deviceId: "", elapse: (p3 = Number(c2 - this.inspectStartTime), { low: p3 |= 0, high: p3 >> 31, unsigned: p3 >= 0 }), fileSize: l2.byteLength, jpgEncryption: 2, height: d2.height, width: d2.width, jpg: l2, networkType: 6, osType: 7, requestId: u2, sdkVersion: "4.23.0", sequence: this.sequence, sid: s2, timestamp: sj(c2), uid: a2, vid: o2, service: this._inspectMode, callbackData: this.extraInfo, ossFilePrefix: this.ossFilePrefix };
          var p3;
          void 0 === this.extraInfo && delete h2.callbackData, void 0 === this.ossFilePrefix && delete h2.ossFilePrefix;
          const _2 = tY(h2);
          if (_2.byteLength < this.workerMessageLengthLimit) {
            if (dN("SHOW_VIDEO_INSPECT_WORKER_MESSAGE")) {
              const e3 = function(e4) {
                for (var t3 = 1; t3 < arguments.length; t3++) {
                  var i4 = null != arguments[t3] ? arguments[t3] : {};
                  t3 % 2 ? wY(Object(i4), true).forEach(function(t4) {
                    QI(e4, t4, i4[t4]);
                  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(i4)) : wY(Object(i4)).forEach(function(t4) {
                    Object.defineProperty(e4, t4, Object.getOwnPropertyDescriptor(i4, t4));
                  });
                }
                return e4;
              }({}, h2);
              delete e3.jpg, BN.debug("[".concat(this._inspectId, "] Request message for worker of inspect content "), JSON.stringify(e3));
            }
            return _2;
          }
          {
            const t3 = this.quality * this.qualityRatio;
            return this.quality = t3, await this.generateRequestData(e2, { appId: i3, cname: n2, cid: r2, vid: o2, sid: s2, uid: a2 });
          }
        }
        close() {
          this._cancelTokenSource.cancel(), this._cancelTokenSource = Ab.CancelToken.source(), this.workerManagerConnection && this.workerManagerConnection.close(), this.workerConnection && this.workerConnection.close(), this.inspectTimer && window.clearInterval(this.inspectTimer), this.inspectTimer = null, this.connectionState = mU.CLOSED, this.emit(SU.STATE_CHANGE, TU.CLOSED);
        }
      }
      const DY = { name: "ContentInspect", create: function(e2) {
        let { config: t2 } = e2;
        return function(e3) {
          if (!e3)
            throw new XN(_w.INVALID_PARAMS, "inspectConfig is necessary.");
          if (!e3.inspectType || !Array.isArray(e3.inspectType))
            throw new XN(_w.INVALID_PARAMS, "inspectConfig.inspectType is necessary and is an instance of Array.");
          {
            const t3 = [...new Set(e3.inspectType)];
            t3.forEach((e4) => {
              var t4;
              if (!Dn(t4 = ["supervise", "moderation"]).call(t4, e4))
                throw new XN(_w.INVALID_PARAMS, "".concat(e4, " is not a valid inspect type."));
            }), e3.inspectType = t3;
          }
          if (e3 && e3.extraInfo && e3.extraInfo.length > 1024)
            throw new XN(_w.INVALID_PARAMS, "inspectConfig.extraInfo length cannot exceed 1024 bytes");
        }(t2), new NY(t2);
      } };
      var PY = i2(ie.Object.getOwnPropertySymbols), LY = wi, kY = qi.indexOf, MY = Bn, UY = I([].indexOf), xY = !!UY && 1 / UY([1], 1, -0) < 0;
      LY({ target: "Array", proto: true, forced: xY || !MY("indexOf") }, { indexOf: function(e2) {
        var t2 = arguments.length > 1 ? arguments[1] : void 0;
        return xY ? UY(this, e2, t2) || 0 : kY(this, e2, t2);
      } });
      var VY = Ji("Array").indexOf, FY = l, BY = VY, jY = Array.prototype, GY = function(e2) {
        var t2 = e2.indexOf;
        return e2 === jY || FY(jY, e2) && t2 === jY.indexOf ? BY : t2;
      }, WY = i2(GY);
      function HY(e2, t2) {
        if (null == e2)
          return {};
        var i3, n2, r2 = function(e3, t3) {
          if (null == e3)
            return {};
          var i4, n3, r3 = {}, o3 = tM(e3);
          for (n3 = 0; n3 < o3.length; n3++)
            i4 = o3[n3], WY(t3).call(t3, i4) >= 0 || (r3[i4] = e3[i4]);
          return r3;
        }(e2, t2);
        if (PY) {
          var o2 = PY(e2);
          for (n2 = 0; n2 < o2.length; n2++)
            i3 = o2[n2], WY(t2).call(t2, i3) >= 0 || Object.prototype.propertyIsEnumerable.call(e2, i3) && (r2[i3] = e2[i3]);
        }
        return r2;
      }
      let KY = class {
        get localCapabilities() {
          return $w(this._localCapabilities);
        }
        get rtpCapabilities() {
          return $w(this._rtpCapabilities);
        }
        get candidates() {
          return $w(this._candidates);
        }
        get iceParameters() {
          return $w(this._iceParameters);
        }
        get dtlsParameters() {
          return $w(this._dtlsParameters);
        }
        constructor(e2) {
          QI(this, "sessionDesc", void 0), QI(this, "_localCapabilities", void 0), QI(this, "_rtpCapabilities", void 0), QI(this, "_candidates", void 0), QI(this, "_iceParameters", void 0), QI(this, "_dtlsParameters", void 0), QI(this, "setup", void 0), QI(this, "currentMidIndex", void 0), QI(this, "cname", "o/i14u9pJrxRKAsu"), QI(this, "firefoxSsrcMidMap", /* @__PURE__ */ new Map()), e2 = $w(e2);
          const { remoteIceParameters: t2, remoteDtlsParameters: i3, candidates: n2, remoteRTPCapabilities: r2, localCapabilities: o2, direction: s2, setup: a2, videoCodec: c2, audioCodec: d2 } = e2;
          let l2;
          this.setup = a2, l2 = s2 === MM.RECEIVE_ONLY ? SN("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0 1\na=msid-semantic: WMS\na=extmap-allow-mixed\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:0\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:1\n") : SN("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0 1\na=msid-semantic: WMS\na=extmap-allow-mixed\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=recvonly\na=rtcp-mux\na=rtcp-rsize\na=mid:0\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=recvonly\na=rtcp-mux\na=rtcp-rsize\na=mid:1\n"), this._rtpCapabilities = r2, this._candidates = n2, this._iceParameters = t2, this._dtlsParameters = i3, this._localCapabilities = o2;
          const u2 = s2 === MM.RECEIVE_ONLY ? this.rtpCapabilities.send : this.rtpCapabilities.recv, h2 = s2 === MM.RECEIVE_ONLY ? this._localCapabilities.recv : this._localCapabilities.send, p3 = s2 === MM.RECEIVE_ONLY ? r2.send.videoCodecs : Nx(lU.VIDEO, u2, h2, c2), _2 = s2 === MM.RECEIVE_ONLY ? r2.send.audioCodecs : Nx(lU.AUDIO, u2, h2, d2);
          for (const e3 of l2.mediaDescriptions)
            e3.attributes.iceUfrag = t2.iceUfrag, e3.attributes.icePwd = t2.icePwd, e3.attributes.fingerprints = i3.fingerprints, e3.attributes.candidates = n2, e3.attributes.setup = this.setup, "application" === e3.media.mediaType && (e3.attributes.sctpPort = "5000"), "video" === e3.media.mediaType && (e3.media.fmts = p3.map((e4) => e4.payloadType.toString(10)), e3.attributes.payloads = p3, e3.attributes.extmaps = u2.videoExtensions), "audio" === e3.media.mediaType && (e3.media.fmts = _2.map((e4) => e4.payloadType.toString(10)), e3.attributes.payloads = _2, e3.attributes.extmaps = u2.audioExtensions, Ox(e3));
          this.sessionDesc = l2, this.currentMidIndex = l2.mediaDescriptions.length - 1;
        }
        toString() {
          return gN(this.sessionDesc);
        }
        hasMid(e2) {
          return Array.isArray(e2) ? e2.every((e3) => this.hasMid(e3)) : this.sessionDesc.mediaDescriptions.some((t2) => t2.attributes.mid === e2);
        }
        send(e2, t2, i3, n2, r2) {
          i3 = i3.replace(/ /g, "-");
          const { ssrcs: o2, ssrcGroups: s2 } = Tx(t2, this.cname, dN("SYNC_GROUP") ? i3 : void 0), a2 = this.findPreloadMediaDesc(o2);
          if (a2) {
            if (Kb() && this.firefoxSsrcMidMap.set(o2[0].ssrcId, a2.attributes.mid), r2 && (r2.twcc || r2.remb)) {
              const e3 = this.sessionDesc.mediaDescriptions.indexOf(a2);
              return this.sessionDesc.mediaDescriptions[e3] = this.mungSendMediaDesc(a2, r2), { mid: a2.attributes.mid, needExchangeSDP: true };
            }
            return { mid: a2.attributes.mid, needExchangeSDP: false };
          }
          {
            const t3 = this.findAvailableMediaIndex(e2, o2, n2);
            let i4;
            return -1 === t3 ? (i4 = this.createOrRecycleSendMedia(e2, o2, s2, "sendonly", n2, r2), this.updateBundleMids()) : (i4 = $w(this.sessionDesc.mediaDescriptions[t3]), i4.attributes.direction = "sendonly", i4.attributes.ssrcs = o2, i4.attributes.ssrcGroups = s2, this.sessionDesc.mediaDescriptions[t3] = this.mungSendMediaDesc(i4, r2)), Kb() && this.firefoxSsrcMidMap.set(o2[0].ssrcId, i4.attributes.mid), { needExchangeSDP: true, mid: i4.attributes.mid };
          }
        }
        stopSending(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => t3.attributes.mid && -1 !== e2.indexOf(t3.attributes.mid));
          if (t2.length !== e2.length)
            throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending.");
          t2.forEach((e3) => {
            e3.attributes.ssrcs = [];
          }), this.updateBundleMids();
        }
        receive(e2, t2, i3) {
          const n2 = [];
          return e2.forEach((e3) => {
            const r2 = e3._mediaStreamTrack.kind, o2 = this.findAvailableRecvMediaIndex(r2);
            let s2, a2 = false;
            -1 === o2 ? (a2 = true, s2 = this.createOrRecycleRecvMedia(e3, [], "recvonly", t2, i3), this.updateBundleMids()) : (s2 = $w(this.sessionDesc.mediaDescriptions[o2]), s2.attributes.direction = "recvonly"), n2.push({ mid: s2.attributes.mid, needCreateTransceiver: a2 });
          }), n2;
        }
        stopReceiving(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => -1 !== e2.indexOf(t3.attributes.mid));
          if (t2.length !== e2.length)
            throw new Error("MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive.");
          t2.forEach((e3) => {
            e3.media.port = "0", e3.attributes.direction = "inactive";
          }), this.updateBundleMids();
        }
        addRemoteCandidate(e2) {
          const { foundation: t2, protocol: i3, address: n2, port: r2, type: o2, relatedAddress: s2, relatedPort: a2, priority: c2 } = new RTCIceCandidate(e2), d2 = { foundation: null != t2 ? t2 : "", componentId: "1", transport: null != i3 ? i3 : "", priority: c2 ? c2 + "" : "", connectionAddress: null != n2 ? n2 : "", port: r2 ? r2 + "" : "", type: o2 ? o2 + "" : "", relAddr: null != s2 ? s2 : "", relPort: a2 ? a2 + "" : "", extension: {} };
          this.candidates.some((e3) => e3.priority === d2.priority && e3.connectionAddress === d2.connectionAddress && e3.port === d2.port) || (this._candidates.push(d2), this.sessionDesc.mediaDescriptions.forEach((e3) => {
            e3.attributes.candidates = this.candidates;
          }));
        }
        clearRemoteCandidate() {
          this._candidates = [], this.sessionDesc.mediaDescriptions[0].attributes.candidates = this._candidates;
        }
        createOrRecycleRecvMedia(e2, t2, i3, n2, r2) {
          const o2 = e2._mediaStreamTrack.kind, s2 = this.rtpCapabilities.recv, a2 = Nx(o2, s2, this.localCapabilities.send, o2 === lU.AUDIO ? r2 : n2), c2 = o2 === lU.VIDEO ? s2.videoExtensions : s2.audioExtensions, d2 = "".concat(++this.currentMidIndex);
          let l2 = { media: { mediaType: o2, port: "9", protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: a2.map((e3) => e3.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: [], extmaps: c2, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t2, ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: a2, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: i3, rtcpMux: true, rtcpRsize: true, mid: "".concat(d2) } };
          l2 = this.mungRecvMediaDsec(l2, e2);
          const u2 = this.findFirstClosedMedia(o2);
          if (u2) {
            const e3 = this.sessionDesc.mediaDescriptions.indexOf(u2);
            this.sessionDesc.mediaDescriptions[e3] = l2;
          } else
            this.sessionDesc.mediaDescriptions.push(l2);
          return l2;
        }
        muteRemote(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => Dn(e2).call(e2, t3.attributes.mid || ""));
          if (t2.length !== e2.length)
            throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
          t2.forEach((e3) => {
            e3.attributes.direction = "inactive";
          });
        }
        unmuteRemote(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => Dn(e2).call(e2, t3.attributes.mid || ""));
          if (t2.length !== e2.length)
            throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
          t2.forEach((e3) => {
            e3.attributes.direction = "recvonly";
          });
        }
        findAvailableMediaIndex(e2, t2, i3) {
          return this.sessionDesc.mediaDescriptions.findIndex((n2) => {
            const r2 = n2.media.mediaType === e2 && "0" !== n2.media.port && ("sendonly" === n2.attributes.direction || "sendrecv" === n2.attributes.direction) && 0 === n2.attributes.ssrcs.length;
            if (Kb()) {
              if (r2) {
                const e3 = this.firefoxSsrcMidMap.get(t2[0].ssrcId);
                return !(e3 || "0" !== n2.attributes.mid && "1" !== n2.attributes.mid) || !(!e3 || e3 !== n2.attributes.mid);
              }
              return false;
            }
            return r2 && n2.attributes.mid === i3;
          });
        }
        findAvailableRecvMediaIndex(e2) {
          return this.sessionDesc.mediaDescriptions.findIndex((t2) => {
            const i3 = t2.media.mediaType === e2 && "0" !== t2.media.port && ("recvonly" === t2.attributes.direction || "sendrecv" === t2.attributes.direction);
            return "0" !== t2.attributes.mid && "1" !== t2.attributes.mid && i3;
          });
        }
        predictReceivingMids(e2) {
          const t2 = [];
          for (let i3 = 0; i3 < e2; i3++)
            t2.push((this.currentMidIndex + i3 + 1).toString(10));
          return t2;
        }
        restartICE(e2) {
          e2 = $w(e2), this._iceParameters = e2, this.sessionDesc.mediaDescriptions.forEach((t2) => {
            t2.attributes.iceUfrag = e2.iceUfrag, t2.attributes.icePwd = e2.icePwd;
          });
        }
        createOrRecycleSendMedia(e2, t2, i3, n2, r2, o2) {
          const s2 = this.rtpCapabilities.send, a2 = e2 === lU.VIDEO ? s2.videoCodecs : s2.audioCodecs, c2 = e2 === lU.VIDEO ? s2.videoExtensions : s2.audioExtensions;
          Kb() && (r2 = "".concat(++this.currentMidIndex));
          let d2 = { media: { mediaType: e2, port: "9", protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: a2.map((e3) => e3.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: [], extmaps: c2, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t2, ssrcGroups: i3, rtcpFeedbackWildcards: [], payloads: a2, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: n2, rtcpMux: true, rtcpRsize: true, mid: r2 } };
          d2 = this.mungSendMediaDesc(d2, o2);
          const l2 = this.findFirstClosedMedia(e2);
          if (l2) {
            const e3 = this.sessionDesc.mediaDescriptions.indexOf(l2);
            this.sessionDesc.mediaDescriptions[e3] = d2;
          } else
            this.sessionDesc.mediaDescriptions.push(d2);
          return d2;
        }
        mungRecvMediaDsec(e2, t2, i3) {
          const n2 = $w(e2);
          return gx(n2), Sx(n2, t2), Rx(n2, t2), Cx(n2), vx(n2, i3, this.localCapabilities.send), n2;
        }
        mungSendMediaDesc(e2, t2) {
          const i3 = $w(e2);
          return vx(i3, t2, this.localCapabilities.recv), Ox(i3), i3;
        }
        updateRecvMedia(e2, t2) {
          const i3 = this.sessionDesc.mediaDescriptions.findIndex((t3) => t3.attributes.mid === e2);
          if (-1 !== i3) {
            const e3 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i3], t2);
            this.sessionDesc.mediaDescriptions[i3] = e3;
          }
        }
        updateBundleMids() {
          this.sessionDesc.attributes.groups[0].identificationTag = this.sessionDesc.mediaDescriptions.filter((e2) => "0" !== e2.media.port).map((e2) => e2.attributes.mid);
        }
        findPreloadMediaDesc(e2) {
          return this.sessionDesc.mediaDescriptions.find((t2) => {
            var i3;
            return (null === (i3 = t2.attributes) || void 0 === i3 || null === (i3 = i3.ssrcs[0]) || void 0 === i3 ? void 0 : i3.ssrcId) === e2[0].ssrcId;
          });
        }
        findFirstClosedMedia(e2) {
          return this.sessionDesc.mediaDescriptions.find((t2) => Kb() ? "0" === t2.media.port && t2.media.mediaType === e2 : "0" === t2.media.port);
        }
      };
      const YY = ["sdp"];
      var qY;
      function zY(e2, t2) {
        var i3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i3.push.apply(i3, n2);
        }
        return i3;
      }
      function XY(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i3 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? zY(Object(i3), true).forEach(function(t3) {
            QI(e2, t3, i3[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : zY(Object(i3)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
          });
        }
        return e2;
      }
      let JY = (qY = class e2 extends cU {
        get currentLocalDescription() {
          return this.peerConnection.currentLocalDescription;
        }
        get currentRemoteDescription() {
          return this.peerConnection.currentRemoteDescription;
        }
        get peerConnectionState() {
          return this.peerConnection.connectionState;
        }
        get iceConnectionState() {
          return this.peerConnection.iceConnectionState;
        }
        get dtlsTransportState() {
          var e3, t2;
          return null !== (e3 = null === (t2 = this.peerConnection.getReceivers()[0]) || void 0 === t2 || null === (t2 = t2.transport) || void 0 === t2 ? void 0 : t2.state) && void 0 !== e3 ? e3 : null;
        }
        get localCodecs() {
          return [];
        }
        set isInRestartIce(e3) {
          this._isInRestartIce = e3;
        }
        get isInRestartIce() {
          return this._isInRestartIce;
        }
        constructor(t2, i3, n2) {
          super(t2, i3), QI(this, "direction", void 0), QI(this, "name", void 0), QI(this, "store", void 0), QI(this, "spec", void 0), QI(this, "peerConnection", void 0), QI(this, "initialOffer", void 0), QI(this, "transport", void 0), QI(this, "statsFilter", void 0), QI(this, "localCandidateCount", 0), QI(this, "_isInRestartIce", false), QI(this, "mutex", void 0), QI(this, "onLocalCandidate", void 0), QI(this, "remoteSDP", void 0), QI(this, "pendingCandidates", []), QI(this, "localCapabilities", void 0), QI(this, "isReady", false), QI(this, "restartCnt", 0), QI(this, "curTurnServerIndex", 0), this.store = i3, this.spec = t2, this.mutex = new vO("P2PConnection-mutex", i3.clientId), this.peerConnection = new RTCPeerConnection(e2.resolvePCConfiguration(t2, i3.p2pTransport), { optional: [{ googDscp: true }] }), this.direction = null != n2 ? n2 : MM.SEND_ONLY, this.name = this.direction === MM.SEND_ONLY ? "sendP2PConnection" : "recvP2PConnection", this.statsFilter = eN(this.peerConnection, dN("STATS_UPDATE_INTERVAL"), void 0, Kb() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1;
        }
        async establish(e3) {
          try {
            const t2 = await yx();
            if (this.localCapabilities = wx(t2), e3) {
              const { sdp: t3 } = e3, i3 = HY(e3, YY), n2 = function() {
                const e4 = { audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: [] }, t4 = px(arguments.length > 2 ? arguments[2] : void 0, arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, "sendonly"), i4 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, n3 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, r3 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] };
                if (bx(t4, e4, "videoExtensions", i4, n3, r3), bx(t4, e4, "videoCodecs", i4, n3, r3), bx(t4, e4, "audioExtensions", i4, n3, r3), bx(t4, e4, "audioCodecs", i4, n3, r3), dN("RAISE_H264_BASELINE_PRIORITY")) {
                  const e5 = r3.videoCodecs.findIndex((e6) => e6.rtpMap && "h264" === e6.rtpMap.encodingName.toLocaleLowerCase() && e6.fmtp && "42001f" === e6.fmtp.parameters["profile-level-id"]);
                  if (-1 !== e5) {
                    const t5 = r3.videoCodecs.findIndex((e6) => e6.rtpMap && "h264" === e6.rtpMap.encodingName.toLocaleLowerCase());
                    if (t5 < e5) {
                      BN.debug("raising H264 baseline profile priority");
                      const i5 = r3.videoCodecs[e5];
                      r3.videoCodecs.splice(e5, 1), r3.videoCodecs.splice(t5, 0, i5);
                    }
                    -1 !== t5 && dN("FILTER_SEND_H264_BASELINE") && (i4.videoCodecs = i4.videoCodecs.filter((e6) => !(e6.rtpMap && "h264" === e6.rtpMap.encodingName.toLocaleLowerCase() && e6.fmtp && "42001f" !== e6.fmtp.parameters["profile-level-id"])));
                  }
                }
                return { send: i4, recv: n3, sendrecv: r3 };
              }({}, {}, t3);
              this.remoteSDP = new KY({ remoteIceParameters: i3.iceParameters, remoteDtlsParameters: i3.dtlsParameters, candidates: [], remoteRTPCapabilities: n2, localCapabilities: this.localCapabilities, direction: this.direction, setup: "actpass", videoCodec: this.store.codec, audioCodec: this.store.audioCodec }), await this.setRemoteDescription({ type: "offer", sdp: this.remoteSDP.toString() }), this.isReady = true;
              const r2 = await this.peerConnection.createAnswer();
              if (!r2.sdp)
                throw new Error("Cannot get answer sdp when trying to establish PeerConnection.");
              const o2 = _x(r2.sdp);
              await this.peerConnection.setLocalDescription(r2);
              const s2 = await Ax({}, {}, r2.sdp);
              this.localCapabilities = wx(s2);
              const a2 = this.peerConnection.getTransceivers()[0];
              return null != a2 && a2.receiver && a2.receiver.transport && this.tryBindTransportEvents(a2.receiver.transport), XY(XY({}, o2), {}, { sdp: r2.sdp });
            }
            {
              this.peerConnection.addTransceiver("video", { direction: "sendonly" }), this.peerConnection.addTransceiver("audio", { direction: "sendonly" });
              const e4 = await this.peerConnection.createOffer();
              if (!e4.sdp)
                throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
              const t3 = _x(e4.sdp);
              return this.initialOffer = e4, XY(XY({}, t3), {}, { sdp: e4.sdp });
            }
          } catch (e4) {
            throw new Ew(_w.GET_LOCAL_CONNECTION_PARAMS_FAILED, e4.toString());
          }
        }
        async connect(e3) {
          try {
            if (!this.initialOffer)
              throw new Error("Cannot establish P2PConnection without initial offer.");
            await this.peerConnection.setLocalDescription(this.initialOffer);
            const { sdp: t2, iceParameters: i3, dtlsParameters: n2 } = e3, r2 = await Ax({}, {}, t2);
            this.remoteSDP = new KY({ remoteIceParameters: i3, remoteDtlsParameters: n2, candidates: [], remoteRTPCapabilities: r2, localCapabilities: this.localCapabilities, direction: this.direction, setup: "active", videoCodec: this.store.codec, audioCodec: this.store.audioCodec }), await this.setRemoteDescription({ type: "answer", sdp: this.remoteSDP.toString() });
            const o2 = this.peerConnection.getTransceivers()[0];
            null != o2 && o2.sender && o2.sender.transport && this.tryBindTransportEvents(o2.sender.transport);
          } catch (e4) {
            throw new Ew(_w.EXCHANGE_SDP_FAILED, "P2PConnection.connect failed; ".concat(e4.toString()));
          }
        }
        async addRemoteCandidate(e3) {
          try {
            e3 && this.pendingCandidates.push(e3), this.peerConnection.remoteDescription && this.isReady && (this.pendingCandidates.forEach((e4) => {
              this.peerConnection.addIceCandidate(e4);
            }), this.pendingCandidates = []);
          } catch (e4) {
            throw new Ew(_w.ADD_CANDIDATE_FAILED, "P2PConnection.addRemoteCandidate failed; ".concat(e4.toString()));
          }
        }
        send(e3, t2, i3) {
          var n2 = this;
          return FA(function* () {
            const r2 = yield BA(n2.mutex.lock("From P2PConnection.send"));
            try {
              if (!n2.remoteSDP)
                throw new Error("Cannot call P2PConnection.send before remote SDP created");
              const o2 = [], s2 = n2.remoteSDP.receive(e3, t2, i3);
              e3.forEach((e4, t3) => {
                if (s2[t3].needCreateTransceiver) {
                  const t4 = n2.peerConnection.addTransceiver(e4._mediaStreamTrack, { direction: "sendonly" });
                  o2.push(t4), e4._updateRtpTransceiver(t4);
                } else {
                  const i4 = n2.peerConnection.getTransceivers().find((e5) => e5.mid === s2[t3].mid);
                  if (!i4)
                    throw new Error("cannot find transceiver when sendPeerconnection send, mid is ".concat(s2[t3].mid));
                  o2.push(i4), e4._updateRtpTransceiver(i4);
                }
              }), Kb() && true === dN("SIMULCAST") && (yield BA(n2.applySimulcastForFirefox(o2, e3)));
              const a2 = s2.map((e4) => e4.mid), c2 = yield BA(n2.peerConnection.createOffer()), d2 = n2.mungSendOfferSDP(c2.sdp, e3, a2), l2 = SN(d2), u2 = a2.map((e4) => {
                const t3 = l2.mediaDescriptions.find((t4) => t4.attributes.mid === e4);
                if (!t3)
                  throw new Error("Cannot extract ssrc from mediaDescription.");
                return Ex(t3, dN("USE_PUB_RTX"));
              }), h2 = o2.map((e4, t3) => {
                const i4 = a2[t3];
                return { localSSRC: u2[t3], id: i4 };
              });
              yield BA(n2.peerConnection.setLocalDescription({ type: "offer", sdp: d2 }));
              try {
                yield h2;
              } catch (e4) {
                const t3 = n2.remoteSDP.toString();
                throw yield BA(n2.peerConnection.setLocalDescription({ type: "offer", sdp: d2 })), yield BA(n2.peerConnection.setRemoteDescription({ type: "answer", sdp: t3 })), yield BA(n2.stopSending(a2, true)), e4;
              }
              yield BA(n2.applySimulcastEncodings(o2, e3)), yield BA(n2.applySendEncodings(o2, e3));
              const p3 = n2.remoteSDP.toString(), _2 = n2.logSDPExchange(d2, "offer", "local", "send");
              return null == _2 || _2(p3), yield BA(n2.setRemoteDescription({ type: "answer", sdp: p3 })), o2.map((e4, t3) => {
                const i4 = a2[t3];
                return { localSSRC: u2[t3], id: i4 };
              });
            } catch (e4) {
              throw e4 instanceof Ew ? e4 : new Ew(_w.EXCHANGE_SDP_FAILED, "P2PConnection.send failed; ".concat(e4.toString()));
            } finally {
              r2();
            }
          })();
        }
        async stopSending(e3, t2) {
          const i3 = t2 ? void 0 : await this.mutex.lock("From P2PConnection.stopSending");
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.stopSending before remote SDP created");
            const t3 = this.peerConnection.getTransceivers().filter((t4) => -1 !== e3.indexOf(t4.mid));
            if (t3.length !== e3.length)
              throw new Error("Transceivers' length (".concat(t3.length, ") doesn't match mids' length (").concat(e3.length, ") when trying to call P2PConnection.stopSending."));
            t3.map((e4) => {
              var t4;
              e4.direction = "inactive", null === (t4 = e4.stop) || void 0 === t4 || t4.call(e4);
            });
            const n2 = await this.peerConnection.createOffer(), r2 = this.logSDPExchange(n2.sdp || "", "offer", "local", "stopSending");
            await this.peerConnection.setLocalDescription(n2), this.remoteSDP.stopReceiving(e3);
            const o2 = this.remoteSDP.toString();
            null == r2 || r2(o2), await this.setRemoteDescription({ type: "answer", sdp: o2 });
          } catch (e4) {
            throw new Ew(_w.EXCHANGE_SDP_FAILED, "P2PConnection.stopSending failed; ".concat(e4.toString()));
          } finally {
            i3 && i3();
          }
        }
        async receive(e3, t2, i3, n2) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.receive ".concat(e3, " before remoteSDP created."));
            const { mid: r2, needExchangeSDP: o2 } = this.remoteSDP.send(e3, t2, i3, n2);
            if (o2) {
              const t3 = this.remoteSDP.toString(), i4 = this.logSDPExchange(t3, "offer", "remote", "receive");
              await this.setRemoteDescription({ type: "offer", sdp: t3 });
              const n3 = await this.peerConnection.createAnswer(), o3 = this.mungReceiveAnswerSDP(n3.sdp, r2, e3);
              null == i4 || i4(o3 || ""), await this.peerConnection.setLocalDescription({ type: "answer", sdp: o3 }), BN.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e3, " by exchanging SDP."));
            } else
              BN.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e3, " no need to exchange SDP."));
            const s2 = this.peerConnection.getTransceivers().find((e4) => e4.mid === r2);
            if (!s2 || null === s2.mid)
              throw new Error("Cannot get transceiver after setLocalDescription.");
            return { track: s2.receiver.track, mid: s2.mid, transceiver: s2 };
          } catch (e4) {
            throw new Ew(_w.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e4.toString()));
          }
        }
        async mockReceive(e3, t2, i3, n2) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.receive ".concat(e3, " before remoteSDP created."));
            const { mid: r2, needExchangeSDP: o2 } = this.remoteSDP.send(e3, t2, i3, n2);
            if (o2) {
              const t3 = this.remoteSDP.toString(), i4 = this.logSDPExchange(t3, "offer", "remote", "receive");
              await this.setRemoteDescription({ type: "offer", sdp: t3 });
              const n3 = await this.peerConnection.createAnswer(), o3 = this.mungReceiveAnswerSDP(n3.sdp, r2, e3);
              null == i4 || i4(o3 || ""), await this.peerConnection.setLocalDescription({ type: "answer", sdp: o3 }), BN.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e3, " by exchanging SDP."));
            } else
              BN.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e3, " no need to exchange SDP."));
          } catch (e4) {
            throw new Ew(_w.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e4.toString()));
          }
        }
        async stopReceiving(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
            this.remoteSDP.stopSending(e3);
            const t2 = this.remoteSDP.toString(), i3 = this.logSDPExchange(t2, "offer", "remote", "stopReceiving");
            await this.setRemoteDescription({ type: "offer", sdp: t2 });
            const n2 = await this.peerConnection.createAnswer();
            null == i3 || i3(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
          } catch (e4) {
            throw new Ew(_w.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e4.toString()));
          }
        }
        async restartICE(t2) {
          try {
            if (this.store.p2pTransport === nN.Auto && (this.store.p2pTransport = nN.SdRtn, QN().supportPCSetConfiguration && this.peerConnection.setConfiguration(e2.resolvePCConfiguration(this.spec, this.store.p2pTransport))), this.restartCnt > 3 && (this.restartCnt = 0, QN().supportPCSetConfiguration && this.peerConnection.setConfiguration(e2.resolvePCConfiguration(this.spec, this.store.p2pTransport, ++this.curTurnServerIndex))), !t2) {
              this.restartCnt++, this.isReady = false;
              const e3 = await this.peerConnection.createOffer({ iceRestart: true });
              if (!e3.sdp)
                throw new Error("Cannot restartICE because restart offer SDP does not exist.");
              const { iceParameters: t3 } = _x(e3.sdp);
              return this.store.descriptionStart(), this.direction === MM.SEND_ONLY && await this.peerConnection.setLocalDescription(e3), t3;
            }
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
            if (this.remoteSDP.restartICE(t2), this.store.descriptionStart(), this.direction === MM.RECEIVE_ONLY) {
              this.restartCnt++, await this.setRemoteDescription({ type: "offer", sdp: this.remoteSDP.toString() });
              const e3 = await this.peerConnection.createAnswer();
              if (!e3.sdp)
                throw new Error("Cannot get answer sdp when trying to iceRestart.");
              const { iceParameters: t3 } = _x(e3.sdp);
              return await this.peerConnection.setLocalDescription(e3), t3;
            }
            await this.setRemoteDescription({ type: "answer", sdp: this.remoteSDP.toString() }), this.isReady = true;
          } catch (e3) {
            throw new Ew(_w.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e3.toString()));
          }
        }
        close() {
          var e3;
          this.peerConnection.close(), this.peerConnection.onicecandidate = null, null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, "closed"), this.tryUnbindTransportEvents(), this.unbindPCEvents(), this.unbindStatsEvents(), this.transport = void 0, this.statsFilter.destroy();
        }
        getStats() {
          return this.statsFilter.getStats();
        }
        getRemoteVideoIsReady(e3) {
          return this.statsFilter.getVideoIsReady(e3);
        }
        async updateEncoderConfig(e3, t2) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created.");
            const i3 = await this.peerConnection.createOffer(), n2 = this.mungSendOfferSDP(i3.sdp, [t2], [e3]);
            this.remoteSDP.updateRecvMedia(e3, t2);
            const r2 = this.remoteSDP.toString(), o2 = this.logSDPExchange(n2, "offer", "local", "updateEncoderConfig");
            await this.peerConnection.setLocalDescription({ type: "offer", sdp: n2 }), null == o2 || o2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e4) {
            throw new Ew(_w.EXCHANGE_SDP_FAILED, e4.toString());
          }
        }
        async updateSendParameters(e3, t2) {
          const i3 = this.peerConnection.getTransceivers().filter((t3) => t3.mid === e3);
          1 === i3.length && (this.isVP8Simulcast(t2) ? Kb() || await this.applySimulcastEncodings(i3, [t2]) : await this.applySendEncodings(i3, [t2]));
        }
        setStatsRemoteVideoIsReady(e3, t2) {
          this.statsFilter.setVideoIsReady2(e3, t2);
        }
        async replaceTrack(e3, t2) {
          const i3 = this.peerConnection.getTransceivers().find((e4) => e4.mid === t2);
          i3 && await i3.sender.replaceTrack(e3._mediaStreamTrack);
        }
        async getSelectedCandidatePair() {
          const e3 = this.peerConnection.getReceivers();
          if (e3.length > 0 && e3[0].transport && e3[0].transport.iceTransport && e3[0].transport.iceTransport.getSelectedCandidatePair && e3[0].transport.iceTransport.getSelectedCandidatePair()) {
            const t2 = e3[0].transport.iceTransport, { local: i3, remote: n2 } = t2.getSelectedCandidatePair();
            return { local: XY(XY({}, VO), {}, { candidateType: i3.type, protocol: i3.protocol, address: i3.address, port: i3.port }), remote: XY(XY({}, VO), {}, { candidateType: n2.type, protocol: n2.protocol, address: n2.address, port: n2.port }) };
          }
          return this.statsFilter.getSelectedCandidatePair();
        }
        bindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = () => {
            var e3, t2;
            Dn(e3 = ["connected", "completed"]).call(e3, this.peerConnection.iceConnectionState) && (this.isReady = false), null === (t2 = this.onICEConnectionStateChange) || void 0 === t2 || t2.call(this, this.peerConnection.iceConnectionState);
          }, this.peerConnection.onconnectionstatechange = () => {
            var e3;
            "connected" === this.peerConnection.connectionState && (this.restartCnt = 0), null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, this.peerConnection.connectionState);
          }, this.startICECandidate();
        }
        startICECandidate() {
          this.peerConnection.onicecandidate || (this.localCandidateCount = 0, this.peerConnection.onicecandidate = (e3) => {
            if (e3.candidate) {
              var t2;
              if (e3.candidate.candidate)
                null === (t2 = this.onLocalCandidate) || void 0 === t2 || t2.call(this, e3.candidate.toJSON());
              this.localCandidateCount += 1;
            } else
              BN.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount);
          });
        }
        unbindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
        }
        static resolvePCConfiguration(t2, i3) {
          let n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
          const r2 = { iceServers: [] };
          var o2;
          t2.iceServers ? r2.iceServers = t2.iceServers : t2.turnServer && "off" !== t2.turnServer.mode && (Vw(t2.turnServer.servers) ? r2.iceServers = t2.turnServer.servers : (r2.iceServers && r2.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.servers, i3, n2)), dN("USE_TURN_SERVER_OF_GATEWAY") && r2.iceServers && t2.turnServer.serversFromGateway && r2.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.serversFromGateway, i3, n2)), Dn(o2 = [nN.Relay, nN.SdRtn]).call(o2, i3) && (r2.iceTransportPolicy = "relay"), dN("FORCE_TURN_TCP") ? r2.iceTransportPolicy = "relay" : t2.turnServer.servers.concat(t2.turnServer.serversFromGateway || []).forEach((e3) => {
            e3.forceturn && (r2.iceTransportPolicy = "relay");
          })));
          return dN("ENABLE_ENCODED_TRANSFORM") && QN().supportWebRTCEncodedTransform && (r2.encodedInsertableStreams = true), BN.debug("P2PConnection p2pTransport is ".concat(i3)), r2;
        }
        static turnServerConfigToIceServers(e3, t2) {
          let i3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
          const n2 = [], r2 = e3.filter((e4) => e4.tcpport);
          BN.debug("P2PConnection turnServers is ".concat(r2, ", current index is ").concat(i3));
          const o2 = r2.length > i3 ? r2[i3] : r2[0];
          switch (t2) {
            case nN.SdRtn:
              const t3 = e3.filter((e4) => {
                var t4;
                return Dn(t4 = e4.username).call(t4, "glb:") && e4.turnServerURL == e4.turnServerURL;
              }), r3 = t3.length > i3 ? t3[i3] : t3[0];
              r3 && (n2.push({ username: r3.username, credential: r3.password, credentialType: "password", urls: "turn:".concat(JU(r3.turnServerURL), ":").concat(r3.tcpport, "?transport=udp") }), n2.push({ username: r3.username, credential: r3.password, credentialType: "password", urls: "turns:".concat(JU(r3.turnServerURL), ":").concat(r3.tcpport, "?transport=tcp") }));
              break;
            case nN.Relay:
              o2 && (n2.push({ username: o2.username, credential: o2.password, credentialType: "password", urls: "turn:".concat(o2.turnServerURL, ":").concat(o2.tcpport, "?transport=udp") }), n2.push({ username: o2.username, credential: o2.password, credentialType: "password", urls: "turns:".concat(JU(o2.turnServerURL), ":").concat(o2.tcpport, "?transport=tcp") }));
              break;
            default:
              o2 && (n2.push({ username: o2.username, credential: o2.password, credentialType: "password", urls: "turn:".concat(o2.turnServerURL, ":").concat(o2.tcpport, "?transport=udp") }), n2.push({ username: o2.username, credential: o2.password, credentialType: "password", urls: "turns:".concat(JU(o2.turnServerURL), ":").concat(o2.tcpport, "?transport=tcp") }), n2.push({ username: o2.username, credential: o2.password, credentialType: "password", urls: "stun:".concat(o2.turnServerURL, ":").concat(o2.tcpport) }));
          }
          return n2;
        }
        tryBindTransportEvents(e3) {
          if (e3) {
            this.transport = e3, e3.onstatechange = () => {
              var t3;
              null != e3 && e3.state && (null === (t3 = this.onDTLSTransportStateChange) || void 0 === t3 || t3.call(this, e3.state));
            }, e3.onerror = (e4) => {
              var t3;
              null === (t3 = this.onDTLSTransportError) || void 0 === t3 || t3.call(this, "error" in e4 ? e4.error : e4);
            };
            const t2 = e3.iceTransport;
            t2 && (t2.onstatechange = () => {
              const t3 = null == e3 ? void 0 : e3.iceTransport.state;
              var i3;
              t3 && (null === (i3 = this.onICETransportStateChange) || void 0 === i3 || i3.call(this, t3));
            }, t2.getSelectedCandidatePair && (t2.onselectedcandidatepairchange = () => {
              if (t2.getSelectedCandidatePair()) {
                const { local: e4, remote: i3 } = t2.getSelectedCandidatePair();
                BN.info("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] selectedcandidatepairchange: local ").concat(JSON.stringify({ candidateType: e4.type, protocol: e4.protocol }), ", remote ").concat(JSON.stringify({ candidateType: i3.type, protocol: i3.protocol, address: i3.address, port: i3.port }), " )"));
              }
            }));
          }
        }
        tryUnbindTransportEvents() {
          this.transport && (this.transport.onstatechange = null, this.transport.onerror = null, this.transport.iceTransport && (this.transport.iceTransport.onstatechange = null));
        }
        async updateRtpSenderEncodings(e3, t2) {
          var i3;
          if (!t2) {
            t2 = this.peerConnection.getSenders().find((t3) => t3.track === e3._mediaStreamTrack);
          }
          if (!t2)
            return BN.warn("[".concat(e3.getTrackId(), "] no rtpSender found}"));
          if (this.isVP8Simulcast(e3))
            return BN.warn("[updateRtpSenderEncodings] Track is VP8 simulcast, please apply simulcast encodings");
          if (!QN().supportSetRtpSenderParameters)
            return BN.warn("[updateRtpSenderEncodings] Browser not support set rtp-sender parameters");
          const n2 = {}, r2 = {};
          switch (e3._optimizationMode) {
            case "motion":
              n2.degradationPreference = "maintain-framerate";
              break;
            case "detail":
              n2.degradationPreference = "maintain-resolution";
              break;
            default:
              n2.degradationPreference = "balanced";
          }
          if (e3._encoderConfig) {
            var o2;
            const { bitrateMax: t3, frameRate: i4, scaleResolutionDownBy: n3 } = e3._encoderConfig;
            t3 && (r2.maxBitrate = 1e3 * t3), Dn(o2 = e3._hints).call(o2, fD.LOW_STREAM) && (i4 && (r2.maxFramerate = ZU(i4)), n3 && n3 >= 1 && (r2.scaleResolutionDownBy = n3));
          }
          if (dN("DSCP_TYPE") && cw()) {
            var s2;
            const e4 = dN("DSCP_TYPE");
            Dn(s2 = ["very-low", "low", "medium", "high"]).call(s2, e4) && (r2.networkPriority = e4);
          }
          const a2 = t2.getParameters(), c2 = null === (i3 = a2.encodings) || void 0 === i3 ? void 0 : i3[0];
          Kb() && !c2 && (n2.encodings = [r2]), c2 && Object.assign(c2, r2), Object.assign(a2, n2), BN.debug("[".concat(e3.getTrackId(), "] updateRtpSenderEncodings: ").concat(JSON.stringify(a2.encodings))), await t2.setParameters(a2);
        }
        async applySendEncodings(e3, t2) {
          try {
            if (!QN().supportSetRtpSenderParameters)
              return;
            if (e3.length !== t2.length)
              return;
            for (let i3 = 0; i3 < e3.length; i3++) {
              const n2 = e3[i3], r2 = t2[i3];
              r2 instanceof ak && !this.isVP8Simulcast(r2) && await this.updateRtpSenderEncodings(r2, n2.sender);
            }
          } catch (e4) {
            BN.debug("[".concat(this.store.clientId, "] Apply RTPSendEncodings failed."));
          }
        }
        mungSendOfferSDP(e3, t2, i3) {
          const n2 = SN(e3);
          return t2.forEach((e4, t3) => {
            const r2 = i3[t3], o2 = n2.mediaDescriptions.find((e5) => e5.attributes.mid === r2);
            o2 && (Sx(o2, e4), Ix(o2, e4, this.store.codec));
          }), gN(n2);
        }
        bindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = (e3) => {
            var t2;
            null === (t2 = this.onFirstAudioReceived) || void 0 === t2 || t2.call(this, e3);
          }, this.statsFilter.onFirstVideoReceived = (e3) => {
            var t2;
            null === (t2 = this.onFirstVideoReceived) || void 0 === t2 || t2.call(this, e3);
          }, this.statsFilter.onFirstAudioDecoded = (e3) => {
            var t2;
            null === (t2 = this.onFirstAudioDecoded) || void 0 === t2 || t2.call(this, e3);
          }, this.statsFilter.onFirstVideoDecoded = (e3, t2, i3) => {
            var n2;
            null === (n2 = this.onFirstVideoDecoded) || void 0 === n2 || n2.call(this, e3, t2, i3);
          }, this.statsFilter.onSelectedLocalCandidateChanged = (e3, t2) => {
            var i3;
            null === (i3 = this.onSelectedLocalCandidateChanged) || void 0 === i3 || i3.call(this, e3, t2);
          }, this.statsFilter.onSelectedRemoteCandidateChanged = (e3, t2) => {
            var i3;
            null === (i3 = this.onSelectedRemoteCandidateChanged) || void 0 === i3 || i3.call(this, e3, t2);
          }, this.statsFilter.onFirstVideoDecodedTimeout = (e3) => {
            var t2;
            null === (t2 = this.onFirstVideoDecodedTimeout) || void 0 === t2 || t2.call(this, e3);
          };
        }
        unbindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0, this.statsFilter.onFirstVideoDecodedTimeout = void 0;
        }
        async applySimulcastForFirefox(e3, t2) {
          if (e3.length === t2.length)
            for (let a2 = 0; a2 < e3.length; a2++) {
              var i3, n2, r2, o2, s2;
              const c2 = e3[a2], d2 = t2[a2];
              if (d2 instanceof ak && !Dn(i3 = d2._hints).call(i3, fD.LOW_STREAM) && null !== (n2 = d2._encoderConfig) && void 0 !== n2 && n2.bitrateMax && (null === (r2 = d2._encoderConfig) || void 0 === r2 ? void 0 : r2.bitrateMax) > 200 && null !== (o2 = d2._scalabilityMode) && void 0 !== o2 && o2.numSpatialLayers && (null === (s2 = d2._scalabilityMode) || void 0 === s2 ? void 0 : s2.numSpatialLayers) > 1 && "vp8" === this.store.codec) {
                const e4 = {}, t3 = { high: 1e3 * (d2._encoderConfig.bitrateMax - 50), medium: 5e4 };
                e4.encodings = [{ rid: "m", active: true, maxBitrate: t3.medium, scaleResolutionDownBy: 4 }, { rid: "h", active: true, maxBitrate: t3.high }];
                const i4 = c2.sender.getParameters();
                await c2.sender.setParameters(Object.assign(i4, e4));
              }
            }
        }
        async applySimulcastEncodings(e3, t2) {
          if (!Kb() && e3.length === t2.length)
            for (let i3 = 0; i3 < e3.length; i3++) {
              const n2 = t2[i3];
              if (n2 instanceof ak && this.isVP8Simulcast(n2)) {
                const t3 = e3[i3], r2 = {}, o2 = { high: 1e3 * (n2._encoderConfig.bitrateMax - 50), medium: 5e4 };
                r2.encodings = [{ active: true, adaptivePtime: false, networkPriority: "high", priority: "high", maxBitrate: o2.high }, { active: true, adaptivePtime: false, networkPriority: "low", priority: "low", maxBitrate: o2.medium, scaleResolutionDownBy: 4 }];
                const s2 = t3.sender.getParameters();
                await t3.sender.setParameters(Object.assign(s2, r2));
              }
            }
        }
        isVP8Simulcast(e3) {
          var t2, i3, n2, r2, o2;
          return !!(e3 instanceof ak && dN("SIMULCAST") && "vp8" === this.store.codec && !Dn(t2 = e3._hints).call(t2, fD.LOW_STREAM) && null !== (i3 = e3._encoderConfig) && void 0 !== i3 && i3.bitrateMax && (null === (n2 = e3._encoderConfig) || void 0 === n2 ? void 0 : n2.bitrateMax) > 200 && null !== (r2 = e3._scalabilityMode) && void 0 !== r2 && r2.numSpatialLayers && (null === (o2 = e3._scalabilityMode) || void 0 === o2 ? void 0 : o2.numSpatialLayers) > 1);
        }
        logSDPExchange(e3, t2, i3, n2) {
          if (dN("SDP_LOGGING"))
            return BN.upload("[".concat(this.store.clientId, "] exchanging ").concat(i3, " ").concat(t2, " SDP during P2PConnection.").concat(n2, "\n"), e3), "offer" === t2 ? (e4) => {
              this.logSDPExchange(e4, "answer", "local" === i3 ? "remote" : "local", n2);
            } : void 0;
        }
        async muteLocal(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created.");
            const t2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid && -1 !== e3.indexOf(t3.mid));
            if (t2.length !== e3.length)
              throw new Error("Transceivers' length doesn't match mids' length.");
            t2.map((e4) => {
              e4.direction = "inactive";
            });
            const i3 = await this.peerConnection.createOffer(), n2 = this.logSDPExchange(i3.sdp || "", "offer", "local", "muteLocal");
            await this.peerConnection.setLocalDescription(i3), this.remoteSDP.muteRemote(e3);
            const r2 = this.remoteSDP.toString();
            null == n2 || n2(r2), await this.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e4) {
            throw new Ew(_w.EXCHANGE_SDP_FAILED, "P2PConnection.muteLocal failed; ".concat(e4.toString()));
          }
        }
        async unmuteLocal(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created.");
            const t2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid && -1 !== e3.indexOf(t3.mid));
            if (t2.length !== e3.length)
              throw new Error("Transceivers' length doesn't match mids' length.");
            t2.map(async (e4) => {
              e4.direction = "sendonly";
            });
            const i3 = await this.peerConnection.createOffer(), n2 = this.logSDPExchange(i3.sdp || "", "offer", "local", "unmuteLocal");
            await this.peerConnection.setLocalDescription(i3), this.remoteSDP.unmuteRemote(e3);
            const r2 = this.remoteSDP.toString();
            null == n2 || n2(r2), await this.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e4) {
            throw new Ew(_w.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteLocal failed; ".concat(e4.toString()));
          }
        }
        async getRemoteSSRC(e3, t2) {
          var i3, n2;
          if (t2 = null !== (i3 = t2) && void 0 !== i3 ? i3 : null === (n2 = this.currentRemoteDescription) || void 0 === n2 ? void 0 : n2.sdp) {
            var r2;
            const i4 = null === (r2 = SN(t2).mediaDescriptions.find((t3) => t3.attributes.mid === e3)) || void 0 === r2 ? void 0 : r2.attributes.ssrcs;
            return null == i4 ? void 0 : i4[0].ssrcId;
          }
        }
        async setRemoteDescription(e3) {
          var t2;
          await this.peerConnection.setRemoteDescription(e3), Dn(t2 = ["connected", "completed"]).call(t2, this.peerConnection.iceConnectionState) || (this.isReady = true, this.addRemoteCandidate());
        }
        mungReceiveAnswerSDP(e3, t2, i3) {
          const n2 = SN(e3), r2 = n2.mediaDescriptions.find((e4) => e4.attributes.mid === t2);
          return r2 && i3 === lU.AUDIO && "audio" === r2.media.mediaType && Ox(r2), gN(n2);
        }
      }, IM(qY.prototype, "establish", [QY], Object.getOwnPropertyDescriptor(qY.prototype, "establish"), qY.prototype), IM(qY.prototype, "connect", [QY], Object.getOwnPropertyDescriptor(qY.prototype, "connect"), qY.prototype), IM(qY.prototype, "receive", [QY], Object.getOwnPropertyDescriptor(qY.prototype, "receive"), qY.prototype), IM(qY.prototype, "mockReceive", [QY], Object.getOwnPropertyDescriptor(qY.prototype, "mockReceive"), qY.prototype), IM(qY.prototype, "stopReceiving", [QY], Object.getOwnPropertyDescriptor(qY.prototype, "stopReceiving"), qY.prototype), IM(qY.prototype, "restartICE", [QY], Object.getOwnPropertyDescriptor(qY.prototype, "restartICE"), qY.prototype), IM(qY.prototype, "close", [QY], Object.getOwnPropertyDescriptor(qY.prototype, "close"), qY.prototype), IM(qY.prototype, "updateEncoderConfig", [QY], Object.getOwnPropertyDescriptor(qY.prototype, "updateEncoderConfig"), qY.prototype), IM(qY.prototype, "updateSendParameters", [QY], Object.getOwnPropertyDescriptor(qY.prototype, "updateSendParameters"), qY.prototype), IM(qY.prototype, "replaceTrack", [QY], Object.getOwnPropertyDescriptor(qY.prototype, "replaceTrack"), qY.prototype), IM(qY.prototype, "muteLocal", [QY], Object.getOwnPropertyDescriptor(qY.prototype, "muteLocal"), qY.prototype), IM(qY.prototype, "unmuteLocal", [QY], Object.getOwnPropertyDescriptor(qY.prototype, "unmuteLocal"), qY.prototype), qY);
      function QY(e2, t2, i3) {
        const n2 = e2[t2];
        if ("function" != typeof n2)
          throw new Error("Cannot use mutex on object property.");
        return i3.value = async function() {
          const e3 = this.mutex, i4 = await e3.lock("From P2PConnection.".concat(t2));
          try {
            for (var r2 = arguments.length, o2 = new Array(r2), s2 = 0; s2 < r2; s2++)
              o2[s2] = arguments[s2];
            return await n2.apply(this, o2);
          } finally {
            i4();
          }
        }, i3;
      }
      let ZY = function(e2) {
        return e2.SEND_ONLY = "SEND_ONLY", e2.RECEIVE_ONLY = "RECEIVE_ONLY", e2;
      }({});
      var $Y, eq2, tq, iq, nq, rq, oq, sq, aq, cq, dq, lq;
      function uq(e2, t2) {
        var i3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i3.push.apply(i3, n2);
        }
        return i3;
      }
      function hq(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i3 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? uq(Object(i3), true).forEach(function(t3) {
            QI(e2, t3, i3[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : uq(Object(i3)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
          });
        }
        return e2;
      }
      let pq = ($Y = _q(ZY.SEND_ONLY), eq2 = _q(ZY.SEND_ONLY), tq = _q(), iq = _q(ZY.RECEIVE_ONLY), nq = _q(ZY.RECEIVE_ONLY), rq = _q(ZY.RECEIVE_ONLY), oq = _q(ZY.RECEIVE_ONLY), sq = _q(ZY.RECEIVE_ONLY), aq = _q(ZY.RECEIVE_ONLY), cq = _q(), dq = _q(ZY.RECEIVE_ONLY), lq = class extends Nw {
        get state() {
          return this._state;
        }
        set state(e2) {
          const t2 = this._state;
          this._state = e2, this.emit(fU.StateChange, t2, this._state);
        }
        constructor(e2, t2) {
          super(), QI(this, "isPlanB", false), QI(this, "store", void 0), QI(this, "statsUploader", void 0), QI(this, "sendConnection", void 0), QI(this, "recvConnection", void 0), QI(this, "localTrackMap", /* @__PURE__ */ new Map()), QI(this, "remoteUserMap", /* @__PURE__ */ new Map()), QI(this, "localDataChannels", []), QI(this, "pendingLocalTracks", []), QI(this, "pendingRemoteTracks", []), QI(this, "statsCollector", void 0), QI(this, "dtlsFailedCount", 0), QI(this, "sendMutex", void 0), QI(this, "recvMutex", void 0), QI(this, "_state", EU.Disconnected), QI(this, "_restartStates", ["disconnected", "failed"]), QI(this, "reconnectInterval", void 0), QI(this, "uploadUnplinkStarted", false), QI(this, "uploadDownlinkStarted", false), QI(this, "uplinkStateUploadInterval", void 0), QI(this, "downlinkStatsUploadInterval", void 0), QI(this, "handleMuteLocalTrack", async (e3, t3, i3) => {
            const n2 = await this.sendMutex.lock("Locking from P2PChannel2.handleMuteLocalTrack");
            try {
              if (!this.sendConnection || this.state !== EU.Connected)
                return void i3(new Ew(_w.INVALID_OPERATION, "Cannot call P2PChannel2.handleMuteLocalTrack before sendConnection established."));
              const s2 = this.filterTobeMutedTracks(e3);
              if (0 === s2.length)
                return void t3();
              const a2 = s2.find((e4) => "videoLowTrack" === e4[0]);
              if (a2) {
                a2[1].track._originMediaStreamTrack.stop();
              }
              await this.sendConnection.muteLocal(s2.map((e4) => {
                let [, { id: t4 }] = e4;
                return t4;
              }));
              let c2 = false;
              var r2, o2;
              if ("video" === e3.trackMediaType)
                c2 = !(null === (r2 = this.localTrackMap.get(_U.LocalAudioTrack)) || void 0 === r2 || !r2.track._muted);
              else
                c2 = void 0 === (null === (o2 = this.localTrackMap.get(_U.LocalVideoTrack)) || void 0 === o2 ? void 0 : o2.id);
              const d2 = this.createMuteMessage(s2);
              await Yw(this, fU.RequestMuteLocal, d2);
              const l2 = "video" === e3.trackMediaType ? bU.MUTE_LOCAL_VIDEO : bU.MUTE_LOCAL_AUDIO;
              await Yw(this, fU.RequestP2PMuteLocal, { action: l2, message: d2, isMuteAll: c2 }), t3();
            } catch (e4) {
              i3(e4);
            } finally {
              n2();
            }
          }), QI(this, "handleUnmuteLocalTrack", async (e3, t3, i3) => {
            const n2 = await this.sendMutex.lock("Locking from P2PChannel2.handleUnmuteLocalTrack");
            try {
              if (!this.sendConnection || this.state !== EU.Connected)
                return void i3(new Ew(_w.INVALID_OPERATION, "Cannot call P2PChannel2.handleUnmuteLocalTrack before sendConnection established."));
              const r2 = this.filterTobeUnmutedTracks(e3);
              if (0 === r2.length)
                return void t3();
              await this.sendConnection.unmuteLocal(r2.map((e4) => {
                let [, { id: t4 }] = e4;
                return t4;
              }));
              const o2 = this.createUnmuteMessage(r2), s2 = "video" === e3.trackMediaType ? bU.UNMUTE_LOCAL_VIDEO : bU.UNMUTE_LOCAL_AUDIO;
              await Yw(this, fU.RequestP2PMuteLocal, { action: s2, message: o2 }), t3();
            } catch (e4) {
              i3(e4);
            } finally {
              n2();
            }
          }), QI(this, "handleUpdateVideoEncoder", async (e3, t3, i3, n2) => {
            let r2;
            "boolean" == typeof n2 && n2 || (r2 = await this.sendMutex.lock("Locking from P2PChannel2.handleUpdateVideoEncoder"));
            try {
              const i4 = this.localTrackMap.get(_U.LocalVideoTrack);
              if (!this.sendConnection || !i4 || i4.track !== e3 || this.state !== EU.Connected)
                return void t3();
              const { id: n3, track: s2 } = i4;
              n3 && (await this.sendConnection.updateSendParameters(n3, s2), await this.sendConnection.updateEncoderConfig(n3, s2), this.emit(fU.UpdateVideoEncoder, s2)), t3();
            } catch (e4) {
              i3(e4);
            } finally {
              var o2;
              null === (o2 = r2) || void 0 === o2 || o2();
            }
          }), QI(this, "handleUpdateVideoSendParameters", async (e3, t3, i3) => {
            const n2 = await this.sendMutex.lock("Locking from P2PChannel2.handleUpdateVideoSendParameters");
            try {
              const i4 = this.localTrackMap.get(_U.LocalVideoTrack);
              if (!this.sendConnection || !i4 || i4.track !== e3 || this.state !== EU.Connected)
                return void t3();
              const { id: r2, track: o2 } = i4;
              r2 && await this.sendConnection.updateSendParameters(r2, o2), t3();
            } catch (e4) {
              i3(e4);
            } finally {
              n2();
            }
          }), QI(this, "handleReplaceTrack", async (e3, t3, i3, n2) => {
            let r2;
            BN.debug("[".concat(this.store.clientId, "] P2PChannel2 handleReplaceTrack for [track-id-").concat(e3.getTrackId(), "]")), "boolean" == typeof n2 && n2 || (r2 = await this.sendMutex.lock("From P2PChannel2.handleReplaceTrack"));
            try {
              var o2;
              const i4 = Array.from(this.localTrackMap.entries()).find((t4) => {
                let [, { track: i5 }] = t4;
                return e3 === i5;
              });
              if (!this.sendConnection || !i4 || void 0 === i4[1].id || this.state !== EU.Connected)
                return void t3();
              if (await (null === (o2 = this.sendConnection) || void 0 === o2 ? void 0 : o2.replaceTrack(e3, i4[1].id)), i4[0] === _U.LocalVideoTrack && QN().supportDualStreamEncoding) {
                const t4 = this.localTrackMap.get(_U.LocalVideoLowTrack);
                if (t4) {
                  const i5 = e3._mediaStreamTrack.clone();
                  t4.track._originMediaStreamTrack.stop(), t4.track._mediaStreamTrack = i5, t4.track._originMediaStreamTrack = i5, await new Wh((e4, i6) => {
                    this.handleReplaceTrack(t4.track, e4, i6, true);
                  });
                }
              }
              t3();
            } catch (e4) {
              i3(e4);
            } finally {
              var s2;
              null === (s2 = r2) || void 0 === s2 || s2();
            }
          }), QI(this, "handleGetLocalVideoStats", (e3) => {
            e3(this.statsCollector.getLocalVideoTrackStats());
          }), QI(this, "handleGetLocalAudioStats", (e3) => {
            e3(this.statsCollector.getLocalAudioTrackStats());
          }), QI(this, "handleGetRemoteVideoStats", (e3) => this.statsCollector.getRemoteVideoTrackStats(e3.uid)[e3.uid]), QI(this, "handleGetRemoteAudioStats", (e3) => this.statsCollector.getRemoteAudioTrackStats(e3.uid)[e3.uid]), this.store = e2, this.statsCollector = t2, this.statsCollector.addP2PChannel(this), this.statsUploader = new xF(e2), this.bindStatsUploaderEvents(), this.sendMutex = new vO("P2PChannel2-send-mutex", e2.clientId), this.recvMutex = new vO("P2PChannel2-recv-mutex", e2.clientId), this.reconnectInterval = window.setInterval(() => {
            [this.sendConnection, this.recvConnection].forEach((e3) => {
              e3 && ("disconnected" !== e3.iceConnectionState && "failed" !== e3.iceConnectionState || this.handleDisconnect(e3.direction));
            });
          }, dN("ICE_RESTART_INTERVAL"));
        }
        async startP2PConnection(e2, t2) {
          throw new Ew(_w.NOT_SUPPORTED, "p2p mode does not support startP2PConnection.");
        }
        async connect(e2) {
          throw new Ew(_w.NOT_SUPPORTED, "p2p mode does not support connect.");
        }
        async startP2P(e2, t2) {
          let i3;
          try {
            if (t2) {
              this.recvConnection && (BN.warning("[".concat(this.store.clientId, "] P2PChannel.startP2P reset recvConnection.")), this.recvConnection.close(), this.unbindConnectionEvents(this.recvConnection)), i3 = await this.recvMutex.lock("From P2PChannel.startP2P"), this.recvConnection = new JY(e2, this.store, MM.RECEIVE_ONLY), this.bindConnectionEvents(this.recvConnection);
              const n2 = await this.recvConnection.establish(t2);
              return { iceParameters: n2.iceParameters, dtlsParameters: n2.dtlsParameters, sdp: n2.sdp };
            }
            {
              this.state = EU.New, this.sendConnection && (BN.warning("[".concat(this.store.clientId, "] P2PChannel.startP2P reset sendConnection.")), this.sendConnection.close(), this.unbindConnectionEvents(this.sendConnection)), i3 = await this.sendMutex.lock("From P2PChannel.startP2P"), this.sendConnection = new JY(e2, this.store), this.store.peerConnectionStart(), this.bindConnectionEvents(this.sendConnection);
              const t3 = await this.sendConnection.establish();
              return { iceParameters: t3.iceParameters, dtlsParameters: t3.dtlsParameters, sdp: t3.sdp };
            }
          } finally {
            i3 && i3();
          }
        }
        async p2pConnect(e2) {
          if (!this.sendConnection)
            throw new Ew(_w.UNEXPECTED_ERROR, "Cannot P2PChannel2.p2pConnect before P2PChannel2.startP2PConnection .");
          this.store.peerConnectionStart(), await this.sendConnection.connect(e2), this.statsUploader.startUploadTransportStats(), this.statsUploader.startUploadExtensionUsageStats(), this.state = EU.Connected;
        }
        async addRemoteCandidate(e2, t2) {
          if (t2 === MM.RECEIVE_ONLY) {
            if (!this.sendConnection)
              throw new Ew(_w.UNEXPECTED_ERROR, "Cannot P2PChannel2.connect before P2PChannel2.addRemoteCandidate .");
            await this.sendConnection.addRemoteCandidate(e2);
          } else {
            if (!this.recvConnection)
              throw new Ew(_w.UNEXPECTED_ERROR, "Cannot P2PChannel2.connect before P2PChannel2.addRemoteCandidate .");
            await this.recvConnection.addRemoteCandidate(e2);
          }
        }
        publish(e2, t2, i3) {
          var n2 = this;
          return FA(function* () {
            const r2 = yield BA(n2.sendMutex.lock("From P2PChannel.publish"));
            try {
              if (!n2.sendConnection || n2.state !== EU.Connected) {
                n2.throwIfTrackTypeNotMatch(e2);
                const t3 = e2.filter((e3) => -1 === n2.pendingLocalTracks.indexOf(e3));
                return void (n2.pendingLocalTracks = n2.pendingLocalTracks.concat(t3));
              }
              n2.store.pubId = n2.store.pubId + 1, UV.markPublishStart(n2.store.clientId, n2.store.pubId);
              const o2 = n2.filterTobePublishedTracks(e2, t2, i3);
              if (0 === o2.length)
                return void (yield BA(n2.tryToUnmuteAudio(e2)));
              o2.forEach((e3) => {
                let { track: t3, type: i4 } = e3;
                const r3 = Date.now();
                n2.store.publish(t3.getTrackId(), i4 === _U.LocalAudioTrack ? "audio" : "video", r3);
              }), n2.bindLocalTrackEvents(o2);
              const s2 = yield BA(n2.sendConnection.send(o2.map((e3) => {
                let { track: t3 } = e3;
                return t3;
              }), n2.store.codec, n2.store.audioCodec)), a2 = (yield BA(s2.next())).value, c2 = n2.createGatewayPublishMessage(o2, a2);
              try {
                yield c2;
              } catch (e3) {
                throw s2.throw(e3), (null == e3 ? void 0 : e3.code) === _w.WS_ABORT && o2.forEach((e4) => {
                  let { track: t3 } = e4;
                  -1 === n2.pendingLocalTracks.indexOf(t3) && n2.pendingLocalTracks.push(t3);
                }), n2.unbindLocalTrackEvents(o2), e3;
              }
              yield BA(s2.next()), o2.forEach((e3) => {
                let { type: t3 } = e3;
                n2.statsCollector.addLocalStats(t3);
              }), n2.statsUploader.startUploadOutboundStats(), n2.assignLocalTracks(o2, a2), o2.forEach((e3) => {
                let { track: t3, type: i4 } = e3;
                const r3 = Date.now();
                n2.store.publish(t3.getTrackId(), i4 === _U.LocalAudioTrack ? "audio" : "video", void 0, r3);
              }), n2.startUploadUplinkState();
            } finally {
              r2();
            }
          })();
        }
        async unpublish(e2) {
          if (!this.sendConnection || this.state !== EU.Connected)
            return void (0 === e2.length ? this.pendingLocalTracks.length = 0 : this.pendingLocalTracks = this.pendingLocalTracks.filter((t3) => !Dn(e2).call(e2, t3)));
          const t2 = this.filterTobeUnpublishedTracks(e2);
          if (0 === t2.length)
            return;
          const i3 = t2.find((e3) => "videoLowTrack" === e3[0]);
          if (i3) {
            i3[1].track.close();
          }
          const n2 = this.createGatewayUnpublishMessage(t2);
          if (await this.sendConnection.stopSending(t2.map((e3) => {
            let [, { id: t3 }] = e3;
            return t3;
          })), this.withdrawLocalTracks(t2), this.unbindLocalTrackEvents(t2.map((e3) => {
            let [t3, { track: i4 }] = e3;
            return { type: t3, track: i4 };
          })), t2.forEach((e3) => {
            let [t3] = e3;
            this.statsCollector.removeLocalStats(t3);
          }), 0 === this.localTrackMap.size && (this.statsUploader.stopUploadOutboundStats(), this.stopUploadUplinkState()), this.sendConnection && this.state === EU.Connected) {
            if (i3) {
              i3[1].track.close();
            }
            return n2;
          }
          e2.forEach((e3) => {
            const t3 = this.pendingLocalTracks.indexOf(e3);
            -1 !== t3 && this.pendingLocalTracks.splice(t3, 1);
          });
        }
        startUploadUplinkState() {
          if (this.uploadUnplinkStarted)
            return;
          this.uploadUnplinkStarted = true, this.uplinkStateUploadInterval && window.clearInterval(this.uplinkStateUploadInterval);
          const e2 = () => {
            const e3 = [], t2 = [];
            Array.from(this.localTrackMap.entries()).forEach((i3) => {
              let [n2, { track: r2, ssrcs: o2 }] = i3;
              const s2 = { stream_type: sF(r2, n2), ssrcs: o2 };
              r2._muted || !r2._enabled ? e3.push(s2) : t2.push(s2);
            }), e3.length > 0 && e3.forEach((e4) => {
              Yw(this, fU.RequestMuteLocal, [e4]);
            }), t2.length > 0 && t2.forEach((e4) => {
              Yw(this, fU.RequestUnmuteLocal, [e4]);
            });
          };
          e2(), this.uplinkStateUploadInterval = window.setInterval(() => {
            e2();
          }, 3e3);
        }
        stopUploadUplinkState() {
          this.uploadUnplinkStarted && (this.uploadUnplinkStarted = false, this.uplinkStateUploadInterval && window.clearInterval(this.uplinkStateUploadInterval));
        }
        publishLowStream(e2) {
          return FA(function* () {
            throw new Ew(_w.NOT_SUPPORTED, "p2p mode does not support publishLowStream.");
          })();
        }
        async republish() {
          this.pendingLocalTracks.length > 0 && (BN.debug("[".concat(this.store.clientId, "] Emit P2PChannelEvents.RequestRePublish to republish tracks.")), await Kw(this, fU.RequestRePublish, this.pendingLocalTracks), this.emit(fU.MediaReconnectEnd, this.store.uid), this.pendingLocalTracks = []);
        }
        async unpublishLowStream() {
          throw new Ew(_w.NOT_SUPPORTED, "p2p mode does not support unpublishLowStream.");
        }
        async subscribe(e2, t2, i3, n2) {
          var r2;
          if (!this.recvConnection)
            throw new Ew(_w.INVALID_OPERATION, "Cannot subscribe remote user when recvConnection disconnected.");
          if (null !== (r2 = this.remoteUserMap.get(e2)) && void 0 !== r2 && r2.has(t2))
            return;
          const { track: o2, mid: s2, transceiver: a2 } = await this.recvConnection.receive(t2, [{ ssrcId: i3 }], String(e2.uid), n2);
          t2 === lU.AUDIO ? (e2._audioTrack ? e2._audioTrack._updateOriginMediaStreamTrack(o2) : (e2._audioTrack = new Ik(o2, e2.uid, e2._uintid, this.store), BN.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote audio track: ").concat(e2._audioTrack.getTrackId()))), a2 && e2._audioTrack._updateRtpTransceiver(a2), this.bindRemoteTrackEvents(e2, e2._audioTrack)) : (e2._videoSSRC = i3, e2._videoTrack ? e2._videoTrack._updateOriginMediaStreamTrack(o2) : (e2._videoTrack = new vk(o2, e2.uid, e2._uintid, this.store), BN.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote video track: ").concat(e2._videoTrack.getTrackId()))), a2 && e2._videoTrack._updateRtpTransceiver(a2), this.bindRemoteTrackEvents(e2, e2._videoTrack));
          const c2 = this.remoteUserMap.get(e2);
          c2 ? c2.set(t2, s2) : this.remoteUserMap.set(e2, /* @__PURE__ */ new Map([[t2, s2]])), this.statsCollector.addRemoteStats(e2.uid), this.statsUploader.startUploadInboundStats(), this.startUploadDownlinkState();
          const d2 = this.pendingRemoteTracks.findIndex((i4) => {
            let { user: n3, kind: r3 } = i4;
            return n3.uid === e2.uid && t2 === r3;
          });
          -1 !== d2 && (this.pendingRemoteTracks.splice(d2, 1), this.emit(fU.MediaReconnectEnd, e2.uid));
        }
        async mockSubscribe(e2, t2, i3, n2) {
          if (!this.recvConnection)
            throw new Ew(_w.INVALID_OPERATION, "Cannot subscribe remote user when recvConnection disconnected.");
          await this.recvConnection.mockReceive(t2, [{ ssrcId: i3 }], String(e2.uid), n2);
        }
        async unsubscribe(e2, t2, i3) {
          const n2 = this.pendingRemoteTracks.filter((i4) => {
            let { user: n3, kind: r3 } = i4;
            return void 0 !== t2 ? n3.uid === e2.uid && t2 === r3 : n3.uid === e2.uid;
          });
          if (n2.forEach((e3) => {
            const t3 = this.pendingRemoteTracks.indexOf(e3);
            this.pendingRemoteTracks.splice(t3, 1);
          }), this.recvConnection || i3 || n2.forEach((t3) => {
            let { kind: i4 } = t3;
            var n3;
            if (i4 === lU.AUDIO)
              null === (n3 = e2._audioTrack) || void 0 === n3 || n3._destroy(), e2._audioTrack = void 0;
            else if (i4 === lU.VIDEO) {
              var r3;
              null === (r3 = e2._videoTrack) || void 0 === r3 || r3._destroy(), e2._videoTrack = void 0;
            }
          }), !this.recvConnection)
            return;
          const r2 = this.filterTobeUnSubscribedTracks(e2, t2);
          0 !== r2.length && (await this.recvConnection.stopReceiving(r2.map((e3) => {
            let [, { id: t3 }] = e3;
            return t3;
          })), this.withdrawRemoteTracks(r2), 0 === this.remoteUserMap.size && (this.statsUploader.stopUploadInboundStats(), this.stopUploadDownlinkState()), r2.forEach((e3) => {
            let [t3, { kind: n3 }] = e3;
            var r3, o2;
            n3 === lU.VIDEO && t3._videoSSRC && (null === (r3 = this.recvConnection) || void 0 === r3 || r3.setStatsRemoteVideoIsReady(t3._videoSSRC, false));
            if (n3 === lU.VIDEO)
              this.unbindRemoteTrackEvents(t3._videoTrack), i3 || (null === (o2 = t3._videoTrack) || void 0 === o2 || o2._destroy(), t3._videoTrack = void 0);
            else if (n3 === lU.AUDIO) {
              var s2;
              if (this.unbindRemoteTrackEvents(t3._audioTrack), !i3)
                null === (s2 = t3._audioTrack) || void 0 === s2 || s2._destroy(), t3._audioTrack = void 0;
            }
          }), r2.forEach((e3) => {
            let [, { kind: t3 }] = e3;
            Yw(this, fU.RequestP2PMuteRemote, t3);
          }));
        }
        startUploadDownlinkState() {
          if (this.uploadDownlinkStarted)
            return;
          this.uploadDownlinkStarted = true, this.downlinkStatsUploadInterval && window.clearInterval(this.downlinkStatsUploadInterval);
          const e2 = () => Array.from(this.remoteUserMap.entries()).forEach((e3) => {
            let [, t2] = e3;
            [lU.VIDEO, lU.AUDIO].forEach((e4) => {
              t2.has(e4) ? Yw(this, fU.RequestP2PUnmuteRemote, e4) : Yw(this, fU.RequestP2PMuteRemote, e4);
            });
          });
          e2(), this.downlinkStatsUploadInterval = window.setInterval(() => {
            e2();
          }, 3e3);
        }
        stopUploadDownlinkState() {
          this.uploadDownlinkStarted && (this.uploadDownlinkStarted = false, this.downlinkStatsUploadInterval && window.clearInterval(this.downlinkStatsUploadInterval));
        }
        getAllDataChannels() {
          return this.localDataChannels;
        }
        async massSubscribe(e2) {
          throw new Ew(_w.NOT_SUPPORTED, "p2p mode does not support massSubscribe.");
        }
        async massSubscribeNoLock(e2) {
          throw new Ew(_w.NOT_SUPPORTED, "p2p mode does not support massSubscribeNoLock.");
        }
        async massUnsubscribe(e2) {
          throw new Ew(_w.NOT_SUPPORTED, "p2p mode does not support massUnsubscribe.");
        }
        async massUnsubscribeNoLock(e2) {
          throw new Ew(_w.NOT_SUPPORTED, "p2p mode does not support massUnsubscribeNoLock.");
        }
        async muteRemote(e2, t2) {
          if (!this.recvConnection)
            return;
          const i3 = this.remoteUserMap.get(e2);
          if (!i3)
            return void BN.warning("[".concat(this.store.clientId, "] P2PChannel2.muteRemote has no remote user ").concat(e2.uid, "."));
          if (!i3.get(t2))
            return void BN.warning("[".concat(this.store.clientId, "] P2PChannel2.muteRemote has no remote user ").concat(e2.uid, " media type ").concat(t2, "."));
          const n2 = t2 === lU.VIDEO ? e2._videoSSRC : e2._audioSSRC;
          void 0 !== n2 && this.recvConnection.setStatsRemoteVideoIsReady(n2, false);
        }
        async unmuteRemote(e2, t2) {
          return this.unmuteRemoteNoLock(e2, t2);
        }
        async unmuteRemoteNoLock(e2, t2) {
          if (!this.recvConnection)
            return;
          const i3 = this.remoteUserMap.get(e2);
          if (!i3)
            return void BN.warning("[".concat(this.store.clientId, "] P2PChannel2.unmuteRemote has no remote user ").concat(e2.uid, "."));
          i3.get(t2) || BN.warning("[".concat(this.store.clientId, "] P2PChannel2.unmuteRemote has no remote user ").concat(e2.uid, " media type ").concat(t2, "."));
        }
        getAllTracks(e2) {
          const t2 = this.localTrackMap.get(_U.LocalAudioTrack);
          if ((null == t2 ? void 0 : t2.track) instanceof RL) {
            const i3 = t2.track;
            return Array.from(this.localTrackMap.entries()).filter((e3) => {
              let [t3] = e3;
              return t3 !== _U.LocalAudioTrack;
            }).filter((t3) => {
              let [i4] = t3;
              return !(e2 && i4 === _U.LocalVideoLowTrack);
            }).map((e3) => {
              let [, { track: t3 }] = e3;
              return t3;
            }).concat(i3.trackList);
          }
          return Array.from(this.localTrackMap.entries()).filter((t3) => {
            let [i3] = t3;
            return !(e2 && i3 === _U.LocalVideoLowTrack);
          }).map((e3) => {
            let [, { track: t3 }] = e3;
            return t3;
          });
        }
        reportPublishEvent(e2, t2, i3, n2, r2) {
          if (e2) {
            const i4 = this.localTrackMap.get(_U.LocalAudioTrack), o3 = n2 ? this.localTrackMap.get(_U.LocalVideoLowTrack) : this.localTrackMap.get(_U.LocalVideoTrack);
            zN.publish(this.store.sessionId, { eventElapse: UV.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: e2, ec: t2, audioName: null == i4 ? void 0 : i4.track.getTrackLabel(), videoName: null == o3 ? void 0 : o3.track.getTrackLabel(), screenshare: -1 !== (null == o3 ? void 0 : o3.track._hints.indexOf(fD.SCREEN_TRACK)), audio: !!i4, video: !!o3, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: r2 });
          } else {
            var o2;
            i3 || (i3 = []);
            const s2 = i3.find((e3) => e3 instanceof TL), a2 = n2 ? null === (o2 = this.localTrackMap.get(_U.LocalVideoTrack)) || void 0 === o2 ? void 0 : o2.track : i3.find((e3) => e3 instanceof ak);
            zN.publish(this.store.sessionId, { eventElapse: UV.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: e2, ec: t2, audioName: null == s2 ? void 0 : s2.getTrackLabel(), videoName: null == a2 ? void 0 : a2.getTrackLabel(), screenshare: -1 !== (null == a2 ? void 0 : a2._hints.indexOf(fD.SCREEN_TRACK)), audio: !!s2, video: !!a2, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: r2 });
          }
        }
        reportSubscribeEvent(e2, t2, i3, n2) {
          const r2 = n2 === lU.VIDEO ? i3._videoSSRC : i3._audioSSRC;
          r2 && zN.subscribe(this.store.sessionId, { succ: e2, ec: t2, video: n2 === lU.VIDEO, audio: n2 === lU.AUDIO, peerid: i3.uid, subscribeRequestid: n2 === lU.VIDEO ? i3._videoSSRC : i3._audioSSRC, p2pid: this.store.p2pId, eventElapse: UV.measureFromSubscribeStart(this.store.clientId, r2) });
        }
        reset() {
          BN.debug("[".concat(this.store.clientId, "] P2PChannel2.reset")), this.sendMutex = new vO("P2PChannel2-send-mutex", this.store.clientId), this.sendMutex = new vO("P2PChannel2-recv-mutex", this.store.clientId), this.sendConnection && (this.sendConnection.close(), this.unbindConnectionEvents(this.sendConnection), this.sendConnection = void 0), this.recvConnection && (this.recvConnection.close(), this.unbindConnectionEvents(this.recvConnection), this.recvConnection = void 0), this.statsUploader.stopUploadOutboundStats(), this.statsUploader.stopUploadInboundStats(), this.statsUploader.stopUploadTransportStats(), this.statsUploader.stopUploadExtensionUsageStats(), this.stopUploadUplinkState(), this.stopUploadDownlinkState(), this.unbindLocalTrackEvents(), this.unbindAllRemoteTrackEvents(), this.unbindRtpTransceiver();
          const e2 = this.localTrackMap.get(_U.LocalAudioTrack);
          if ((null == e2 ? void 0 : e2.track) instanceof RL) {
            if (e2.track.trackList.length > 0) {
              const t2 = e2.track;
              e2.track.trackList.forEach((e3) => {
                t2.removeAudioTrack(e3);
              });
            }
            e2.track.close();
          }
          this.localTrackMap.clear(), this.remoteUserMap.clear(), this.statsCollector.removeRemoteStats(), this.statsCollector.removeLocalStats(), this.dtlsFailedCount = 0, this.pendingLocalTracks = [], this.pendingRemoteTracks = [], this.reconnectInterval && (window.clearInterval(this.reconnectInterval), this.reconnectInterval = void 0), this.state = EU.Disconnected;
        }
        getStats(e2) {
          var t2, i3;
          return e2 ? null === (i3 = this.recvConnection) || void 0 === i3 ? void 0 : i3.getStats() : null === (t2 = this.sendConnection) || void 0 === t2 ? void 0 : t2.getStats();
        }
        getRemoteVideoIsReady(e2) {
          var t2;
          return (null === (t2 = this.recvConnection) || void 0 === t2 ? void 0 : t2.getRemoteVideoIsReady(e2)) || false;
        }
        getLocalAudioVolume() {
          const e2 = this.localTrackMap.get(_U.LocalAudioTrack);
          if (e2)
            return e2.track.getVolumeLevel();
        }
        getLocalVideoSize() {
          const e2 = this.localTrackMap.get(_U.LocalVideoTrack);
          if (e2)
            return { width: e2.track.videoWidth || 0, height: e2.track.videoHeight || 0 };
        }
        getEncoderConfig(e2) {
          const t2 = this.localTrackMap.get(e2);
          return t2 && t2.track instanceof ak || t2 && t2.track instanceof TL ? t2.track._encoderConfig : void 0;
        }
        getLocalMedia(e2) {
          return this.localTrackMap.get(e2);
        }
        hasLocalMedia() {
          return this.localTrackMap.size > 0;
        }
        hasRemoteMedia(e2, t2) {
          if (!e2)
            return this.remoteUserMap.size > 0;
          const i3 = this.remoteUserMap.get(e2);
          return !!i3 && (!t2 || i3.has(t2));
        }
        async hasRemoteMediaWithLock(e2, t2) {
          if (!e2)
            return this.remoteUserMap.size > 0;
          const i3 = this.remoteUserMap.get(e2);
          return !!i3 && (!t2 || i3.has(t2));
        }
        getRemoteMedia(e2) {
          var t2;
          const i3 = Array.from(ON(t2 = this.remoteUserMap).call(t2)).find((t3) => t3.uid === e2);
          return i3 ? { audioTrack: i3.audioTrack, audioSSRC: i3._audioSSRC, videoTrack: i3.videoTrack, videoSSRC: i3._videoSSRC } : {};
        }
        getAudioLevels() {
          let e2 = Array.from(this.remoteUserMap.entries()).map((e3) => {
            let [t3] = e3;
            return { uid: t3.uid, level: t3.audioTrack ? 100 * t3.audioTrack._source.getAccurateVolumeLevel() : 0 };
          });
          const t2 = this.localTrackMap.get(_U.LocalAudioTrack);
          return t2 && e2.push({ level: 100 * t2.track._source.getAccurateVolumeLevel(), uid: this.store.uid }), e2 = CS(e2).call(e2, (e3, t3) => e3.level - t3.level), e2;
        }
        async disconnectForReconnect() {
          this.sendConnection && this.recvConnection && (BN.debug("[".concat(this.store.clientId, "] P2PChannel2.disconnectForReconnect closing P2PConnection")), this.state = EU.Reconnecting, dN("KEEP_LAST_FRAME") && 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach((e2) => {
            let [t2] = e2;
            var i3;
            t2._videoTrack && t2._videoTrack._player && (null === (i3 = t2._videoTrack._player.getVideoElement()) || void 0 === i3 || i3.pause(), t2._videoTrack._player.isKeepLastFrame = true, t2._videoTrack._originMediaStreamTrack.stop());
          }), this.sendConnection.close(), this.unbindConnectionEvents(this.sendConnection), this.sendConnection = void 0, this.recvConnection.close(), this.unbindConnectionEvents(this.recvConnection), this.recvConnection = void 0, 0 !== this.localTrackMap.size && (Array.from(this.localTrackMap.entries()).forEach((e2) => {
            var t2;
            let [i3, { track: n2 }] = e2;
            switch (i3) {
              case _U.LocalVideoTrack:
                Dn(t2 = n2._hints).call(t2, fD.LOW_STREAM) ? n2.close() : this.pendingLocalTracks.push(n2);
                break;
              case _U.LocalAudioTrack:
                n2 instanceof RL ? this.pendingLocalTracks = this.pendingLocalTracks.concat(n2.trackList) : this.pendingLocalTracks.push(n2);
              case _U.LocalVideoLowTrack:
            }
          }), this.emit(fU.MediaReconnectStart, this.store.uid)), this.unbindLocalTrackEvents(), this.localTrackMap.clear(), 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach((e2) => {
            let [t2, i3] = e2;
            Array.from(ON(i3).call(i3)).forEach((e3) => {
              this.setPendingRemoteMedia(t2, e3);
            }), this.emit(fU.MediaReconnectStart, t2.uid);
          }), this.unbindAllRemoteTrackEvents(), this.remoteUserMap.clear(), this.stopUploadUplinkState(), this.stopUploadDownlinkState(), this.statsUploader.stopUploadOutboundStats(), this.statsUploader.stopUploadInboundStats(), this.statsUploader.stopUploadTransportStats(), BN.debug("[".concat(this.store.clientId, "] P2PChannel2 disconnected, waiting to reconnect.")));
        }
        hasPendingRemoteMedia(e2, t2) {
          for (const i3 of this.pendingRemoteTracks) {
            const { user: n2, kind: r2 } = i3;
            if ((e2 instanceof GV ? e2.uid : e2) === n2.uid && t2 === r2)
              return true;
          }
          return false;
        }
        setPendingRemoteMedia(e2, t2) {
          this.hasPendingRemoteMedia(e2, t2) || this.pendingRemoteTracks.push({ user: e2, kind: t2 });
        }
        async restartICE(e2, t2) {
          let i3, n2;
          if (e2 === MM.SEND_ONLY) {
            if (!this.sendConnection)
              throw new Ew(_w.INVALID_OPERATION, "Cannot call P2PChannel2.handleMuteLocalTrack before sendConnection established.");
            i3 = await this.sendMutex.lock("From P2PChannel.restartICE"), n2 = this.sendConnection;
          } else {
            if (!this.recvConnection)
              throw new Ew(_w.INVALID_OPERATION, "Cannot call P2PChannel2.handleMuteLocalTrack before recvConnection established.");
            i3 = await this.recvMutex.lock("From P2PChannel.restartICE"), n2 = this.recvConnection;
          }
          try {
            if (t2) {
              const e3 = await n2.restartICE(t2);
              return n2.isInRestartIce = false, e3;
            }
            {
              const e3 = await n2.restartICE();
              if (e3) {
                const t3 = await Kw(this, fU.RequestP2PRestartICE, { direction: MM.RECEIVE_ONLY, iceParameter: e3 });
                await n2.restartICE(t3), n2.isInRestartIce = false;
              }
            }
          } finally {
            i3();
          }
        }
        getUplinkNetworkQuality() {
          if (!this.sendConnection)
            return 0;
          const e2 = this.sendConnection.getStats(), t2 = this.localTrackMap.get(_U.LocalVideoTrack), i3 = this.localTrackMap.get(_U.LocalAudioTrack), n2 = e2.videoSend.find((e3) => {
            var i4;
            return e3.ssrc === (null == t2 || null === (i4 = t2.ssrcs) || void 0 === i4 ? void 0 : i4[0].ssrcId);
          }), r2 = e2.audioSend.find((e3) => {
            var t3;
            return e3.ssrc === (null == i3 || null === (t3 = i3.ssrcs) || void 0 === t3 ? void 0 : t3[0].ssrcId);
          });
          if (!n2 || !r2)
            return 1;
          const o2 = qw(this, fU.NeedSignalRTT), s2 = n2 ? n2.rttMs : void 0, a2 = r2 ? r2.rttMs : void 0, c2 = s2 && a2 ? (s2 + a2) / 2 : s2 || a2, d2 = (c2 && o2 ? (c2 + o2) / 2 : c2 || o2) || 0, l2 = 100 * e2.sendPacketLossRate * 0.7 / 50 + 0.3 * d2 / 1500, u2 = l2 < 0.17 ? 1 : l2 < 0.36 ? 2 : l2 < 0.59 ? 3 : l2 < 0.1 ? 4 : 5, h2 = null == t2 ? void 0 : t2.track;
          if (h2 && h2._encoderConfig && -1 === h2._hints.indexOf(fD.SCREEN_TRACK)) {
            const t3 = h2._encoderConfig.bitrateMax, i4 = e2.bitrate.actualEncoded;
            if (t3 && i4) {
              const e3 = (1e3 * t3 - i4) / (1e3 * t3);
              return Fk[e3 < 0.15 ? 0 : e3 < 0.3 ? 1 : e3 < 0.45 ? 2 : e3 < 0.6 ? 3 : 4][u2];
            }
          }
          return u2;
        }
        getDownlinkNetworkQuality() {
          if (!this.recvConnection)
            return 0;
          const e2 = this.recvConnection.getStats();
          let t2 = 0;
          return Array.from(this.remoteUserMap.entries()).forEach((i3) => {
            let [n2] = i3;
            const r2 = n2._audioSSRC, o2 = n2._videoSSRC, s2 = e2.audioRecv.find((e3) => e3.ssrc === r2), a2 = e2.videoRecv.find((e3) => e3.ssrc === o2);
            if (!s2 && !a2)
              return void (t2 += 1);
            const c2 = qw(this, fU.NeedSignalRTT), d2 = e2.rtt, l2 = (d2 && c2 ? (d2 + c2) / 2 : d2 || c2) || 0, u2 = s2 ? s2.jitterMs : void 0, h2 = e2.recvPacketLossRate;
            let p3 = 0.7 * h2 * 100 / 50 + 0.3 * l2 / 1500;
            u2 && (p3 = 0.6 * h2 * 100 / 50 + 0.2 * l2 / 1500 + 0.2 * u2 / 400);
            t2 += p3 < 0.1 ? 1 : p3 < 0.17 ? 2 : p3 < 0.36 ? 3 : p3 < 0.59 ? 4 : 5;
          }), this.remoteUserMap.size > 0 ? Math.round(t2 / this.remoteUserMap.size) : t2;
        }
        async muteLocalTrack(e2) {
          return new Wh((t2, i3) => {
            this.handleMuteLocalTrack(e2, t2, i3);
          });
        }
        filterTobePublishedTracks(e2, t2, i3) {
          const n2 = [], r2 = QN(), o2 = this.getAllTracks();
          e2 = Qw(e2 = e2.filter((e3) => -1 === o2.indexOf(e3)));
          let s2 = false, a2 = false;
          for (const o3 of e2) {
            if (o3 instanceof ak && (this.localTrackMap.has(_U.LocalVideoTrack) || s2 ? new Ew(_w.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS).throw() : (n2.push({ track: o3, type: _U.LocalVideoTrack }), s2 = true), t2)) {
              const e3 = this.getLowVideoTrack(o3, i3);
              n2.push({ track: e3, type: _U.LocalVideoLowTrack });
            }
            if (o3 instanceof TL) {
              const e3 = this.localTrackMap.get(_U.LocalAudioTrack);
              if (e3) {
                if (!(e3.track instanceof RL))
                  throw new Ew(_w.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing");
                if (o3._bypassWebAudio)
                  throw new Ew(_w.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio");
                e3.track.addAudioTrack(o3), this.bindLocalAudioTrackEvents(o3, true);
              } else if (a2) {
                const e4 = n2.find((e5) => {
                  let { type: t3 } = e5;
                  return t3 === _U.LocalAudioTrack;
                });
                if (!(e4.track instanceof RL))
                  throw new Ew(_w.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing");
                if (o3._bypassWebAudio)
                  throw new Ew(_w.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio");
                e4.track.addAudioTrack(o3);
              } else {
                if (!r2.webAudioMediaStreamDest || o3 instanceof RL || o3._bypassWebAudio)
                  n2.push({ track: o3, type: _U.LocalAudioTrack });
                else {
                  const e4 = new RL();
                  e4.addAudioTrack(o3), n2.push({ track: e4, type: _U.LocalAudioTrack });
                }
                a2 = true;
              }
            }
          }
          return n2;
        }
        filterTobeUnpublishedTracks(e2) {
          const t2 = [], i3 = this.getAllTracks();
          e2 = Qw(e2 = e2.filter((e3) => -1 !== i3.indexOf(e3)));
          for (const i4 of e2) {
            if (i4 instanceof TL) {
              const e3 = this.localTrackMap.get(_U.LocalAudioTrack);
              if (!e3)
                continue;
              e3.track instanceof RL ? (e3.track.removeAudioTrack(i4), this.unbindLocalAudioTrackEvents(i4), 0 === e3.track.trackList.length && (t2.push([_U.LocalAudioTrack, e3]), e3.track.close())) : t2.push([_U.LocalAudioTrack, e3]);
            }
            if (i4 instanceof ak) {
              const e3 = this.localTrackMap.get(_U.LocalVideoTrack);
              if (!e3)
                continue;
              t2.push([_U.LocalVideoTrack, e3]);
              const i5 = this.localTrackMap.get(_U.LocalVideoLowTrack);
              i5 && t2.push([_U.LocalVideoLowTrack, i5]);
            }
          }
          return t2;
        }
        bindLocalTrackEvents(e2) {
          e2.forEach((e3) => {
            let { track: t2, type: i3 } = e3;
            switch (i3) {
              case _U.LocalVideoTrack:
                t2.addListener(ED.GET_STATS, this.handleGetLocalVideoStats), t2.addListener(ED.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t2.addListener(ED.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t2.addListener(ED.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t2.addListener(ED.NEED_UPDATE_VIDEO_SEND_PARAMETERS, this.handleUpdateVideoSendParameters), t2.addListener(ED.NEED_REPLACE_TRACK, this.handleReplaceTrack), t2.addListener(ED.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t2.addListener(ED.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
                break;
              case _U.LocalAudioTrack:
                this.bindLocalAudioTrackEvents(t2);
              case _U.LocalVideoLowTrack:
            }
          });
        }
        bindLocalAudioTrackEvents(e2, t2) {
          e2 instanceof RL ? e2.trackList.forEach((e3) => {
            e3.addListener(ED.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e3.addListener(ED.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e3.addListener(ED.GET_STATS, this.handleGetLocalAudioStats), e3.addListener(ED.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e3.addListener(ED.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
          }) : (e2.addListener(ED.GET_STATS, this.handleGetLocalAudioStats), e2.addListener(ED.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e2.addListener(ED.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e2.addListener(ED.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e2.addListener(ED.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack), t2 || e2.addListener(ED.NEED_REPLACE_TRACK, this.handleReplaceTrack));
        }
        unbindLocalTrackEvents(e2) {
          e2 || (e2 = Array.from(this.localTrackMap.entries()).map((e3) => {
            let [t2, { track: i3 }] = e3;
            return { track: i3, type: t2 };
          })), e2.forEach((e3) => {
            let { track: t2, type: i3 } = e3;
            switch (i3) {
              case _U.LocalVideoTrack:
                t2.off(ED.GET_STATS, this.handleGetLocalVideoStats), t2.off(ED.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t2.off(ED.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t2.off(ED.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t2.off(ED.NEED_UPDATE_VIDEO_SEND_PARAMETERS, this.handleUpdateVideoSendParameters), t2.off(ED.NEED_REPLACE_TRACK, this.handleReplaceTrack), t2.off(ED.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t2.off(ED.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
                break;
              case _U.LocalAudioTrack:
                this.unbindLocalAudioTrackEvents(t2);
              case _U.LocalVideoLowTrack:
            }
          });
        }
        unbindLocalAudioTrackEvents(e2) {
          e2 instanceof RL ? e2.trackList.forEach((e3) => {
            e3.off(ED.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e3.off(ED.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e3.off(ED.GET_STATS, this.handleGetLocalAudioStats), e3.off(ED.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e3.off(ED.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
          }) : (e2.off(ED.GET_STATS, this.handleGetLocalAudioStats), e2.off(ED.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e2.off(ED.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e2.off(ED.NEED_REPLACE_TRACK, this.handleReplaceTrack), e2.off(ED.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e2.off(ED.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack));
        }
        bindRemoteTrackEvents(e2, t2) {
          t2 instanceof vk && t2.addListener(ED.GET_STATS, (t3) => {
            t3(this.handleGetRemoteVideoStats(e2));
          }), t2 instanceof Ik && t2.addListener(ED.GET_STATS, (t3) => {
            t3(this.handleGetRemoteAudioStats(e2));
          });
        }
        unbindRemoteTrackEvents(e2) {
          e2 && e2.removeAllListeners(ED.GET_STATS);
        }
        unbindAllRemoteTrackEvents() {
          Array.from(this.remoteUserMap.entries()).forEach((e2) => {
            let [t2, i3] = e2;
            i3.has(lU.AUDIO) && this.unbindRemoteTrackEvents(t2._audioTrack), i3.has(lU.VIDEO) && this.unbindRemoteTrackEvents(t2._videoTrack);
          });
        }
        createGatewayPublishMessage(e2, t2) {
          return e2.map((e3, i3) => {
            var n2;
            let r2, { track: o2, type: s2 } = e3;
            switch (s2) {
              case _U.LocalAudioTrack:
                r2 = ZM.Audio;
                break;
              case _U.LocalVideoTrack:
                r2 = Dn(n2 = o2._hints).call(n2, fD.SCREEN_TRACK) ? ZM.Screen : ZM.High;
                break;
              case _U.LocalVideoLowTrack:
                r2 = ZM.Low;
            }
            return { kind: s2 === _U.LocalAudioTrack ? lU.AUDIO : lU.VIDEO, stream_type: r2, mid: t2[i3].id, ssrcs: t2[i3].localSSRC, isMuted: o2.muted || !o2.enabled };
          });
        }
        createGatewayUnpublishMessage(e2) {
          return e2.map((e3) => {
            var t2;
            let i3, [n2, { track: r2, ssrcs: o2, id: s2 }] = e3;
            switch (n2) {
              case _U.LocalVideoTrack:
                i3 = Dn(t2 = r2._hints).call(t2, fD.SCREEN_TRACK) ? ZM.Screen : ZM.High;
                break;
              case _U.LocalAudioTrack:
                i3 = ZM.Audio;
                break;
              case _U.LocalVideoLowTrack:
                i3 = ZM.Low;
            }
            return { stream_type: i3, ssrcs: o2, mid: s2 };
          });
        }
        assignLocalTracks(e2, t2) {
          e2.forEach((e3, i3) => {
            let { track: n2, type: r2 } = e3;
            this.localTrackMap.set(r2, { track: n2, id: t2[i3].id, ssrcs: t2[i3].localSSRC });
          });
        }
        withdrawLocalTracks(e2) {
          e2.forEach((e3) => {
            let [t2] = e3;
            this.localTrackMap.delete(t2);
          });
        }
        bindConnectionEvents(e2) {
          e2.onConnectionStateChange = async (t2) => {
            var i3;
            BN.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: ").concat(e2.name, ".onConnectionStateChange(").concat(t2, ")")), this.emit(fU.PeerConnectionStateChange, t2), "connected" !== t2 || this.store.keyMetrics.peerConnectionEnd || this.store.peerConnectionEnd(), "connected" === t2 && (e2.isInRestartIce = false), Dn(i3 = this._restartStates).call(i3, t2) && !e2.isInRestartIce && ("disconnected" === t2 && await lO(800), "disconnected" !== e2.iceConnectionState && "failed" !== e2.iceConnectionState || this.handleDisconnect(e2.direction));
          }, e2.onICEConnectionStateChange = (e3) => {
            "connected" !== e3 || this.store.keyMetrics.iceConnectionEnd || this.store.iceConnectionEnd(), BN.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICEConnectionStateChange(").concat(e3, ")")), zN.reportApiInvoke(this.store.sessionId, { name: "ICEConnectionStateChange", options: e3, tag: kw.TRACER }).onSuccess(), this.emit(fU.IceConnectionStateChange, e3);
          }, e2.onICETransportStateChange = (e3) => {
            BN.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICETransportStateChange(").concat(e3, ")"));
          }, e2.onDTLSTransportStateChange = (e3) => {
            BN.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportStateChange(").concat(e3, ")"));
          }, e2.onDTLSTransportError = (e3) => {
            BN.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportError(").concat(e3, ")"));
          }, e2.onFirstAudioDecoded = (e3) => {
            var t2;
            const i3 = Array.from(ON(t2 = this.remoteUserMap).call(t2)).find((t3) => t3._audioSSRC === e3);
            var n2;
            i3 && (this.store.subscribe(i3.uid, "audio", void 0, void 0, void 0, Date.now()), null === (n2 = i3.audioTrack) || void 0 === n2 || n2.emit(CD.FIRST_FRAME_DECODED), zN.firstRemoteFrame(this.store.sessionId, HN.FIRST_AUDIO_DECODE, KN.FIRST_AUDIO_DECODE, { peer: i3._uintid, subscribeElapse: UV.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId }));
          }, e2.onFirstAudioReceived = (e3) => {
            var t2;
            const i3 = Array.from(ON(t2 = this.remoteUserMap).call(t2)).find((t3) => t3._audioSSRC === e3);
            i3 && zN.firstRemoteFrame(this.store.sessionId, HN.FIRST_AUDIO_RECEIVED, KN.FIRST_AUDIO_RECEIVED, { peer: i3._uintid, subscribeElapse: UV.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId });
          }, e2.onFirstVideoDecoded = (e3, t2, i3) => {
            this.reportVideoFirstFrameDecoded(e3, t2, i3);
          }, e2.onFirstVideoReceived = (e3) => {
            var t2;
            const i3 = Array.from(ON(t2 = this.remoteUserMap).call(t2)).find((t3) => t3._videoSSRC === e3);
            i3 && zN.firstRemoteFrame(this.store.sessionId, HN.FIRST_VIDEO_RECEIVED, KN.FIRST_VIDEO_RECEIVED, { peer: i3._uintid, subscribeElapse: UV.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId });
          }, e2.onSelectedLocalCandidateChanged = (e3, t2) => {
            const i3 = "relay" === e3.candidateType, n2 = "relay" === t2.candidateType;
            "unknown" !== t2.candidateType && i3 === n2 || this.emit(fU.ConnectionTypeChange, i3), BN.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.SelectedLocalCandidateChanged(").concat(JSON.stringify(rx(t2)), " -> ").concat(JSON.stringify(rx(e3)), ")"));
          }, e2.onSelectedRemoteCandidateChanged = (e3, t2) => {
            BN.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.SelectedRemoteCandidateChanged(").concat(JSON.stringify(rx(t2)), " -> ").concat(JSON.stringify(rx(e3)), ")"));
          }, e2.onFirstVideoDecodedTimeout = (e3) => {
            this.reportVideoFirstFrameDecoded(e3, void 0, void 0, true);
          }, e2.onLocalCandidate = (t2) => {
            this.emit(fU.LocalCandidate, { candidate: t2, direction: e2.direction });
          };
        }
        unbindConnectionEvents(e2) {
          e2.onConnectionStateChange = void 0, e2.onICEConnectionStateChange = void 0, e2.onICETransportStateChange = void 0, e2.onDTLSTransportStateChange = void 0, e2.onDTLSTransportError = void 0, e2.onFirstAudioDecoded = void 0, e2.onFirstAudioReceived = void 0, e2.onFirstVideoDecoded = void 0, e2.onFirstVideoReceived = void 0, e2.onSelectedLocalCandidateChanged = void 0, e2.onSelectedRemoteCandidateChanged = void 0, e2.onFirstVideoDecodedTimeout = void 0, e2.onLocalCandidate = void 0;
        }
        async handleDisconnect(e2) {
          const t2 = e2 === MM.SEND_ONLY ? this.sendConnection : this.recvConnection;
          t2 && !t2.isInRestartIce && (t2.isInRestartIce = true, BN.debug("[".concat(this.store.clientId, "] [P2PChannel-").concat(t2.name, "] start use restartICE")), e2 === MM.SEND_ONLY ? this.restartICE(e2) : Kw(this, fU.RequestP2PRestartICE, { direction: MM.SEND_ONLY }));
        }
        filterTobeMutedTracks(e2) {
          const t2 = [];
          if (-1 === this.getAllTracks().indexOf(e2))
            return t2;
          const i3 = this.localTrackMap.get(_U.LocalAudioTrack);
          if (e2 instanceof TL && (null == i3 ? void 0 : i3.track) instanceof RL)
            return i3.track.isActive || t2.push([_U.LocalAudioTrack, i3]), t2;
          const n2 = Array.from(this.localTrackMap.entries()).find((t3) => {
            let [, { track: i4 }] = t3;
            return e2 === i4;
          });
          if (n2 && (t2.push(n2), n2[0] === _U.LocalVideoTrack)) {
            const e3 = this.localTrackMap.get(_U.LocalVideoLowTrack);
            e3 && t2.push([_U.LocalVideoLowTrack, e3]);
          }
          return t2;
        }
        filterTobeUnmutedTracks(e2) {
          const t2 = [], i3 = this.localTrackMap.get(_U.LocalAudioTrack);
          if (e2 instanceof TL && (null == i3 ? void 0 : i3.track) instanceof RL)
            return i3.track.isActive && t2.push([_U.LocalAudioTrack, i3]), t2;
          const n2 = Array.from(this.localTrackMap.entries()).find((t3) => {
            let [, { track: i4 }] = t3;
            return e2 === i4;
          });
          if (n2)
            if (n2[0] === _U.LocalVideoTrack) {
              t2.push(n2);
              const e3 = this.localTrackMap.get(_U.LocalVideoLowTrack);
              e3 && t2.push([_U.LocalVideoLowTrack, e3]);
            } else
              t2.push(n2);
          return t2;
        }
        createMuteMessage(e2) {
          return e2.map((e3) => {
            var t2;
            let i3, [n2, { track: r2, ssrcs: o2, id: s2 }] = e3;
            switch (n2) {
              case _U.LocalAudioTrack:
                i3 = ZM.Audio;
                break;
              case _U.LocalVideoTrack:
                i3 = Dn(t2 = r2._hints).call(t2, fD.SCREEN_TRACK) ? ZM.Screen : ZM.High;
                break;
              case _U.LocalVideoLowTrack:
                i3 = ZM.Low;
            }
            return { stream_type: i3, ssrcs: o2, mid: s2 };
          });
        }
        createUnmuteMessage(e2) {
          return e2.map((e3) => {
            var t2;
            let i3, [n2, { track: r2, ssrcs: o2, id: s2 }] = e3;
            switch (n2) {
              case _U.LocalAudioTrack:
                i3 = ZM.Audio;
                break;
              case _U.LocalVideoTrack:
                i3 = Dn(t2 = r2._hints).call(t2, fD.SCREEN_TRACK) ? ZM.Screen : ZM.High;
                break;
              case _U.LocalVideoLowTrack:
                i3 = ZM.Low;
            }
            return { stream_type: i3, ssrcs: o2, mid: s2 };
          });
        }
        filterTobeUnSubscribedTracks(e2, t2) {
          const i3 = [], n2 = this.remoteUserMap.get(e2);
          if (!n2)
            return i3;
          if (t2) {
            const r2 = n2.get(t2);
            if (!r2)
              return i3;
            i3.push([e2, { kind: t2, id: r2 }]);
          } else
            Array.from(n2.entries()).forEach((t3) => {
              let [n3, r2] = t3;
              i3.push([e2, { kind: n3, id: r2 }]);
            });
          return i3;
        }
        createUnsubscribeMessage(e2) {
          const t2 = [];
          return e2.forEach((e3) => {
            let [i3, { kind: n2, id: r2 }] = e3;
            switch (n2) {
              case lU.VIDEO:
                return void (i3._videoSSRC && t2.push({ stream_type: lU.VIDEO, ssrcId: i3._videoSSRC }));
              case lU.AUDIO:
                return void (i3._audioSSRC && t2.push({ stream_type: lU.AUDIO, ssrcId: i3._audioSSRC }));
            }
          }), t2;
        }
        withdrawRemoteTracks(e2) {
          e2.forEach((e3) => {
            let [t2, { kind: i3 }] = e3;
            const n2 = this.remoteUserMap.get(t2);
            n2 && (n2.delete(i3), 0 === Array.from(n2.entries()).length && this.remoteUserMap.delete(t2));
          });
        }
        async updateBitrateLimit(e2) {
          const t2 = this.localTrackMap.get(_U.LocalVideoTrack), i3 = this.localTrackMap.get(_U.LocalVideoLowTrack);
          t2 && (await t2.track.setBitrateLimit(e2.uplink), await new Wh((e3, i4) => {
            this.handleUpdateVideoEncoder(t2.track, e3, i4, true);
          })), i3 && e2.low_stream_uplink && (await i3.track.setBitrateLimit({ max_bitrate: e2.low_stream_uplink.bitrate, min_bitrate: e2.low_stream_uplink.bitrate || 0 }), await new Wh((e3, t3) => {
            this.handleUpdateVideoEncoder(i3.track, e3, t3, true);
          }));
        }
        isP2PDisconnected() {
          if (this.sendConnection && this.recvConnection) {
            const e2 = this.sendConnection.peerConnectionState, t2 = this.recvConnection.peerConnectionState;
            return "connected" !== e2 && "connected" !== t2;
          }
          return true;
        }
        async tryToUnmuteAudio(e2) {
          for (let t2 = 0; t2 < e2.length; t2++)
            if (e2[t2] instanceof TL) {
              const i3 = this.filterTobeUnmutedTracks(e2[t2]);
              if (0 === i3.length)
                continue;
              const n2 = this.createUnmuteMessage(i3);
              return void await Yw(this, fU.RequestUnmuteLocal, n2);
            }
        }
        bindStatsUploaderEvents() {
          this.statsUploader.requestStats = (e2) => this.getStats(e2), this.statsUploader.requestLocalMedia = () => Array.from(this.localTrackMap.entries()).filter((e2) => {
            let [, { ssrcs: t2 }] = e2;
            return !!t2;
          }), this.statsUploader.requestRemoteMedia = () => Array.from(this.remoteUserMap.entries()), this.statsUploader.requestVideoIsReady = (e2) => {
            var t2;
            return !(null === (t2 = this.recvConnection) || void 0 === t2 || !t2.getRemoteVideoIsReady(e2));
          }, this.statsUploader.requestUpload = (e2, t2) => this.emit(fU.RequestUpload, e2, t2), this.statsUploader.requestUploadStats = (e2) => this.emit(fU.RequestUploadStats, e2), this.statsUploader.requestAllTracks = () => this.getAllTracks();
        }
        unbindStatsUploaderEvents() {
          this.statsUploader.requestStats = void 0, this.statsUploader.requestLocalMedia = void 0, this.statsUploader.requestRemoteMedia = void 0, this.statsUploader.requestVideoIsReady = void 0;
        }
        async requestReconnect() {
          this.dtlsFailedCount += 1, await lO(AO(this.dtlsFailedCount, yO)), this.emit(fU.RequestReconnect);
        }
        async reconnectP2P() {
        }
        canPublishLowStream() {
          return this.localTrackMap.has(_U.LocalVideoTrack) || this.pendingLocalTracks.some((e2) => e2 instanceof ak);
        }
        throwIfTrackTypeNotMatch(e2) {
          if (e2.filter((e3) => e3 instanceof ak).length > 1)
            throw new Ew(_w.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
          if (e2.filter((e3) => e3 instanceof TL).length > 1 && (e2.some((e3) => e3 instanceof TL && e3._bypassWebAudio) || !QN().webAudioMediaStreamDest))
            throw new Ew(_w.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
          for (const t2 of e2) {
            if (t2 instanceof ak && this.pendingLocalTracks.some((e3) => e3 instanceof ak))
              throw new Ew(_w.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
            if (t2 instanceof TL && this.pendingLocalTracks.some((e3) => e3 instanceof TL) && (!QN().webAudioMediaStreamDest || t2._bypassWebAudio || this.pendingLocalTracks.some((e3) => e3 instanceof TL && e3._bypassWebAudio)))
              throw new Ew(_w.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
          }
        }
        getLowVideoTrack(e2, t2) {
          const i3 = !dN("DISABLE_DUAL_STREAM_USE_ENCODING") && QN().supportDualStreamEncoding, n2 = hq(hq({}, { width: 160, height: 120, framerate: 15, bitrate: 50 }), t2);
          let r2;
          r2 = i3 ? e2._mediaStreamTrack.clone() : TF(e2, n2);
          const o2 = uO(8, "track-low-"), s2 = new ak(r2, hq(hq({}, i3 && { scaleResolutionDownBy: nx(n2, e2) }), {}, { frameRate: n2.framerate, bitrateMax: n2.bitrate, bitrateMin: n2.bitrate }), void 0, void 0, o2);
          return s2.on(gD.TRANSCEIVER_UPDATED, (t3) => {
            e2._updateRtpTransceiver(t3, mD.LOW_STREAM);
          }), s2._hints.push(fD.LOW_STREAM), e2.addListener(ED.NEED_CLOSE, () => {
            s2.close();
          }), s2;
        }
        async globalLock() {
          return this.recvMutex.lock("From P2PChannel2.globalLock");
        }
        reportVideoFirstFrameDecoded(e2, t2, i3, n2) {
          var r2;
          const o2 = Array.from(ON(r2 = this.remoteUserMap).call(r2)).find((t3) => t3._videoSSRC === e2);
          if (o2) {
            n2 || this.store.subscribe(o2.uid, "video", void 0, void 0, void 0, void 0, Date.now());
            const r3 = this.store.keyMetrics, s2 = r3.subscribe.find((e3) => e3.userId === o2.uid && "video" === e3.type);
            zN.firstRemoteVideoDecode(this.store.sessionId, HN.FIRST_VIDEO_DECODE, KN.FIRST_VIDEO_DECODE, { peer: o2._uintid, videowidth: t2, videoheight: i3, subscribeElapse: UV.measureFromSubscribeStart(this.store.clientId, e2), subscribeRequestid: e2, p2pid: this.store.p2pId, apEnd: r3.requestAPEnd || 0, apStart: r3.requestAPStart || 0, joinGwEnd: r3.joinGatewayEnd || 0, joinGwStart: r3.joinGatewayStart || 0, pcEnd: r3.peerConnectionEnd || 0, pcStart: r3.peerConnectionStart || 0, subscriberEnd: (null == s2 ? void 0 : s2.subscribeEnd) || 0, subscriberStart: (null == s2 ? void 0 : s2.subscribeStart) || 0, videoAddNotify: (null == s2 ? void 0 : s2.streamAdded) || 0, state: n2 ? 1 : 0 });
          }
        }
        async remoteMediaSsrcChanged(e2, t2, i3) {
          if (!this.recvConnection)
            return false;
          const n2 = this.remoteUserMap.get(e2);
          if (!n2)
            return false;
          const r2 = n2.get(t2);
          if (!r2)
            return false;
          const o2 = await this.recvConnection.getRemoteSSRC(r2);
          return void 0 !== o2 && o2 !== i3;
        }
        isPreSubScribe(e2) {
          return false;
        }
        async publishDataChannel(e2) {
          throw new Ew(_w.NOT_SUPPORTED);
        }
        async unpublishDataChannel(e2) {
          throw new Ew(_w.NOT_SUPPORTED);
        }
        async subscribeDataChannel(e2, t2) {
          throw new Ew(_w.NOT_SUPPORTED);
        }
        async unsubscribeDataChannel(e2, t2) {
          throw new Ew(_w.NOT_SUPPORTED);
        }
        hasPendingRemoteDataChannel(e2, t2) {
          throw new Ew(_w.NOT_SUPPORTED);
        }
        setPendingRemoteDataChannel(e2, t2) {
          throw new Ew(_w.NOT_SUPPORTED);
        }
        async preConnect(e2) {
          throw new Ew(_w.NOT_SUPPORTED);
        }
        getEstablishParams() {
          throw new Ew(_w.NOT_SUPPORTED);
        }
        async reSubscribe(e2) {
          throw new Ew(_w.NOT_SUPPORTED);
        }
        async updateVideoStreamParameter(e2, t2) {
          throw new Ew(_w.NOT_SUPPORTED);
        }
        unbindRtpTransceiver() {
          0 !== this.localTrackMap.size && Array.from(this.localTrackMap.entries()).forEach((e2) => {
            let [t2, { track: i3 }] = e2;
            t2 === _U.LocalVideoLowTrack ? i3._updateRtpTransceiver(void 0, mD.LOW_STREAM) : i3._updateRtpTransceiver(void 0);
          });
        }
      }, IM(lq.prototype, "p2pConnect", [$Y], Object.getOwnPropertyDescriptor(lq.prototype, "p2pConnect"), lq.prototype), IM(lq.prototype, "unpublish", [eq2], Object.getOwnPropertyDescriptor(lq.prototype, "unpublish"), lq.prototype), IM(lq.prototype, "unpublishLowStream", [tq], Object.getOwnPropertyDescriptor(lq.prototype, "unpublishLowStream"), lq.prototype), IM(lq.prototype, "subscribe", [iq], Object.getOwnPropertyDescriptor(lq.prototype, "subscribe"), lq.prototype), IM(lq.prototype, "mockSubscribe", [nq], Object.getOwnPropertyDescriptor(lq.prototype, "mockSubscribe"), lq.prototype), IM(lq.prototype, "unsubscribe", [rq], Object.getOwnPropertyDescriptor(lq.prototype, "unsubscribe"), lq.prototype), IM(lq.prototype, "muteRemote", [oq], Object.getOwnPropertyDescriptor(lq.prototype, "muteRemote"), lq.prototype), IM(lq.prototype, "unmuteRemote", [sq], Object.getOwnPropertyDescriptor(lq.prototype, "unmuteRemote"), lq.prototype), IM(lq.prototype, "hasRemoteMediaWithLock", [aq], Object.getOwnPropertyDescriptor(lq.prototype, "hasRemoteMediaWithLock"), lq.prototype), IM(lq.prototype, "disconnectForReconnect", [cq], Object.getOwnPropertyDescriptor(lq.prototype, "disconnectForReconnect"), lq.prototype), IM(lq.prototype, "remoteMediaSsrcChanged", [dq], Object.getOwnPropertyDescriptor(lq.prototype, "remoteMediaSsrcChanged"), lq.prototype), lq);
      function _q(e2) {
        return function(t2, i3, n2) {
          const r2 = t2[i3];
          if ("function" != typeof r2)
            throw new Error("Cannot use mutex on object property.");
          return n2.value = async function() {
            for (var t3 = arguments.length, n3 = new Array(t3), o2 = 0; o2 < t3; o2++)
              n3[o2] = arguments[o2];
            switch (e2) {
              case ZY.SEND_ONLY: {
                const e3 = await this.sendMutex.lock("From P2PChannel2.".concat(i3));
                try {
                  return await r2.apply(this, n3);
                } finally {
                  e3();
                }
              }
              case ZY.RECEIVE_ONLY: {
                const e3 = await this.recvMutex.lock("From P2PChannel2.".concat(i3));
                try {
                  return await r2.apply(this, n3);
                } finally {
                  e3();
                }
              }
              default: {
                const e3 = await this.sendMutex.lock("From P2PChannel2.".concat(i3)), t4 = await this.recvMutex.lock("From P2PChannel2.".concat(i3));
                try {
                  return await r2.apply(this, n3);
                } finally {
                  e3(), t4();
                }
              }
            }
          }, n2;
        };
      }
      class Eq extends Nw {
        constructor(e2, t2) {
          super(), QI(this, "signal", void 0), QI(this, "token", void 0), QI(this, "tokenTimeout", void 0), QI(this, "tokenInterval", void 0), QI(this, "_sequence", 0), QI(this, "userMap", /* @__PURE__ */ new Map()), QI(this, "encoder", new TextEncoder()), this.signal = e2, this.token = t2;
          const i3 = () => {
            this.signal.connectionState === NM.CONNECTED && this.check(), 0 === this.userMap.size ? this.tokenInterval = window.setTimeout(i3, 1e3) : this.tokenInterval = window.setTimeout(i3, 3 * dN("P2P_TOKEN_INTERVAL"));
          };
          i3();
        }
        async send(e2, t2, i3, n2, r2) {
          var o2, s2, a2;
          if (0 === this.userMap.size)
            return;
          const c2 = Array.from(Zh(o2 = this.userMap).call(o2))[0].token;
          "string" != typeof t2 && (t2 = JSON.stringify(t2)), n2 = null !== (s2 = n2) && void 0 !== s2 ? s2 : uO(6, ""), r2 = null !== (a2 = r2) && void 0 !== a2 ? a2 : this._sequence++;
          const d2 = { _id: n2, _type: e2, _seq: r2, _message: t2, token: "".concat(this.token, "_").concat(c2) };
          dN("SHOW_P2P_LOG") && BN.debug("send message", d2, "noNeedResponse : ".concat(i3));
          this.splitMessage(JSON.stringify(d2)).forEach((e3) => {
            this.signal.request(PM.DATA_STREAM, { payload: rO(this.encoder.encode(e3)) });
          });
          const l2 = new Wh((t3, r3) => {
            const o3 = window.setTimeout(() => {
              this.off("res-@".concat(n2, "_ack"), s3), this.off("res-@".concat(n2), c3), this.off(AU.ABORT, a3), BN.debug("[external-signal] request timeout, type: ".concat(e2, ", requestId: ").concat(n2)), 0 === this.userMap.size ? r3(new Ew(_w.INVALID_REMOTE_USER)) : r3(new Ew(_w.TIMEOUT));
            }, dN("EXTERNAL_SIGNAL_REQUEST_TIMEOUT")), s3 = () => {
              o3 && window.clearTimeout(o3), this.off(AU.ABORT, a3), i3 && t3();
            }, a3 = () => {
              o3 && window.clearTimeout(o3), this.off("res-@".concat(n2, "_ack"), s3), this.off("res-@".concat(n2), c3), r3(new Ew(_w.EXTERNAL_SIGNAL_ABORT, "type: ".concat(e2, ", requestId: ").concat(n2)));
            };
            this.once(AU.ABORT, a3), this.once("res-@".concat(n2, "_ack"), s3);
            const c3 = (i4, c4) => {
              l3 = true, o3 && window.clearTimeout(o3), this.off("res-@".concat(n2, "_ack"), s3), this.off(AU.ABORT, a3), "success" === i4 ? t3(c4) : r3(new Ew(_w.P2P_MESSAGE_FAILED, "request ".concat(e2, " failed, requestId: ").concat(n2)));
            };
            let l3 = false;
            i3 || (this.once("res-@".concat(n2), c3), lO(dN("SIGNAL_REQUEST_TIMEOUT")).then(() => {
              l3 || BN.warning("external_signal request timeout, type: ".concat(e2, ", requestId: ").concat(n2, ", ").concat(d2));
            }));
          });
          try {
            return await l2;
          } catch (o3) {
            if (o3.code === _w.TIMEOUT)
              return await this.send(e2, t2, i3, n2, r2);
            throw o3;
          }
        }
        onMessage(e2) {
          var t2;
          const { _uid: i3 } = e2;
          let n2, r2 = this.userMap.get(i3);
          if (r2)
            n2 = r2.splitMessageMap;
          else {
            if (this.userMap.size > 0 || !("_type" in e2) || e2._type !== yU.CHECK)
              return;
            const { token: t3 } = e2;
            n2 = /* @__PURE__ */ new Map(), r2 = { uid: i3, isStart: true, token: t3, splitMessageMap: n2, nextExpectedSequenceNumber: 0, receivedMessagesMap: /* @__PURE__ */ new Map() }, this.userMap.set(i3, r2), this.signal.emit(kM.ON_USER_ONLINE, { uid: i3 }), this.handleUserOnline();
          }
          if ("id" in e2 && "total" in e2) {
            var o2;
            const { id: t3, total: r3 } = e2, s3 = null !== (o2 = n2.get(t3)) && void 0 !== o2 ? o2 : [];
            if (s3.push(e2), n2.has(t3) || n2.set(t3, s3), s3.length !== r3)
              return;
            {
              const r4 = CS(s3).call(s3, (e3, t4) => e3.index - t4.index).map((e3) => e3.payload).join("");
              n2.delete(t3), (e2 = JSON.parse(r4))._uid = i3;
            }
          }
          const { _type: s2, token: a2 } = e2;
          if (Dn(t2 = [yU.ACK, yU.CHECK]).call(t2, s2))
            return s2 === yU.CHECK && this.handleCheckToken(r2, a2), void this.receiveMessage(e2);
          a2 === "".concat(r2.token, "_").concat(this.token) ? this.handleReceivedMessage(e2) : BN.debug('Receive unexpected message", '.concat(a2, ", cur_token: ").concat(r2.token, "_").concat(this.token), e2);
        }
        check() {
          const e2 = { _id: uO(6, ""), token: this.token, _type: yU.CHECK };
          dN("SHOW_P2P_LOG") && BN.debug("send message", e2), this.signal.request(PM.DATA_STREAM, { payload: rO(this.encoder.encode(JSON.stringify(e2))) });
        }
        ack(e2) {
          const t2 = { _id: e2, _type: yU.ACK, token: this.token };
          dN("SHOW_P2P_LOG") && BN.debug("send message", t2), this.signal.request(PM.DATA_STREAM, { payload: rO(this.encoder.encode(JSON.stringify(t2))) });
        }
        response(e2, t2, i3) {
          this.send(yU.RESPONSE, JSON.stringify({ success: !i3, message: t2 }), true, e2);
        }
        handleReceivedMessage(e2) {
          const t2 = () => {
            this.userMap.forEach((e3) => {
              const { receivedMessagesMap: t3, nextExpectedSequenceNumber: i4 } = e3;
              for (; t3.has(i4); ) {
                const n3 = t3.get(i4);
                t3.delete(i4), this.receiveMessage(n3), e3.nextExpectedSequenceNumber++;
              }
            });
          };
          if (!e2)
            return void t2();
          const { _uid: i3, _seq: n2 } = e2, r2 = this.userMap.get(i3), { receivedMessagesMap: o2, isStart: s2, nextExpectedSequenceNumber: a2 } = r2;
          if (n2 < a2)
            return this.ack(e2._id), void BN.debug("[external-signal] receive old message, seq: ".concat(n2, ", ").concat(e2._message));
          o2.set(n2, e2), s2 && n2 === a2 && (this.receiveMessage(e2), o2.delete(a2), r2.nextExpectedSequenceNumber++, t2());
        }
        receiveMessage(e2) {
          const { _id: t2, _type: i3, _message: n2, _uid: r2 } = e2;
          if (dN("SHOW_P2P_LOG") && BN.debug("receive message", e2), t2) {
            let o2;
            switch (e2._type !== yU.ACK && (n2 && (o2 = JSON.parse(n2)), this.ack(e2._id)), e2._type) {
              case yU.CANDIDATE:
              case yU.CONTROL:
                this.signal.emit(i3, o2, r2);
                break;
              case yU.PUBLISH:
              case yU.UNPUBLISH:
              case yU.RESTART_ICE:
              case yU.CALL:
                o2.uid = r2, Kw(this.signal, i3, o2).then((t3) => {
                  this.response(e2._id, t3);
                }).catch(() => {
                  this.response(e2._id, void 0, true);
                });
                break;
              case yU.ACK:
                this.getListeners("res-@".concat(t2, "_ack")).length > 0 && this.emit("res-@".concat(t2, "_ack"));
                break;
              case yU.RESPONSE: {
                const { success: e3, message: i4 } = o2;
                this.emit("res-@".concat(t2), e3 ? "success" : "failed", i4);
                break;
              }
            }
          }
        }
        splitMessage(e2) {
          if (e2.length < Eq.MAX_MESSAGE_SIZE)
            return [e2];
          const t2 = [], { remoteToken: i3 } = JSON.parse(e2), n2 = uO(6, "");
          let r2 = 0, o2 = 800;
          const s2 = Math.ceil(e2.length / o2);
          for (; e2.length > 0; ) {
            r2++;
            const a2 = { id: n2, index: r2, total: s2, payload: e2.slice(0, o2), token: "".concat(this.token, "_").concat(i3) };
            JSON.stringify(a2).length > Eq.MAX_MESSAGE_SIZE ? o2 -= 50 : (t2.push(a2), e2 = e2.slice(o2));
          }
          return t2.map((e3) => JSON.stringify(e3));
        }
        handleCheckToken(e2, t2) {
          return e2.token !== t2 ? (BN.debug("token changed, from ".concat(e2.token, " to ").concat(t2)), this.reset(e2.uid, t2), false) : (this.tokenTimeout && (window.clearTimeout(this.tokenTimeout), this.tokenTimeout = void 0), this.tokenTimeout = window.setTimeout(() => {
            BN.debug("token timeout, ".concat(t2)), this.reset(e2.uid);
          }, dN("MAX_P2P_TIMEOUT")), true);
        }
        async handleUserOnline() {
          const e2 = await Kw(this.signal, yU.CALL, void 0), t2 = await this.send(yU.CALL, e2);
          this.signal.emit(DM.P2P_CONNECTION, t2, true);
        }
        async reset(e2, t2) {
          const i3 = this.userMap.get(e2);
          i3 && (this.emit(AU.ABORT), this.signal.emit(kM.ON_USER_OFFLINE, { uid: i3.uid, reason: wU.P2P_TOKEN_CHANGED }), this._sequence = 0, this.userMap.clear(), t2 || (BN.debug("change local token from ".concat(t2, " to ").concat(t2)), this.token = uO(6, "")));
        }
        clear() {
          this._sequence = 0, this.userMap.clear(), this.tokenInterval && window.clearTimeout(this.tokenInterval), this.tokenInterval = void 0, this.tokenTimeout && window.clearTimeout(this.tokenTimeout), this.tokenTimeout = void 0, this.emit(AU.ABORT);
        }
      }
      QI(Eq, "MAX_SIZE", 1), QI(Eq, "MAX_MESSAGE_SIZE", 1024);
      class fq extends Nw {
        get connectionState() {
          return this._connectionState;
        }
        set connectionState(e2) {
          e2 !== this._connectionState && (this._connectionState = e2, e2 === NM.CONNECTED ? this.emit(DM.WS_CONNECTED) : e2 === NM.RECONNECTING ? this.emit(DM.WS_RECONNECTING, this._websocketReconnectReason) : e2 === NM.CLOSED && this.emit(DM.WS_CLOSED, this._disconnectedReason));
        }
        get currentURLIndex() {
          return this.websocket.currentURLIndex;
        }
        get url() {
          return this.websocket && this.websocket.url || null;
        }
        get rtt() {
          return this.rttRolling.mean();
        }
        constructor(e2, t2) {
          super(), QI(this, "_disconnectedReason", void 0), QI(this, "_websocketReconnectReason", void 0), QI(this, "_connectionState", NM.CLOSED), QI(this, "reconnectToken", void 0), QI(this, "p2pToken", void 0), QI(this, "websocket", void 0), QI(this, "openConnectionTime", void 0), QI(this, "clientId", void 0), QI(this, "lastMsgTime", Date.now()), QI(this, "uploadCache", []), QI(this, "uploadCacheInterval", void 0), QI(this, "rttRolling", new OO(5)), QI(this, "pingpongTimer", void 0), QI(this, "pingpongTimeoutCount", 0), QI(this, "joinResponse", void 0), QI(this, "multiIpOption", void 0), QI(this, "initError", void 0), QI(this, "spec", void 0), QI(this, "store", void 0), QI(this, "_external_signal", void 0), QI(this, "onWebsocketMessage", (e3) => {
            if (e3.data instanceof ArrayBuffer)
              return void this.emit(DM.ON_BINARY_DATA, e3.data);
            const t3 = JSON.parse(e3.data);
            if (this.lastMsgTime = Date.now(), Object.prototype.hasOwnProperty.call(t3, "_id")) {
              const e4 = "res-@".concat(t3._id);
              this.emit(e4, t3._result, t3._message);
            } else if (Object.prototype.hasOwnProperty.call(t3, "_type")) {
              switch (t3._type) {
                case kM.ON_DATA_STREAM:
                  return void this.handleDataStream(t3._message);
                case kM.MUTE_AUDIO:
                case kM.MUTE_VIDEO:
                case kM.ON_P2P_LOST:
                case kM.ON_USER_ONLINE:
                  return;
                case kM.ON_USER_OFFLINE:
                  const { uid: e4 } = t3._message;
                  return BN.debug("[".concat(this.clientId, "] user-offline uid: ").concat(e4)), void this._external_signal.reset(e4);
              }
              if (this.emit(t3._type, t3._message), t3._type === kM.ON_NOTIFICATION && this.handleNotification(t3._message), t3._type === kM.ON_USER_BANNED)
                switch (t3._message.error_code) {
                  case 14:
                    this.close(xw.UID_BANNED);
                    break;
                  case 15:
                    this.close(xw.IP_BANNED);
                    break;
                  case 16:
                    this.close(xw.CHANNEL_BANNED);
                }
              if (t3._type === kM.ON_USER_LICENSE_BANNED)
                switch (t3._message.error_code) {
                  case OM.ERR_LICENSE_MISSING:
                    this.close(xw.LICENSE_MISSING);
                    break;
                  case OM.ERR_LICENSE_EXPIRED:
                    this.close(xw.LICENSE_EXPIRED);
                    break;
                  case OM.ERR_LICENSE_MINUTES_EXCEEDED:
                    this.close(xw.LICENSE_MINUTES_EXCEEDED);
                    break;
                  case OM.ERR_LICENSE_PERIOD_INVALID:
                    this.close(xw.LICENSE_PERIOD_INVALID);
                    break;
                  case OM.ERR_LICENSE_MULTIPLE_SDK_SERVICE:
                    this.close(xw.LICENSE_MULTIPLE_SDK_SERVICE);
                    break;
                  case OM.ERR_LICENSE_ILLEGAL:
                    this.close(xw.LICENSE_ILLEGAL);
                    break;
                  default:
                    this.close();
                }
            }
          }), this.clientId = e2.clientId, this.spec = e2, this.store = t2, this.websocket = new HU("gateway-".concat(this.clientId), this.spec.retryConfig, true, dN("JOIN_GATEWAY_USE_DUAL_DOMAIN"), dN("JOIN_GATEWAY_USE_443PORT_ONLY"), t2), this.handleWebsocketEvents(), window.addEventListener("offline", () => {
            this.connectionState === NM.CONNECTED && this.reconnect("retry", Gw.OFFLINE);
          }), this.p2pToken = uO(6, ""), this._external_signal = new Eq(this, this.p2pToken);
        }
        async request(e2, t2, i3, n2) {
          const r2 = uO(6, ""), o2 = { _id: r2, _type: e2, _message: t2 }, s2 = this.websocket.connectionID, a2 = () => new Wh((e3, t3) => {
            if (this.connectionState === NM.CONNECTED)
              return e3();
            const i4 = () => {
              this.off(DM.WS_CLOSED, n3), e3();
            }, n3 = () => {
              this.off(DM.WS_CONNECTED, i4), t3(new Ew(_w.WS_ABORT));
            };
            this.once(DM.WS_CONNECTED, i4), this.once(DM.WS_CLOSED, n3);
          });
          if (this.connectionState !== NM.CONNECTING && this.connectionState !== NM.RECONNECTING || e2 === PM.JOIN || e2 === PM.REJOIN || await a2(), this.websocket.sendMessage(o2, true), n2)
            return;
          const c2 = new Wh((i4, n3) => {
            let o3 = false;
            const a3 = (n4, r3) => {
              o3 = true, i4({ isSuccess: "success" === n4, message: r3 || {} }), this.off(DM.WS_CLOSED, c3), this.off(DM.WS_RECONNECTING, c3), this.emit(DM.REQUEST_SUCCESS, e2, t2);
            };
            this.once("res-@".concat(r2), a3);
            const c3 = () => {
              n3(new Ew(_w.WS_ABORT, "type: ".concat(e2))), this.off(DM.WS_CLOSED, c3), this.off(DM.WS_RECONNECTING, c3), this.off("res-@".concat(r2), a3);
            };
            this.once(DM.WS_CLOSED, c3), this.once(DM.WS_RECONNECTING, c3), lO(dN("SIGNAL_REQUEST_TIMEOUT")).then(() => {
              this.websocket.connectionID !== s2 || o3 || (BN.warning("[".concat(this.clientId, "] ws request timeout, type: ").concat(e2)), this.emit(DM.REQUEST_TIMEOUT, e2, t2));
            });
          });
          let d2 = null;
          try {
            d2 = await c2;
          } catch (n3) {
            if (this.connectionState === NM.CLOSED || e2 === PM.LEAVE)
              throw new Ew(_w.WS_ABORT);
            return !this.spec.forceWaitGatewayResponse || i3 ? n3.throw() : e2 === PM.JOIN || e2 === PM.REJOIN ? null : (await a2(), await this.request(e2, t2));
          }
          if (d2.isSuccess)
            return d2.message;
          const l2 = Number(d2.message.error_code || d2.message.code), u2 = PU(l2), h2 = new Ew(_w.UNEXPECTED_RESPONSE, "".concat(u2.desc, ": ").concat(d2.message.error_str), { code: l2, data: d2.message, desc: u2.desc });
          return "success" === u2.action ? d2.message : (BN.warning("[".concat(this.clientId, "] [").concat(this.websocket.connectionID, "] unexpected response from type ").concat(e2, ", error_code: ").concat(l2, ", message: ").concat(u2.desc, ", action: ").concat(u2.action)), l2 === OM.ERR_TOO_MANY_BROADCASTERS ? e2 === PM.JOIN || e2 === PM.REJOIN ? (this.initError = h2, this.close(), h2.throw()) : h2.throw() : "failed" === u2.action ? h2.throw() : "quit" === u2.action ? (this.initError = h2, this.close(), h2.throw()) : (l2 === OM.ERR_JOIN_BY_MULTI_IP ? (this.multiIpOption = d2.message.option, BN.warning("[".concat(this.clientId, "] detect multi ip, recover")), this.reconnect("recover", Gw.MULTI_IP)) : this.reconnect(u2.action, Gw.SERVER_ERROR), e2 === PM.JOIN || e2 === PM.REJOIN ? null : await this.request(e2, t2)));
        }
        waitMessage(e2, t2) {
          return new Wh((i3) => {
            const n2 = (r2) => {
              (!t2 || t2(r2)) && (this.off(e2, n2), i3(r2));
            };
            this.on(e2, n2);
          });
        }
        uploadWRTCStats(e2) {
          if (!this.store.sessionId)
            return void BN.warn("[".concat(this.clientId, "] no session id when upload wrtc stats"));
          const t2 = { lts: Date.now(), sid: this.store.sessionId, uid: this.store.intUid, stats: e2 };
          this.upload(LM.WRTC_STATS, t2);
        }
        upload(e2, t2) {
          const i3 = { _type: e2, _message: t2 };
          try {
            this.websocket.sendMessage(i3);
          } catch (e3) {
            const t3 = dN("MAX_UPLOAD_CACHE") || 50;
            this.uploadCache.push(i3), this.uploadCache.length > t3 && this.uploadCache.splice(0, 1), this.uploadCache.length > 0 && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval(() => {
              if (this.connectionState !== NM.CONNECTED)
                return;
              const e4 = this.uploadCache.splice(0, 1)[0];
              0 === this.uploadCache.length && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0), this.upload(e4._type, e4._message);
            }, dN("UPLOAD_CACHE_INTERVAL") || 2e3));
          }
        }
        send(e2, t2) {
          const i3 = { _type: e2, _message: t2 };
          this.websocket.sendMessage(i3);
        }
        async sendExtensionMessage(e2, t2, i3) {
          return await this._external_signal.send(e2, t2, i3);
        }
        init(e2) {
          return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, this.openConnectionTime = void 0, new Wh((t2, i3) => {
            this.once(DM.WS_CONNECTED, () => t2(this.joinResponse)), this.once(DM.WS_CLOSED, () => i3(this.initError || new Ew(_w.WS_ABORT))), this.connectionState = NM.CONNECTING, this.websocket.init(e2).catch(i3);
          });
        }
        close(e2) {
          this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.reconnectToken = void 0, this.joinResponse = void 0, this._external_signal.clear(), this._disconnectedReason = e2 || xw.LEAVE, this.connectionState = NM.CLOSED, BN.debug("[".concat(this.clientId, "] ") + "will close websocket in signal"), this.websocket.close(), this.p2pToken = uO(6, ""), this._external_signal.clear(), this._external_signal = new Eq(this, this.p2pToken);
        }
        async join() {
          if (!this.joinResponse) {
            this.emit(DM.ABORT_P2P_EXECUTION);
            const e2 = await Kw(this, DM.REQUEST_JOIN_INFO), t2 = await this.request(PM.JOIN, e2);
            if (!t2)
              return this.emit(DM.REPORT_JOIN_GATEWAY, _w.TIMEOUT, this.url || ""), false;
            this.joinResponse = t2, this.emit(DM.JOIN_RESPONSE, this.joinResponse), this.reconnectToken = this.joinResponse.rejoin_token;
          }
          return this.connectionState = NM.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), true;
        }
        reconnect(e2, t2) {
          this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.websocket.reconnect(e2, t2);
        }
        handleDataStream(e2) {
          try {
            var t2;
            const i3 = nO(e2.payload), n2 = new TextDecoder().decode(i3), r2 = JSON.parse(n2);
            "total" in r2 && "id" in r2 || Dn(t2 = Object.values(yU)).call(t2, r2._type) ? (r2._uid = e2.uid, this._external_signal.onMessage(r2)) : this.emit(kM.ON_DATA_STREAM, e2);
          } catch (t3) {
            this.emit(kM.ON_DATA_STREAM, e2);
          }
        }
        handleNotification(e2) {
          BN.debug("[".concat(this.clientId, "] receive notification: "), e2);
          const t2 = PU(e2.code);
          if ("success" !== t2.action) {
            if ("failed" !== t2.action)
              return "quit" === t2.action ? ("ERR_REPEAT_JOIN_CHANNEL" === t2.desc && this.close(xw.UID_BANNED), void this.close()) : void this.reconnect(t2.action, Gw.SERVER_ERROR);
            BN.error("[".concat(this.clientId, "] ignore error: "), t2.desc);
          }
        }
        handlePingPong() {
          if (!this.websocket || "connected" !== this.websocket.state)
            return;
          this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3), this.pingpongTimeoutCount += 1;
          const e2 = dN("PING_PONG_TIME_OUT"), t2 = Date.now();
          this.pingpongTimeoutCount >= e2 && (BN.warning("[".concat(this.clientId, "] PINGPONG Timeout. Last Socket Message: ").concat(t2 - this.lastMsgTime, "ms")), t2 - this.lastMsgTime > dN("WEBSOCKET_TIMEOUT_MIN")) ? this.reconnect("retry", Gw.TIMEOUT) : this.request(PM.PING, void 0, true).then(() => {
            this.pingpongTimeoutCount = 0;
            const e3 = Date.now() - t2;
            this.rttRolling.add(e3), dN("REPORT_STATS") && this.send(PM.PING_BACK, { pingpongElapse: e3 });
          }).catch((e3) => {
          });
        }
        handleWebsocketEvents() {
          this.websocket.on(UM.RECONNECT_CREATE_CONNECTION, (e2) => {
            this.emit(DM.WS_RECONNECT_CREATE_CONNECTION, e2);
          }), this.websocket.on(UM.ON_MESSAGE, this.onWebsocketMessage), this.websocket.on(UM.CLOSED, () => {
            this.connectionState = NM.CLOSED;
          }), this.websocket.on(UM.FAILED, () => {
            this._disconnectedReason = xw.NETWORK_ERROR, this.connectionState = NM.CLOSED;
          }), this.websocket.on(UM.RECONNECTING, (e2) => {
            this._websocketReconnectReason = e2, this.joinResponse = void 0, this.connectionState === NM.CONNECTED ? this.connectionState = NM.RECONNECTING : this.connectionState = NM.CONNECTING;
          }), this.websocket.on(UM.WILL_RECONNECT, (e2, t2, i3) => {
            "retry" !== e2 ? (BN.debug("".concat(this.clientId, " websocket will_connect event, renewSession reconnectMode is ").concat(e2)), this.reconnectToken = void 0) : BN.debug("".concat(this.clientId, " reconnect mode is retry, no need to renew session")), i3(e2);
          }), this.websocket.on(UM.CONNECTED, () => {
            this.openConnectionTime = Date.now(), this.join().catch((e2) => {
              if (this.emit(DM.REPORT_JOIN_GATEWAY, e2, this.url || ""), e2 instanceof Ew && e2.code === _w.UNEXPECTED_RESPONSE && e2.data.code === OM.ERR_NO_AUTHORIZED)
                return BN.warning("[".concat(this.clientId, "] reconnect no authorized, recover")), void this.reconnect("recover", Gw.SERVER_ERROR);
              BN.error("[".concat(this.clientId, "] join gateway request failed"), e2.toString()), this.spec.forceWaitGatewayResponse ? this.reconnect("tryNext", Gw.SERVER_ERROR) : (this.initError = e2, this.close());
            });
          }), this.websocket.on(UM.REQUEST_NEW_URLS, (e2, t2) => {
            Kw(this, DM.REQUEST_RECOVER, this.multiIpOption).then(e2).catch(t2);
          }), this.websocket.on(UM.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
            this.emit(kM.ON_TOKEN_PRIVILEGE_DID_EXPIRE);
          });
        }
      }
      const mq = { name: "P2PChannel", create: function(e2) {
        let { store: t2, statsCollector: i3 } = e2;
        return new pq(t2, i3);
      }, createSubmodule: function(e2) {
        let { store: t2, spec: i3 } = e2;
        return new fq(i3, t2);
      } };
      function Tq(e2, t2) {
        var i3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i3.push.apply(i3, n2);
        }
        return i3;
      }
      function Sq(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i3 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? Tq(Object(i3), true).forEach(function(t3) {
            QI(e2, t3, i3[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : Tq(Object(i3)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
          });
        }
        return e2;
      }
      class gq {
        constructor(e2) {
          QI(this, "sessionDesc", void 0), QI(this, "localCapabilities", void 0), QI(this, "rtpCapabilities", void 0), QI(this, "candidates", void 0), QI(this, "_originCandidates", void 0), QI(this, "iceParameters", void 0), QI(this, "dtlsParameters", void 0), QI(this, "setup", void 0), QI(this, "currentMidIndex", void 0), QI(this, "cname", void 0), e2 = $w(e2);
          const { iceParameters: t2, dtlsParameters: i3, candidates: n2, rtpCapabilities: r2, setup: o2, localCapabilities: s2, sdkCodec: a2, cname: c2 } = e2, d2 = SN("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE audio video\na=msid-semantic: WMS\na=ice-lite\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendrecv\na=rtcp-mux\na=rtcp-rsize\na=mid:audio\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendrecv\na=rtcp-mux\na=rtcp-rsize\na=mid:video\n");
          this.rtpCapabilities = r2, this.candidates = n2, this._originCandidates = $w(n2), this.iceParameters = t2, this.dtlsParameters = i3, this.setup = o2, this.localCapabilities = s2, this.cname = c2;
          for (let e3 = 0; e3 < d2.mediaDescriptions.length; e3++) {
            const s3 = d2.mediaDescriptions[e3];
            if (s3.attributes.iceUfrag = t2.iceUfrag, s3.attributes.icePwd = t2.icePwd, s3.attributes.fingerprints = i3.fingerprints, s3.attributes.candidates = n2, s3.attributes.setup = o2, "video" === s3.media.mediaType) {
              s3.media.fmts = r2.videoCodecs.map((e5) => e5.payloadType.toString(10));
              let e4 = r2.videoCodecs.filter((e5) => {
                var t3, i4;
                return null === (t3 = e5.rtpMap) || void 0 === t3 ? void 0 : Dn(i4 = t3.encodingName.toLowerCase()).call(i4, a2);
              });
              0 === e4.length && (e4 = r2.videoCodecs), s3.attributes.payloads = e4, s3.attributes.extmaps = r2.videoExtensions;
            }
            "audio" === s3.media.mediaType && (s3.media.fmts = r2.audioCodecs.map((e4) => e4.payloadType.toString(10)), s3.attributes.payloads = r2.audioCodecs, s3.attributes.extmaps = r2.audioExtensions), d2.mediaDescriptions[e3] = this.mungMediaDesc(s3);
          }
          this.sessionDesc = d2, this.currentMidIndex = d2.mediaDescriptions.length - 1;
        }
        toString() {
          return gN(this.sessionDesc);
        }
        send(e2, t2, i3) {
          const { ssrcs: n2, ssrcGroups: r2 } = Tx(t2, this.cname), o2 = this.sessionDesc.mediaDescriptions.find((t3) => e2 === lU.VIDEO ? "video" === t3.media.mediaType : "audio" === t3.media.mediaType), s2 = n2[0].attributes.label, a2 = n2[0].attributes.mslabel;
          return o2.attributes.ssrcs = o2.attributes.ssrcs.concat(n2), o2.attributes.ssrcGroups = o2.attributes.ssrcGroups.concat(r2), { id: s2, mslabel: a2 };
        }
        batchSend(e2) {
          return e2.map((e3) => {
            let { kind: t2, ssrcMsg: i3 } = e3;
            return this.send(t2, i3, void 0);
          });
        }
        stopSending(e2) {
          this.sessionDesc.mediaDescriptions.forEach((t2) => {
            const i3 = [], n2 = [], r2 = [];
            t2.attributes.ssrcs.forEach((t3) => {
              Dn(e2).call(e2, t3.attributes.label || "") ? r2.push(t3) : i3.push(t3);
            }), t2.attributes.ssrcGroups.forEach((e3) => {
              var t3;
              Dn(t3 = r2.map((e4) => e4.ssrcId)).call(t3, e3.ssrcIds[0]) || n2.push(e3);
            }), t2.attributes.ssrcs = i3, t2.attributes.ssrcGroups = n2;
          });
        }
        mute(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.find((t3) => t3.attributes.mid === e2);
          if (!t2)
            throw new Error("mediaDescription not found with ".concat(e2, " in remote SDP when calling RemoteSDP.mute."));
          t2.attributes.direction = "inactive";
        }
        unmute(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.find((t3) => t3.attributes.mid === e2);
          if (!t2)
            throw new Error("mediaDescription not found with ".concat(e2, " in remote SDP when calling RemoteSDP.unmute."));
          t2.attributes.direction = "sendonly";
        }
        receive(e2, t2, i3) {
          e2.forEach((e3, t3) => {
            const i4 = e3._mediaStreamTrack, n2 = this.sessionDesc.mediaDescriptions.findIndex((e4) => e4.attributes.mid === i4.kind), r2 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[n2], e3);
            this.sessionDesc.mediaDescriptions[n2] = r2;
          });
        }
        stopReceiving(e2) {
        }
        updateCandidates(e2) {
          const t2 = this._originCandidates.filter((e3) => "udp" === e3.transport), i3 = [];
          if (t2.forEach((e3) => {
            i3.push(Sq(Sq({}, e3), {}, { foundation: "tcpcandidate", priority: Number(e3.priority) - 1 + "", transport: "tcp", port: Number(e3.port) + 90 + "" }));
          }), 0 !== t2.length) {
            switch (e2) {
              case uU.TCP_RELAY:
                this.candidates = i3;
                break;
              case uU.UDP_TCP_RELAY:
              case uU.RELAY:
                this.candidates = [...t2, ...i3];
                break;
              default:
                this.candidates = t2;
            }
            for (const e3 of this.sessionDesc.mediaDescriptions)
              e3.attributes.candidates = this.candidates;
          }
        }
        restartICE(e2) {
          e2 = $w(e2), this.iceParameters = e2, this.sessionDesc.mediaDescriptions.forEach((t2) => {
            t2.attributes.iceUfrag = e2.iceUfrag, t2.attributes.icePwd = e2.icePwd;
          });
        }
        predictReceivingMids(e2) {
          const t2 = [];
          for (let i3 = 0; i3 < e2; i3++)
            t2.push((this.currentMidIndex + i3 + 1).toString(10));
          return t2;
        }
        mungRecvMediaDsec(e2, t2) {
          const i3 = $w(e2);
          return Sx(i3, t2), Rx(i3, t2), i3;
        }
        updateRecvMedia(e2, t2) {
          const i3 = this.sessionDesc.mediaDescriptions.findIndex((t3) => t3.attributes.mid === e2);
          if (-1 !== i3) {
            const e3 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i3], t2);
            this.sessionDesc.mediaDescriptions[i3] = e3;
          }
        }
        bumpMid(e2) {
          this.currentMidIndex += e2;
        }
        updateTrackLabel(e2, t2, i3) {
          const n2 = this.sessionDesc.mediaDescriptions.find((t3) => e2 === lU.VIDEO ? "video" === t3.attributes.mid : "audio" === t3.attributes.mid);
          if (n2) {
            const e3 = n2.attributes.ssrcs.find((e4) => e4.attributes.label === t2);
            var r2;
            if (e3)
              e3.attributes.label = i3, null === (r2 = e3.attributes.msid) || void 0 === r2 || r2.replace(t2, i3);
          }
        }
        mungMediaDesc(e2) {
          const t2 = $w(e2);
          return gx(t2), function(e3) {
            const t3 = e3.attributes.extmaps.find((e4) => lx(e4.extensionName));
            t3 && e3.attributes.extmaps.splice(e3.attributes.extmaps.indexOf(t3), 1), e3.attributes.payloads.forEach((e4) => {
              const t4 = e4.rtcpFeedbacks.findIndex((e5) => "transport-cc" === e5.type);
              -1 !== t4 && e4.rtcpFeedbacks.splice(t4, 1);
            });
          }(t2), t2;
        }
        getSSRC(e2) {
          for (const t2 of this.sessionDesc.mediaDescriptions)
            for (const i3 of t2.attributes.ssrcs)
              if (i3.attributes.label === e2)
                return [i3];
        }
      }
      var Rq;
      function Cq(e2, t2) {
        var i3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), i3.push.apply(i3, n2);
        }
        return i3;
      }
      function vq(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i3 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? Cq(Object(i3), true).forEach(function(t3) {
            QI(e2, t3, i3[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : Cq(Object(i3)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
          });
        }
        return e2;
      }
      let Iq = (Rq = class e2 extends dU {
        get peerConnectionState() {
          return this.peerConnection.connectionState;
        }
        get iceConnectionState() {
          return this.peerConnection.iceConnectionState;
        }
        get currentLocalDescription() {
          return this.peerConnection.currentLocalDescription;
        }
        get currentRemoteDescription() {
          return this.peerConnection.currentRemoteDescription;
        }
        get localCodecs() {
          return [...new Set(this.localCapabilities && this.localCapabilities.videoCodecs.map((e3) => e3.rtpMap && e3.rtpMap.encodingName.toLowerCase() || "").filter((e3) => {
            var t2;
            return Dn(t2 = Object.keys(hN)).call(t2, e3);
          }))];
        }
        constructor(t2, i3) {
          super(t2, i3), QI(this, "store", void 0), QI(this, "peerConnection", void 0), QI(this, "remoteSDP", void 0), QI(this, "initialOffer", void 0), QI(this, "statsFilter", void 0), QI(this, "useRTX", false), QI(this, "localCapabilities", void 0), QI(this, "localCandidateCount", 0), QI(this, "allCandidatesReceived", false), QI(this, "establishPromise", void 0), QI(this, "mutex", void 0), this.store = i3, this.mutex = new vO("P2PConnection-mutex", i3.clientId), this.peerConnection = new RTCPeerConnection(e2.resolvePCConfiguration(t2), { optional: [{ googDscp: true }] }), this.statsFilter = eN(this.peerConnection, dN("STATS_UPDATE_INTERVAL"), void 0, Kb() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1, this.establishPromise = this.establish();
        }
        async establish() {
          try {
            const e3 = await this.peerConnection.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true });
            if (!e3.sdp)
              throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
            const t2 = _x(e3.sdp), i3 = px(e3.sdp, { filterRTX: !this.useRTX, filterVideoFec: dN("FILTER_VIDEO_FEC"), filterAudioFec: dN("FILTER_AUDIO_FEC"), filterAudioCodec: ["opus"] });
            return this.localCapabilities = i3, this.initialOffer = e3, vq(vq({}, t2), {}, { rtpCapabilities: { send: { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, recv: { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, sendrecv: i3 }, offerSDP: e3.sdp });
          } catch (e3) {
            throw new Ew(_w.GET_LOCAL_CONNECTION_PARAMS_FAILED, e3.toString());
          }
        }
        async updateRemoteConnect() {
        }
        async connect(e3) {
          try {
            if (!this.initialOffer)
              throw new Error("Cannot establish P2PConnection without initial offer.");
            this.remoteSDP = new gq(vq(vq({}, e3), {}, { rtpCapabilities: e3.rtpCapabilities.send, localCapabilities: this.localCapabilities, sdkCodec: this.store.codec }));
            const t2 = this.remoteSDP.toString();
            await this.peerConnection.setLocalDescription(this.initialOffer), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: t2 });
          } catch (e4) {
            throw new Ew(_w.EXCHANGE_SDP_FAILED, "P2PConnection.connect failed; ".concat(e4.toString()));
          }
        }
        async updateRemoteRTPCapabilities(e3, t2) {
          throw new Ew(_w.NOT_SUPPORTED, "Planb mode does not support createDataChannels.");
        }
        getPreMedia(e3) {
        }
        send(e3, t2) {
          var i3 = this;
          return FA(function* () {
            const n2 = yield BA(i3.mutex.lock());
            try {
              if (!i3.remoteSDP)
                throw new Error("Cannot call P2PConnection.send before remote SDP created");
              const r2 = e3.map((e4) => i3.peerConnection.addTrack(e4._mediaStreamTrack)), o2 = yield BA(i3.peerConnection.createOffer()), s2 = SN(o2.sdp), a2 = e3.map((e4) => {
                const t3 = e4._mediaStreamTrack, n3 = s2.mediaDescriptions.find((e5) => e5.attributes.mid === t3.kind);
                if (!n3)
                  throw new Error("Cannot extract ssrc from mediaDescription.");
                return function(e5, t4, i4) {
                  const n4 = e5.attributes.ssrcs.filter((e6) => e6.attributes.label === t4), r3 = e5.attributes.ssrcGroups;
                  if (0 === n4.length)
                    throw new Error("Cannot extract ssrc from plan-b SDP.");
                  if (r3 && n4.length > 1) {
                    const e6 = r3.find((e7) => -1 !== e7.ssrcIds.indexOf(n4[0].ssrcId));
                    return e6 ? [{ ssrcId: e6.ssrcIds[0], rtx: i4 ? e6.ssrcIds[1] : void 0 }] : [{ ssrcId: n4[0].ssrcId }];
                  }
                  return [{ ssrcId: n4[0].ssrcId }];
                }(n3, t3.id, i3.useRTX);
              });
              let c2;
              try {
                c2 = yield a2;
              } catch (e4) {
                throw r2.forEach((e5) => {
                  Wb() && e5.replaceTrack(null), i3.peerConnection.removeTrack(e5);
                }), e4;
              }
              const d2 = i3.mungSendOfferSDP(o2.sdp, e3);
              i3.remoteSDP.receive(e3, t2, c2);
              const l2 = i3.remoteSDP.toString();
              return yield BA(i3.peerConnection.setLocalDescription({ type: "offer", sdp: d2 })), yield BA(i3.applySendEncodings(r2, e3)), yield BA(i3.peerConnection.setRemoteDescription({ type: "answer", sdp: l2 })), e3.map((e4, t3) => {
                const i4 = e4._mediaStreamTrack.id;
                return { localSSRC: a2[t3], id: i4 };
              });
            } catch (e4) {
              throw new Ew(_w.EXCHANGE_SDP_FAILED, "P2PConnection.send failed; ".concat(e4.toString()));
            } finally {
              n2();
            }
          })();
        }
        async stopSending(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.stopSending before remote SDP created");
            const t2 = this.peerConnection.getSenders().filter((t3) => {
              var i4;
              return -1 !== e3.indexOf((null === (i4 = t3.track) || void 0 === i4 ? void 0 : i4.id) || "");
            });
            if (t2.length !== e3.length)
              throw new Error("Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending.");
            t2.map((e4) => {
              Wb() && e4.replaceTrack(null), this.peerConnection.removeTrack(e4);
            });
            const i3 = await this.peerConnection.createOffer();
            await this.peerConnection.setLocalDescription(i3), this.remoteSDP.stopReceiving(e3);
            const n2 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n2 });
          } catch (e4) {
            throw new Ew(_w.EXCHANGE_SDP_FAILED, "P2PConnection.stopSending failed; ".concat(e4.toString()));
          }
        }
        async receive(e3, t2, i3, n2) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.receive ".concat(e3, " before remoteSDP created."));
            const { id: i4, mslabel: r2 } = this.remoteSDP.send(e3, t2, n2), o2 = new Wh((t3, n3) => {
              const o3 = setTimeout(() => {
                n3(new Error("Cannot receive track, id: ".concat(i4)));
              }, 1e4), s3 = (n4) => {
                const a3 = xb();
                if (("Safari" === a3.name && 11 === Number(a3.version) || Yb()) && n4.track.id !== i4 && n4.streams[0].id === r2) {
                  var c2;
                  const r3 = n4.streams[0].getTracks()[0];
                  return null === (c2 = this.remoteSDP) || void 0 === c2 || c2.updateTrackLabel(e3, i4, n4.track.id), this.peerConnection.removeEventListener("track", s3), clearTimeout(o3), void t3(r3);
                }
                if (n4.track.id === i4)
                  return this.peerConnection.removeEventListener("track", s3), clearTimeout(o3), void t3(n4.track);
              };
              this.peerConnection.addEventListener("track", s3);
            }), s2 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: s2 });
            const a2 = await this.peerConnection.createAnswer();
            await this.peerConnection.setLocalDescription(a2);
            return { track: await o2, id: i4 };
          } catch (e4) {
            throw new Ew(_w.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e4.toString()));
          }
        }
        async stopReceiving(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
            this.remoteSDP.stopSending(e3);
            const t2 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
            const i3 = await this.peerConnection.createAnswer();
            await this.peerConnection.setLocalDescription(i3);
          } catch (e4) {
            throw new Ew(_w.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e4.toString()));
          }
        }
        async muteRemote(e3) {
        }
        async unmuteRemote(e3) {
        }
        async muteLocal(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created.");
            const t2 = this.peerConnection.getSenders().filter((t3) => {
              var i3;
              return -1 !== e3.indexOf((null === (i3 = t3.track) || void 0 === i3 ? void 0 : i3.id) || "");
            });
            if (t2.length !== e3.length)
              throw new Error("sender' length doesn't match mids' length.");
            t2.map((e4) => {
              if (Wb() && e4.track)
                e4.track.enabled = false;
              else {
                const t3 = e4.getParameters();
                t3.encodings.forEach((e5) => e5.active = false), e4.setParameters(t3);
              }
            });
          } catch (e4) {
            throw new Ew(_w.EXCHANGE_SDP_FAILED, "P2PConnection.muteLocal failed; ".concat(e4.toString()));
          }
        }
        async unmuteLocal(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created.");
            const t2 = this.peerConnection.getSenders().filter((t3) => {
              var i4;
              return -1 !== e3.indexOf((null === (i4 = t3.track) || void 0 === i4 ? void 0 : i4.id) || "");
            });
            if (t2.length !== e3.length)
              throw new Error("Senders' length doesn't match mids' length.");
            t2.map(async (e4) => {
              if (Wb() && e4.track)
                e4.track.enabled = true;
              else {
                const t3 = e4.getParameters();
                t3.encodings.forEach((e5) => e5.active = true), await e4.setParameters(t3);
              }
            });
            const i3 = await this.peerConnection.createOffer();
            await this.peerConnection.setLocalDescription(i3);
            const n2 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n2 });
          } catch (e4) {
            throw new Ew(_w.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteLocal failed; ".concat(e4.toString()));
          }
        }
        restartICE(e3) {
          var t2 = this;
          return FA(function* () {
            const i3 = yield BA(t2.mutex.lock("From P2PConnection.restartICE"));
            try {
              if (!t2.remoteSDP)
                throw new Error("Cannot restartICE before remoteSDP created.");
              const n2 = QN().supportPCSetConfiguration;
              if (e3 === uU.RELAY && !n2)
                return;
              if (n2) {
                const i4 = t2.peerConnection.getConfiguration(), n3 = e3 === uU.RELAY ? "relay" : "all";
                i4.iceTransportPolicy !== n3 && (BN.debug("[".concat(t2.store.clientId, "] restartICE change iceTransportPolicy from [").concat(i4.iceTransportPolicy, "] to [").concat(n3, "]")), i4.iceTransportPolicy = n3, t2.peerConnection.setConfiguration(i4));
              }
              e3 !== uU.RELAY && t2.remoteSDP.updateCandidates(e3);
              const r2 = yield BA(t2.peerConnection.createOffer({ iceRestart: true }));
              if (!r2.sdp)
                throw new Error("Cannot restartICE because restart offer SDP does not exist.");
              const o2 = _x(r2.sdp), { remoteIceParameters: s2 } = yield o2.iceParameters;
              t2.remoteSDP.restartICE(s2);
              const a2 = t2.remoteSDP.toString();
              yield BA(t2.peerConnection.setLocalDescription(r2)), yield BA(t2.peerConnection.setRemoteDescription({ type: "answer", sdp: a2 }));
            } catch (e4) {
              BN.warning("[".concat(t2.store.clientId, "] restart ICE failed, abort operation"), e4);
            } finally {
              i3();
            }
          })();
        }
        close() {
          var e3;
          this.peerConnection.close(), null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, "closed"), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.statsFilter.destroy();
        }
        getStats() {
          return this.statsFilter.getStats();
        }
        getRemoteVideoIsReady(e3) {
          return this.statsFilter.getVideoIsReady(e3);
        }
        async updateEncoderConfig(e3, t2) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created.");
            const e4 = await this.peerConnection.createOffer(), i3 = this.mungSendOfferSDP(e4.sdp, [t2]);
            this.remoteSDP.updateRecvMedia(t2._mediaStreamTrack.kind, t2);
            const n2 = this.remoteSDP.toString();
            await this.peerConnection.setLocalDescription({ type: "offer", sdp: i3 }), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n2 });
          } catch (e4) {
            throw new Ew(_w.EXCHANGE_SDP_FAILED, e4.toString());
          }
        }
        async updateSendParameters(e3, t2) {
          const i3 = this.peerConnection.getSenders().filter((t3) => {
            var i4;
            return (null === (i4 = t3.track) || void 0 === i4 ? void 0 : i4.id) === e3;
          });
          1 === i3.length && await this.applySendEncodings(i3, [t2]);
        }
        setStatsRemoteVideoIsReady(e3, t2) {
          this.statsFilter.setVideoIsReady2(e3, t2);
        }
        async replaceTrack(e3, t2) {
          const i3 = this.peerConnection.getSenders().find((e4) => {
            var i4;
            return (null === (i4 = e4.track) || void 0 === i4 ? void 0 : i4.id) === t2;
          });
          i3 && await i3.replaceTrack(e3._mediaStreamTrack);
        }
        createDataChannels(e3, t2) {
          throw new Ew(_w.NOT_SUPPORTED, "Planb mode does not support createDataChannels.");
        }
        stopDataChannels(e3) {
          throw new Ew(_w.NOT_SUPPORTED, "Planb mode does not support stopDataChannels.");
        }
        bindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = () => {
            var e3;
            null === (e3 = this.onICEConnectionStateChange) || void 0 === e3 || e3.call(this, this.peerConnection.iceConnectionState);
          }, this.peerConnection.onconnectionstatechange = () => {
            var e3;
            null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, this.peerConnection.connectionState);
          }, this.peerConnection.onicecandidate = (e3) => {
            e3.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = true, BN.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount));
          }, setTimeout(() => {
            this.allCandidatesReceived || (this.allCandidatesReceived = true, BN.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount));
          }, dN("CANDIDATE_TIMEOUT"));
        }
        unbindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
        }
        static resolvePCConfiguration(t2) {
          const i3 = { iceServers: [], sdpSemantics: "plan-b" };
          return t2.iceServers ? i3.iceServers = t2.iceServers : t2.turnServer && "off" !== t2.turnServer.mode && (Vw(t2.turnServer.servers) ? i3.iceServers = t2.turnServer.servers : (i3.iceServers && i3.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.servers)), dN("USE_TURN_SERVER_OF_GATEWAY") && i3.iceServers && t2.turnServer.serversFromGateway && i3.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.serversFromGateway)), t2.turnServer.servers.concat(t2.turnServer.serversFromGateway || []).forEach((e3) => {
            e3.forceturn && (i3.iceTransportPolicy = "relay");
          }))), i3;
        }
        static turnServerConfigToIceServers(e3) {
          const t2 = [];
          return e3.forEach((e4) => {
            e4.security ? e4.tcpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turns:".concat(e4.turnServerURL, ":").concat(e4.tcpport, "?transport=tcp") }) : (e4.udpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.udpport, "?transport=udp") }), e4.tcpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.tcpport, "?transport=tcp") }));
          }), t2;
        }
        async updateRtpSenderEncodings(e3, t2) {
          var i3;
          if (!t2) {
            t2 = this.peerConnection.getSenders().find((t3) => {
              var i4;
              return (null === (i4 = t3.track) || void 0 === i4 ? void 0 : i4.id) === e3._mediaStreamTrack.id;
            });
          }
          if (!t2)
            return BN.warn("[".concat(e3.getTrackId(), "] no rtpSender found}"));
          if (!QN().supportSetRtpSenderParameters)
            return BN.warn("Browser not support set rtp-sender parameters");
          const n2 = {}, r2 = {};
          if (e3 instanceof ak)
            switch (e3._optimizationMode) {
              case "motion":
                n2.degradationPreference = "maintain-framerate";
                break;
              case "detail":
                n2.degradationPreference = "maintain-resolution";
                break;
              default:
                n2.degradationPreference = "balanced";
            }
          if (dN("DSCP_TYPE") && cw()) {
            var o2;
            const e4 = dN("DSCP_TYPE");
            Dn(o2 = ["very-low", "low", "medium", "high"]).call(o2, e4) && (r2.networkPriority = e4);
          }
          const s2 = t2.getParameters(), a2 = null === (i3 = s2.encodings) || void 0 === i3 ? void 0 : i3[0];
          a2 && Object.assign(a2, r2), Object.assign(s2, n2), BN.debug("[".concat(e3.getTrackId(), "] updateRtpSenderEncodings: ").concat(JSON.stringify(s2.encodings))), await t2.setParameters(s2);
        }
        async applySendEncodings(e3, t2) {
          try {
            if (!QN().supportSetRtpSenderParameters)
              return;
            if (e3.length !== t2.length)
              return;
            for (let i3 = 0; i3 < e3.length; i3++) {
              const n2 = e3[i3], r2 = t2[i3];
              n2 && r2 && await this.updateRtpSenderEncodings(r2, n2);
            }
          } catch (e4) {
            BN.debug("[".concat(this.store.clientId, "] Apply RTPSendEncodings failed."));
          }
        }
        mungSendOfferSDP(e3, t2) {
          const i3 = SN(e3);
          return t2.forEach((e4, t3) => {
            const n2 = e4._mediaStreamTrack, r2 = i3.mediaDescriptions.find((e5) => e5.attributes.mid === n2.kind);
            r2 && Sx(r2, e4);
          }), gN(i3);
        }
        bindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = (e3) => {
            var t2;
            null === (t2 = this.onFirstAudioReceived) || void 0 === t2 || t2.call(this, e3);
          }, this.statsFilter.onFirstVideoReceived = (e3) => {
            var t2;
            null === (t2 = this.onFirstVideoReceived) || void 0 === t2 || t2.call(this, e3);
          }, this.statsFilter.onFirstAudioDecoded = (e3) => {
            var t2;
            null === (t2 = this.onFirstAudioDecoded) || void 0 === t2 || t2.call(this, e3);
          }, this.statsFilter.onFirstVideoDecoded = (e3, t2, i3) => {
            var n2;
            null === (n2 = this.onFirstVideoDecoded) || void 0 === n2 || n2.call(this, e3, t2, i3);
          }, this.statsFilter.onSelectedLocalCandidateChanged = (e3, t2) => {
            var i3;
            null === (i3 = this.onSelectedLocalCandidateChanged) || void 0 === i3 || i3.call(this, e3, t2);
          }, this.statsFilter.onSelectedRemoteCandidateChanged = (e3, t2) => {
            var i3;
            null === (i3 = this.onSelectedRemoteCandidateChanged) || void 0 === i3 || i3.call(this, e3, t2);
          };
        }
        unbindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0;
        }
        async batchReceive(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.batchReceive before remoteSDP created.");
            const t2 = this.remoteSDP.batchSend(e3).map((t3, i4) => {
              let { id: n3, mslabel: r2 } = t3;
              const { kind: o2 } = e3[i4];
              return new Wh((e4, t4) => {
                const i5 = setTimeout(() => {
                  t4(new Error("Cannot receive track, id: ".concat(n3)));
                }, 1e4), s2 = (t5) => {
                  const a2 = xb();
                  if ("Safari" === a2.name && 11 === Number(a2.version) && t5.track.id !== n3 && t5.streams[0].id === r2) {
                    var c2;
                    const r3 = t5.streams[0].getTracks()[0];
                    return null === (c2 = this.remoteSDP) || void 0 === c2 || c2.updateTrackLabel(o2, n3, t5.track.id), this.peerConnection.removeEventListener("track", s2), clearTimeout(i5), void e4({ track: r3, id: n3 });
                  }
                  if (t5.track.id === n3)
                    return this.peerConnection.removeEventListener("track", s2), clearTimeout(i5), void e4({ track: t5.track, id: n3 });
                };
                this.peerConnection.addEventListener("track", s2);
              });
            }), i3 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: i3 });
            const n2 = await this.peerConnection.createAnswer();
            return await this.peerConnection.setLocalDescription(n2), await Wh.all(t2);
          } catch (e4) {
            throw new Ew(_w.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e4.toString()));
          }
        }
        async getRemoteSSRC(e3) {
          if (!this.remoteSDP)
            return;
          const t2 = this.remoteSDP.getSSRC(e3);
          return null == t2 ? void 0 : t2[0].ssrcId;
        }
        setConfiguration(t2) {
          if (QN().supportPCSetConfiguration) {
            const i3 = e2.resolvePCConfiguration(t2);
            this.peerConnection.setConfiguration(i3);
          }
        }
      }, IM(Rq.prototype, "connect", [yq], Object.getOwnPropertyDescriptor(Rq.prototype, "connect"), Rq.prototype), IM(Rq.prototype, "stopSending", [yq], Object.getOwnPropertyDescriptor(Rq.prototype, "stopSending"), Rq.prototype), IM(Rq.prototype, "receive", [yq], Object.getOwnPropertyDescriptor(Rq.prototype, "receive"), Rq.prototype), IM(Rq.prototype, "stopReceiving", [yq], Object.getOwnPropertyDescriptor(Rq.prototype, "stopReceiving"), Rq.prototype), IM(Rq.prototype, "muteRemote", [yq], Object.getOwnPropertyDescriptor(Rq.prototype, "muteRemote"), Rq.prototype), IM(Rq.prototype, "unmuteRemote", [yq], Object.getOwnPropertyDescriptor(Rq.prototype, "unmuteRemote"), Rq.prototype), IM(Rq.prototype, "muteLocal", [yq], Object.getOwnPropertyDescriptor(Rq.prototype, "muteLocal"), Rq.prototype), IM(Rq.prototype, "unmuteLocal", [yq], Object.getOwnPropertyDescriptor(Rq.prototype, "unmuteLocal"), Rq.prototype), IM(Rq.prototype, "close", [yq], Object.getOwnPropertyDescriptor(Rq.prototype, "close"), Rq.prototype), IM(Rq.prototype, "updateEncoderConfig", [yq], Object.getOwnPropertyDescriptor(Rq.prototype, "updateEncoderConfig"), Rq.prototype), IM(Rq.prototype, "updateSendParameters", [yq], Object.getOwnPropertyDescriptor(Rq.prototype, "updateSendParameters"), Rq.prototype), IM(Rq.prototype, "replaceTrack", [yq], Object.getOwnPropertyDescriptor(Rq.prototype, "replaceTrack"), Rq.prototype), IM(Rq.prototype, "getRemoteSSRC", [yq], Object.getOwnPropertyDescriptor(Rq.prototype, "getRemoteSSRC"), Rq.prototype), Rq);
      function yq(e2, t2, i3) {
        const n2 = e2[t2];
        if ("function" != typeof n2)
          throw new Error("Cannot use mutex on object property.");
        return i3.value = async function() {
          const e3 = this.mutex, i4 = await e3.lock("Locking from P2PConnection.".concat(t2));
          try {
            for (var r2 = arguments.length, o2 = new Array(r2), s2 = 0; s2 < r2; s2++)
              o2[s2] = arguments[s2];
            return await n2.apply(this, o2);
          } finally {
            i4();
          }
        }, i3;
      }
      const Aq = { name: "PlanBConnection", create: function(e2) {
        let { store: t2, spec: i3 } = e2;
        return new Iq(i3, t2);
      } };
      cN("PROCESS_ID", "process-".concat(uO(8, ""), "-").concat(uO(4, ""), "-").concat(uO(4, ""), "-").concat(uO(4, ""), "-").concat(uO(12, ""))), function() {
        let e2;
        try {
          e2 = window.localStorage.getItem("websdk_ng_global_parameter");
        } catch (e3) {
          return void BN.error("Error loading sdk config", e3.message);
        }
        if (e2)
          try {
            const t2 = JSON.parse(window.atob(e2)), i3 = Date.now();
            BN.debug("Loading global parameters from cache", t2), Object.keys(t2).forEach((e3) => {
              if (Object.prototype.hasOwnProperty.call(aN, e3)) {
                const { value: n2, expires: r2 } = t2[e3];
                if (r2 && r2 <= i3)
                  return;
                lN[e3] = n2, aN[e3] = n2;
              }
            });
          } catch (t2) {
            BN.error("Error loading mutableParamsCache: ".concat(e2), t2.message);
          }
      }(), Array.isArray(lN.AREAS) && lN.AREAS.length > 0 && oV(lN.AREAS, true);
      const bq = (e2, t2, i3) => {
        BN.debug("setParameter key:".concat(e2, ", value:").concat(JSON.stringify(t2))), cN(e2, t2, i3);
      };
      jx(qK, false), jx(eY, false), jx(lj, false), jx(DY, false), jx(HK, false), jx(mq, false), jx(Aq, false);
      const wq = function(e2) {
        const t2 = new Nw(), i3 = e2, n2 = { getListeners: t2.getListeners.bind(t2), on: (e3, i4) => (function(e4, t3) {
          e4 === RU.SECURITY_POLICY_VIOLATION && lG(t3, true);
        }(e3, i4), t2.on.bind(t2)(e3, i4)), addListener: t2.addListener.bind(t2), once: t2.once.bind(t2), off: t2.off.bind(t2), removeAllListeners: t2.removeAllListeners.bind(t2), emit: t2.emit.bind(t2), safeEmit: t2.safeEmit.bind(t2) };
        return cG(cG({}, i3), n2);
      }({ __TRACK_LIST__: pD, VERSION: tN, BUILD: sN, ESM_BUNDLER: false, ESM: false, UMD: true, DEV: false, setParameter: bq, getParameter: dN, getSupportedCodec: async function() {
        let e2 = { audio: [], video: [] };
        try {
          let t2 = new RTCPeerConnection();
          const i3 = await async function(e3) {
            let t3;
            return QN().supportUnifiedPlan ? (e3.addTransceiver("video", { direction: "recvonly" }), e3.addTransceiver("audio", { direction: "recvonly" }), t3 = (await e3.createOffer()).sdp) : t3 = (await e3.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true })).sdp, t3;
          }(t2);
          if (!i3)
            return e2;
          t2.close(), t2 = null, e2 = function(e3) {
            const t3 = { video: [], audio: [] };
            return e3.match(/ VP8/i) && t3.video.push("VP8"), e3.match(/ VP9/i) && t3.video.push("VP9"), e3.match(/ AV1/i) && t3.video.push("AV1"), e3.match(/ H264/i) && t3.video.push("H264"), e3.match(/ H265/i) && t3.video.push("H265"), e3.match(/ opus/i) && t3.audio.push("OPUS"), e3.match(/ PCMU/i) && t3.audio.push("PCMU"), e3.match(/ PCMA/i) && t3.audio.push("PCMA"), e3.match(/ G722/i) && t3.audio.push("G722"), t3;
          }(i3);
        } catch (e3) {
          throw new XN(_w.CREATE_OFFER_FAILED, e3.toString && e3.toString()).print();
        }
        return e2;
      }, checkSystemRequirements: function() {
        const e2 = zN.reportApiInvoke(null, { name: Lw.CHECK_SYSTEM_REQUIREMENTS, options: [], tag: kw.TRACER });
        let t2 = false;
        try {
          const e3 = window.RTCPeerConnection, i4 = navigator.mediaDevices && navigator.mediaDevices.getUserMedia, n3 = window.WebSocket;
          t2 = !!(e3 && i4 && n3), t2 && aw() && zb(75) && new e3().close();
        } catch (e3) {
          return BN.error("check system requirement failed: ", e3), false;
        }
        let i3 = false;
        const n2 = xb();
        n2.name === Lb.CHROME && Number(n2.version) >= 58 && ("WebKit" !== Mb.engine.name || function() {
          const e3 = xb();
          if (jb()) {
            if (e3.os === Pb.MAC_OS)
              return true;
            if (e3.os === Pb.IOS) {
              const e4 = Mb.os.version && Mb.os.version.split(".");
              if (e4 && 14 === Number(e4[0]) && e4[1] && Number(e4[1]) >= 3)
                return true;
              if (e4 && Number(e4[0]) > 14)
                return true;
            }
          }
          return false;
        }()) && (i3 = true), (n2.name === Lb.FIREFOX && Number(n2.version) >= 56 || n2.name === Lb.OPERA && Number(n2.version) >= 45 || n2.name === Lb.SAFARI && Number(n2.version) >= 11 || "WebKit" === n2.name && (Yb() || rw()) && n2.osVersion && Number(n2.osVersion.split(".")[0]) >= 11 || ow() || xb().name === Lb.QQ) && (i3 = true), BN.debug("checkSystemRequirements, api:", t2, "browser", i3);
        const r2 = t2 && i3;
        return e2.onSuccess(r2), r2;
      }, getDevices: function(e2) {
        return lP.enumerateDevices(true, true, e2);
      }, getMicrophones: function(e2) {
        return lP.getRecordingDevices(e2);
      }, getCameras: function(e2) {
        return lP.getCamerasDevices(e2);
      }, getElectronScreenSources: iP, getPlaybackDevices: function(e2) {
        return lP.getSpeakers(e2);
      }, createClient: function() {
        var e2;
        let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { codec: "vp8", audioCodec: "opus", mode: "rtc" };
        const i3 = uO(5, "client-"), n2 = zN.reportApiInvoke(null, { id: i3, name: Lw.CREATE_CLIENT, options: [t2], tag: kw.TRACER });
        try {
          !function(e3) {
            mw(e3.codec, "config.codec", ["vp8", "vp9", "av1", "h264", "h265"]), mw(e3.mode, "config.mode", ["rtc", "live", "p2p"]), void 0 !== e3.audioCodec && mw(e3.audioCodec, "config.audioCodec", ["opus", "pcmu", "pcma", "g722"]), void 0 !== e3.proxyServer && gw(e3.proxyServer, "config.proxyServer", 1, 1e4), void 0 !== e3.turnServer && Fw(e3.turnServer), void 0 !== e3.httpRetryConfig && Mw(e3.httpRetryConfig), void 0 !== e3.websocketRetryConfig && Mw(e3.websocketRetryConfig);
          }(t2);
        } catch (e3) {
          throw n2.onError(e3), e3;
        }
        return (Qb(16, 0, true) || Zb(16, 0, true)) && ("vp9" === t2.codec && (t2.codec = "vp8", BN.debug("browser not support vp9, force use vp8")), cN("UNSUPPORTED_VIDEO_CODEC", ["vp9"])), void 0 === t2.audioCodec && (t2.audioCodec = "opus"), n2.onSuccess(), new tG(eG(eG({ forceWaitGatewayResponse: true }, t2), {}, { role: Dn(e2 = ["rtc", "p2p"]).call(e2, t2.mode) ? "host" : t2.role || "audience" }), i3);
      }, createCameraVideoTrack: async function() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        const t2 = dN("CAMERA_CAPTURE_CONFIG"), i3 = uO(8, "track-cam-"), n2 = zN.reportApiInvoke(null, { id: i3, tag: kw.TRACER, name: Lw.CREATE_CAM_VIDEO_TRACK, options: [jD({}, e2), t2] });
        t2 && (e2.encoderConfig = t2);
        const r2 = yP(e2);
        let o2 = null;
        BN.info("start create camera video track with config", JSON.stringify(e2), "trackId", i3);
        try {
          o2 = (await sP({ video: r2 }, i3)).getVideoTracks()[0] || null;
        } catch (e3) {
          throw n2.onError(e3), e3;
        }
        if (!o2) {
          const e3 = new Ew(_w.UNEXPECTED_ERROR, "can not find track in media stream");
          return n2.onError(e3), e3.throw(BN);
        }
        e2.optimizationMode && dk(i3, o2, e2, cD(e2.encoderConfig));
        const s2 = new ck(o2, e2, r2, e2.scalabiltyMode ? lD(e2.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, e2.optimizationMode, i3);
        return n2.onSuccess(s2.getTrackId()), BN.info("create camera video success, trackId:", i3), s2;
      }, createCustomVideoTrack: function(e2) {
        const t2 = uO(8, "track-cus-"), i3 = zN.reportApiInvoke(null, { id: t2, tag: kw.TRACER, name: Lw.CREATE_CUSTOM_VIDEO_TRACK, options: [e2] }), n2 = new ak(e2.mediaStreamTrack, { width: e2.width, height: e2.height, frameRate: e2.frameRate, bitrateMax: e2.bitrateMax, bitrateMin: e2.bitrateMin }, e2.scalabiltyMode ? lD(e2.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, e2.optimizationMode, t2, [fD.CUSTOM_TRACK]);
        return i3.onSuccess(n2.getTrackId()), BN.info("create custom video track success with config", e2, "trackId", n2.getTrackId()), n2;
      }, createScreenVideoTrack: async function() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "disable";
        const i3 = "object" == typeof t2 ? function(e3) {
          return AP(e3);
        }(t2) : void 0;
        i3 && (t2 = "auto");
        const n2 = uO(8, "track-scr-v-"), r2 = zN.reportApiInvoke(null, { id: n2, tag: kw.TRACER, name: Lw.CREATE_SCREEN_VIDEO_TRACK, options: [jD({}, e2), t2] });
        e2.encoderConfig ? "string" == typeof e2.encoderConfig || e2.encoderConfig.width && e2.encoderConfig.height || (e2.encoderConfig.width = { max: 1920 }, e2.encoderConfig.height = { max: 1080 }) : e2.encoderConfig = "1080p_2";
        const o2 = function(e3) {
          const t3 = {};
          e3.screenSourceType && (t3.mediaSource = e3.screenSourceType), e3.extensionId && Gb() && (t3.extensionId = e3.extensionId);
          const { displaySurface: i4, selfBrowserSurface: n3, surfaceSwitching: r3, systemAudio: o3, preferCurrentTab: s3 } = e3;
          (qb(107) || Xb(107) || $b(93)) && (i4 && (mw(i4, "displaySurface", ["browser", "window", "monitor"]), t3.displaySurface = i4), n3 ? (mw(n3, "selfBrowserSurface", ["exclude", "include"]), t3.selfBrowserSurface = n3) : t3.selfBrowserSurface = "include", r3 && (mw(r3, "surfaceSwitching", ["exclude", "include"]), t3.surfaceSwitching = r3)), (qb(105) || Xb(105) || $b(91)) && o3 && (mw(o3, "systemAudio", ["exclude", "include"]), t3.systemAudio = o3), (qb(94) || Xb(94) || $b(80)) && s3 && (t3.preferCurrentTab = true), e3.electronScreenSourceId && (t3.sourceId = e3.electronScreenSourceId);
          const a3 = e3.encoderConfig ? dD(e3.encoderConfig) : null;
          return t3.mandatory = { chromeMediaSource: "desktop", maxWidth: a3 ? a3.width : void 0, maxHeight: a3 ? a3.height : void 0 }, a3 && (a3.frameRate && ("number" == typeof a3.frameRate ? (t3.mandatory.maxFrameRate = a3.frameRate, t3.mandatory.minFrameRate = a3.frameRate) : (t3.mandatory.maxFrameRate = a3.frameRate.max || a3.frameRate.ideal || a3.frameRate.exact || void 0, t3.mandatory.minFrameRate = a3.frameRate.min || a3.frameRate.ideal || a3.frameRate.exact || void 0), t3.frameRate = a3.frameRate), a3.width && (t3.width = a3.width), a3.height && (t3.height = a3.height)), t3;
        }(e2);
        let s2 = null, a2 = null;
        const c2 = QN();
        if (!c2.supportShareAudio && "enable" === t2) {
          const e3 = new Ew(_w.NOT_SUPPORTED, "your browser or platform is not support share-screen with audio");
          return r2.onError(e3), e3.throw(BN);
        }
        BN.info("start create screen video track with config", e2, "withAudio", t2, "trackId", n2);
        const d2 = c2.supportShareAudio && "disable" !== t2;
        try {
          const e3 = await sP({ screen: o2, screenAudio: d2 ? i3 || true : void 0 }, n2);
          s2 = e3.getVideoTracks()[0] || null, a2 = e3.getAudioTracks()[0] || null;
        } catch (e3) {
          throw r2.onError(e3), e3;
        }
        if (!s2) {
          const e3 = new Ew(_w.UNEXPECTED_ERROR, "can not find track in media stream");
          return r2.onError(e3), e3.throw(BN);
        }
        if (!a2 && "enable" === t2) {
          s2 && s2.stop();
          const e3 = new Ew(_w.SHARE_AUDIO_NOT_ALLOWED);
          return r2.onError(e3), e3.throw(BN);
        }
        e2.optimizationMode || (e2.optimizationMode = "detail"), e2.optimizationMode && (dk(n2, s2, e2, e2.encoderConfig && dD(e2.encoderConfig) || void 0), e2.encoderConfig && "string" != typeof e2.encoderConfig && (e2.encoderConfig.bitrateMin = e2.encoderConfig.bitrateMax));
        const l2 = new ak(s2, e2.encoderConfig ? dD(e2.encoderConfig) : {}, e2.scalabiltyMode ? lD(e2.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, e2.optimizationMode, n2, [fD.SCREEN_TRACK]);
        if (!a2)
          return r2.onSuccess(l2.getTrackId()), BN.info("create screen video track success", "video:", l2.getTrackId()), l2;
        const u2 = new TL(a2, void 0, uO(8, "track-scr-a-"), false);
        return r2.onSuccess([l2.getTrackId(), u2.getTrackId()]), BN.info("create screen video track success", "video:", l2.getTrackId(), "audio:", u2.getTrackId()), [l2, u2];
      }, createMicrophoneAndCameraTracks: async function() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        const i3 = dN("CAMERA_CAPTURE_CONFIG"), n2 = uO(8, "track-mic-"), r2 = uO(8, "track-cam-"), o2 = zN.reportApiInvoke(null, { id: "".concat(n2, "-").concat(r2), tag: kw.TRACER, name: Lw.CREATE_MIC_AND_CAM_TRACKS, options: [e2, t2, i3] });
        i3 && (t2.encoderConfig = i3);
        const s2 = yP(t2), a2 = bP(e2);
        let c2 = null, d2 = null;
        BN.info("start create camera video track(".concat(r2, ") and microphone audio track(").concat(n2, ") with config, audio: ").concat(JSON.stringify(e2), ", video: ").concat(JSON.stringify(t2)));
        try {
          const e3 = await sP({ audio: a2, video: s2 }, "".concat(n2, "-").concat(r2));
          c2 = e3.getAudioTracks()[0], d2 = e3.getVideoTracks()[0];
        } catch (e3) {
          throw o2.onError(e3), e3;
        }
        if (!c2 || !d2) {
          const e3 = new Ew(_w.UNEXPECTED_ERROR, "can not find tracks in media stream");
          return o2.onError(e3), e3.throw(BN);
        }
        t2.optimizationMode && dk(r2, d2, t2, cD(t2.encoderConfig));
        const l2 = new SL(c2, e2, a2, n2), u2 = new ck(d2, t2, s2, t2.scalabiltyMode ? lD(t2.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, t2.optimizationMode, r2);
        return o2.onSuccess([l2.getTrackId(), u2.getTrackId()]), BN.info("create camera video track(".concat(r2, ") and microphone audio track(").concat(n2, ") success")), [l2, u2];
      }, createMicrophoneAudioTrack: async function() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        const t2 = uO(8, "track-mic-"), i3 = zN.reportApiInvoke(null, { id: t2, tag: kw.TRACER, name: Lw.CREATE_MIC_AUDIO_TRACK, options: [e2] }), n2 = bP(e2);
        let r2 = null;
        BN.info("start create microphone audio track with config", JSON.stringify(e2), "trackId", t2);
        try {
          r2 = (await sP({ audio: n2 }, t2)).getAudioTracks()[0] || null;
        } catch (e3) {
          throw i3.onError(e3), e3;
        }
        if (!r2) {
          const e3 = new Ew(_w.UNEXPECTED_ERROR, "can not find track in media stream");
          return i3.onError(e3), e3.throw(BN);
        }
        const o2 = new SL(r2, e2, n2, t2);
        return i3.onSuccess(o2.getTrackId()), BN.info("create microphone audio track success, trackId:", t2), o2;
      }, createCustomAudioTrack: function(e2) {
        const t2 = uO(8, "track-cus-"), i3 = zN.reportApiInvoke(null, { id: t2, tag: kw.TRACER, name: Lw.CREATE_CUSTOM_AUDIO_TRACK, options: [e2] }), n2 = new TL(e2.mediaStreamTrack, e2.encoderConfig ? hD(e2.encoderConfig) : {}, t2, false);
        return BN.info("create custom audio track success with config", e2, "trackId", n2.getTrackId()), i3.onSuccess(n2.getTrackId()), n2;
      }, createBufferSourceAudioTrack: async function(e2) {
        var t2;
        const { cacheOnlineFile: i3, encoderConfig: n2 } = e2;
        let { source: r2 } = e2;
        const o2 = { source: r2 instanceof AudioBuffer ? "AudioBuffer" : r2 instanceof File ? null !== (t2 = File.name) && void 0 !== t2 ? t2 : "File" : r2, cacheOnlineFile: i3, encoderConfig: n2 }, s2 = uO(8, "track-buf-"), a2 = zN.reportApiInvoke(null, { id: s2, tag: kw.TRACER, name: Lw.CREATE_BUFFER_AUDIO_TRACK, options: [o2] });
        if (dN("DISABLE_WEBAUDIO"))
          throw new Ew(_w.NOT_SUPPORTED, "can not create BufferSourceAudioTrack when WebAudio disabled");
        BN.info("start create buffer source audio track with config", JSON.stringify(o2), "trackId", s2);
        const c2 = r2;
        if (!(r2 instanceof AudioBuffer))
          try {
            r2 = await async function(e3, t3) {
              let i4 = null;
              if ("string" == typeof e3) {
                const t4 = vL.get(e3);
                if (t4)
                  return BN.debug("use cached audio resource: ", e3), t4;
                try {
                  i4 = (await bO(() => Ab.get(e3, { responseType: "arraybuffer" }), void 0, void 0, { maxRetryCount: 3 })).data;
                } catch (e4) {
                  throw new Ew(_w.FETCH_AUDIO_FILE_FAILED, e4.toString());
                }
              } else {
                const t4 = new Wh((t5, i5) => {
                  const n4 = new FileReader();
                  n4.onload = (e4) => {
                    e4.target ? t5(e4.target.result) : i5(new Ew(_w.READ_LOCAL_AUDIO_FILE_ERROR));
                  }, n4.onerror = () => {
                    i5(new Ew(_w.READ_LOCAL_AUDIO_FILE_ERROR));
                  }, n4.readAsArrayBuffer(e3);
                });
                i4 = await t4;
              }
              const n3 = await function(e4) {
                const t4 = qD();
                return new Wh((i5, n4) => {
                  t4.decodeAudioData(e4, (e5) => {
                    i5(e5);
                  }, (e5) => {
                    n4(new Ew(_w.DECODE_AUDIO_FILE_FAILED, e5.toString()));
                  });
                });
              }(i4);
              return "string" == typeof e3 && t3 && vL.set(e3, n3), n3;
            }(r2, i3);
          } catch (e3) {
            return a2.onError(e3), e3.throw(BN);
          }
        const d2 = new CL(r2), l2 = new gL(c2, d2, n2 ? hD(n2) : {}, s2);
        return BN.info("create buffer source audio track success, trackId:", s2), a2.onSuccess(l2.getTrackId()), l2;
      }, setAppType: function(e2) {
        if (BN.debug("setAppType: ".concat(e2)), !(Number.isInteger(e2) && e2 >= 0))
          throw BN.debug("Invalid appType"), new XN(_w.INVALID_PARAMS, "invalid app type", e2);
        cN("APP_TYPE", Math.floor(e2));
      }, setLogLevel: function(e2) {
        BN.setLogLevel(e2);
      }, enableLogUpload: function() {
        dN("USE_NEW_LOG") ? cN("UPLOAD_LOG", true) : BN.enableLogUpload();
      }, disableLogUpload: function() {
        dN("USE_NEW_LOG") ? cN("UPLOAD_LOG", false) : BN.disableLogUpload();
      }, createChannelMediaRelayConfiguration: function() {
        return new BV();
      }, checkAudioTrackIsActive: async function(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
        const i3 = zN.reportApiInvoke(null, { tag: kw.TRACER, name: Lw.CHECK_AUDIO_TRACK_IS_ACTIVE, options: [t2] });
        if (!(e2 instanceof TL || e2 instanceof Ik)) {
          const e3 = new XN(_w.INVALID_TRACK, "the parameter is not a audio track");
          return i3.onError(e3), e3.throw();
        }
        t2 && t2 < 1e3 && (t2 = 1e3);
        const n2 = e2 instanceof TL ? e2.getTrackLabel() : "remote_track", r2 = e2.getVolumeLevel();
        let o2 = r2, s2 = r2;
        const a2 = Date.now();
        return new Wh((r3) => {
          const c2 = setInterval(() => {
            const d2 = e2.getVolumeLevel();
            o2 = d2 > o2 ? d2 : o2, s2 = d2 < s2 ? d2 : s2;
            const l2 = o2 - s2 > 1e-4, u2 = Date.now() - a2;
            if (l2 || u2 > t2) {
              clearInterval(c2);
              const t3 = l2, s3 = { duration: u2, deviceLabel: n2, maxVolumeLevel: o2, result: t3 };
              BN.info("[track-".concat(e2.getTrackId(), "] check audio track active completed. ").concat(JSON.stringify(s3))), i3.onSuccess(s3), r3(t3);
            }
          }, 200);
        });
      }, checkVideoTrackIsActive: async function(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
        const i3 = zN.reportApiInvoke(null, { tag: kw.TRACER, name: Lw.CHECK_VIDEO_TRACK_IS_ACTIVE, options: [t2] });
        if (!(e2 instanceof ak || e2 instanceof vk)) {
          const e3 = new XN(_w.INVALID_TRACK, "the parameter is not a video track");
          return i3.onError(e3), e3.throw();
        }
        t2 && t2 < 1e3 && (t2 = 1e3);
        const n2 = e2 instanceof ak ? e2.getTrackLabel() : "remote_track", r2 = e2.getMediaStreamTrack(true), o2 = document.createElement("video");
        o2.style.width = "1px", o2.style.height = "1px", o2.setAttribute("muted", ""), o2.muted = true, o2.setAttribute("playsinline", ""), o2.controls = false, (Wb() || jb()) && (o2.style.opacity = "0.01", o2.style.position = "fixed", o2.style.left = "0", o2.style.top = "0", document.body.appendChild(o2)), o2.srcObject = new MediaStream([r2]), o2.play();
        const s2 = document.createElement("canvas");
        s2.width = 160, s2.height = 120;
        let a2 = 0, c2 = 0;
        try {
          const e3 = Date.now();
          a2 = await function(e4, t3, i4, n3) {
            let r3, o3 = 0, s3 = null;
            return new Wh((a3, c3) => {
              function d3() {
                o3 > n3 && r3 && (r3(), a3(o3));
                const t4 = i4.getContext("2d");
                if (!t4) {
                  const e5 = new XN(_w.UNEXPECTED_ERROR, "can not get canvas 2d context.");
                  return BN.error(e5.toString()), void c3(e5);
                }
                t4.drawImage(e4, 0, 0, 160, 120);
                const d4 = t4.getImageData(0, 0, i4.width, i4.height), l3 = Math.floor(d4.data.length / 3);
                if (s3) {
                  for (let e5 = 0; e5 < l3; e5 += 3)
                    if (d4.data[e5] !== s3[e5])
                      return o3 += 1, void (s3 = d4.data);
                  s3 = d4.data;
                } else
                  s3 = d4.data;
              }
              setTimeout(() => {
                r3 && (r3(), a3(o3));
              }, t3), r3 = JD(() => {
                d3();
              }, 30);
            });
          }(o2, t2, s2, 4), c2 = Date.now() - e3;
        } catch (e3) {
          throw i3.onError(e3), e3;
        }
        aB === Lb.SAFARI && (o2.pause(), o2.remove()), o2.srcObject = null;
        const d2 = a2 > 4, l2 = { duration: c2, changedPicNum: a2, deviceLabel: n2, result: d2 };
        return BN.info("[track-".concat(e2.getTrackId(), "] check video track active completed. ").concat(JSON.stringify(l2))), i3.onSuccess(l2), d2;
      }, setArea: oV, audioElementPlayCenter: fP, resumeAudioContext: function() {
        fP.autoResumeAfterInterruption(true);
      }, processExternalMediaAEC: function(e2) {
        sG.processExternalMediaAEC(e2);
      }, registerExtensions: function(e2) {
        const t2 = dN("PLUGIN_INFO") || [];
        e2.forEach((e3) => {
          "name" in e3 && !Dn(t2).call(t2, e3.name) && t2.push(e3.name);
          const i3 = e3;
          i3.__registered__ = true, i3.logger.hookLog = BN.extLog, i3.reporter.hookApiInvoke = zN.extApiInvoke, i3.parameters && Object.keys(i3.parameters).forEach((e4) => {
            i3.parameters[e4] = dN(e4);
          });
        }), bq("PLUGIN_INFO", t2);
      }, ChannelMediaRelayError: QM, ChannelMediaRelayEvent: XM, ChannelMediaRelayState: JM, RemoteStreamFallbackType: SD, RemoteStreamType: TD, ConnectionDisconnectedReason: xw, AudienceLatencyLevelType: Uw, AREAS: iU, preload: async function(e2, t2, i3, n2) {
        return RB(e2, t2, i3, n2);
      } });
      return Object.defineProperties(wq, { onAudioAutoplayFailed: { get: () => hP.onAudioAutoplayFailed, set: (e2) => {
        hP.onAudioAutoplayFailed = e2;
      } }, onAutoplayFailed: { get: () => hP.onAutoplayFailed, set: (e2) => {
        hP.onAutoplayFailed = e2;
      } }, _onSecurityPolicyViolation: { value: void 0, writable: true }, _cspEventHandlerPointer: { value: void 0, writable: true }, onSecurityPolicyViolation: { get: () => wq._onSecurityPolicyViolation, set(e2) {
        wq._onSecurityPolicyViolation = e2, lG(e2);
      } }, __CLIENT_LIST__: { get: () => dN("SHOW_GLOBAL_CLIENT_LIST") ? Bk : [] } }), lP.on(LD.CAMERA_DEVICE_CHANGED, (e2) => {
        BN.info("camera device changed", JSON.stringify(e2)), wq.onCameraChanged && wq.onCameraChanged(e2), wq.safeEmit(RU.CAMERA_CHANGED, e2);
      }), lP.on(LD.RECORDING_DEVICE_CHANGED, (e2) => {
        BN.info("microphone device changed", JSON.stringify(e2)), wq.onMicrophoneChanged && wq.onMicrophoneChanged(e2), wq.safeEmit(RU.MICROPHONE_CHANGED, e2);
      }), lP.on(LD.PLAYOUT_DEVICE_CHANGED, (e2) => {
        BN.debug("playout device changed", JSON.stringify(e2)), wq.onPlaybackDeviceChanged && wq.onPlaybackDeviceChanged(e2), wq.safeEmit(RU.PLAYBACK_DEVICE_CHANGED, e2);
      }), fP.onAutoplayFailed = () => {
        BN.info("detect audio element autoplay failed"), hP.onAudioAutoplayFailed && hP.onAudioAutoplayFailed();
      }, YD.on("autoplay-failed", () => {
        BN.info("detect webaudio autoplay failed"), hP.onAudioAutoplayFailed && hP.onAudioAutoplayFailed(), wq.safeEmit(RU.AUTOPLAY_FAILED);
      }), YD.on(eD.STATE_CHANGE, (e2, t2) => {
        BN.info("audio context state changed: ".concat(t2, " => ").concat(e2)), wq.onAudioContextStateChanged && wq.onAudioContextStateChanged(e2, t2), wq.safeEmit(RU.AUDIO_CONTEXT_STATE_CHANGED, e2, t2);
      }), Xw.on(Hw.NETWORK_STATE_CHANGE, (e2, t2) => {
        BN.info("[network-indicator] network state changed, ".concat(t2, " => ").concat(e2));
      }), window && (window.__ARTC__ = wq), wq;
    });
  }
});

// node_modules/agora-rtm-sdk/agora-rtm.js
var require_agora_rtm = __commonJS({
  "node_modules/agora-rtm-sdk/agora-rtm.js"(exports, module) {
    !function(A, e) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = e(require_AgoraRTC_N_production()) : "function" == typeof define && define.amd ? define(["agora-rtc-sdk-ng"], e) : (A = "undefined" != typeof globalThis ? globalThis : A || self).AgoraRTM = e(A.AgoraRTC);
    }(exports, function(AgoraRTC) {
      "use strict";
      let AreaCodeMap = function(A) {
        return A.CHINA = "CN", A.ASIA = "AS", A.NORTH_AMERICA = "NA", A.EUROPE = "EU", A.JAPAN = "JP", A.INDIA = "IN", A.OCEANIA = "OC", A.SOUTH_AMERICA = "SA", A.AFRICA = "AF", A.GLOBAL = "GLOBAL", A.OVERSEA = "OVERSEA", A.SOUTH_KOREA = "KR", A.UNITED_STATES = "US", A;
      }({});
      AreaCodeMap.CHINA, AreaCodeMap.NORTH_AMERICA, AreaCodeMap.EUROPE, AreaCodeMap.ASIA, AreaCodeMap.JAPAN, AreaCodeMap.INDIA, AreaCodeMap.OCEANIA, AreaCodeMap.OVERSEA, AreaCodeMap.SOUTH_AMERICA, AreaCodeMap.AFRICA, AreaCodeMap.SOUTH_KOREA, AreaCodeMap.UNITED_STATES, AreaCodeMap.GLOBAL;
      const AREA_DOMAIN_MAP$1 = { [AreaCodeMap.ASIA]: { CODE: AreaCodeMap.ASIA, AP_DOMAINS: ["ap-web-1-asia.agora.io"], AP_BACKUP_DOMAINS: ["ap-web-2-asia.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-asia.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-asia.agora.io"], LOG_UPLOAD_SERVER: ["logservice-asia.agora.io"], PROXY_AP: ["proxy-ap-web-asia.agora.io"], PROXY_NGINX: ["southeast-asia.webrtc-cloud-proxy.sd-rtn.com"] }, [AreaCodeMap.NORTH_AMERICA]: { CODE: AreaCodeMap.NORTH_AMERICA, AP_DOMAINS: ["ap-web-1-north-america.agora.io"], AP_BACKUP_DOMAINS: ["ap-web-2-north-america.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-north-america.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-north-america.agora.io"], LOG_UPLOAD_SERVER: ["logservice-north-america.agora.io"], PROXY_AP: ["proxy-ap-web-america.agora.io"], PROXY_NGINX: ["east-usa.webrtc-cloud-proxy.sd-rtn.com"] }, [AreaCodeMap.EUROPE]: { CODE: AreaCodeMap.EUROPE, AP_DOMAINS: ["ap-web-1-europe.agora.io"], AP_BACKUP_DOMAINS: ["ap-web-2-europe.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-europe.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-europe.agora.io"], LOG_UPLOAD_SERVER: ["logservice-europe.agora.io"], PROXY_AP: ["proxy-ap-web-europe.agora.io"], PROXY_NGINX: ["europe.webrtc-cloud-proxy.sd-rtn.com"] }, [AreaCodeMap.JAPAN]: { CODE: AreaCodeMap.JAPAN, AP_DOMAINS: ["ap-web-1-japan.agora.io"], AP_BACKUP_DOMAINS: ["ap-web-2-japan.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-japan.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-japan.agora.io"], LOG_UPLOAD_SERVER: ["logservice-japan.agora.io"], PROXY_AP: ["proxy-ap-web-japan.agora.io"], PROXY_NGINX: ["japan.webrtc-cloud-proxy.sd-rtn.com"] }, [AreaCodeMap.INDIA]: { CODE: AreaCodeMap.INDIA, AP_DOMAINS: ["ap-web-1-india.agora.io"], AP_BACKUP_DOMAINS: ["ap-web-2-india.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-india.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-india.agora.io"], LOG_UPLOAD_SERVER: ["logservice-india.agora.io"], PROXY_AP: ["proxy-ap-web-india.agora.io"], PROXY_NGINX: ["india.webrtc-cloud-proxy.sd-rtn.com"] }, [AreaCodeMap.OVERSEA]: { CODE: AreaCodeMap.OVERSEA, AP_DOMAINS: ["ap-web-1-oversea.agora.io"], AP_BACKUP_DOMAINS: ["ap-web-2-oversea.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-oversea.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-oversea.agora.io"], LOG_UPLOAD_SERVER: ["logservice-oversea.agora.io"], PROXY_AP: ["proxy-ap-web-oversea.agora.io"], PROXY_NGINX: ["webrtc-cloud-proxy.agora.io"] }, [AreaCodeMap.GLOBAL]: { CODE: AreaCodeMap.GLOBAL, AP_DOMAINS: ["ap-web-1.agora.io", "ap-web-2.agora.io"], AP_BACKUP_DOMAINS: ["ap-web-3.agora.io", "ap-web-4.agora.io"], EVENT_REPORT_DOMAIN: ["webcollector-rtm.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["webcollector-1.agora.io"], LOG_UPLOAD_SERVER: ["logservice-rtm.agora.io"], PROXY_AP: ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"], PROXY_NGINX: ["webrtc-cloud-proxy.sd-rtn.com"] }, [AreaCodeMap.OCEANIA]: { CODE: AreaCodeMap.OCEANIA, AP_DOMAINS: ["ap-web-1-oceania.agora.io"], AP_BACKUP_DOMAINS: ["ap-web-2-oceania.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-oceania.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-oceania.agora.io"], LOG_UPLOAD_SERVER: ["logservice-oceania.agora.io"], PROXY_AP: ["proxy-ap-web-oceania.agora.io"], PROXY_NGINX: ["oceania.webrtc-cloud-proxy.sd-rtn.com"] }, [AreaCodeMap.SOUTH_AMERICA]: { CODE: AreaCodeMap.SOUTH_AMERICA, AP_DOMAINS: ["ap-web-1-south-america.agora.io"], AP_BACKUP_DOMAINS: ["ap-web-2-south-america.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-south-america.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-south-america.agora.io"], LOG_UPLOAD_SERVER: ["logservice-south-america.agora.io"], PROXY_AP: ["proxy-ap-web-south-america.agora.io"], PROXY_NGINX: ["south-america.webrtc-cloud-proxy.sd-rtn.com"] }, [AreaCodeMap.AFRICA]: { CODE: AreaCodeMap.AFRICA, AP_DOMAINS: ["ap-web-1-africa.agora.io"], AP_BACKUP_DOMAINS: ["ap-web-2-africa.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-africa.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-africa.agora.io"], LOG_UPLOAD_SERVER: ["logservice-south-africa.agora.io"], PROXY_AP: ["proxy-ap-web-africa.agora.io"], PROXY_NGINX: ["africa.webrtc-cloud-proxy.sd-rtn.com"] }, [AreaCodeMap.CHINA]: { CODE: AreaCodeMap.CHINA, AP_DOMAINS: ["webrtc2-2.ap.sd-rtn.com"], AP_BACKUP_DOMAINS: ["webrtc2-4.ap.sd-rtn.com"], EVENT_REPORT_DOMAIN: ["statscollector-1-china.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-china.agora.io"], LOG_UPLOAD_SERVER: ["logservice-china.agora.io"], PROXY_AP: ["proxy-ap-web.agoraio.cn"], PROXY_NGINX: ["east-cn.webrtc-cloud-proxy.sd-rtn.com"] }, [AreaCodeMap.SOUTH_KOREA]: { CODE: AreaCodeMap.SOUTH_KOREA, AP_DOMAINS: ["ap-web-1-korea.agora.io"], AP_BACKUP_DOMAINS: ["ap-web-2-korea.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-korea.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-korea.agora.io"], LOG_UPLOAD_SERVER: ["logservice-korea.agora.io"], PROXY_AP: ["proxy-ap-web-korea.agora.io"], PROXY_NGINX: ["korea.webrtc-cloud-proxy.sd-rtn.com"] }, [AreaCodeMap.UNITED_STATES]: { CODE: AreaCodeMap.UNITED_STATES, AP_DOMAINS: ["ap-web-1-us.agora.io"], AP_BACKUP_DOMAINS: ["ap-web-2-us.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-us.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-us.agora.io"], LOG_UPLOAD_SERVER: ["logservice-us.agora.io"], PROXY_AP: ["proxy-ap-web-us.agora.io"], PROXY_NGINX: ["us.webrtc-cloud-proxy.sd-rtn.com"] } }, continentCountryMap = { [AreaCodeMap.ASIA]: [AreaCodeMap.CHINA, AreaCodeMap.JAPAN, AreaCodeMap.INDIA], [AreaCodeMap.EUROPE]: [], [AreaCodeMap.NORTH_AMERICA]: [], [AreaCodeMap.SOUTH_AMERICA]: [], [AreaCodeMap.OCEANIA]: [], [AreaCodeMap.AFRICA]: [] }, areaWeights = [AreaCodeMap.GLOBAL, AreaCodeMap.CHINA, AreaCodeMap.NORTH_AMERICA, AreaCodeMap.EUROPE, AreaCodeMap.ASIA, AreaCodeMap.JAPAN, AreaCodeMap.INDIA, AreaCodeMap.OCEANIA, AreaCodeMap.SOUTH_AMERICA, AreaCodeMap.AFRICA];
      function _applyDecoratedDescriptor(A, e, t, g, o) {
        var I = {};
        return Object.keys(g).forEach(function(A2) {
          I[A2] = g[A2];
        }), I.enumerable = !!I.enumerable, I.configurable = !!I.configurable, ("value" in I || I.initializer) && (I.writable = true), I = t.slice().reverse().reduce(function(t2, g2) {
          return g2(A, e, t2) || t2;
        }, I), o && void 0 !== I.initializer && (I.value = I.initializer ? I.initializer.call(o) : void 0, I.initializer = void 0), void 0 === I.initializer ? (Object.defineProperty(A, e, I), null) : I;
      }
      function _defineProperty$1(A, e, t) {
        return (e = _toPropertyKey(e)) in A ? Object.defineProperty(A, e, { value: t, enumerable: true, configurable: true, writable: true }) : A[e] = t, A;
      }
      function ownKeys(A, e) {
        var t = Object.keys(A);
        if (Object.getOwnPropertySymbols) {
          var g = Object.getOwnPropertySymbols(A);
          e && (g = g.filter(function(e2) {
            return Object.getOwnPropertyDescriptor(A, e2).enumerable;
          })), t.push.apply(t, g);
        }
        return t;
      }
      function _objectSpread2(A) {
        for (var e = 1; e < arguments.length; e++) {
          var t = null != arguments[e] ? arguments[e] : {};
          e % 2 ? ownKeys(Object(t), true).forEach(function(e2) {
            _defineProperty$1(A, e2, t[e2]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(A, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(e2) {
            Object.defineProperty(A, e2, Object.getOwnPropertyDescriptor(t, e2));
          });
        }
        return A;
      }
      function _objectWithoutProperties(A, e) {
        if (null == A)
          return {};
        var t, g, o = _objectWithoutPropertiesLoose(A, e);
        if (Object.getOwnPropertySymbols) {
          var I = Object.getOwnPropertySymbols(A);
          for (g = 0; g < I.length; g++)
            t = I[g], -1 === e.indexOf(t) && {}.propertyIsEnumerable.call(A, t) && (o[t] = A[t]);
        }
        return o;
      }
      function _objectWithoutPropertiesLoose(A, e) {
        if (null == A)
          return {};
        var t = {};
        for (var g in A)
          if ({}.hasOwnProperty.call(A, g)) {
            if (-1 !== e.indexOf(g))
              continue;
            t[g] = A[g];
          }
        return t;
      }
      function _toPrimitive(A, e) {
        if ("object" != typeof A || !A)
          return A;
        var t = A[Symbol.toPrimitive];
        if (void 0 !== t) {
          var g = t.call(A, e);
          if ("object" != typeof g)
            return g;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === e ? String : Number)(A);
      }
      function _toPropertyKey(A) {
        var e = _toPrimitive(A, "string");
        return "symbol" == typeof e ? e : e + "";
      }
      let subscribedState = function(A) {
        return A.UNSUBSCRIBED = "UNSUBSCRIBED", A.SUBSCRIBED = "SUBSCRIBED", A;
      }({}), MessageType$1 = function(A) {
        return A.STRING = "STRING", A.BINARY = "BINARY", A;
      }({}), LegacyAreaCode = function(A) {
        return A.CN = "CN", A.NA = "NA", A.EU = "EU", A.AS = "AS", A.JP = "JP", A.IN = "IN", A.GLOB = "GLOB", A.OC = "OC", A.SA = "SA", A.AF = "AF", A.KR = "KR", A.US = "US", A.OVS = "OVS", A;
      }({}), AreaCode = function(A) {
        return A.GLOBAL = "GLOBAL", A.INDIA = "INDIA", A.JAPAN = "JAPAN", A.ASIA = "ASIA", A.EUROPE = "EUROPE", A.CHINA = "CHINA", A.NORTH_AMERICA = "NORTH_AMERICA", A;
      }({}), LinkStateChangeReason4Report = function(A) {
        return A[A.UNKNOWN = 0] = "UNKNOWN", A[A.LOGIN = 1] = "LOGIN", A[A.LOGIN_SUCCESS = 2] = "LOGIN_SUCCESS", A[A.LOGIN_TIMEOUT = 3] = "LOGIN_TIMEOUT", A[A.LOGIN_NOT_AUTHORIZED = 4] = "LOGIN_NOT_AUTHORIZED", A[A.LOGIN_REJECTED = 5] = "LOGIN_REJECTED", A[A.RELOGIN = 6] = "RELOGIN", A[A.LOGOUT = 7] = "LOGOUT", A[A.AUTO_RECONNECT = 8] = "AUTO_RECONNECT", A[A.RECONNECT_TIMEOUT = 9] = "RECONNECT_TIMEOUT", A[A.RECONNECT_SUCCESS = 10] = "RECONNECT_SUCCESS", A[A.JOIN = 11] = "JOIN", A[A.JOIN_SUCCESS = 12] = "JOIN_SUCCESS", A[A.JOIN_FAILED = 13] = "JOIN_FAILED", A[A.REJOIN = 14] = "REJOIN", A[A.LEAVE = 15] = "LEAVE", A[A.INVALID_TOKEN = 16] = "INVALID_TOKEN", A[A.TOKEN_EXPIRED = 17] = "TOKEN_EXPIRED", A[A.INCONSISTENT_APP_ID = 18] = "INCONSISTENT_APP_ID", A[A.INVALID_CHANNEL_NAME = 19] = "INVALID_CHANNEL_NAME", A[A.INVALID_USER_ID = 20] = "INVALID_USER_ID", A[A.NOT_INITIALIZED = 21] = "NOT_INITIALIZED", A[A.RTM_SERVICE_NOT_CONNECTED = 22] = "RTM_SERVICE_NOT_CONNECTED", A[A.CHANNEL_INSTANCE_EXCEED_LIMITATION = 23] = "CHANNEL_INSTANCE_EXCEED_LIMITATION", A[A.OPERATION_RATE_EXCEED_LIMITATION = 24] = "OPERATION_RATE_EXCEED_LIMITATION", A[A.CHANNEL_IN_ERROR_STATE = 25] = "CHANNEL_IN_ERROR_STATE", A[A.PRESENCE_NOT_CONNECTED = 26] = "PRESENCE_NOT_CONNECTED", A[A.SAME_UID_LOGIN = 27] = "SAME_UID_LOGIN", A[A.KICKED_OUT_BY_SERVER = 28] = "KICKED_OUT_BY_SERVER", A[A.KEEP_ALIVE_TIMEOUT = 29] = "KEEP_ALIVE_TIMEOUT", A[A.CONNECTION_ERROR = 30] = "CONNECTION_ERROR", A[A.PRESENCE_NOT_READY = 31] = "PRESENCE_NOT_READY", A[A.NETWORK_CHANGE = 32] = "NETWORK_CHANGE", A[A.SERVICE_NOT_SUPPORTED = 33] = "SERVICE_NOT_SUPPORTED", A[A.STREAM_CHANNEL_NOT_AVAILABLE = 34] = "STREAM_CHANNEL_NOT_AVAILABLE", A[A.STORAGE_NOT_AVAILABLE = 35] = "STORAGE_NOT_AVAILABLE", A[A.LOCK_NOT_AVAILABLE = 36] = "LOCK_NOT_AVAILABLE", A[A.LOGIN_TOO_FREQUENT = 37] = "LOGIN_TOO_FREQUENT", A;
      }({}), LinkStateChangeReasonDescription = function(A) {
        return A.UNKNOWN = "Unknown", A.LOGIN = "Perform login operation", A.LOGIN_SUCCESS = "Login success", A.LOGIN_TIMEOUT = "Login timeout", A.LOGIN_NOT_AUTHORIZED = "Login not authorized", A.LOGIN_REJECTED = "Login rejected", A.RELOGIN = "Perform login operation again", A.LOGOUT = "Logout success", A.AUTO_RECONNECT = "Reconnecting", A.RECONNECT_TIMEOUT = "Reconnect timeout", A.RECONNECT_SUCCESS = "Reconnect success", A.JOIN = "Perform join operation", A.JOIN_SUCCESS = "Join channel success", A.JOIN_FAILED = "Join channel failed", A.REJOIN = "Perform join operation again", A.LEAVE = "Leave channel success", A.INVALID_TOKEN = "Invalid token", A.TOKEN_EXPIRED = "Token expired", A.INCONSISTENT_APP_ID = "Inconsistent app ID", A.INVALID_CHANNEL_NAME = "Invalid channel name", A.INVALID_USER_ID = "Invalid user id", A.NOT_INITIALIZED = "Not initialized", A.RTM_SERVICE_NOT_CONNECTED = "RTM service not connected", A.CHANNEL_INSTANCE_EXCEED_LIMITATION = "Channel instance exceed limitation", A.OPERATION_RATE_EXCEED_LIMITATION = "Operation rate exceed limitation", A.CHANNEL_IN_ERROR_STATE = "Channel in error state", A.PRESENCE_NOT_CONNECTED = "Presence not connected", A.SAME_UID_LOGIN = "The same uid login on another device", A.KICKED_OUT_BY_SERVER = "Kicked out by server", A.KEEP_ALIVE_TIMEOUT = "Keep alive timeout", A.CONNECTION_ERROR = "Connection error", A.PRESENCE_NOT_READY = "Presence not ready", A.NETWORK_CHANGE = "Network change", A.SERVICE_NOT_SUPPORTED = "Service not supported", A.STREAM_CHANNEL_NOT_AVAILABLE = "Stream channel not available", A.STORAGE_NOT_AVAILABLE = "Storage service is not available", A.LOCK_NOT_AVAILABLE = "Lock service is not available", A.LOGIN_TOO_FREQUENT = "Login too frequent", A;
      }({}), TokenEventReason = function(A) {
        return A.WILL_EXPIRE = "The token is about to expire", A.READ_PERMISSION_REVOKED = "The token read permission is revoked", A;
      }({}), ChannelTypeEnum = function(A) {
        return A[A.MESSAGE = 1] = "MESSAGE", A[A.STREAM = 2] = "STREAM", A[A.USER = 3] = "USER", A;
      }({});
      var ConstantsType = Object.freeze({ __proto__: null, AreaCode, ChannelTypeEnum, LegacyAreaCode, LinkStateChangeReason4Report, LinkStateChangeReasonDescription, MessageType: MessageType$1, TokenEventReason, subscribedState }), commonjsGlobal = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
      function getDefaultExportFromCjs(A) {
        return A && A.__esModule && Object.prototype.hasOwnProperty.call(A, "default") ? A.default : A;
      }
      function getAugmentedNamespace(A) {
        if (A.__esModule)
          return A;
        var e = A.default;
        if ("function" == typeof e) {
          var t = function A2() {
            return this instanceof A2 ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
          };
          t.prototype = e.prototype;
        } else
          t = {};
        return Object.defineProperty(t, "__esModule", { value: true }), Object.keys(A).forEach(function(e2) {
          var g = Object.getOwnPropertyDescriptor(A, e2);
          Object.defineProperty(t, e2, g.get ? g : { enumerable: true, get: function() {
            return A[e2];
          } });
        }), t;
      }
      function format(A) {
        var e = Array.prototype.slice.call(arguments, 1);
        return e.length && (A = A.replace(/(%?)(%([jds]))/g, function(A2, t, g, o) {
          var I = e.shift();
          switch (o) {
            case "s":
              I = "" + I;
              break;
            case "d":
              I = Number(I);
              break;
            case "j":
              I = JSON.stringify(I);
          }
          return t ? (e.unshift(I), A2) : I;
        })), e.length && (A += " " + e.join(" ")), "" + (A = A.replace(/%{2,2}/g, "%"));
      }
      var format_1 = format, format$1 = getDefaultExportFromCjs(format_1), _extendStatics = function(A, e) {
        return _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(A2, e2) {
          A2.__proto__ = e2;
        } || function(A2, e2) {
          for (var t in e2)
            e2.hasOwnProperty(t) && (A2[t] = e2[t]);
        }, _extendStatics(A, e);
      };
      function __extends$3(A, e) {
        function t() {
          this.constructor = A;
        }
        _extendStatics(A, e), A.prototype = null === e ? Object.create(e) : (t.prototype = e.prototype, new t());
      }
      function isFunction$7(A) {
        return "function" == typeof A;
      }
      var _enable_super_gross_mode_that_will_cause_bad_things = false, config$1 = { set useDeprecatedSynchronousErrorHandling(A) {
        A && new Error().stack;
        _enable_super_gross_mode_that_will_cause_bad_things = A;
      }, get useDeprecatedSynchronousErrorHandling() {
        return _enable_super_gross_mode_that_will_cause_bad_things;
      } };
      function hostReportError(A) {
        setTimeout(function() {
          throw A;
        }, 0);
      }
      var empty$1 = { closed: true, next: function(A) {
      }, error: function(A) {
        if (config$1.useDeprecatedSynchronousErrorHandling)
          throw A;
        hostReportError(A);
      }, complete: function() {
      } }, isArray$g = function() {
        return Array.isArray || function(A) {
          return A && "number" == typeof A.length;
        };
      }();
      function isObject$e(A) {
        return null !== A && "object" == typeof A;
      }
      var UnsubscriptionErrorImpl$1 = function() {
        function A(A2) {
          return Error.call(this), this.message = A2 ? A2.length + " errors occurred during unsubscription:\n" + A2.map(function(A3, e) {
            return e + 1 + ") " + A3.toString();
          }).join("\n  ") : "", this.name = "UnsubscriptionError", this.errors = A2, this;
        }
        return A.prototype = Object.create(Error.prototype), A;
      }(), UnsubscriptionError$1 = UnsubscriptionErrorImpl$1, Subscription$2 = function() {
        function A(A2) {
          this.closed = false, this._parentOrParents = null, this._subscriptions = null, A2 && (this._ctorUnsubscribe = true, this._unsubscribe = A2);
        }
        return A.prototype.unsubscribe = function() {
          var e;
          if (!this.closed) {
            var t = this, g = t._parentOrParents, o = t._ctorUnsubscribe, I = t._unsubscribe, i2 = t._subscriptions;
            if (this.closed = true, this._parentOrParents = null, this._subscriptions = null, g instanceof A)
              g.remove(this);
            else if (null !== g)
              for (var r = 0; r < g.length; ++r) {
                g[r].remove(this);
              }
            if (isFunction$7(I)) {
              o && (this._unsubscribe = void 0);
              try {
                I.call(this);
              } catch (A2) {
                e = A2 instanceof UnsubscriptionError$1 ? flattenUnsubscriptionErrors$1(A2.errors) : [A2];
              }
            }
            if (isArray$g(i2)) {
              r = -1;
              for (var n = i2.length; ++r < n; ) {
                var C = i2[r];
                if (isObject$e(C))
                  try {
                    C.unsubscribe();
                  } catch (A2) {
                    e = e || [], A2 instanceof UnsubscriptionError$1 ? e = e.concat(flattenUnsubscriptionErrors$1(A2.errors)) : e.push(A2);
                  }
              }
            }
            if (e)
              throw new UnsubscriptionError$1(e);
          }
        }, A.prototype.add = function(e) {
          var t = e;
          if (!e)
            return A.EMPTY;
          switch (typeof e) {
            case "function":
              t = new A(e);
            case "object":
              if (t === this || t.closed || "function" != typeof t.unsubscribe)
                return t;
              if (this.closed)
                return t.unsubscribe(), t;
              if (!(t instanceof A)) {
                var g = t;
                (t = new A())._subscriptions = [g];
              }
              break;
            default:
              throw new Error("unrecognized teardown " + e + " added to Subscription.");
          }
          var o = t._parentOrParents;
          if (null === o)
            t._parentOrParents = this;
          else if (o instanceof A) {
            if (o === this)
              return t;
            t._parentOrParents = [o, this];
          } else {
            if (-1 !== o.indexOf(this))
              return t;
            o.push(this);
          }
          var I = this._subscriptions;
          return null === I ? this._subscriptions = [t] : I.push(t), t;
        }, A.prototype.remove = function(A2) {
          var e = this._subscriptions;
          if (e) {
            var t = e.indexOf(A2);
            -1 !== t && e.splice(t, 1);
          }
        }, A.EMPTY = function(A2) {
          return A2.closed = true, A2;
        }(new A()), A;
      }();
      function flattenUnsubscriptionErrors$1(A) {
        return A.reduce(function(A2, e) {
          return A2.concat(e instanceof UnsubscriptionError$1 ? e.errors : e);
        }, []);
      }
      var rxSubscriber = function() {
        return "function" == typeof Symbol ? Symbol("rxSubscriber") : "@@rxSubscriber_" + Math.random();
      }(), Subscriber = function(A) {
        function e(t, g, o) {
          var I = A.call(this) || this;
          switch (I.syncErrorValue = null, I.syncErrorThrown = false, I.syncErrorThrowable = false, I.isStopped = false, arguments.length) {
            case 0:
              I.destination = empty$1;
              break;
            case 1:
              if (!t) {
                I.destination = empty$1;
                break;
              }
              if ("object" == typeof t) {
                t instanceof e ? (I.syncErrorThrowable = t.syncErrorThrowable, I.destination = t, t.add(I)) : (I.syncErrorThrowable = true, I.destination = new SafeSubscriber(I, t));
                break;
              }
            default:
              I.syncErrorThrowable = true, I.destination = new SafeSubscriber(I, t, g, o);
          }
          return I;
        }
        return __extends$3(e, A), e.prototype[rxSubscriber] = function() {
          return this;
        }, e.create = function(A2, t, g) {
          var o = new e(A2, t, g);
          return o.syncErrorThrowable = false, o;
        }, e.prototype.next = function(A2) {
          this.isStopped || this._next(A2);
        }, e.prototype.error = function(A2) {
          this.isStopped || (this.isStopped = true, this._error(A2));
        }, e.prototype.complete = function() {
          this.isStopped || (this.isStopped = true, this._complete());
        }, e.prototype.unsubscribe = function() {
          this.closed || (this.isStopped = true, A.prototype.unsubscribe.call(this));
        }, e.prototype._next = function(A2) {
          this.destination.next(A2);
        }, e.prototype._error = function(A2) {
          this.destination.error(A2), this.unsubscribe();
        }, e.prototype._complete = function() {
          this.destination.complete(), this.unsubscribe();
        }, e.prototype._unsubscribeAndRecycle = function() {
          var A2 = this._parentOrParents;
          return this._parentOrParents = null, this.unsubscribe(), this.closed = false, this.isStopped = false, this._parentOrParents = A2, this;
        }, e;
      }(Subscription$2), SafeSubscriber = function(A) {
        function e(e2, t, g, o) {
          var I, i2 = A.call(this) || this;
          i2._parentSubscriber = e2;
          var r = i2;
          return isFunction$7(t) ? I = t : t && (I = t.next, g = t.error, o = t.complete, t !== empty$1 && (isFunction$7((r = Object.create(t)).unsubscribe) && i2.add(r.unsubscribe.bind(r)), r.unsubscribe = i2.unsubscribe.bind(i2))), i2._context = r, i2._next = I, i2._error = g, i2._complete = o, i2;
        }
        return __extends$3(e, A), e.prototype.next = function(A2) {
          if (!this.isStopped && this._next) {
            var e2 = this._parentSubscriber;
            config$1.useDeprecatedSynchronousErrorHandling && e2.syncErrorThrowable ? this.__tryOrSetError(e2, this._next, A2) && this.unsubscribe() : this.__tryOrUnsub(this._next, A2);
          }
        }, e.prototype.error = function(A2) {
          if (!this.isStopped) {
            var e2 = this._parentSubscriber, t = config$1.useDeprecatedSynchronousErrorHandling;
            if (this._error)
              t && e2.syncErrorThrowable ? (this.__tryOrSetError(e2, this._error, A2), this.unsubscribe()) : (this.__tryOrUnsub(this._error, A2), this.unsubscribe());
            else if (e2.syncErrorThrowable)
              t ? (e2.syncErrorValue = A2, e2.syncErrorThrown = true) : hostReportError(A2), this.unsubscribe();
            else {
              if (this.unsubscribe(), t)
                throw A2;
              hostReportError(A2);
            }
          }
        }, e.prototype.complete = function() {
          var A2 = this;
          if (!this.isStopped) {
            var e2 = this._parentSubscriber;
            if (this._complete) {
              var t = function() {
                return A2._complete.call(A2._context);
              };
              config$1.useDeprecatedSynchronousErrorHandling && e2.syncErrorThrowable ? (this.__tryOrSetError(e2, t), this.unsubscribe()) : (this.__tryOrUnsub(t), this.unsubscribe());
            } else
              this.unsubscribe();
          }
        }, e.prototype.__tryOrUnsub = function(A2, e2) {
          try {
            A2.call(this._context, e2);
          } catch (A3) {
            if (this.unsubscribe(), config$1.useDeprecatedSynchronousErrorHandling)
              throw A3;
            hostReportError(A3);
          }
        }, e.prototype.__tryOrSetError = function(A2, e2, t) {
          if (!config$1.useDeprecatedSynchronousErrorHandling)
            throw new Error("bad call");
          try {
            e2.call(this._context, t);
          } catch (e3) {
            return config$1.useDeprecatedSynchronousErrorHandling ? (A2.syncErrorValue = e3, A2.syncErrorThrown = true, true) : (hostReportError(e3), true);
          }
          return false;
        }, e.prototype._unsubscribe = function() {
          var A2 = this._parentSubscriber;
          this._context = null, this._parentSubscriber = null, A2.unsubscribe();
        }, e;
      }(Subscriber);
      function canReportError(A) {
        for (; A; ) {
          var e = A, t = e.closed, g = e.destination, o = e.isStopped;
          if (t || o)
            return false;
          A = g && g instanceof Subscriber ? g : null;
        }
        return true;
      }
      function toSubscriber(A, e, t) {
        if (A) {
          if (A instanceof Subscriber)
            return A;
          if (A[rxSubscriber])
            return A[rxSubscriber]();
        }
        return A || e || t ? new Subscriber(A, e, t) : new Subscriber(empty$1);
      }
      var observable = function() {
        return "function" == typeof Symbol && Symbol.observable || "@@observable";
      }();
      function identity$5(A) {
        return A;
      }
      function pipe() {
        for (var A = [], e = 0; e < arguments.length; e++)
          A[e] = arguments[e];
        return pipeFromArray(A);
      }
      function pipeFromArray(A) {
        return 0 === A.length ? identity$5 : 1 === A.length ? A[0] : function(e) {
          return A.reduce(function(A2, e2) {
            return e2(A2);
          }, e);
        };
      }
      var Observable = function() {
        function A(A2) {
          this._isScalar = false, A2 && (this._subscribe = A2);
        }
        return A.prototype.lift = function(e) {
          var t = new A();
          return t.source = this, t.operator = e, t;
        }, A.prototype.subscribe = function(A2, e, t) {
          var g = this.operator, o = toSubscriber(A2, e, t);
          if (g ? o.add(g.call(o, this.source)) : o.add(this.source || config$1.useDeprecatedSynchronousErrorHandling && !o.syncErrorThrowable ? this._subscribe(o) : this._trySubscribe(o)), config$1.useDeprecatedSynchronousErrorHandling && o.syncErrorThrowable && (o.syncErrorThrowable = false, o.syncErrorThrown))
            throw o.syncErrorValue;
          return o;
        }, A.prototype._trySubscribe = function(A2) {
          try {
            return this._subscribe(A2);
          } catch (e) {
            config$1.useDeprecatedSynchronousErrorHandling && (A2.syncErrorThrown = true, A2.syncErrorValue = e), canReportError(A2) ? A2.error(e) : console.warn(e);
          }
        }, A.prototype.forEach = function(A2, e) {
          var t = this;
          return new (e = getPromiseCtor(e))(function(e2, g) {
            var o;
            o = t.subscribe(function(e3) {
              try {
                A2(e3);
              } catch (A3) {
                g(A3), o && o.unsubscribe();
              }
            }, g, e2);
          });
        }, A.prototype._subscribe = function(A2) {
          var e = this.source;
          return e && e.subscribe(A2);
        }, A.prototype[observable] = function() {
          return this;
        }, A.prototype.pipe = function() {
          for (var A2 = [], e = 0; e < arguments.length; e++)
            A2[e] = arguments[e];
          return 0 === A2.length ? this : pipeFromArray(A2)(this);
        }, A.prototype.toPromise = function(A2) {
          var e = this;
          return new (A2 = getPromiseCtor(A2))(function(A3, t) {
            var g;
            e.subscribe(function(A4) {
              return g = A4;
            }, function(A4) {
              return t(A4);
            }, function() {
              return A3(g);
            });
          });
        }, A.create = function(e) {
          return new A(e);
        }, A;
      }();
      function getPromiseCtor(A) {
        if (A || (A = Promise), !A)
          throw new Error("no Promise impl found");
        return A;
      }
      var ObjectUnsubscribedErrorImpl = function() {
        function A() {
          return Error.call(this), this.message = "object unsubscribed", this.name = "ObjectUnsubscribedError", this;
        }
        return A.prototype = Object.create(Error.prototype), A;
      }(), ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl, SubjectSubscription = function(A) {
        function e(e2, t) {
          var g = A.call(this) || this;
          return g.subject = e2, g.subscriber = t, g.closed = false, g;
        }
        return __extends$3(e, A), e.prototype.unsubscribe = function() {
          if (!this.closed) {
            this.closed = true;
            var A2 = this.subject, e2 = A2.observers;
            if (this.subject = null, e2 && 0 !== e2.length && !A2.isStopped && !A2.closed) {
              var t = e2.indexOf(this.subscriber);
              -1 !== t && e2.splice(t, 1);
            }
          }
        }, e;
      }(Subscription$2), SubjectSubscriber = function(A) {
        function e(e2) {
          var t = A.call(this, e2) || this;
          return t.destination = e2, t;
        }
        return __extends$3(e, A), e;
      }(Subscriber), Subject = function(A) {
        function e() {
          var e2 = A.call(this) || this;
          return e2.observers = [], e2.closed = false, e2.isStopped = false, e2.hasError = false, e2.thrownError = null, e2;
        }
        return __extends$3(e, A), e.prototype[rxSubscriber] = function() {
          return new SubjectSubscriber(this);
        }, e.prototype.lift = function(A2) {
          var e2 = new AnonymousSubject(this, this);
          return e2.operator = A2, e2;
        }, e.prototype.next = function(A2) {
          if (this.closed)
            throw new ObjectUnsubscribedError();
          if (!this.isStopped)
            for (var e2 = this.observers, t = e2.length, g = e2.slice(), o = 0; o < t; o++)
              g[o].next(A2);
        }, e.prototype.error = function(A2) {
          if (this.closed)
            throw new ObjectUnsubscribedError();
          this.hasError = true, this.thrownError = A2, this.isStopped = true;
          for (var e2 = this.observers, t = e2.length, g = e2.slice(), o = 0; o < t; o++)
            g[o].error(A2);
          this.observers.length = 0;
        }, e.prototype.complete = function() {
          if (this.closed)
            throw new ObjectUnsubscribedError();
          this.isStopped = true;
          for (var A2 = this.observers, e2 = A2.length, t = A2.slice(), g = 0; g < e2; g++)
            t[g].complete();
          this.observers.length = 0;
        }, e.prototype.unsubscribe = function() {
          this.isStopped = true, this.closed = true, this.observers = null;
        }, e.prototype._trySubscribe = function(e2) {
          if (this.closed)
            throw new ObjectUnsubscribedError();
          return A.prototype._trySubscribe.call(this, e2);
        }, e.prototype._subscribe = function(A2) {
          if (this.closed)
            throw new ObjectUnsubscribedError();
          return this.hasError ? (A2.error(this.thrownError), Subscription$2.EMPTY) : this.isStopped ? (A2.complete(), Subscription$2.EMPTY) : (this.observers.push(A2), new SubjectSubscription(this, A2));
        }, e.prototype.asObservable = function() {
          var A2 = new Observable();
          return A2.source = this, A2;
        }, e.create = function(A2, e2) {
          return new AnonymousSubject(A2, e2);
        }, e;
      }(Observable), AnonymousSubject = function(A) {
        function e(e2, t) {
          var g = A.call(this) || this;
          return g.destination = e2, g.source = t, g;
        }
        return __extends$3(e, A), e.prototype.next = function(A2) {
          var e2 = this.destination;
          e2 && e2.next && e2.next(A2);
        }, e.prototype.error = function(A2) {
          var e2 = this.destination;
          e2 && e2.error && this.destination.error(A2);
        }, e.prototype.complete = function() {
          var A2 = this.destination;
          A2 && A2.complete && this.destination.complete();
        }, e.prototype._subscribe = function(A2) {
          return this.source ? this.source.subscribe(A2) : Subscription$2.EMPTY;
        }, e;
      }(Subject);
      function refCount() {
        return function(A) {
          return A.lift(new RefCountOperator(A));
        };
      }
      var RefCountOperator = function() {
        function A(A2) {
          this.connectable = A2;
        }
        return A.prototype.call = function(A2, e) {
          var t = this.connectable;
          t._refCount++;
          var g = new RefCountSubscriber(A2, t), o = e.subscribe(g);
          return g.closed || (g.connection = t.connect()), o;
        }, A;
      }(), RefCountSubscriber = function(A) {
        function e(e2, t) {
          var g = A.call(this, e2) || this;
          return g.connectable = t, g;
        }
        return __extends$3(e, A), e.prototype._unsubscribe = function() {
          var A2 = this.connectable;
          if (A2) {
            this.connectable = null;
            var e2 = A2._refCount;
            if (e2 <= 0)
              this.connection = null;
            else if (A2._refCount = e2 - 1, e2 > 1)
              this.connection = null;
            else {
              var t = this.connection, g = A2._connection;
              this.connection = null, !g || t && g !== t || g.unsubscribe();
            }
          } else
            this.connection = null;
        }, e;
      }(Subscriber), ConnectableObservable = function(A) {
        function e(e2, t) {
          var g = A.call(this) || this;
          return g.source = e2, g.subjectFactory = t, g._refCount = 0, g._isComplete = false, g;
        }
        return __extends$3(e, A), e.prototype._subscribe = function(A2) {
          return this.getSubject().subscribe(A2);
        }, e.prototype.getSubject = function() {
          var A2 = this._subject;
          return A2 && !A2.isStopped || (this._subject = this.subjectFactory()), this._subject;
        }, e.prototype.connect = function() {
          var A2 = this._connection;
          return A2 || (this._isComplete = false, (A2 = this._connection = new Subscription$2()).add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this))), A2.closed && (this._connection = null, A2 = Subscription$2.EMPTY)), A2;
        }, e.prototype.refCount = function() {
          return refCount()(this);
        }, e;
      }(Observable), connectableObservableDescriptor = function() {
        var A = ConnectableObservable.prototype;
        return { operator: { value: null }, _refCount: { value: 0, writable: true }, _subject: { value: null, writable: true }, _connection: { value: null, writable: true }, _subscribe: { value: A._subscribe }, _isComplete: { value: A._isComplete, writable: true }, getSubject: { value: A.getSubject }, connect: { value: A.connect }, refCount: { value: A.refCount } };
      }(), ConnectableSubscriber = function(A) {
        function e(e2, t) {
          var g = A.call(this, e2) || this;
          return g.connectable = t, g;
        }
        return __extends$3(e, A), e.prototype._error = function(e2) {
          this._unsubscribe(), A.prototype._error.call(this, e2);
        }, e.prototype._complete = function() {
          this.connectable._isComplete = true, this._unsubscribe(), A.prototype._complete.call(this);
        }, e.prototype._unsubscribe = function() {
          var A2 = this.connectable;
          if (A2) {
            this.connectable = null;
            var e2 = A2._connection;
            A2._refCount = 0, A2._subject = null, A2._connection = null, e2 && e2.unsubscribe();
          }
        }, e;
      }(SubjectSubscriber), Action$2 = function(A) {
        function e(e2, t) {
          return A.call(this) || this;
        }
        return __extends$3(e, A), e.prototype.schedule = function(A2, e2) {
          return this;
        }, e;
      }(Subscription$2), AsyncAction$2 = function(A) {
        function e(e2, t) {
          var g = A.call(this, e2, t) || this;
          return g.scheduler = e2, g.work = t, g.pending = false, g;
        }
        return __extends$3(e, A), e.prototype.schedule = function(A2, e2) {
          if (void 0 === e2 && (e2 = 0), this.closed)
            return this;
          this.state = A2;
          var t = this.id, g = this.scheduler;
          return null != t && (this.id = this.recycleAsyncId(g, t, e2)), this.pending = true, this.delay = e2, this.id = this.id || this.requestAsyncId(g, this.id, e2), this;
        }, e.prototype.requestAsyncId = function(A2, e2, t) {
          return void 0 === t && (t = 0), setInterval(A2.flush.bind(A2, this), t);
        }, e.prototype.recycleAsyncId = function(A2, e2, t) {
          if (void 0 === t && (t = 0), null !== t && this.delay === t && false === this.pending)
            return e2;
          clearInterval(e2);
        }, e.prototype.execute = function(A2, e2) {
          if (this.closed)
            return new Error("executing a cancelled action");
          this.pending = false;
          var t = this._execute(A2, e2);
          if (t)
            return t;
          false === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
        }, e.prototype._execute = function(A2, e2) {
          var t = false, g = void 0;
          try {
            this.work(A2);
          } catch (A3) {
            t = true, g = !!A3 && A3 || new Error(A3);
          }
          if (t)
            return this.unsubscribe(), g;
        }, e.prototype._unsubscribe = function() {
          var A2 = this.id, e2 = this.scheduler, t = e2.actions, g = t.indexOf(this);
          this.work = null, this.state = null, this.pending = false, this.scheduler = null, -1 !== g && t.splice(g, 1), null != A2 && (this.id = this.recycleAsyncId(e2, A2, null)), this.delay = null;
        }, e;
      }(Action$2), QueueAction = function(A) {
        function e(e2, t) {
          var g = A.call(this, e2, t) || this;
          return g.scheduler = e2, g.work = t, g;
        }
        return __extends$3(e, A), e.prototype.schedule = function(e2, t) {
          return void 0 === t && (t = 0), t > 0 ? A.prototype.schedule.call(this, e2, t) : (this.delay = t, this.state = e2, this.scheduler.flush(this), this);
        }, e.prototype.execute = function(e2, t) {
          return t > 0 || this.closed ? A.prototype.execute.call(this, e2, t) : this._execute(e2, t);
        }, e.prototype.requestAsyncId = function(e2, t, g) {
          return void 0 === g && (g = 0), null !== g && g > 0 || null === g && this.delay > 0 ? A.prototype.requestAsyncId.call(this, e2, t, g) : e2.flush(this);
        }, e;
      }(AsyncAction$2), Scheduler$2 = function() {
        function A(e, t) {
          void 0 === t && (t = A.now), this.SchedulerAction = e, this.now = t;
        }
        return A.prototype.schedule = function(A2, e, t) {
          return void 0 === e && (e = 0), new this.SchedulerAction(this, A2).schedule(t, e);
        }, A.now = function() {
          return Date.now();
        }, A;
      }(), AsyncScheduler$2 = function(A) {
        function e(t, g) {
          void 0 === g && (g = Scheduler$2.now);
          var o = A.call(this, t, function() {
            return e.delegate && e.delegate !== o ? e.delegate.now() : g();
          }) || this;
          return o.actions = [], o.active = false, o.scheduled = void 0, o;
        }
        return __extends$3(e, A), e.prototype.schedule = function(t, g, o) {
          return void 0 === g && (g = 0), e.delegate && e.delegate !== this ? e.delegate.schedule(t, g, o) : A.prototype.schedule.call(this, t, g, o);
        }, e.prototype.flush = function(A2) {
          var e2 = this.actions;
          if (this.active)
            e2.push(A2);
          else {
            var t;
            this.active = true;
            do {
              if (t = A2.execute(A2.state, A2.delay))
                break;
            } while (A2 = e2.shift());
            if (this.active = false, t) {
              for (; A2 = e2.shift(); )
                A2.unsubscribe();
              throw t;
            }
          }
        }, e;
      }(Scheduler$2), QueueScheduler = function(A) {
        function e() {
          return null !== A && A.apply(this, arguments) || this;
        }
        return __extends$3(e, A), e;
      }(AsyncScheduler$2), queueScheduler = new QueueScheduler(QueueAction), queue = queueScheduler, EMPTY = new Observable(function(A) {
        return A.complete();
      });
      function empty(A) {
        return A ? emptyScheduled(A) : EMPTY;
      }
      function emptyScheduled(A) {
        return new Observable(function(e) {
          return A.schedule(function() {
            return e.complete();
          });
        });
      }
      function isScheduler(A) {
        return A && "function" == typeof A.schedule;
      }
      var subscribeToArray = function(A) {
        return function(e) {
          for (var t = 0, g = A.length; t < g && !e.closed; t++)
            e.next(A[t]);
          e.complete();
        };
      };
      function scheduleArray(A, e) {
        return new Observable(function(t) {
          var g = new Subscription$2(), o = 0;
          return g.add(e.schedule(function() {
            o !== A.length ? (t.next(A[o++]), t.closed || g.add(this.schedule())) : t.complete();
          })), g;
        });
      }
      function fromArray(A, e) {
        return e ? scheduleArray(A, e) : new Observable(subscribeToArray(A));
      }
      function of() {
        for (var A = [], e = 0; e < arguments.length; e++)
          A[e] = arguments[e];
        var t = A[A.length - 1];
        return isScheduler(t) ? (A.pop(), scheduleArray(A, t)) : fromArray(A);
      }
      function throwError(A, e) {
        return new Observable(function(e2) {
          return e2.error(A);
        });
      }
      var Notification = function() {
        function A(A2, e, t) {
          this.kind = A2, this.value = e, this.error = t, this.hasValue = "N" === A2;
        }
        return A.prototype.observe = function(A2) {
          switch (this.kind) {
            case "N":
              return A2.next && A2.next(this.value);
            case "E":
              return A2.error && A2.error(this.error);
            case "C":
              return A2.complete && A2.complete();
          }
        }, A.prototype.do = function(A2, e, t) {
          switch (this.kind) {
            case "N":
              return A2 && A2(this.value);
            case "E":
              return e && e(this.error);
            case "C":
              return t && t();
          }
        }, A.prototype.accept = function(A2, e, t) {
          return A2 && "function" == typeof A2.next ? this.observe(A2) : this.do(A2, e, t);
        }, A.prototype.toObservable = function() {
          switch (this.kind) {
            case "N":
              return of(this.value);
            case "E":
              return throwError(this.error);
            case "C":
              return empty();
          }
          throw new Error("unexpected notification kind value");
        }, A.createNext = function(e) {
          return void 0 !== e ? new A("N", e) : A.undefinedValueNotification;
        }, A.createError = function(e) {
          return new A("E", void 0, e);
        }, A.createComplete = function() {
          return A.completeNotification;
        }, A.completeNotification = new A("C"), A.undefinedValueNotification = new A("N", void 0), A;
      }();
      function observeOn(A, e) {
        return void 0 === e && (e = 0), function(t) {
          return t.lift(new ObserveOnOperator(A, e));
        };
      }
      var ObserveOnOperator = function() {
        function A(A2, e) {
          void 0 === e && (e = 0), this.scheduler = A2, this.delay = e;
        }
        return A.prototype.call = function(A2, e) {
          return e.subscribe(new ObserveOnSubscriber(A2, this.scheduler, this.delay));
        }, A;
      }(), ObserveOnSubscriber = function(A) {
        function e(e2, t, g) {
          void 0 === g && (g = 0);
          var o = A.call(this, e2) || this;
          return o.scheduler = t, o.delay = g, o;
        }
        return __extends$3(e, A), e.dispatch = function(A2) {
          var e2 = A2.notification, t = A2.destination;
          e2.observe(t), this.unsubscribe();
        }, e.prototype.scheduleMessage = function(A2) {
          this.destination.add(this.scheduler.schedule(e.dispatch, this.delay, new ObserveOnMessage(A2, this.destination)));
        }, e.prototype._next = function(A2) {
          this.scheduleMessage(Notification.createNext(A2));
        }, e.prototype._error = function(A2) {
          this.scheduleMessage(Notification.createError(A2)), this.unsubscribe();
        }, e.prototype._complete = function() {
          this.scheduleMessage(Notification.createComplete()), this.unsubscribe();
        }, e;
      }(Subscriber), ObserveOnMessage = function() {
        return function(A, e) {
          this.notification = A, this.destination = e;
        };
      }(), ReplaySubject = function(A) {
        function e(e2, t, g) {
          void 0 === e2 && (e2 = Number.POSITIVE_INFINITY), void 0 === t && (t = Number.POSITIVE_INFINITY);
          var o = A.call(this) || this;
          return o.scheduler = g, o._events = [], o._infiniteTimeWindow = false, o._bufferSize = e2 < 1 ? 1 : e2, o._windowTime = t < 1 ? 1 : t, t === Number.POSITIVE_INFINITY ? (o._infiniteTimeWindow = true, o.next = o.nextInfiniteTimeWindow) : o.next = o.nextTimeWindow, o;
        }
        return __extends$3(e, A), e.prototype.nextInfiniteTimeWindow = function(e2) {
          if (!this.isStopped) {
            var t = this._events;
            t.push(e2), t.length > this._bufferSize && t.shift();
          }
          A.prototype.next.call(this, e2);
        }, e.prototype.nextTimeWindow = function(e2) {
          this.isStopped || (this._events.push(new ReplayEvent(this._getNow(), e2)), this._trimBufferThenGetEvents()), A.prototype.next.call(this, e2);
        }, e.prototype._subscribe = function(A2) {
          var e2, t = this._infiniteTimeWindow, g = t ? this._events : this._trimBufferThenGetEvents(), o = this.scheduler, I = g.length;
          if (this.closed)
            throw new ObjectUnsubscribedError();
          if (this.isStopped || this.hasError ? e2 = Subscription$2.EMPTY : (this.observers.push(A2), e2 = new SubjectSubscription(this, A2)), o && A2.add(A2 = new ObserveOnSubscriber(A2, o)), t)
            for (var i2 = 0; i2 < I && !A2.closed; i2++)
              A2.next(g[i2]);
          else
            for (i2 = 0; i2 < I && !A2.closed; i2++)
              A2.next(g[i2].value);
          return this.hasError ? A2.error(this.thrownError) : this.isStopped && A2.complete(), e2;
        }, e.prototype._getNow = function() {
          return (this.scheduler || queue).now();
        }, e.prototype._trimBufferThenGetEvents = function() {
          for (var A2 = this._getNow(), e2 = this._bufferSize, t = this._windowTime, g = this._events, o = g.length, I = 0; I < o && !(A2 - g[I].time < t); )
            I++;
          return o > e2 && (I = Math.max(I, o - e2)), I > 0 && g.splice(0, I), g;
        }, e;
      }(Subject), ReplayEvent = function() {
        return function(A, e) {
          this.time = A, this.value = e;
        };
      }(), nextHandle = 1, RESOLVED = function() {
        return Promise.resolve();
      }(), activeHandles = {};
      function findAndClearHandle(A) {
        return A in activeHandles && (delete activeHandles[A], true);
      }
      var Immediate = { setImmediate: function(A) {
        var e = nextHandle++;
        return activeHandles[e] = true, RESOLVED.then(function() {
          return findAndClearHandle(e) && A();
        }), e;
      }, clearImmediate: function(A) {
        findAndClearHandle(A);
      } }, AsapAction = function(A) {
        function e(e2, t) {
          var g = A.call(this, e2, t) || this;
          return g.scheduler = e2, g.work = t, g;
        }
        return __extends$3(e, A), e.prototype.requestAsyncId = function(e2, t, g) {
          return void 0 === g && (g = 0), null !== g && g > 0 ? A.prototype.requestAsyncId.call(this, e2, t, g) : (e2.actions.push(this), e2.scheduled || (e2.scheduled = Immediate.setImmediate(e2.flush.bind(e2, null))));
        }, e.prototype.recycleAsyncId = function(e2, t, g) {
          if (void 0 === g && (g = 0), null !== g && g > 0 || null === g && this.delay > 0)
            return A.prototype.recycleAsyncId.call(this, e2, t, g);
          0 === e2.actions.length && (Immediate.clearImmediate(t), e2.scheduled = void 0);
        }, e;
      }(AsyncAction$2), AsapScheduler = function(A) {
        function e() {
          return null !== A && A.apply(this, arguments) || this;
        }
        return __extends$3(e, A), e.prototype.flush = function(A2) {
          this.active = true, this.scheduled = void 0;
          var e2, t = this.actions, g = -1, o = t.length;
          A2 = A2 || t.shift();
          do {
            if (e2 = A2.execute(A2.state, A2.delay))
              break;
          } while (++g < o && (A2 = t.shift()));
          if (this.active = false, e2) {
            for (; ++g < o && (A2 = t.shift()); )
              A2.unsubscribe();
            throw e2;
          }
        }, e;
      }(AsyncScheduler$2), asapScheduler = new AsapScheduler(AsapAction), asyncScheduler = new AsyncScheduler$2(AsyncAction$2), async = asyncScheduler;
      function noop$3() {
      }
      var ArgumentOutOfRangeErrorImpl = function() {
        function A() {
          return Error.call(this), this.message = "argument out of range", this.name = "ArgumentOutOfRangeError", this;
        }
        return A.prototype = Object.create(Error.prototype), A;
      }(), ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl, EmptyErrorImpl = function() {
        function A() {
          return Error.call(this), this.message = "no elements in sequence", this.name = "EmptyError", this;
        }
        return A.prototype = Object.create(Error.prototype), A;
      }(), EmptyError = EmptyErrorImpl, TimeoutErrorImpl = function() {
        function A() {
          return Error.call(this), this.message = "Timeout has occurred", this.name = "TimeoutError", this;
        }
        return A.prototype = Object.create(Error.prototype), A;
      }(), TimeoutError = TimeoutErrorImpl;
      function map$1(A, e) {
        return function(t) {
          if ("function" != typeof A)
            throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
          return t.lift(new MapOperator(A, e));
        };
      }
      var MapOperator = function() {
        function A(A2, e) {
          this.project = A2, this.thisArg = e;
        }
        return A.prototype.call = function(A2, e) {
          return e.subscribe(new MapSubscriber(A2, this.project, this.thisArg));
        }, A;
      }(), MapSubscriber = function(A) {
        function e(e2, t, g) {
          var o = A.call(this, e2) || this;
          return o.project = t, o.count = 0, o.thisArg = g || o, o;
        }
        return __extends$3(e, A), e.prototype._next = function(A2) {
          var e2;
          try {
            e2 = this.project.call(this.thisArg, A2, this.count++);
          } catch (A3) {
            return void this.destination.error(A3);
          }
          this.destination.next(e2);
        }, e;
      }(Subscriber), OuterSubscriber = function(A) {
        function e() {
          return null !== A && A.apply(this, arguments) || this;
        }
        return __extends$3(e, A), e.prototype.notifyNext = function(A2, e2, t, g, o) {
          this.destination.next(e2);
        }, e.prototype.notifyError = function(A2, e2) {
          this.destination.error(A2);
        }, e.prototype.notifyComplete = function(A2) {
          this.destination.complete();
        }, e;
      }(Subscriber), InnerSubscriber = function(A) {
        function e(e2, t, g) {
          var o = A.call(this) || this;
          return o.parent = e2, o.outerValue = t, o.outerIndex = g, o.index = 0, o;
        }
        return __extends$3(e, A), e.prototype._next = function(A2) {
          this.parent.notifyNext(this.outerValue, A2, this.outerIndex, this.index++, this);
        }, e.prototype._error = function(A2) {
          this.parent.notifyError(A2, this), this.unsubscribe();
        }, e.prototype._complete = function() {
          this.parent.notifyComplete(this), this.unsubscribe();
        }, e;
      }(Subscriber), subscribeToPromise = function(A) {
        return function(e) {
          return A.then(function(A2) {
            e.closed || (e.next(A2), e.complete());
          }, function(A2) {
            return e.error(A2);
          }).then(null, hostReportError), e;
        };
      };
      function getSymbolIterator() {
        return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator";
      }
      var iterator = getSymbolIterator(), subscribeToIterable = function(A) {
        return function(e) {
          for (var t = A[iterator](); ; ) {
            var g = void 0;
            try {
              g = t.next();
            } catch (A2) {
              return e.error(A2), e;
            }
            if (g.done) {
              e.complete();
              break;
            }
            if (e.next(g.value), e.closed)
              break;
          }
          return "function" == typeof t.return && e.add(function() {
            t.return && t.return();
          }), e;
        };
      }, subscribeToObservable = function(A) {
        return function(e) {
          var t = A[observable]();
          if ("function" != typeof t.subscribe)
            throw new TypeError("Provided object does not correctly implement Symbol.observable");
          return t.subscribe(e);
        };
      }, isArrayLike$9 = function(A) {
        return A && "number" == typeof A.length && "function" != typeof A;
      };
      function isPromise(A) {
        return !!A && "function" != typeof A.subscribe && "function" == typeof A.then;
      }
      var subscribeTo = function(A) {
        if (A && "function" == typeof A[observable])
          return subscribeToObservable(A);
        if (isArrayLike$9(A))
          return subscribeToArray(A);
        if (isPromise(A))
          return subscribeToPromise(A);
        if (A && "function" == typeof A[iterator])
          return subscribeToIterable(A);
        var e = isObject$e(A) ? "an invalid object" : "'" + A + "'";
        throw new TypeError("You provided " + e + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.");
      };
      function subscribeToResult(A, e, t, g, o) {
        if (void 0 === o && (o = new InnerSubscriber(A, t, g)), !o.closed)
          return e instanceof Observable ? e.subscribe(o) : subscribeTo(e)(o);
      }
      function from(A, e) {
        return A instanceof Observable ? A : new Observable(subscribeTo(A));
      }
      var SimpleInnerSubscriber = function(A) {
        function e(e2) {
          var t = A.call(this) || this;
          return t.parent = e2, t;
        }
        return __extends$3(e, A), e.prototype._next = function(A2) {
          this.parent.notifyNext(A2);
        }, e.prototype._error = function(A2) {
          this.parent.notifyError(A2), this.unsubscribe();
        }, e.prototype._complete = function() {
          this.parent.notifyComplete(), this.unsubscribe();
        }, e;
      }(Subscriber), SimpleOuterSubscriber = function(A) {
        function e() {
          return null !== A && A.apply(this, arguments) || this;
        }
        return __extends$3(e, A), e.prototype.notifyNext = function(A2) {
          this.destination.next(A2);
        }, e.prototype.notifyError = function(A2) {
          this.destination.error(A2);
        }, e.prototype.notifyComplete = function() {
          this.destination.complete();
        }, e;
      }(Subscriber);
      function innerSubscribe(A, e) {
        if (!e.closed) {
          if (A instanceof Observable)
            return A.subscribe(e);
          var t;
          try {
            t = subscribeTo(A)(e);
          } catch (A2) {
            e.error(A2);
          }
          return t;
        }
      }
      function mergeMap(A, e, t) {
        return void 0 === t && (t = Number.POSITIVE_INFINITY), "function" == typeof e ? function(g) {
          return g.pipe(mergeMap(function(t2, g2) {
            return from(A(t2, g2)).pipe(map$1(function(A2, o) {
              return e(t2, A2, g2, o);
            }));
          }, t));
        } : ("number" == typeof e && (t = e), function(e2) {
          return e2.lift(new MergeMapOperator(A, t));
        });
      }
      var MergeMapOperator = function() {
        function A(A2, e) {
          void 0 === e && (e = Number.POSITIVE_INFINITY), this.project = A2, this.concurrent = e;
        }
        return A.prototype.call = function(A2, e) {
          return e.subscribe(new MergeMapSubscriber(A2, this.project, this.concurrent));
        }, A;
      }(), MergeMapSubscriber = function(A) {
        function e(e2, t, g) {
          void 0 === g && (g = Number.POSITIVE_INFINITY);
          var o = A.call(this, e2) || this;
          return o.project = t, o.concurrent = g, o.hasCompleted = false, o.buffer = [], o.active = 0, o.index = 0, o;
        }
        return __extends$3(e, A), e.prototype._next = function(A2) {
          this.active < this.concurrent ? this._tryNext(A2) : this.buffer.push(A2);
        }, e.prototype._tryNext = function(A2) {
          var e2, t = this.index++;
          try {
            e2 = this.project(A2, t);
          } catch (A3) {
            return void this.destination.error(A3);
          }
          this.active++, this._innerSub(e2);
        }, e.prototype._innerSub = function(A2) {
          var e2 = new SimpleInnerSubscriber(this), t = this.destination;
          t.add(e2);
          var g = innerSubscribe(A2, e2);
          g !== e2 && t.add(g);
        }, e.prototype._complete = function() {
          this.hasCompleted = true, 0 === this.active && 0 === this.buffer.length && this.destination.complete(), this.unsubscribe();
        }, e.prototype.notifyNext = function(A2) {
          this.destination.next(A2);
        }, e.prototype.notifyComplete = function() {
          var A2 = this.buffer;
          this.active--, A2.length > 0 ? this._next(A2.shift()) : 0 === this.active && this.hasCompleted && this.destination.complete();
        }, e;
      }(SimpleOuterSubscriber);
      function mergeAll(A) {
        return void 0 === A && (A = Number.POSITIVE_INFINITY), mergeMap(identity$5, A);
      }
      function concatAll() {
        return mergeAll(1);
      }
      function concat() {
        for (var A = [], e = 0; e < arguments.length; e++)
          A[e] = arguments[e];
        return concatAll()(of.apply(void 0, A));
      }
      function defer(A) {
        return new Observable(function(e) {
          var t;
          try {
            t = A();
          } catch (A2) {
            return void e.error(A2);
          }
          return (t ? from(t) : empty()).subscribe(e);
        });
      }
      function fromEvent(A, e, t, g) {
        return isFunction$7(t) && (g = t, t = void 0), g ? fromEvent(A, e, t).pipe(map$1(function(A2) {
          return isArray$g(A2) ? g.apply(void 0, A2) : g(A2);
        })) : new Observable(function(g2) {
          setupSubscription(A, e, function(A2) {
            arguments.length > 1 ? g2.next(Array.prototype.slice.call(arguments)) : g2.next(A2);
          }, g2, t);
        });
      }
      function setupSubscription(A, e, t, g, o) {
        var I;
        if (isEventTarget(A)) {
          var i2 = A;
          A.addEventListener(e, t, o), I = function() {
            return i2.removeEventListener(e, t, o);
          };
        } else if (isJQueryStyleEventEmitter(A)) {
          var r = A;
          A.on(e, t), I = function() {
            return r.off(e, t);
          };
        } else if (isNodeStyleEventEmitter(A)) {
          var n = A;
          A.addListener(e, t), I = function() {
            return n.removeListener(e, t);
          };
        } else {
          if (!A || !A.length)
            throw new TypeError("Invalid event target");
          for (var C = 0, E = A.length; C < E; C++)
            setupSubscription(A[C], e, t, g, o);
        }
        g.add(I);
      }
      function isNodeStyleEventEmitter(A) {
        return A && "function" == typeof A.addListener && "function" == typeof A.removeListener;
      }
      function isJQueryStyleEventEmitter(A) {
        return A && "function" == typeof A.on && "function" == typeof A.off;
      }
      function isEventTarget(A) {
        return A && "function" == typeof A.addEventListener && "function" == typeof A.removeEventListener;
      }
      function isNumeric(A) {
        return !isArray$g(A) && A - parseFloat(A) + 1 >= 0;
      }
      function interval(A, e) {
        return void 0 === A && (A = 0), void 0 === e && (e = async), (!isNumeric(A) || A < 0) && (A = 0), e && "function" == typeof e.schedule || (e = async), new Observable(function(t) {
          return t.add(e.schedule(dispatch$1, A, { subscriber: t, counter: 0, period: A })), t;
        });
      }
      function dispatch$1(A) {
        var e = A.subscriber, t = A.counter, g = A.period;
        e.next(t), this.schedule({ subscriber: e, counter: t + 1, period: g }, g);
      }
      function merge() {
        for (var A = [], e = 0; e < arguments.length; e++)
          A[e] = arguments[e];
        var t = Number.POSITIVE_INFINITY, g = null, o = A[A.length - 1];
        return isScheduler(o) ? (g = A.pop(), A.length > 1 && "number" == typeof A[A.length - 1] && (t = A.pop())) : "number" == typeof o && (t = A.pop()), null === g && 1 === A.length && A[0] instanceof Observable ? A[0] : mergeAll(t)(fromArray(A, g));
      }
      var NEVER = new Observable(noop$3);
      function filter(A, e) {
        return function(t) {
          return t.lift(new FilterOperator(A, e));
        };
      }
      var FilterOperator = function() {
        function A(A2, e) {
          this.predicate = A2, this.thisArg = e;
        }
        return A.prototype.call = function(A2, e) {
          return e.subscribe(new FilterSubscriber(A2, this.predicate, this.thisArg));
        }, A;
      }(), FilterSubscriber = function(A) {
        function e(e2, t, g) {
          var o = A.call(this, e2) || this;
          return o.predicate = t, o.thisArg = g, o.count = 0, o;
        }
        return __extends$3(e, A), e.prototype._next = function(A2) {
          var e2;
          try {
            e2 = this.predicate.call(this.thisArg, A2, this.count++);
          } catch (A3) {
            return void this.destination.error(A3);
          }
          e2 && this.destination.next(A2);
        }, e;
      }(Subscriber);
      function race() {
        for (var A = [], e = 0; e < arguments.length; e++)
          A[e] = arguments[e];
        if (1 === A.length) {
          if (!isArray$g(A[0]))
            return A[0];
          A = A[0];
        }
        return fromArray(A, void 0).lift(new RaceOperator());
      }
      var RaceOperator = function() {
        function A() {
        }
        return A.prototype.call = function(A2, e) {
          return e.subscribe(new RaceSubscriber(A2));
        }, A;
      }(), RaceSubscriber = function(A) {
        function e(e2) {
          var t = A.call(this, e2) || this;
          return t.hasFirst = false, t.observables = [], t.subscriptions = [], t;
        }
        return __extends$3(e, A), e.prototype._next = function(A2) {
          this.observables.push(A2);
        }, e.prototype._complete = function() {
          var A2 = this.observables, e2 = A2.length;
          if (0 === e2)
            this.destination.complete();
          else {
            for (var t = 0; t < e2 && !this.hasFirst; t++) {
              var g = subscribeToResult(this, A2[t], void 0, t);
              this.subscriptions && this.subscriptions.push(g), this.add(g);
            }
            this.observables = null;
          }
        }, e.prototype.notifyNext = function(A2, e2, t) {
          if (!this.hasFirst) {
            this.hasFirst = true;
            for (var g = 0; g < this.subscriptions.length; g++)
              if (g !== t) {
                var o = this.subscriptions[g];
                o.unsubscribe(), this.remove(o);
              }
            this.subscriptions = null;
          }
          this.destination.next(e2);
        }, e;
      }(OuterSubscriber);
      function timer(A, e, t) {
        void 0 === A && (A = 0);
        var g = -1;
        return isNumeric(e) ? g = Number(e) < 1 ? 1 : Number(e) : isScheduler(e) && (t = e), isScheduler(t) || (t = async), new Observable(function(e2) {
          var o = isNumeric(A) ? A : +A - t.now();
          return t.schedule(dispatch, o, { index: 0, period: g, subscriber: e2 });
        });
      }
      function dispatch(A) {
        var e = A.index, t = A.period, g = A.subscriber;
        if (g.next(e), !g.closed) {
          if (-1 === t)
            return g.complete();
          A.index = e + 1, this.schedule(A, t);
        }
      }
      function zip() {
        for (var A = [], e = 0; e < arguments.length; e++)
          A[e] = arguments[e];
        var t = A[A.length - 1];
        return "function" == typeof t && A.pop(), fromArray(A, void 0).lift(new ZipOperator(t));
      }
      var ZipOperator = function() {
        function A(A2) {
          this.resultSelector = A2;
        }
        return A.prototype.call = function(A2, e) {
          return e.subscribe(new ZipSubscriber(A2, this.resultSelector));
        }, A;
      }(), ZipSubscriber = function(A) {
        function e(e2, t, g) {
          var o = A.call(this, e2) || this;
          return o.resultSelector = t, o.iterators = [], o.active = 0, o.resultSelector = "function" == typeof t ? t : void 0, o;
        }
        return __extends$3(e, A), e.prototype._next = function(A2) {
          var e2 = this.iterators;
          isArray$g(A2) ? e2.push(new StaticArrayIterator(A2)) : "function" == typeof A2[iterator] ? e2.push(new StaticIterator(A2[iterator]())) : e2.push(new ZipBufferIterator(this.destination, this, A2));
        }, e.prototype._complete = function() {
          var A2 = this.iterators, e2 = A2.length;
          if (this.unsubscribe(), 0 !== e2) {
            this.active = e2;
            for (var t = 0; t < e2; t++) {
              var g = A2[t];
              if (g.stillUnsubscribed)
                this.destination.add(g.subscribe());
              else
                this.active--;
            }
          } else
            this.destination.complete();
        }, e.prototype.notifyInactive = function() {
          this.active--, 0 === this.active && this.destination.complete();
        }, e.prototype.checkIterators = function() {
          for (var A2 = this.iterators, e2 = A2.length, t = this.destination, g = 0; g < e2; g++) {
            if ("function" == typeof (i2 = A2[g]).hasValue && !i2.hasValue())
              return;
          }
          var o = false, I = [];
          for (g = 0; g < e2; g++) {
            var i2, r = (i2 = A2[g]).next();
            if (i2.hasCompleted() && (o = true), r.done)
              return void t.complete();
            I.push(r.value);
          }
          this.resultSelector ? this._tryresultSelector(I) : t.next(I), o && t.complete();
        }, e.prototype._tryresultSelector = function(A2) {
          var e2;
          try {
            e2 = this.resultSelector.apply(this, A2);
          } catch (A3) {
            return void this.destination.error(A3);
          }
          this.destination.next(e2);
        }, e;
      }(Subscriber), StaticIterator = function() {
        function A(A2) {
          this.iterator = A2, this.nextResult = A2.next();
        }
        return A.prototype.hasValue = function() {
          return true;
        }, A.prototype.next = function() {
          var A2 = this.nextResult;
          return this.nextResult = this.iterator.next(), A2;
        }, A.prototype.hasCompleted = function() {
          var A2 = this.nextResult;
          return Boolean(A2 && A2.done);
        }, A;
      }(), StaticArrayIterator = function() {
        function A(A2) {
          this.array = A2, this.index = 0, this.length = 0, this.length = A2.length;
        }
        return A.prototype[iterator] = function() {
          return this;
        }, A.prototype.next = function(A2) {
          var e = this.index++, t = this.array;
          return e < this.length ? { value: t[e], done: false } : { value: null, done: true };
        }, A.prototype.hasValue = function() {
          return this.array.length > this.index;
        }, A.prototype.hasCompleted = function() {
          return this.array.length === this.index;
        }, A;
      }(), ZipBufferIterator = function(A) {
        function e(e2, t, g) {
          var o = A.call(this, e2) || this;
          return o.parent = t, o.observable = g, o.stillUnsubscribed = true, o.buffer = [], o.isComplete = false, o;
        }
        return __extends$3(e, A), e.prototype[iterator] = function() {
          return this;
        }, e.prototype.next = function() {
          var A2 = this.buffer;
          return 0 === A2.length && this.isComplete ? { value: null, done: true } : { value: A2.shift(), done: false };
        }, e.prototype.hasValue = function() {
          return this.buffer.length > 0;
        }, e.prototype.hasCompleted = function() {
          return 0 === this.buffer.length && this.isComplete;
        }, e.prototype.notifyComplete = function() {
          this.buffer.length > 0 ? (this.isComplete = true, this.parent.notifyInactive()) : this.destination.complete();
        }, e.prototype.notifyNext = function(A2) {
          this.buffer.push(A2), this.parent.checkIterators();
        }, e.prototype.subscribe = function() {
          return innerSubscribe(this.observable, new SimpleInnerSubscriber(this));
        }, e;
      }(SimpleOuterSubscriber), umd = { exports: {} };
      !function(A, e) {
        "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, function(A2) {
          Object.defineProperty(A2, "__esModule", { value: true }), A2.default = void 0;
          var e2 = null;
          try {
            e2 = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
          } catch (A3) {
          }
          function t(A3, e3, t2) {
            this.low = 0 | A3, this.high = 0 | e3, this.unsigned = !!t2;
          }
          function g(A3) {
            return true === (A3 && A3.__isLong__);
          }
          function o(A3) {
            var e3 = Math.clz32(A3 & -A3);
            return A3 ? 31 - e3 : e3;
          }
          t.prototype.__isLong__, Object.defineProperty(t.prototype, "__isLong__", { value: true }), t.isLong = g;
          var I = {}, i2 = {};
          function r(A3, e3) {
            var t2, g2, o2;
            return e3 ? (o2 = 0 <= (A3 >>>= 0) && A3 < 256) && (g2 = i2[A3]) ? g2 : (t2 = C(A3, 0, true), o2 && (i2[A3] = t2), t2) : (o2 = -128 <= (A3 |= 0) && A3 < 128) && (g2 = I[A3]) ? g2 : (t2 = C(A3, A3 < 0 ? -1 : 0, false), o2 && (I[A3] = t2), t2);
          }
          function n(A3, e3) {
            if (isNaN(A3))
              return e3 ? d : u;
            if (e3) {
              if (A3 < 0)
                return d;
              if (A3 >= c)
                return w;
            } else {
              if (A3 <= -l)
                return _;
              if (A3 + 1 >= l)
                return R2;
            }
            return A3 < 0 ? n(-A3, e3).neg() : C(A3 % Q | 0, A3 / Q | 0, e3);
          }
          function C(A3, e3, g2) {
            return new t(A3, e3, g2);
          }
          t.fromInt = r, t.fromNumber = n, t.fromBits = C;
          var E = Math.pow;
          function s(A3, e3, t2) {
            if (0 === A3.length)
              throw Error("empty string");
            if ("number" == typeof e3 ? (t2 = e3, e3 = false) : e3 = !!e3, "NaN" === A3 || "Infinity" === A3 || "+Infinity" === A3 || "-Infinity" === A3)
              return e3 ? d : u;
            if ((t2 = t2 || 10) < 2 || 36 < t2)
              throw RangeError("radix");
            var g2;
            if ((g2 = A3.indexOf("-")) > 0)
              throw Error("interior hyphen");
            if (0 === g2)
              return s(A3.substring(1), e3, t2).neg();
            for (var o2 = n(E(t2, 8)), I2 = u, i3 = 0; i3 < A3.length; i3 += 8) {
              var r2 = Math.min(8, A3.length - i3), C2 = parseInt(A3.substring(i3, i3 + r2), t2);
              if (r2 < 8) {
                var B2 = n(E(t2, r2));
                I2 = I2.mul(B2).add(n(C2));
              } else
                I2 = (I2 = I2.mul(o2)).add(n(C2));
            }
            return I2.unsigned = e3, I2;
          }
          function B(A3, e3) {
            return "number" == typeof A3 ? n(A3, e3) : "string" == typeof A3 ? s(A3, e3) : C(A3.low, A3.high, "boolean" == typeof e3 ? e3 : A3.unsigned);
          }
          t.fromString = s, t.fromValue = B;
          var a = 65536, Q = a * a, c = Q * Q, l = c / 2, h = r(1 << 24), u = r(0);
          t.ZERO = u;
          var d = r(0, true);
          t.UZERO = d;
          var D = r(1);
          t.ONE = D;
          var y = r(1, true);
          t.UONE = y;
          var p2 = r(-1);
          t.NEG_ONE = p2;
          var R2 = C(-1, 2147483647, false);
          t.MAX_VALUE = R2;
          var w = C(-1, -1, true);
          t.MAX_UNSIGNED_VALUE = w;
          var _ = C(0, -2147483648, false);
          t.MIN_VALUE = _;
          var S = t.prototype;
          S.toInt = function() {
            return this.unsigned ? this.low >>> 0 : this.low;
          }, S.toNumber = function() {
            return this.unsigned ? (this.high >>> 0) * Q + (this.low >>> 0) : this.high * Q + (this.low >>> 0);
          }, S.toString = function(A3) {
            if ((A3 = A3 || 10) < 2 || 36 < A3)
              throw RangeError("radix");
            if (this.isZero())
              return "0";
            if (this.isNegative()) {
              if (this.eq(_)) {
                var e3 = n(A3), t2 = this.div(e3), g2 = t2.mul(e3).sub(this);
                return t2.toString(A3) + g2.toInt().toString(A3);
              }
              return "-" + this.neg().toString(A3);
            }
            for (var o2 = n(E(A3, 6), this.unsigned), I2 = this, i3 = ""; ; ) {
              var r2 = I2.div(o2), C2 = (I2.sub(r2.mul(o2)).toInt() >>> 0).toString(A3);
              if ((I2 = r2).isZero())
                return C2 + i3;
              for (; C2.length < 6; )
                C2 = "0" + C2;
              i3 = "" + C2 + i3;
            }
          }, S.getHighBits = function() {
            return this.high;
          }, S.getHighBitsUnsigned = function() {
            return this.high >>> 0;
          }, S.getLowBits = function() {
            return this.low;
          }, S.getLowBitsUnsigned = function() {
            return this.low >>> 0;
          }, S.getNumBitsAbs = function() {
            if (this.isNegative())
              return this.eq(_) ? 64 : this.neg().getNumBitsAbs();
            for (var A3 = 0 != this.high ? this.high : this.low, e3 = 31; e3 > 0 && !(A3 & 1 << e3); e3--)
              ;
            return 0 != this.high ? e3 + 33 : e3 + 1;
          }, S.isSafeInteger = function() {
            var A3 = this.high >> 21;
            return !A3 || !this.unsigned && -1 === A3 && !(0 === this.low && -2097152 === this.high);
          }, S.isZero = function() {
            return 0 === this.high && 0 === this.low;
          }, S.eqz = S.isZero, S.isNegative = function() {
            return !this.unsigned && this.high < 0;
          }, S.isPositive = function() {
            return this.unsigned || this.high >= 0;
          }, S.isOdd = function() {
            return !(1 & ~this.low);
          }, S.isEven = function() {
            return !(1 & this.low);
          }, S.equals = function(A3) {
            return g(A3) || (A3 = B(A3)), (this.unsigned === A3.unsigned || this.high >>> 31 != 1 || A3.high >>> 31 != 1) && this.high === A3.high && this.low === A3.low;
          }, S.eq = S.equals, S.notEquals = function(A3) {
            return !this.eq(A3);
          }, S.neq = S.notEquals, S.ne = S.notEquals, S.lessThan = function(A3) {
            return this.comp(A3) < 0;
          }, S.lt = S.lessThan, S.lessThanOrEqual = function(A3) {
            return this.comp(A3) <= 0;
          }, S.lte = S.lessThanOrEqual, S.le = S.lessThanOrEqual, S.greaterThan = function(A3) {
            return this.comp(A3) > 0;
          }, S.gt = S.greaterThan, S.greaterThanOrEqual = function(A3) {
            return this.comp(A3) >= 0;
          }, S.gte = S.greaterThanOrEqual, S.ge = S.greaterThanOrEqual, S.compare = function(A3) {
            if (g(A3) || (A3 = B(A3)), this.eq(A3))
              return 0;
            var e3 = this.isNegative(), t2 = A3.isNegative();
            return e3 && !t2 ? -1 : !e3 && t2 ? 1 : this.unsigned ? A3.high >>> 0 > this.high >>> 0 || A3.high === this.high && A3.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(A3).isNegative() ? -1 : 1;
          }, S.comp = S.compare, S.negate = function() {
            return !this.unsigned && this.eq(_) ? _ : this.not().add(D);
          }, S.neg = S.negate, S.add = function(A3) {
            g(A3) || (A3 = B(A3));
            var e3 = this.high >>> 16, t2 = 65535 & this.high, o2 = this.low >>> 16, I2 = 65535 & this.low, i3 = A3.high >>> 16, r2 = 65535 & A3.high, n2 = A3.low >>> 16, E2 = 0, s2 = 0, a2 = 0, Q2 = 0;
            return a2 += (Q2 += I2 + (65535 & A3.low)) >>> 16, s2 += (a2 += o2 + n2) >>> 16, E2 += (s2 += t2 + r2) >>> 16, E2 += e3 + i3, C((a2 &= 65535) << 16 | (Q2 &= 65535), (E2 &= 65535) << 16 | (s2 &= 65535), this.unsigned);
          }, S.subtract = function(A3) {
            return g(A3) || (A3 = B(A3)), this.add(A3.neg());
          }, S.sub = S.subtract, S.multiply = function(A3) {
            if (this.isZero())
              return this;
            if (g(A3) || (A3 = B(A3)), e2)
              return C(e2.mul(this.low, this.high, A3.low, A3.high), e2.get_high(), this.unsigned);
            if (A3.isZero())
              return this.unsigned ? d : u;
            if (this.eq(_))
              return A3.isOdd() ? _ : u;
            if (A3.eq(_))
              return this.isOdd() ? _ : u;
            if (this.isNegative())
              return A3.isNegative() ? this.neg().mul(A3.neg()) : this.neg().mul(A3).neg();
            if (A3.isNegative())
              return this.mul(A3.neg()).neg();
            if (this.lt(h) && A3.lt(h))
              return n(this.toNumber() * A3.toNumber(), this.unsigned);
            var t2 = this.high >>> 16, o2 = 65535 & this.high, I2 = this.low >>> 16, i3 = 65535 & this.low, r2 = A3.high >>> 16, E2 = 65535 & A3.high, s2 = A3.low >>> 16, a2 = 65535 & A3.low, Q2 = 0, c2 = 0, l2 = 0, D2 = 0;
            return l2 += (D2 += i3 * a2) >>> 16, c2 += (l2 += I2 * a2) >>> 16, l2 &= 65535, c2 += (l2 += i3 * s2) >>> 16, Q2 += (c2 += o2 * a2) >>> 16, c2 &= 65535, Q2 += (c2 += I2 * s2) >>> 16, c2 &= 65535, Q2 += (c2 += i3 * E2) >>> 16, Q2 += t2 * a2 + o2 * s2 + I2 * E2 + i3 * r2, C((l2 &= 65535) << 16 | (D2 &= 65535), (Q2 &= 65535) << 16 | (c2 &= 65535), this.unsigned);
          }, S.mul = S.multiply, S.divide = function(A3) {
            if (g(A3) || (A3 = B(A3)), A3.isZero())
              throw Error("division by zero");
            var t2, o2, I2;
            if (e2)
              return this.unsigned || -2147483648 !== this.high || -1 !== A3.low || -1 !== A3.high ? C((this.unsigned ? e2.div_u : e2.div_s)(this.low, this.high, A3.low, A3.high), e2.get_high(), this.unsigned) : this;
            if (this.isZero())
              return this.unsigned ? d : u;
            if (this.unsigned) {
              if (A3.unsigned || (A3 = A3.toUnsigned()), A3.gt(this))
                return d;
              if (A3.gt(this.shru(1)))
                return y;
              I2 = d;
            } else {
              if (this.eq(_))
                return A3.eq(D) || A3.eq(p2) ? _ : A3.eq(_) ? D : (t2 = this.shr(1).div(A3).shl(1)).eq(u) ? A3.isNegative() ? D : p2 : (o2 = this.sub(A3.mul(t2)), I2 = t2.add(o2.div(A3)));
              if (A3.eq(_))
                return this.unsigned ? d : u;
              if (this.isNegative())
                return A3.isNegative() ? this.neg().div(A3.neg()) : this.neg().div(A3).neg();
              if (A3.isNegative())
                return this.div(A3.neg()).neg();
              I2 = u;
            }
            for (o2 = this; o2.gte(A3); ) {
              t2 = Math.max(1, Math.floor(o2.toNumber() / A3.toNumber()));
              for (var i3 = Math.ceil(Math.log(t2) / Math.LN2), r2 = i3 <= 48 ? 1 : E(2, i3 - 48), s2 = n(t2), a2 = s2.mul(A3); a2.isNegative() || a2.gt(o2); )
                a2 = (s2 = n(t2 -= r2, this.unsigned)).mul(A3);
              s2.isZero() && (s2 = D), I2 = I2.add(s2), o2 = o2.sub(a2);
            }
            return I2;
          }, S.div = S.divide, S.modulo = function(A3) {
            return g(A3) || (A3 = B(A3)), e2 ? C((this.unsigned ? e2.rem_u : e2.rem_s)(this.low, this.high, A3.low, A3.high), e2.get_high(), this.unsigned) : this.sub(this.div(A3).mul(A3));
          }, S.mod = S.modulo, S.rem = S.modulo, S.not = function() {
            return C(~this.low, ~this.high, this.unsigned);
          }, S.countLeadingZeros = function() {
            return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
          }, S.clz = S.countLeadingZeros, S.countTrailingZeros = function() {
            return this.low ? o(this.low) : o(this.high) + 32;
          }, S.ctz = S.countTrailingZeros, S.and = function(A3) {
            return g(A3) || (A3 = B(A3)), C(this.low & A3.low, this.high & A3.high, this.unsigned);
          }, S.or = function(A3) {
            return g(A3) || (A3 = B(A3)), C(this.low | A3.low, this.high | A3.high, this.unsigned);
          }, S.xor = function(A3) {
            return g(A3) || (A3 = B(A3)), C(this.low ^ A3.low, this.high ^ A3.high, this.unsigned);
          }, S.shiftLeft = function(A3) {
            return g(A3) && (A3 = A3.toInt()), 0 == (A3 &= 63) ? this : A3 < 32 ? C(this.low << A3, this.high << A3 | this.low >>> 32 - A3, this.unsigned) : C(0, this.low << A3 - 32, this.unsigned);
          }, S.shl = S.shiftLeft, S.shiftRight = function(A3) {
            return g(A3) && (A3 = A3.toInt()), 0 == (A3 &= 63) ? this : A3 < 32 ? C(this.low >>> A3 | this.high << 32 - A3, this.high >> A3, this.unsigned) : C(this.high >> A3 - 32, this.high >= 0 ? 0 : -1, this.unsigned);
          }, S.shr = S.shiftRight, S.shiftRightUnsigned = function(A3) {
            return g(A3) && (A3 = A3.toInt()), 0 == (A3 &= 63) ? this : A3 < 32 ? C(this.low >>> A3 | this.high << 32 - A3, this.high >>> A3, this.unsigned) : C(32 === A3 ? this.high : this.high >>> A3 - 32, 0, this.unsigned);
          }, S.shru = S.shiftRightUnsigned, S.shr_u = S.shiftRightUnsigned, S.rotateLeft = function(A3) {
            var e3;
            return g(A3) && (A3 = A3.toInt()), 0 == (A3 &= 63) ? this : 32 === A3 ? C(this.high, this.low, this.unsigned) : A3 < 32 ? (e3 = 32 - A3, C(this.low << A3 | this.high >>> e3, this.high << A3 | this.low >>> e3, this.unsigned)) : (e3 = 32 - (A3 -= 32), C(this.high << A3 | this.low >>> e3, this.low << A3 | this.high >>> e3, this.unsigned));
          }, S.rotl = S.rotateLeft, S.rotateRight = function(A3) {
            var e3;
            return g(A3) && (A3 = A3.toInt()), 0 == (A3 &= 63) ? this : 32 === A3 ? C(this.high, this.low, this.unsigned) : A3 < 32 ? (e3 = 32 - A3, C(this.high << e3 | this.low >>> A3, this.low << e3 | this.high >>> A3, this.unsigned)) : (e3 = 32 - (A3 -= 32), C(this.low << e3 | this.high >>> A3, this.high << e3 | this.low >>> A3, this.unsigned));
          }, S.rotr = S.rotateRight, S.toSigned = function() {
            return this.unsigned ? C(this.low, this.high, false) : this;
          }, S.toUnsigned = function() {
            return this.unsigned ? this : C(this.low, this.high, true);
          }, S.toBytes = function(A3) {
            return A3 ? this.toBytesLE() : this.toBytesBE();
          }, S.toBytesLE = function() {
            var A3 = this.high, e3 = this.low;
            return [255 & e3, e3 >>> 8 & 255, e3 >>> 16 & 255, e3 >>> 24, 255 & A3, A3 >>> 8 & 255, A3 >>> 16 & 255, A3 >>> 24];
          }, S.toBytesBE = function() {
            var A3 = this.high, e3 = this.low;
            return [A3 >>> 24, A3 >>> 16 & 255, A3 >>> 8 & 255, 255 & A3, e3 >>> 24, e3 >>> 16 & 255, e3 >>> 8 & 255, 255 & e3];
          }, t.fromBytes = function(A3, e3, g2) {
            return g2 ? t.fromBytesLE(A3, e3) : t.fromBytesBE(A3, e3);
          }, t.fromBytesLE = function(A3, e3) {
            return new t(A3[0] | A3[1] << 8 | A3[2] << 16 | A3[3] << 24, A3[4] | A3[5] << 8 | A3[6] << 16 | A3[7] << 24, e3);
          }, t.fromBytesBE = function(A3, e3) {
            return new t(A3[4] << 24 | A3[5] << 16 | A3[6] << 8 | A3[7], A3[0] << 24 | A3[1] << 16 | A3[2] << 8 | A3[3], e3);
          }, "function" == typeof BigInt && (t.fromBigInt = function(A3, e3) {
            return C(Number(BigInt.asIntN(32, A3)), Number(BigInt.asIntN(32, A3 >> BigInt(32))), e3);
          }, t.fromValue = function(A3, e3) {
            return "bigint" == typeof A3 ? t.fromBigInt(A3, e3) : B(A3, e3);
          }, S.toBigInt = function() {
            var A3 = BigInt(this.low >>> 0);
            return BigInt(this.unsigned ? this.high >>> 0 : this.high) << BigInt(32) | A3;
          }), A2.default = t;
        }(e), A.exports = function(A2) {
          return A2.default || A2;
        }(e);
      }(umd, umd.exports);
      var umdExports = umd.exports, Long$1 = getDefaultExportFromCjs(umdExports);
      const FUSION = false, VERSION = "2.2.3", BUILD = "v2.2.3-0-g1291e257-dirty", isDev = false, WEB_PLATFORM_TYPE = 7, VERSION_NO = 10, BASE_VERSION = Number("100"), SUBVERSION = BASE_VERSION, LOG_PING_PONG = false, LOG_SYNC_PING_PONG = false;
      let isBusy = false, loginAbortController = new AbortController();
      function changeBusyStatus(A) {
        (isBusy || A) && (loginAbortController.abort(), A && (loginAbortController = new AbortController()), isBusy = A);
      }
      const OperationName = { initRTM: "initRTM", login: "login", logout: "logout", renewToken: "renewToken", updateConfig: "updateConfig", publish: "publish", subscribe: "subscribe", unsubscribe: "unsubscribe", createStreamChannel: "createStreamChannel", leave: "leave", joinTopic: "joinTopic", join: "join", publishTopicMessage: "publishTopicMessage", leaveTopic: "leaveTopic", subscribeTopic: "subscribeTopic", unsubscribeTopic: "unsubscribeTopic", getSubscribedUserList: "getSubscribedUserList", setChannelMetadata: "setChannelMetadata", getChannelMetadata: "getChannelMetadata", removeChannelMetadata: "removeChannelMetadata", updateChannelMetadata: "updateChannelMetadata", setUserMetadata: "setUserMetadata", getUserMetadata: "getUserMetadata", removeUserMetadata: "removeUserMetadata", updateUserMetadata: "updateUserMetadata", subscribeUserMetadata: "subscribeUserMetadata", unsubscribeUserMetadata: "unsubscribeUserMetadata", setLock: "setLock", removeLock: "removeLock", acquireLock: "acquireLock", releaseLock: "releaseLock", revokeLock: "revokeLock", getLock: "getLock", rtm: "rtm", presenceSetState: "presenceSetState", whereNow: "whereNow", getUserChannels: "getUserChannels", whoNow: "whoNow", getOnlineUsers: "getOnlineUsers", presenceGetState: "presenceGetState", presenceRemoveState: "presenceRemoveState", storage: "storage", getMessages: "getMessages" }, AP_CONCURRENT_REQ_NUM = 3, MIN_HEARTBEAT_INTERVAL = 5e3, MAX_HEARTBEAT_INTERVAL = 18e5, SHAKEHAND_TIMEOUT = 15e3, CONFIGURABLE_KEY_RTM_LINK_KEEP_ALIVE_TIMEOUT = 1e4, CONFIGURABLE_KEY_RTM_HEARTBEAT_INTERVAL = MIN_HEARTBEAT_INTERVAL, SOCKET_RETRY_INTERVAL = 3e3, LINK_INTERVALS = [2, 4, 8, 16, 32, 32], SUSPENDED_TIME_INTERVAL = 30, LOGIN_RESP_TIMEOUT = 5e3, LOGIN_QPS_LIMIT = 2, MESSAGE_MIN_COMPRESSION_LEN = 128, MESSAGE_SEND_TIMEOUT = 1e4, COMMON_REQUEST_TIMEOUT = 1e4, P2P_MESSAGE_SEND_TIMEOUT = 13e3, DIALOGUE_EXPIRE_TIMEOUT = 1e4, LRU_MAX_ITEMS = 1e4, MESSAGE_RETRY_TIMEOUT = 6e3, TEXT_MESSAGE_MAX_TEXT_BYTES = 32768, ONLINE_MESSAGE_DEDUP_DELAY = 750, OFFLINE_MESSAGE_DEDUP_DELAY = 1500, MSG_DEDUP_MAX_LEN = 200, PUBLISH_MESSAGE_SIZE = 32768, TOPIC_MESSAGE_SIZE = 1024, CUSTOM_TYPE_SIZE = 32, K_P2P_MESSAGE_PREFIX = "*p*", LOGOUT_SOCKET_CLOSE_TIMEOUT = 5e3, LOG_UPLOAD_MAX_ITEMS = 1e3, MAX_JOINED_CHANNELS = 50, SUB_STREAM_CHANNEL_LIMITATION = 10, K_STREAM_CHANNEL_PREFIX = "*s*", MAX_SUBSCRIPTION_USER = 50, MAX_METADATA_COUNT = 32, RTM_METADATA_MAX_LENGTH = 16384, RTM_METADATA_KEY_MAX_LENGTH = 32, RTM_METADATA_VALUE_MAX_LENGTH = 16384, LOCK_DEFAULT_TTL = 10, MAX_LOCK_TTL = 300, LAST_PONG_RECEIVED_TS_FIELD_NUMBER = 4e3, IV_LENGTH = 12, TAG_LENGTH = 16, KEY_ITERATIONS_COUNT = 1e3, ROUNDUP_BIT_SIZE = 4, SALT_LENGTH = 32, JOIN_TOPIC_LIMITATION = 8, SUB_TOPIC_LIMITATION = 50, SUB_TOPIC_USER_LIMITATION = 64, TOPIC_NAME_SIZE = 16, DEFAULT_RPC_TIMEOUT_TIME = 5e3, PRESENCE_DATABASE = "vendor-state", MAX_STATE_COUNT = 32, MAX_STATE_KEY_SIZE = 32, MAX_STATE_VALUE_SIZE = 16384, K_PRESENCE_MAX_CHANNEL_COUNT = 100, K_USER_COLLECTION = "/Users", K_PRESENCE_PREFIX = "/Vendors/", K_GLOBAL_ONLINE = "/Presence", K_CHANNEL_ONLINE = "/ChannelPresence/", K_GLOBAL_PRESENCE_COLLECTION = "_keepalive_", K_PRESENCE_EXPIRED = "_expired", K_SYNC_INTERNAL_KEY_PREFIX = "_", K_INTERVAL_THRESHOLD_MAX = 128, K_INTERVAL_THRESHOLD_MIN = 8, K_DEFAULT_INTERVAL_THRESHOLD = 50, K_PRESENCE_INTERVAL_MAX = 300, K_PRESENCE_INTERVAL_MIN = 10, K_PRESENCE_INTERVAL_DEFAULT = 30, K_PRESENCE_TIMEOUT_MAX = 300, K_PRESENCE_TIMEOUT_MIN = 5, K_PRESENCE_TIMEOUT_DEFAULT = 300, K_DEBOUNCE_DEFAULT = 2, CREATE_COLL_INTERVALS = [10, 20, 30], MONITOR_INTERVAL = 1e3, PRESENCE_BACKOFF_EVENT_INTERVAL = 6e4, APP_ID_LENGTH = 32, VERSION_LENGTH = 3, API_QPS_SECOND = 1e3, JOIN_TIMEOUT = 15e3, RECONNECT_STREAM_CHANNEL_TIMEOUT = 12e5, GET_MESSAGE_TIME_LIMIT = 864e5, GET_MESSAGE_MAX_COUNT = 100, JOIN_LOCK_FLAG = 1, JOIN_STORAGE_FLAG = 2, JOIN_PRESENCE_FLAG = 4, JOIN_MESSAGE_FLAG = 8, JOIN_BE_QUIET_FLAG = 16;
      let SyncEstablishState = function(A) {
        return A.DISCONNECTED = "DISCONNECTED", A.CONNECTING = "CONNECTING", A.CONNECTED = "CONNECTED", A.SYNCINIT_0 = "SYNCINIT_0", A.SYNCINIT_1 = "SYNCINIT_1", A;
      }({});
      const SYNC_RPC_START = "Sync Request Start", SYNC_RPC_END = "Sync Request End", SyncDisconnectedReason = { REQUEST_FIRST_SYNC_PHYSICAL_CONNECTION_ERROR: "request first sync physical connection error", REG_SOCKET_RECONNECT: "reg socket reconnect", SYNC_FIN: "sync fin", CONNECT_SYNC_DATABASE_ERROR: "connect sync database error", RETRY_SYNC_PHYSICAL_CONNECTION: "retry sync physical connection" }, ACCESS_POINT_CODE = 101, UNI_LBS_CODE = 201, ApResErrorMessage = { INVALID_APP_ID: "Illegal App ID", APP_ID_NO_ACTIVATED: "The vendor is not activated", DYNAMIC_KEY_NOT_ENABLED: "The vendor did not enable the dynamic key, but uses the dynamic key", NO_AUTHORIZED: "Signature verification failed", DYNAMIC_ENABLED_BUT_STATIC_KEY: "The vendor enabled the dynamic key, but uses the static key", INVALID_USER_ID: "The user ID to login does not match the token", INVALID_TOKEN_UID: "UID in the security key(token) is not valid", TOKEN_TIMEOUT: "Dynamic key expired", TOKEN_EXPIRED: "The token has expired", CANNOT_MEET_AREA_DEMAND: "Cannot allocate to meet the requirements of the given area limit", INIT_APPID_MISMATCH: "The appid in the init request does not match the appid in the token", FORBIDDEN_REGION: "Forbidden to access the request in this area", NO_ACTIVE_PRODUCT_STATUS: "NOT_ENABLE_RTM or service has been stopped." }, ApResErrorCode = { 5: "INVALID_APP_ID", 7: "INVALID_USER_ID", 9: "NO_AUTHORIZED", 10: "TOKEN_TIMEOUT", 11: "APP_ID_NO_ACTIVATED", 12: "INVALID_TOKEN_UID", 13: "TOKEN_EXPIRED", 14: "DYNAMIC_KEY_NOT_ENABLED", 15: "DYNAMIC_ENABLED_BUT_STATIC_KEY", 18: "FORBIDDEN_REGION", 19: "CANNOT_MEET_AREA_DEMAND", 23: "INIT_APPID_MISMATCH", 26: "NO_ACTIVE_PRODUCT_STATUS" }, UniLbsNonRetryableErrorCodes = [100, 101, 102, 103, 104], AP_DETAIL_KEY_APP_ID = 25, AP_DETAIL_KEY_BUSINESS_TYPE = 26, AP_DOMAINS_NEW = ["web-1.ap.sd-rtn.com", "web-2.ap.sd-rtn.com"], AP_DOMAINS_IO = ["ap-web-1.agora.io", "ap-web-2.agora.io"], AP_BACKUP_DOMAINS_NEW = ["web-3.ap.sd-rtn.com", "web-4.ap.sd-rtn.com"], AP_BACKUP_DOMAINS_IO = ["ap-web-3.agora.io", "ap-web-4.agora.io"];
      let RTMErrorCode = function(A) {
        return A[A.RTM_ERROR_OK = 0] = "RTM_ERROR_OK", A[A.RTM_ERROR_NOT_INITIALIZED = -10001] = "RTM_ERROR_NOT_INITIALIZED", A[A.RTM_ERROR_NOT_LOGIN = -10002] = "RTM_ERROR_NOT_LOGIN", A[A.RTM_ERROR_INVALID_APP_ID = -10003] = "RTM_ERROR_INVALID_APP_ID", A[A.RTM_ERROR_INVALID_EVENT_HANDLER = -10004] = "RTM_ERROR_INVALID_EVENT_HANDLER", A[A.RTM_ERROR_INVALID_TOKEN = -10005] = "RTM_ERROR_INVALID_TOKEN", A[A.RTM_ERROR_INVALID_USER_ID = -10006] = "RTM_ERROR_INVALID_USER_ID", A[A.RTM_ERROR_INIT_SERVICE_FAILED = -10007] = "RTM_ERROR_INIT_SERVICE_FAILED", A[A.RTM_ERROR_INVALID_CHANNEL_NAME = -10008] = "RTM_ERROR_INVALID_CHANNEL_NAME", A[A.RTM_ERROR_TOKEN_EXPIRED = -10009] = "RTM_ERROR_TOKEN_EXPIRED", A[A.RTM_ERROR_LOGIN_NO_SERVER_RESOURCES = -10010] = "RTM_ERROR_LOGIN_NO_SERVER_RESOURCES", A[A.RTM_ERROR_LOGIN_TIMEOUT = -10011] = "RTM_ERROR_LOGIN_TIMEOUT", A[A.RTM_ERROR_LOGIN_REJECTED = -10012] = "RTM_ERROR_LOGIN_REJECTED", A[A.RTM_ERROR_LOGIN_ABORTED = -10013] = "RTM_ERROR_LOGIN_ABORTED", A[A.RTM_ERROR_INVALID_PARAMETER = -10014] = "RTM_ERROR_INVALID_PARAMETER", A[A.RTM_ERROR_LOGIN_NOT_AUTHORIZED = -10015] = "RTM_ERROR_LOGIN_NOT_AUTHORIZED", A[A.RTM_ERROR_INCONSISTENT_APPID = -10016] = "RTM_ERROR_INCONSISTENT_APPID", A[A.RTM_ERROR_DUPLICATE_OPERATION = -10017] = "RTM_ERROR_DUPLICATE_OPERATION", A[A.RTM_ERROR_INSTANCE_ALREADY_RELEASED = -10018] = "RTM_ERROR_INSTANCE_ALREADY_RELEASED", A[A.RTM_ERROR_INVALID_CHANNEL_TYPE = -10019] = "RTM_ERROR_INVALID_CHANNEL_TYPE", A[A.RTM_ERROR_INVALID_ENCRYPTION_PARAMETER = -10020] = "RTM_ERROR_INVALID_ENCRYPTION_PARAMETER", A[A.RTM_ERROR_OPERATION_RATE_EXCEED_LIMITATION = -10021] = "RTM_ERROR_OPERATION_RATE_EXCEED_LIMITATION", A[A.RTM_ERROR_SERVICE_NOT_SUPPORTED = -10022] = "RTM_ERROR_SERVICE_NOT_SUPPORTED", A[A.RTM_ERROR_LOGIN_CANCELED = -10023] = "RTM_ERROR_LOGIN_CANCELED", A[A.RTM_ERROR_INVALID_PRIVATE_CONFIG = -10024] = "RTM_ERROR_INVALID_PRIVATE_CONFIG", A[A.RTM_ERROR_NOT_CONNECTED = -10025] = "RTM_ERROR_NOT_CONNECTED", A[A.RTM_ERROR_RENEW_TOKEN_TIMEOUT = -10026] = "RTM_ERROR_RENEW_TOKEN_TIMEOUT", A[A.RTM_ERROR_CHANNEL_NOT_JOINED = -11001] = "RTM_ERROR_CHANNEL_NOT_JOINED", A[A.RTM_ERROR_CHANNEL_NOT_SUBSCRIBED = -11002] = "RTM_ERROR_CHANNEL_NOT_SUBSCRIBED", A[A.RTM_ERROR_CHANNEL_EXCEED_TOPIC_USER_LIMITATION = -11003] = "RTM_ERROR_CHANNEL_EXCEED_TOPIC_USER_LIMITATION", A[A.RTM_ERROR_CHANNEL_IN_REUSE = -11004] = "RTM_ERROR_CHANNEL_IN_REUSE", A[A.RTM_ERROR_CHANNEL_INSTANCE_EXCEED_LIMITATION = -11005] = "RTM_ERROR_CHANNEL_INSTANCE_EXCEED_LIMITATION", A[A.RTM_ERROR_CHANNEL_IN_ERROR_STATE = -11006] = "RTM_ERROR_CHANNEL_IN_ERROR_STATE", A[A.RTM_ERROR_CHANNEL_JOIN_FAILED = -11007] = "RTM_ERROR_CHANNEL_JOIN_FAILED", A[A.RTM_ERROR_CHANNEL_INVALID_TOPIC_NAME = -11008] = "RTM_ERROR_CHANNEL_INVALID_TOPIC_NAME", A[A.RTM_ERROR_CHANNEL_INVALID_MESSAGE = -11009] = "RTM_ERROR_CHANNEL_INVALID_MESSAGE", A[A.RTM_ERROR_CHANNEL_MESSAGE_LENGTH_EXCEED_LIMITATION = -11010] = "RTM_ERROR_CHANNEL_MESSAGE_LENGTH_EXCEED_LIMITATION", A[A.RTM_ERROR_CHANNEL_INVALID_USER_LIST = -11011] = "RTM_ERROR_CHANNEL_INVALID_USER_LIST", A[A.RTM_ERROR_CHANNEL_NOT_AVAILABLE = -11012] = "RTM_ERROR_CHANNEL_NOT_AVAILABLE", A[A.RTM_ERROR_CHANNEL_TOPIC_NOT_SUBSCRIBED = -11013] = "RTM_ERROR_CHANNEL_TOPIC_NOT_SUBSCRIBED", A[A.RTM_ERROR_CHANNEL_EXCEED_TOPIC_LIMITATION = -11014] = "RTM_ERROR_CHANNEL_EXCEED_TOPIC_LIMITATION", A[A.RTM_ERROR_CHANNEL_JOIN_TOPIC_FAILED = -11015] = "RTM_ERROR_CHANNEL_JOIN_TOPIC_FAILED", A[A.RTM_ERROR_CHANNEL_TOPIC_NOT_JOINED = -11016] = "RTM_ERROR_CHANNEL_TOPIC_NOT_JOINED", A[A.RTM_ERROR_CHANNEL_TOPIC_NOT_EXIST = -11017] = "RTM_ERROR_CHANNEL_TOPIC_NOT_EXIST", A[A.RTM_ERROR_CHANNEL_INVALID_TOPIC_META = -11018] = "RTM_ERROR_CHANNEL_INVALID_TOPIC_META", A[A.RTM_ERROR_CHANNEL_SUBSCRIBE_TIMEOUT = -11019] = "RTM_ERROR_CHANNEL_SUBSCRIBE_TIMEOUT", A[A.RTM_ERROR_CHANNEL_SUBSCRIBE_TOO_FREQUENT = -11020] = "RTM_ERROR_CHANNEL_SUBSCRIBE_TOO_FREQUENT", A[A.RTM_ERROR_CHANNEL_SUBSCRIBE_FAILED = -11021] = "RTM_ERROR_CHANNEL_SUBSCRIBE_FAILED", A[A.RTM_ERROR_CHANNEL_UNSUBSCRIBE_FAILED = -11022] = "RTM_ERROR_CHANNEL_UNSUBSCRIBE_FAILED", A[A.RTM_ERROR_CHANNEL_ENCRYPT_MESSAGE_FAILED = -11023] = "RTM_ERROR_CHANNEL_ENCRYPT_MESSAGE_FAILED", A[A.RTM_ERROR_CHANNEL_PUBLISH_MESSAGE_FAILED = -11024] = "RTM_ERROR_CHANNEL_PUBLISH_MESSAGE_FAILED", A[A.RTM_ERROR_CHANNEL_PUBLISH_MESSAGE_TOO_FREQUENT = -11025] = "RTM_ERROR_CHANNEL_PUBLISH_MESSAGE_TOO_FREQUENT", A[A.RTM_ERROR_CHANNEL_PUBLISH_MESSAGE_TIMEOUT = -11026] = "RTM_ERROR_CHANNEL_PUBLISH_MESSAGE_TIMEOUT", A[A.RTM_ERROR_CHANNEL_NOT_CONNECTED = -11027] = "RTM_ERROR_CHANNEL_NOT_CONNECTED", A[A.RTM_ERROR_CHANNEL_LEAVE_FAILED = -11028] = "RTM_ERROR_CHANNEL_LEAVE_FAILED", A[A.RTM_ERROR_CHANNEL_CUSTOM_TYPE_LENGTH_OVERFLOW = -11029] = "RTM_ERROR_CHANNEL_CUSTOM_TYPE_LENGTH_OVERFLOW", A[A.RTM_ERROR_CHANNEL_INVALID_CUSTOM_TYPE = -11030] = "RTM_ERROR_CHANNEL_INVALID_CUSTOM_TYPE", A[A.RTM_ERROR_CHANNEL_UNSUPPORTED_MESSAGE_TYPE = -11031] = "RTM_ERROR_CHANNEL_UNSUPPORTED_MESSAGE_TYPE", A[A.RTM_ERROR_CHANNEL_PRESENCE_NOT_READY = -11032] = "RTM_ERROR_CHANNEL_PRESENCE_NOT_READY", A[A.RTM_ERROR_CHANNEL_RECEIVER_OFFLINE = -11033] = "RTM_ERROR_CHANNEL_RECEIVER_OFFLINE", A[A.RTM_ERROR_CHANNEL_JOIN_CANCELED = -11034] = "RTM_ERROR_CHANNEL_JOIN_CANCELED", A[A.RTM_ERROR_CHANNEL_RECEIVER_OFFLINE_BUT_STORE_SUCCEEDED = -11035] = "RTM_ERROR_CHANNEL_RECEIVER_OFFLINE_BUT_STORE_SUCCEEDED", A[A.RTM_ERROR_CHANNEL_RECEIVER_OFFLINE_AND_STORE_FAILED = -11036] = "RTM_ERROR_CHANNEL_RECEIVER_OFFLINE_AND_STORE_FAILED", A[A.RTM_ERROR_CHANNEL_MESSAGE_DELIVERED_BUT_STORE_FAILED = -11037] = "RTM_ERROR_CHANNEL_MESSAGE_DELIVERED_BUT_STORE_FAILED", A[A.RTM_ERROR_CHANNEL_SUBSCRIBE_PERMISSION_DENIED = -11038] = "RTM_ERROR_CHANNEL_SUBSCRIBE_PERMISSION_DENIED", A[A.RTM_ERROR_CHANNEL_PUBLISH_PERMISSION_DENIED = -11039] = "RTM_ERROR_CHANNEL_PUBLISH_PERMISSION_DENIED", A[A.RTM_ERROR_STORAGE_OPERATION_FAILED = -12001] = "RTM_ERROR_STORAGE_OPERATION_FAILED", A[A.RTM_ERROR_STORAGE_METADATA_ITEM_EXCEED_LIMITATION = -12002] = "RTM_ERROR_STORAGE_METADATA_ITEM_EXCEED_LIMITATION", A[A.RTM_ERROR_STORAGE_INVALID_METADATA_ITEM = -12003] = "RTM_ERROR_STORAGE_INVALID_METADATA_ITEM", A[A.RTM_ERROR_STORAGE_INVALID_ARGUMENT = -12004] = "RTM_ERROR_STORAGE_INVALID_ARGUMENT", A[A.RTM_ERROR_STORAGE_INVALID_REVISION = -12005] = "RTM_ERROR_STORAGE_INVALID_REVISION", A[A.RTM_ERROR_STORAGE_METADATA_LENGTH_OVERFLOW = -12006] = "RTM_ERROR_STORAGE_METADATA_LENGTH_OVERFLOW", A[A.RTM_ERROR_STORAGE_INVALID_LOCK_NAME = -12007] = "RTM_ERROR_STORAGE_INVALID_LOCK_NAME", A[A.RTM_ERROR_STORAGE_LOCK_NOT_ACQUIRED = -12008] = "RTM_ERROR_STORAGE_LOCK_NOT_ACQUIRED", A[A.RTM_ERROR_STORAGE_INVALID_KEY = -12009] = "RTM_ERROR_STORAGE_INVALID_KEY", A[A.RTM_ERROR_STORAGE_INVALID_VALUE = -12010] = "RTM_ERROR_STORAGE_INVALID_VALUE", A[A.RTM_ERROR_STORAGE_KEY_LENGTH_OVERFLOW = -12011] = "RTM_ERROR_STORAGE_KEY_LENGTH_OVERFLOW", A[A.RTM_ERROR_STORAGE_VALUE_LENGTH_OVERFLOW = -12012] = "RTM_ERROR_STORAGE_VALUE_LENGTH_OVERFLOW", A[A.RTM_ERROR_STORAGE_DUPLICATE_KEY = -12013] = "RTM_ERROR_STORAGE_DUPLICATE_KEY", A[A.RTM_ERROR_STORAGE_OUTDATED_REVISION = -12014] = "RTM_ERROR_STORAGE_OUTDATED_REVISION", A[A.RTM_ERROR_STORAGE_NOT_SUBSCRIBE = -12015] = "RTM_ERROR_STORAGE_NOT_SUBSCRIBE", A[A.RTM_ERROR_STORAGE_INVALID_METADATA_INSTANCE = -12016] = "RTM_ERROR_STORAGE_INVALID_METADATA_INSTANCE", A[A.RTM_ERROR_STORAGE_SUBSCRIBE_USER_EXCEED_LIMITATION = -12017] = "RTM_ERROR_STORAGE_SUBSCRIBE_USER_EXCEED_LIMITATION", A[A.RTM_ERROR_STORAGE_OPERATION_TIMEOUT = -12018] = "RTM_ERROR_STORAGE_OPERATION_TIMEOUT", A[A.RTM_ERROR_STORAGE_NOT_AVAILABLE = -12019] = "RTM_ERROR_STORAGE_NOT_AVAILABLE", A[A.RTM_ERROR_STORAGE_PERMISSION_DENIED = -12020] = "RTM_ERROR_STORAGE_PERMISSION_DENIED", A[A.RTM_ERROR_PRESENCE_NOT_CONNECTED = -13001] = "RTM_ERROR_PRESENCE_NOT_CONNECTED", A[A.RTM_ERROR_PRESENCE_NOT_WRITABLE = -13002] = "RTM_ERROR_PRESENCE_NOT_WRITABLE", A[A.RTM_ERROR_PRESENCE_INVALID_ARGUMENT = -13003] = "RTM_ERROR_PRESENCE_INVALID_ARGUMENT", A[A.RTM_ERROR_PRESENCE_CACHED_TOO_MANY_STATES = -13004] = "RTM_ERROR_PRESENCE_CACHED_TOO_MANY_STATES", A[A.RTM_ERROR_PRESENCE_STATE_COUNT_OVERFLOW = -13005] = "RTM_ERROR_PRESENCE_STATE_COUNT_OVERFLOW", A[A.RTM_ERROR_PRESENCE_INVALID_STATE_KEY = -13006] = "RTM_ERROR_PRESENCE_INVALID_STATE_KEY", A[A.RTM_ERROR_PRESENCE_INVALID_STATE_VALUE = -13007] = "RTM_ERROR_PRESENCE_INVALID_STATE_VALUE", A[A.RTM_ERROR_PRESENCE_STATE_KEY_SIZE_OVERFLOW = -13008] = "RTM_ERROR_PRESENCE_STATE_KEY_SIZE_OVERFLOW", A[A.RTM_ERROR_PRESENCE_STATE_VALUE_SIZE_OVERFLOW = -13009] = "RTM_ERROR_PRESENCE_STATE_VALUE_SIZE_OVERFLOW", A[A.RTM_ERROR_PRESENCE_STATE_DUPLICATE_KEY = -13010] = "RTM_ERROR_PRESENCE_STATE_DUPLICATE_KEY", A[A.RTM_ERROR_PRESENCE_USER_NOT_EXIST = -13011] = "RTM_ERROR_PRESENCE_USER_NOT_EXIST", A[A.RTM_ERROR_PRESENCE_OPERATION_TIMEOUT = -13012] = "RTM_ERROR_PRESENCE_OPERATION_TIMEOUT", A[A.RTM_ERROR_PRESENCE_OPERATION_FAILED = -13013] = "RTM_ERROR_PRESENCE_OPERATION_FAILED", A[A.RTM_ERROR_LOCK_OPERATION_FAILED = -14001] = "RTM_ERROR_LOCK_OPERATION_FAILED", A[A.RTM_ERROR_LOCK_OPERATION_TIMEOUT = -14002] = "RTM_ERROR_LOCK_OPERATION_TIMEOUT", A[A.RTM_ERROR_LOCK_OPERATION_PERFORMING = -14003] = "RTM_ERROR_LOCK_OPERATION_PERFORMING", A[A.RTM_ERROR_LOCK_ALREADY_EXIST = -14004] = "RTM_ERROR_LOCK_ALREADY_EXIST", A[A.RTM_ERROR_LOCK_INVALID_NAME = -14005] = "RTM_ERROR_LOCK_INVALID_NAME", A[A.RTM_ERROR_LOCK_NOT_ACQUIRED = -14006] = "RTM_ERROR_LOCK_NOT_ACQUIRED", A[A.RTM_ERROR_LOCK_ACQUIRE_FAILED = -14007] = "RTM_ERROR_LOCK_ACQUIRE_FAILED", A[A.RTM_ERROR_LOCK_NOT_EXIST = -14008] = "RTM_ERROR_LOCK_NOT_EXIST", A[A.RTM_ERROR_LOCK_NOT_AVAILABLE = -14009] = "RTM_ERROR_LOCK_NOT_AVAILABLE", A[A.RTM_ERROR_LOCK_PERMISSION_DENIED = -14010] = "RTM_ERROR_LOCK_PERMISSION_DENIED", A[A.RTM_ERROR_HISTORY_OPERATION_FAILED = -15001] = "RTM_ERROR_HISTORY_OPERATION_FAILED", A[A.RTM_ERROR_HISTORY_INVALID_TIMESTAMP = -15002] = "RTM_ERROR_HISTORY_INVALID_TIMESTAMP", A[A.RTM_ERROR_HISTORY_OPERATION_TIMEOUT = -15003] = "RTM_ERROR_HISTORY_OPERATION_TIMEOUT", A[A.RTM_ERROR_HISTORY_OPERATION_NOT_PERMITTED = -15004] = "RTM_ERROR_HISTORY_OPERATION_NOT_PERMITTED", A[A.RTM_ERROR_HISTORY_NOT_AVAILABLE = -15005] = "RTM_ERROR_HISTORY_NOT_AVAILABLE", A[A.RTM_ERROR_HISTORY_PERMISSION_DENIED = -15006] = "RTM_ERROR_HISTORY_PERMISSION_DENIED", A;
      }({});
      const detailMsg4InvalidParam = "illegal symbol or too long.", RTMErrorDescription = { [RTMErrorCode.RTM_ERROR_OK]: "No error.", [RTMErrorCode.RTM_ERROR_NOT_INITIALIZED]: "Preform operation without initialize.", [RTMErrorCode.RTM_ERROR_NOT_LOGIN]: "Preform operation without login RTM service.", [RTMErrorCode.RTM_ERROR_INVALID_APP_ID]: "Invalid App id. ".concat(detailMsg4InvalidParam), [RTMErrorCode.RTM_ERROR_INVALID_EVENT_HANDLER]: "Invalid event handler.", [RTMErrorCode.RTM_ERROR_INVALID_TOKEN]: "Invalid token.", [RTMErrorCode.RTM_ERROR_INVALID_USER_ID]: "Invalid user id. ".concat(detailMsg4InvalidParam), [RTMErrorCode.RTM_ERROR_INIT_SERVICE_FAILED]: "Initialize agora service failed.", [RTMErrorCode.RTM_ERROR_INVALID_CHANNEL_NAME]: "Invalid channel name. ".concat(detailMsg4InvalidParam), [RTMErrorCode.RTM_ERROR_TOKEN_EXPIRED]: "Token is expired.", [RTMErrorCode.RTM_ERROR_LOGIN_NO_SERVER_RESOURCES]: "No server resources.", [RTMErrorCode.RTM_ERROR_LOGIN_TIMEOUT]: "Login RTM service timeout.", [RTMErrorCode.RTM_ERROR_LOGIN_REJECTED]: "Login RTM service was rejected due to server error.", [RTMErrorCode.RTM_ERROR_LOGIN_ABORTED]: "Login RTM service was aborted due to unrecoverable error.", [RTMErrorCode.RTM_ERROR_INVALID_PARAMETER]: "Invalid parameter.", [RTMErrorCode.RTM_ERROR_LOGIN_NOT_AUTHORIZED]: "The RTM service is not enabled or has been stopped.", [RTMErrorCode.RTM_ERROR_INCONSISTENT_APPID]: "The appid is not consistent.", [RTMErrorCode.RTM_ERROR_DUPLICATE_OPERATION]: "Same subscribe, join or login request", [RTMErrorCode.RTM_ERROR_INSTANCE_ALREADY_RELEASED]: "Instance already released or destroyed, need to create new one", [RTMErrorCode.RTM_ERROR_INVALID_CHANNEL_TYPE]: "Invalid channel type, some api not support set channel type as user.", [RTMErrorCode.RTM_ERROR_INVALID_ENCRYPTION_PARAMETER]: "Invalid encryption parameter.", [RTMErrorCode.RTM_ERROR_OPERATION_RATE_EXCEED_LIMITATION]: "The operation rate exceeds limitation.", [RTMErrorCode.RTM_ERROR_SERVICE_NOT_SUPPORTED]: "Service doesn't support.", [RTMErrorCode.RTM_ERROR_LOGIN_CANCELED]: "Login RTM service was canceled by user.", [RTMErrorCode.RTM_ERROR_INVALID_PRIVATE_CONFIG]: "Set private config should both set serviceType and accessPointHosts.", [RTMErrorCode.RTM_ERROR_NOT_CONNECTED]: "Perform operation failed due to RTM service is not connected", [RTMErrorCode.RTM_ERROR_RENEW_TOKEN_TIMEOUT]: "RenewToken operation timeout.", [RTMErrorCode.RTM_ERROR_CHANNEL_NOT_JOINED]: "Perform operation without join stream channel.", [RTMErrorCode.RTM_ERROR_CHANNEL_NOT_SUBSCRIBED]: "Perform operation without subscribe message channel.", [RTMErrorCode.RTM_ERROR_CHANNEL_EXCEED_TOPIC_USER_LIMITATION]: "Subscribe failed due to exceed topic user limitation in stream channel.", [RTMErrorCode.RTM_ERROR_CHANNEL_IN_REUSE]: "Release a stream channel which was reused in RTC channel.", [RTMErrorCode.RTM_ERROR_CHANNEL_INSTANCE_EXCEED_LIMITATION]: "Join or subscribe too many channels and have reach limitation.", [RTMErrorCode.RTM_ERROR_CHANNEL_IN_ERROR_STATE]: "Perform channel operation failed since channel state is incorrect.", [RTMErrorCode.RTM_ERROR_CHANNEL_JOIN_FAILED]: "Join stream channel failed.", [RTMErrorCode.RTM_ERROR_CHANNEL_INVALID_TOPIC_NAME]: "Perform topic operation with invalid name.".concat(detailMsg4InvalidParam), [RTMErrorCode.RTM_ERROR_CHANNEL_INVALID_MESSAGE]: "Publish invalid message.", [RTMErrorCode.RTM_ERROR_CHANNEL_MESSAGE_LENGTH_EXCEED_LIMITATION]: "Publish too long message.", [RTMErrorCode.RTM_ERROR_CHANNEL_INVALID_USER_LIST]: "Perform topic operation with invalid user list.", [RTMErrorCode.RTM_ERROR_CHANNEL_NOT_AVAILABLE]: "Stream channel not available for this app id.", [RTMErrorCode.RTM_ERROR_CHANNEL_TOPIC_NOT_SUBSCRIBED]: "Perform topic operation without subscribe.", [RTMErrorCode.RTM_ERROR_CHANNEL_EXCEED_TOPIC_LIMITATION]: "Have subscribe or joined too many topics.", [RTMErrorCode.RTM_ERROR_CHANNEL_JOIN_TOPIC_FAILED]: "Join topic failed.", [RTMErrorCode.RTM_ERROR_CHANNEL_TOPIC_NOT_JOINED]: "Perform topic operation without join.", [RTMErrorCode.RTM_ERROR_CHANNEL_TOPIC_NOT_EXIST]: "Topic does not exist.", [RTMErrorCode.RTM_ERROR_CHANNEL_INVALID_TOPIC_META]: "Topic meta is invalid.", [RTMErrorCode.RTM_ERROR_CHANNEL_SUBSCRIBE_TIMEOUT]: "Subscribe message channel timeout.", [RTMErrorCode.RTM_ERROR_CHANNEL_SUBSCRIBE_TOO_FREQUENT]: "Subscribe message channel too frequently.", [RTMErrorCode.RTM_ERROR_CHANNEL_SUBSCRIBE_FAILED]: "Subscribe message channel failed.", [RTMErrorCode.RTM_ERROR_CHANNEL_UNSUBSCRIBE_FAILED]: "Unsubscribe message channel failed.", [RTMErrorCode.RTM_ERROR_CHANNEL_ENCRYPT_MESSAGE_FAILED]: "Encrypt message failed.", [RTMErrorCode.RTM_ERROR_CHANNEL_PUBLISH_MESSAGE_FAILED]: "Publish message failed.", [RTMErrorCode.RTM_ERROR_CHANNEL_PUBLISH_MESSAGE_TOO_FREQUENT]: "Publish message too frequently.", [RTMErrorCode.RTM_ERROR_CHANNEL_PUBLISH_MESSAGE_TIMEOUT]: "Publish message timeout.", [RTMErrorCode.RTM_ERROR_CHANNEL_NOT_CONNECTED]: "Perform operation failed due to connection closed.", [RTMErrorCode.RTM_ERROR_CHANNEL_LEAVE_FAILED]: "Leave channel failed.", [RTMErrorCode.RTM_ERROR_CHANNEL_CUSTOM_TYPE_LENGTH_OVERFLOW]: "The length of custom type overflow.", [RTMErrorCode.RTM_ERROR_CHANNEL_INVALID_CUSTOM_TYPE]: "Send message with invalid custom type.", [RTMErrorCode.RTM_ERROR_CHANNEL_UNSUPPORTED_MESSAGE_TYPE]: "Send message with unsupported message type.", [RTMErrorCode.RTM_ERROR_CHANNEL_PRESENCE_NOT_READY]: "Join or subscribe channel failed due to presence service not ready.", [RTMErrorCode.RTM_ERROR_CHANNEL_RECEIVER_OFFLINE]: "Publish a message to user now is offline.", [RTMErrorCode.RTM_ERROR_CHANNEL_JOIN_CANCELED]: "Join channel operation was canceled.", [RTMErrorCode.RTM_ERROR_CHANNEL_RECEIVER_OFFLINE_BUT_STORE_SUCCEEDED]: "Message receiver is offline but store in history succeeded.", [RTMErrorCode.RTM_ERROR_CHANNEL_RECEIVER_OFFLINE_AND_STORE_FAILED]: "Message receiver is offline and store in history failed.", [RTMErrorCode.RTM_ERROR_CHANNEL_MESSAGE_DELIVERED_BUT_STORE_FAILED]: "Message delivered successfully but store in history failed.", [RTMErrorCode.RTM_ERROR_CHANNEL_SUBSCRIBE_PERMISSION_DENIED]: "No permission to subscribe message channel.", [RTMErrorCode.RTM_ERROR_CHANNEL_PUBLISH_PERMISSION_DENIED]: "No permission to publish message.", [RTMErrorCode.RTM_ERROR_STORAGE_OPERATION_FAILED]: "Storage operation failed.", [RTMErrorCode.RTM_ERROR_STORAGE_METADATA_ITEM_EXCEED_LIMITATION]: "Metadata item size exceeds limitation.", [RTMErrorCode.RTM_ERROR_STORAGE_INVALID_METADATA_ITEM]: "Metadata item is invalid.", [RTMErrorCode.RTM_ERROR_STORAGE_INVALID_ARGUMENT]: "Server reject operation due to invalid argument.", [RTMErrorCode.RTM_ERROR_STORAGE_INVALID_REVISION]: "Metadata item with invalid revision.", [RTMErrorCode.RTM_ERROR_STORAGE_METADATA_LENGTH_OVERFLOW]: "The length of metadata items overflow.", [RTMErrorCode.RTM_ERROR_STORAGE_INVALID_LOCK_NAME]: "Storage operation with invalid lock name. ".concat(detailMsg4InvalidParam), [RTMErrorCode.RTM_ERROR_STORAGE_LOCK_NOT_ACQUIRED]: "Storage operation with lock not acquired.", [RTMErrorCode.RTM_ERROR_STORAGE_INVALID_KEY]: "Storage operation with invalid key.", [RTMErrorCode.RTM_ERROR_STORAGE_INVALID_VALUE]: "Storage operation with invalid value.", [RTMErrorCode.RTM_ERROR_STORAGE_KEY_LENGTH_OVERFLOW]: "Storage operation with key length overflow.", [RTMErrorCode.RTM_ERROR_STORAGE_VALUE_LENGTH_OVERFLOW]: "Storage operation with value length overflow.", [RTMErrorCode.RTM_ERROR_STORAGE_DUPLICATE_KEY]: "Storage operation with duplicate key.", [RTMErrorCode.RTM_ERROR_STORAGE_OUTDATED_REVISION]: "Storage operation with outdated revision or the key does not exist.", [RTMErrorCode.RTM_ERROR_STORAGE_NOT_SUBSCRIBE]: "Storage operation without subscribe.", [RTMErrorCode.RTM_ERROR_STORAGE_INVALID_METADATA_INSTANCE]: "Metadata instance is invalid.", [RTMErrorCode.RTM_ERROR_STORAGE_SUBSCRIBE_USER_EXCEED_LIMITATION]: "Subscribe user metadata exceeds limitation.", [RTMErrorCode.RTM_ERROR_STORAGE_OPERATION_TIMEOUT]: "Storage operation timeout.", [RTMErrorCode.RTM_ERROR_STORAGE_NOT_AVAILABLE]: "Storage service is not available.", [RTMErrorCode.RTM_ERROR_STORAGE_PERMISSION_DENIED]: "No permission to access storage service.", [RTMErrorCode.RTM_ERROR_PRESENCE_NOT_CONNECTED]: "Presence service not connected.", [RTMErrorCode.RTM_ERROR_PRESENCE_NOT_WRITABLE]: "Operation failed since presence document is not writable, try later.", [RTMErrorCode.RTM_ERROR_PRESENCE_INVALID_ARGUMENT]: "Presence operation failed due to invalid argument.", [RTMErrorCode.RTM_ERROR_PRESENCE_CACHED_TOO_MANY_STATES]: "Exceed presence cache limitation.", [RTMErrorCode.RTM_ERROR_PRESENCE_STATE_COUNT_OVERFLOW]: "Exceed presence state count limitation.", [RTMErrorCode.RTM_ERROR_PRESENCE_INVALID_STATE_KEY]: "Invalid presence state key.", [RTMErrorCode.RTM_ERROR_PRESENCE_INVALID_STATE_VALUE]: "Invalid presence state value.", [RTMErrorCode.RTM_ERROR_PRESENCE_STATE_KEY_SIZE_OVERFLOW]: "Presence state key length is too long.", [RTMErrorCode.RTM_ERROR_PRESENCE_STATE_VALUE_SIZE_OVERFLOW]: "Presence state value length is too long.", [RTMErrorCode.RTM_ERROR_PRESENCE_STATE_DUPLICATE_KEY]: "Presence operation failed since including duplicate key.", [RTMErrorCode.RTM_ERROR_PRESENCE_USER_NOT_EXIST]: "Presence operation failed due to inexistent user.", [RTMErrorCode.RTM_ERROR_PRESENCE_OPERATION_TIMEOUT]: "Presence operation timeout.", [RTMErrorCode.RTM_ERROR_PRESENCE_OPERATION_FAILED]: "Presence operation failed.", [RTMErrorCode.RTM_ERROR_LOCK_OPERATION_FAILED]: "Lock operation failed.", [RTMErrorCode.RTM_ERROR_LOCK_OPERATION_TIMEOUT]: "Lock operation timeout.", [RTMErrorCode.RTM_ERROR_LOCK_OPERATION_PERFORMING]: "Lock operation is performing, try later.", [RTMErrorCode.RTM_ERROR_LOCK_ALREADY_EXIST]: "Lock already exist.", [RTMErrorCode.RTM_ERROR_LOCK_INVALID_NAME]: "Lock operation with invalid name. ".concat(detailMsg4InvalidParam), [RTMErrorCode.RTM_ERROR_LOCK_NOT_ACQUIRED]: "Lock not acquired.", [RTMErrorCode.RTM_ERROR_LOCK_ACQUIRE_FAILED]: "Lock acquire failed.", [RTMErrorCode.RTM_ERROR_LOCK_NOT_EXIST]: "Lock not exist.", [RTMErrorCode.RTM_ERROR_LOCK_NOT_AVAILABLE]: "Lock service is not available.", [RTMErrorCode.RTM_ERROR_LOCK_PERMISSION_DENIED]: "No permission to access lock service.", [RTMErrorCode.RTM_ERROR_HISTORY_INVALID_TIMESTAMP]: "Invalid start or end timestamp.", [RTMErrorCode.RTM_ERROR_HISTORY_OPERATION_FAILED]: "History operation failed.", [RTMErrorCode.RTM_ERROR_HISTORY_OPERATION_TIMEOUT]: "History operation timeout.", [RTMErrorCode.RTM_ERROR_HISTORY_OPERATION_NOT_PERMITTED]: "History operation is not permitted.", [RTMErrorCode.RTM_ERROR_HISTORY_NOT_AVAILABLE]: "History service is not available.", [RTMErrorCode.RTM_ERROR_HISTORY_PERMISSION_DENIED]: "No permission to access history service." }, ReportId = { Counter: 1, ApiExec: 154, Session: 164, ApEvent: 165, Link: 166, Logout: 167, TxMessage: 168, RxMessage: 169, KickedOff: 170, TxMessageRes: 171, ChnJoin: 172, ChnJoinRes: 173, ChnLeave: 174, ChnGetMembers: 175, ChnGetMembersRes: 176, ChnMemberJoined: 177, ChnMemberLeft: 178, QueryPeersOnlineStatus: 179, QueryPeersOnlineStatusRes: 180, RenewToken: 181, OperateAttribute: 186, OperateAttributeRes: 187, ApRequest: 188, LinkTcpEvent: 189, LinkLoginRequest: 190, ConnectionStateChange: 191, RtmSdkMessageCount: 510, SyncOperateEvent: 9654, SyncSubscribeEvent: 9651, LoginResult: 10071, ChannelPresenceSnapshotEvent: 10070, LinkStateChange: 10201, RenewTokenRes: 10204, SyncLockAcquireEvent: 9740, SyncLockReleaseEvent: 9741, SyncLockUpdateEvent: 9742, SyncLockDisableEvent: 9764, StreamChnJoin: 10273, StreamChnLeave: 10274, TopicJoin: 10275, TopicLeave: 10276, TopicSubscribe: 10202, TopicUnsubscribe: 10277, TopicUpdateEvent: 10278 }, LogFilter = { LOG_FILTER_NONE: { error: false, warn: false, info: false, track: false, debug: false }, LOG_FILTER_ERROR: { error: true, warn: false, info: false, track: false, debug: false }, LOG_FILTER_WARN: { error: true, warn: true, info: false, track: false, debug: false }, LOG_FILTER_INFO: { error: true, warn: true, info: true, track: false, debug: false }, LOG_FILTER_DEBUG: { error: true, warn: true, info: true, track: true, debug: true } }, linkStateCodeMap = { IDLE: 0, CONNECTING: 1, CONNECTED: 2, DISCONNECTED: 3, SUSPENDED: 4, FAILED: 5 }, topicEventTypeMap = { NONE: 0, SNAPSHOT: 1, REMOTE_JOIN: 2, REMOTE_LEAVE: 3 }, linkOperationCodeMap = { LOGIN: 0, LOGOUT: 1, JOIN: 2, LEAVE: 3, SERVER_REJECT: 4, AUTO_RECONNECT: 5, RECONNECTED: 6, HEARTBEAT_TIMEOUT: 7, SERVER_TIMEOUT: 8, NETWORK_CHANGE: 9 }, STREAM_CHANNEL_PREFIX = "*s*", EDGE_ENV_PORT = { 0: 9591, 1: 9593 };
      var util$7 = { exports: {} }, forge$8 = { options: { usePureJavaScript: false } }, api = {}, baseN$1 = api, _reverseAlphabets = {};
      function _encodeWithByteBuffer(A, e) {
        var t = 0, g = e.length, o = e.charAt(0), I = [0];
        for (t = 0; t < A.length(); ++t) {
          for (var i2 = 0, r = A.at(t); i2 < I.length; ++i2)
            r += I[i2] << 8, I[i2] = r % g, r = r / g | 0;
          for (; r > 0; )
            I.push(r % g), r = r / g | 0;
        }
        var n = "";
        for (t = 0; 0 === A.at(t) && t < A.length() - 1; ++t)
          n += o;
        for (t = I.length - 1; t >= 0; --t)
          n += e[I[t]];
        return n;
      }
      api.encode = function(A, e, t) {
        if ("string" != typeof e)
          throw new TypeError('"alphabet" must be a string.');
        if (void 0 !== t && "number" != typeof t)
          throw new TypeError('"maxline" must be a number.');
        var g = "";
        if (A instanceof Uint8Array) {
          var o = 0, I = e.length, i2 = e.charAt(0), r = [0];
          for (o = 0; o < A.length; ++o) {
            for (var n = 0, C = A[o]; n < r.length; ++n)
              C += r[n] << 8, r[n] = C % I, C = C / I | 0;
            for (; C > 0; )
              r.push(C % I), C = C / I | 0;
          }
          for (o = 0; 0 === A[o] && o < A.length - 1; ++o)
            g += i2;
          for (o = r.length - 1; o >= 0; --o)
            g += e[r[o]];
        } else
          g = _encodeWithByteBuffer(A, e);
        if (t) {
          var E = new RegExp(".{1," + t + "}", "g");
          g = g.match(E).join("\r\n");
        }
        return g;
      }, api.decode = function(A, e) {
        if ("string" != typeof A)
          throw new TypeError('"input" must be a string.');
        if ("string" != typeof e)
          throw new TypeError('"alphabet" must be a string.');
        var t = _reverseAlphabets[e];
        if (!t) {
          t = _reverseAlphabets[e] = [];
          for (var g = 0; g < e.length; ++g)
            t[e.charCodeAt(g)] = g;
        }
        A = A.replace(/\s/g, "");
        var o = e.length, I = e.charAt(0), i2 = [0];
        for (g = 0; g < A.length; g++) {
          var r = t[A.charCodeAt(g)];
          if (void 0 === r)
            return;
          for (var n = 0, C = r; n < i2.length; ++n)
            C += i2[n] * o, i2[n] = 255 & C, C >>= 8;
          for (; C > 0; )
            i2.push(255 & C), C >>= 8;
        }
        for (var E = 0; A[E] === I && E < A.length - 1; ++E)
          i2.push(0);
        return "undefined" != typeof Buffer ? Buffer.from(i2.reverse()) : new Uint8Array(i2.reverse());
      };
      var forge$7 = forge$8, baseN = baseN$1, util$5 = util$7.exports = forge$7.util = forge$7.util || {};
      function _checkBitsParam(A) {
        if (8 !== A && 16 !== A && 24 !== A && 32 !== A)
          throw new Error("Only 8, 16, 24, or 32 bits supported: " + A);
      }
      function ByteStringBuffer(A) {
        if (this.data = "", this.read = 0, "string" == typeof A)
          this.data = A;
        else if (util$5.isArrayBuffer(A) || util$5.isArrayBufferView(A))
          if ("undefined" != typeof Buffer && A instanceof Buffer)
            this.data = A.toString("binary");
          else {
            var e = new Uint8Array(A);
            try {
              this.data = String.fromCharCode.apply(null, e);
            } catch (A2) {
              for (var t = 0; t < e.length; ++t)
                this.putByte(e[t]);
            }
          }
        else
          (A instanceof ByteStringBuffer || "object" == typeof A && "string" == typeof A.data && "number" == typeof A.read) && (this.data = A.data, this.read = A.read);
        this._constructedStringLength = 0;
      }
      !function() {
        if ("undefined" != typeof process && process.nextTick && !process.browser)
          return util$5.nextTick = process.nextTick, void ("function" == typeof setImmediate ? util$5.setImmediate = setImmediate : util$5.setImmediate = util$5.nextTick);
        if ("function" == typeof setImmediate)
          return util$5.setImmediate = function() {
            return setImmediate.apply(void 0, arguments);
          }, void (util$5.nextTick = function(A2) {
            return setImmediate(A2);
          });
        if (util$5.setImmediate = function(A2) {
          setTimeout(A2, 0);
        }, "undefined" != typeof window && "function" == typeof window.postMessage) {
          let i2 = function(t2) {
            if (t2.source === window && t2.data === A) {
              t2.stopPropagation();
              var g2 = e.slice();
              e.length = 0, g2.forEach(function(A2) {
                A2();
              });
            }
          };
          var A = "forge.setImmediate", e = [];
          util$5.setImmediate = function(t2) {
            e.push(t2), 1 === e.length && window.postMessage(A, "*");
          }, window.addEventListener("message", i2, true);
        }
        if ("undefined" != typeof MutationObserver) {
          var t = Date.now(), g = true, o = document.createElement("div");
          e = [];
          new MutationObserver(function() {
            var A2 = e.slice();
            e.length = 0, A2.forEach(function(A3) {
              A3();
            });
          }).observe(o, { attributes: true });
          var I = util$5.setImmediate;
          util$5.setImmediate = function(A2) {
            Date.now() - t > 15 ? (t = Date.now(), I(A2)) : (e.push(A2), 1 === e.length && o.setAttribute("a", g = !g));
          };
        }
        util$5.nextTick = util$5.setImmediate;
      }(), util$5.isNodejs = "undefined" != typeof process && process.versions && process.versions.node, util$5.globalScope = util$5.isNodejs ? commonjsGlobal : "undefined" == typeof self ? window : self, util$5.isArray = Array.isArray || function(A) {
        return "[object Array]" === Object.prototype.toString.call(A);
      }, util$5.isArrayBuffer = function(A) {
        return "undefined" != typeof ArrayBuffer && A instanceof ArrayBuffer;
      }, util$5.isArrayBufferView = function(A) {
        return A && util$5.isArrayBuffer(A.buffer) && void 0 !== A.byteLength;
      }, util$5.ByteBuffer = ByteStringBuffer, util$5.ByteStringBuffer = ByteStringBuffer;
      var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
      function DataBuffer(A, e) {
        e = e || {}, this.read = e.readOffset || 0, this.growSize = e.growSize || 1024;
        var t = util$5.isArrayBuffer(A), g = util$5.isArrayBufferView(A);
        if (t || g)
          return this.data = t ? new DataView(A) : new DataView(A.buffer, A.byteOffset, A.byteLength), void (this.write = "writeOffset" in e ? e.writeOffset : this.data.byteLength);
        this.data = new DataView(new ArrayBuffer(0)), this.write = 0, null != A && this.putBytes(A), "writeOffset" in e && (this.write = e.writeOffset);
      }
      util$5.ByteStringBuffer.prototype._optimizeConstructedString = function(A) {
        this._constructedStringLength += A, this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH && (this.data.substr(0, 1), this._constructedStringLength = 0);
      }, util$5.ByteStringBuffer.prototype.length = function() {
        return this.data.length - this.read;
      }, util$5.ByteStringBuffer.prototype.isEmpty = function() {
        return this.length() <= 0;
      }, util$5.ByteStringBuffer.prototype.putByte = function(A) {
        return this.putBytes(String.fromCharCode(A));
      }, util$5.ByteStringBuffer.prototype.fillWithByte = function(A, e) {
        A = String.fromCharCode(A);
        for (var t = this.data; e > 0; )
          1 & e && (t += A), (e >>>= 1) > 0 && (A += A);
        return this.data = t, this._optimizeConstructedString(e), this;
      }, util$5.ByteStringBuffer.prototype.putBytes = function(A) {
        return this.data += A, this._optimizeConstructedString(A.length), this;
      }, util$5.ByteStringBuffer.prototype.putString = function(A) {
        return this.putBytes(util$5.encodeUtf8(A));
      }, util$5.ByteStringBuffer.prototype.putInt16 = function(A) {
        return this.putBytes(String.fromCharCode(A >> 8 & 255) + String.fromCharCode(255 & A));
      }, util$5.ByteStringBuffer.prototype.putInt24 = function(A) {
        return this.putBytes(String.fromCharCode(A >> 16 & 255) + String.fromCharCode(A >> 8 & 255) + String.fromCharCode(255 & A));
      }, util$5.ByteStringBuffer.prototype.putInt32 = function(A) {
        return this.putBytes(String.fromCharCode(A >> 24 & 255) + String.fromCharCode(A >> 16 & 255) + String.fromCharCode(A >> 8 & 255) + String.fromCharCode(255 & A));
      }, util$5.ByteStringBuffer.prototype.putInt16Le = function(A) {
        return this.putBytes(String.fromCharCode(255 & A) + String.fromCharCode(A >> 8 & 255));
      }, util$5.ByteStringBuffer.prototype.putInt24Le = function(A) {
        return this.putBytes(String.fromCharCode(255 & A) + String.fromCharCode(A >> 8 & 255) + String.fromCharCode(A >> 16 & 255));
      }, util$5.ByteStringBuffer.prototype.putInt32Le = function(A) {
        return this.putBytes(String.fromCharCode(255 & A) + String.fromCharCode(A >> 8 & 255) + String.fromCharCode(A >> 16 & 255) + String.fromCharCode(A >> 24 & 255));
      }, util$5.ByteStringBuffer.prototype.putInt = function(A, e) {
        _checkBitsParam(e);
        var t = "";
        do {
          e -= 8, t += String.fromCharCode(A >> e & 255);
        } while (e > 0);
        return this.putBytes(t);
      }, util$5.ByteStringBuffer.prototype.putSignedInt = function(A, e) {
        return A < 0 && (A += 2 << e - 1), this.putInt(A, e);
      }, util$5.ByteStringBuffer.prototype.putBuffer = function(A) {
        return this.putBytes(A.getBytes());
      }, util$5.ByteStringBuffer.prototype.getByte = function() {
        return this.data.charCodeAt(this.read++);
      }, util$5.ByteStringBuffer.prototype.getInt16 = function() {
        var A = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
        return this.read += 2, A;
      }, util$5.ByteStringBuffer.prototype.getInt24 = function() {
        var A = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
        return this.read += 3, A;
      }, util$5.ByteStringBuffer.prototype.getInt32 = function() {
        var A = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
        return this.read += 4, A;
      }, util$5.ByteStringBuffer.prototype.getInt16Le = function() {
        var A = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
        return this.read += 2, A;
      }, util$5.ByteStringBuffer.prototype.getInt24Le = function() {
        var A = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
        return this.read += 3, A;
      }, util$5.ByteStringBuffer.prototype.getInt32Le = function() {
        var A = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
        return this.read += 4, A;
      }, util$5.ByteStringBuffer.prototype.getInt = function(A) {
        _checkBitsParam(A);
        var e = 0;
        do {
          e = (e << 8) + this.data.charCodeAt(this.read++), A -= 8;
        } while (A > 0);
        return e;
      }, util$5.ByteStringBuffer.prototype.getSignedInt = function(A) {
        var e = this.getInt(A), t = 2 << A - 2;
        return e >= t && (e -= t << 1), e;
      }, util$5.ByteStringBuffer.prototype.getBytes = function(A) {
        var e;
        return A ? (A = Math.min(this.length(), A), e = this.data.slice(this.read, this.read + A), this.read += A) : 0 === A ? e = "" : (e = 0 === this.read ? this.data : this.data.slice(this.read), this.clear()), e;
      }, util$5.ByteStringBuffer.prototype.bytes = function(A) {
        return void 0 === A ? this.data.slice(this.read) : this.data.slice(this.read, this.read + A);
      }, util$5.ByteStringBuffer.prototype.at = function(A) {
        return this.data.charCodeAt(this.read + A);
      }, util$5.ByteStringBuffer.prototype.setAt = function(A, e) {
        return this.data = this.data.substr(0, this.read + A) + String.fromCharCode(e) + this.data.substr(this.read + A + 1), this;
      }, util$5.ByteStringBuffer.prototype.last = function() {
        return this.data.charCodeAt(this.data.length - 1);
      }, util$5.ByteStringBuffer.prototype.copy = function() {
        var A = util$5.createBuffer(this.data);
        return A.read = this.read, A;
      }, util$5.ByteStringBuffer.prototype.compact = function() {
        return this.read > 0 && (this.data = this.data.slice(this.read), this.read = 0), this;
      }, util$5.ByteStringBuffer.prototype.clear = function() {
        return this.data = "", this.read = 0, this;
      }, util$5.ByteStringBuffer.prototype.truncate = function(A) {
        var e = Math.max(0, this.length() - A);
        return this.data = this.data.substr(this.read, e), this.read = 0, this;
      }, util$5.ByteStringBuffer.prototype.toHex = function() {
        for (var A = "", e = this.read; e < this.data.length; ++e) {
          var t = this.data.charCodeAt(e);
          t < 16 && (A += "0"), A += t.toString(16);
        }
        return A;
      }, util$5.ByteStringBuffer.prototype.toString = function() {
        return util$5.decodeUtf8(this.bytes());
      }, util$5.DataBuffer = DataBuffer, util$5.DataBuffer.prototype.length = function() {
        return this.write - this.read;
      }, util$5.DataBuffer.prototype.isEmpty = function() {
        return this.length() <= 0;
      }, util$5.DataBuffer.prototype.accommodate = function(A, e) {
        if (this.length() >= A)
          return this;
        e = Math.max(e || this.growSize, A);
        var t = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength), g = new Uint8Array(this.length() + e);
        return g.set(t), this.data = new DataView(g.buffer), this;
      }, util$5.DataBuffer.prototype.putByte = function(A) {
        return this.accommodate(1), this.data.setUint8(this.write++, A), this;
      }, util$5.DataBuffer.prototype.fillWithByte = function(A, e) {
        this.accommodate(e);
        for (var t = 0; t < e; ++t)
          this.data.setUint8(A);
        return this;
      }, util$5.DataBuffer.prototype.putBytes = function(A, e) {
        if (util$5.isArrayBufferView(A)) {
          var t = (g = new Uint8Array(A.buffer, A.byteOffset, A.byteLength)).byteLength - g.byteOffset;
          return this.accommodate(t), new Uint8Array(this.data.buffer, this.write).set(g), this.write += t, this;
        }
        if (util$5.isArrayBuffer(A)) {
          var g = new Uint8Array(A);
          return this.accommodate(g.byteLength), new Uint8Array(this.data.buffer).set(g, this.write), this.write += g.byteLength, this;
        }
        if (A instanceof util$5.DataBuffer || "object" == typeof A && "number" == typeof A.read && "number" == typeof A.write && util$5.isArrayBufferView(A.data)) {
          g = new Uint8Array(A.data.byteLength, A.read, A.length());
          return this.accommodate(g.byteLength), new Uint8Array(A.data.byteLength, this.write).set(g), this.write += g.byteLength, this;
        }
        if (A instanceof util$5.ByteStringBuffer && (A = A.data, e = "binary"), e = e || "binary", "string" == typeof A) {
          var o;
          if ("hex" === e)
            return this.accommodate(Math.ceil(A.length / 2)), o = new Uint8Array(this.data.buffer, this.write), this.write += util$5.binary.hex.decode(A, o, this.write), this;
          if ("base64" === e)
            return this.accommodate(3 * Math.ceil(A.length / 4)), o = new Uint8Array(this.data.buffer, this.write), this.write += util$5.binary.base64.decode(A, o, this.write), this;
          if ("utf8" === e && (A = util$5.encodeUtf8(A), e = "binary"), "binary" === e || "raw" === e)
            return this.accommodate(A.length), o = new Uint8Array(this.data.buffer, this.write), this.write += util$5.binary.raw.decode(o), this;
          if ("utf16" === e)
            return this.accommodate(2 * A.length), o = new Uint16Array(this.data.buffer, this.write), this.write += util$5.text.utf16.encode(o), this;
          throw new Error("Invalid encoding: " + e);
        }
        throw Error("Invalid parameter: " + A);
      }, util$5.DataBuffer.prototype.putBuffer = function(A) {
        return this.putBytes(A), A.clear(), this;
      }, util$5.DataBuffer.prototype.putString = function(A) {
        return this.putBytes(A, "utf16");
      }, util$5.DataBuffer.prototype.putInt16 = function(A) {
        return this.accommodate(2), this.data.setInt16(this.write, A), this.write += 2, this;
      }, util$5.DataBuffer.prototype.putInt24 = function(A) {
        return this.accommodate(3), this.data.setInt16(this.write, A >> 8 & 65535), this.data.setInt8(this.write, A >> 16 & 255), this.write += 3, this;
      }, util$5.DataBuffer.prototype.putInt32 = function(A) {
        return this.accommodate(4), this.data.setInt32(this.write, A), this.write += 4, this;
      }, util$5.DataBuffer.prototype.putInt16Le = function(A) {
        return this.accommodate(2), this.data.setInt16(this.write, A, true), this.write += 2, this;
      }, util$5.DataBuffer.prototype.putInt24Le = function(A) {
        return this.accommodate(3), this.data.setInt8(this.write, A >> 16 & 255), this.data.setInt16(this.write, A >> 8 & 65535, true), this.write += 3, this;
      }, util$5.DataBuffer.prototype.putInt32Le = function(A) {
        return this.accommodate(4), this.data.setInt32(this.write, A, true), this.write += 4, this;
      }, util$5.DataBuffer.prototype.putInt = function(A, e) {
        _checkBitsParam(e), this.accommodate(e / 8);
        do {
          e -= 8, this.data.setInt8(this.write++, A >> e & 255);
        } while (e > 0);
        return this;
      }, util$5.DataBuffer.prototype.putSignedInt = function(A, e) {
        return _checkBitsParam(e), this.accommodate(e / 8), A < 0 && (A += 2 << e - 1), this.putInt(A, e);
      }, util$5.DataBuffer.prototype.getByte = function() {
        return this.data.getInt8(this.read++);
      }, util$5.DataBuffer.prototype.getInt16 = function() {
        var A = this.data.getInt16(this.read);
        return this.read += 2, A;
      }, util$5.DataBuffer.prototype.getInt24 = function() {
        var A = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
        return this.read += 3, A;
      }, util$5.DataBuffer.prototype.getInt32 = function() {
        var A = this.data.getInt32(this.read);
        return this.read += 4, A;
      }, util$5.DataBuffer.prototype.getInt16Le = function() {
        var A = this.data.getInt16(this.read, true);
        return this.read += 2, A;
      }, util$5.DataBuffer.prototype.getInt24Le = function() {
        var A = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
        return this.read += 3, A;
      }, util$5.DataBuffer.prototype.getInt32Le = function() {
        var A = this.data.getInt32(this.read, true);
        return this.read += 4, A;
      }, util$5.DataBuffer.prototype.getInt = function(A) {
        _checkBitsParam(A);
        var e = 0;
        do {
          e = (e << 8) + this.data.getInt8(this.read++), A -= 8;
        } while (A > 0);
        return e;
      }, util$5.DataBuffer.prototype.getSignedInt = function(A) {
        var e = this.getInt(A), t = 2 << A - 2;
        return e >= t && (e -= t << 1), e;
      }, util$5.DataBuffer.prototype.getBytes = function(A) {
        var e;
        return A ? (A = Math.min(this.length(), A), e = this.data.slice(this.read, this.read + A), this.read += A) : 0 === A ? e = "" : (e = 0 === this.read ? this.data : this.data.slice(this.read), this.clear()), e;
      }, util$5.DataBuffer.prototype.bytes = function(A) {
        return void 0 === A ? this.data.slice(this.read) : this.data.slice(this.read, this.read + A);
      }, util$5.DataBuffer.prototype.at = function(A) {
        return this.data.getUint8(this.read + A);
      }, util$5.DataBuffer.prototype.setAt = function(A, e) {
        return this.data.setUint8(A, e), this;
      }, util$5.DataBuffer.prototype.last = function() {
        return this.data.getUint8(this.write - 1);
      }, util$5.DataBuffer.prototype.copy = function() {
        return new util$5.DataBuffer(this);
      }, util$5.DataBuffer.prototype.compact = function() {
        if (this.read > 0) {
          var A = new Uint8Array(this.data.buffer, this.read), e = new Uint8Array(A.byteLength);
          e.set(A), this.data = new DataView(e), this.write -= this.read, this.read = 0;
        }
        return this;
      }, util$5.DataBuffer.prototype.clear = function() {
        return this.data = new DataView(new ArrayBuffer(0)), this.read = this.write = 0, this;
      }, util$5.DataBuffer.prototype.truncate = function(A) {
        return this.write = Math.max(0, this.length() - A), this.read = Math.min(this.read, this.write), this;
      }, util$5.DataBuffer.prototype.toHex = function() {
        for (var A = "", e = this.read; e < this.data.byteLength; ++e) {
          var t = this.data.getUint8(e);
          t < 16 && (A += "0"), A += t.toString(16);
        }
        return A;
      }, util$5.DataBuffer.prototype.toString = function(A) {
        var e = new Uint8Array(this.data, this.read, this.length());
        if ("binary" === (A = A || "utf8") || "raw" === A)
          return util$5.binary.raw.encode(e);
        if ("hex" === A)
          return util$5.binary.hex.encode(e);
        if ("base64" === A)
          return util$5.binary.base64.encode(e);
        if ("utf8" === A)
          return util$5.text.utf8.decode(e);
        if ("utf16" === A)
          return util$5.text.utf16.decode(e);
        throw new Error("Invalid encoding: " + A);
      }, util$5.createBuffer = function(A, e) {
        return e = e || "raw", void 0 !== A && "utf8" === e && (A = util$5.encodeUtf8(A)), new util$5.ByteBuffer(A);
      }, util$5.fillString = function(A, e) {
        for (var t = ""; e > 0; )
          1 & e && (t += A), (e >>>= 1) > 0 && (A += A);
        return t;
      }, util$5.xorBytes = function(A, e, t) {
        for (var g = "", o = "", I = "", i2 = 0, r = 0; t > 0; --t, ++i2)
          o = A.charCodeAt(i2) ^ e.charCodeAt(i2), r >= 10 && (g += I, I = "", r = 0), I += String.fromCharCode(o), ++r;
        return g += I;
      }, util$5.hexToBytes = function(A) {
        var e = "", t = 0;
        for (true & A.length && (t = 1, e += String.fromCharCode(parseInt(A[0], 16))); t < A.length; t += 2)
          e += String.fromCharCode(parseInt(A.substr(t, 2), 16));
        return e;
      }, util$5.bytesToHex = function(A) {
        return util$5.createBuffer(A).toHex();
      }, util$5.int32ToBytes = function(A) {
        return String.fromCharCode(A >> 24 & 255) + String.fromCharCode(A >> 16 & 255) + String.fromCharCode(A >> 8 & 255) + String.fromCharCode(255 & A);
      };
      var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", _base64Idx = [62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, 64, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
      util$5.encode64 = function(A, e) {
        for (var t, g, o, I = "", i2 = "", r = 0; r < A.length; )
          t = A.charCodeAt(r++), g = A.charCodeAt(r++), o = A.charCodeAt(r++), I += _base64.charAt(t >> 2), I += _base64.charAt((3 & t) << 4 | g >> 4), isNaN(g) ? I += "==" : (I += _base64.charAt((15 & g) << 2 | o >> 6), I += isNaN(o) ? "=" : _base64.charAt(63 & o)), e && I.length > e && (i2 += I.substr(0, e) + "\r\n", I = I.substr(e));
        return i2 += I;
      }, util$5.decode64 = function(A) {
        A = A.replace(/[^A-Za-z0-9\+\/\=]/g, "");
        for (var e, t, g, o, I = "", i2 = 0; i2 < A.length; )
          e = _base64Idx[A.charCodeAt(i2++) - 43], t = _base64Idx[A.charCodeAt(i2++) - 43], g = _base64Idx[A.charCodeAt(i2++) - 43], o = _base64Idx[A.charCodeAt(i2++) - 43], I += String.fromCharCode(e << 2 | t >> 4), 64 !== g && (I += String.fromCharCode((15 & t) << 4 | g >> 2), 64 !== o && (I += String.fromCharCode((3 & g) << 6 | o)));
        return I;
      }, util$5.encodeUtf8 = function(A) {
        return unescape(encodeURIComponent(A));
      }, util$5.decodeUtf8 = function(A) {
        return decodeURIComponent(escape(A));
      }, util$5.binary = { raw: {}, hex: {}, base64: {}, base58: {}, baseN: { encode: baseN.encode, decode: baseN.decode } }, util$5.binary.raw.encode = function(A) {
        return String.fromCharCode.apply(null, A);
      }, util$5.binary.raw.decode = function(A, e, t) {
        var g = e;
        g || (g = new Uint8Array(A.length));
        for (var o = t = t || 0, I = 0; I < A.length; ++I)
          g[o++] = A.charCodeAt(I);
        return e ? o - t : g;
      }, util$5.binary.hex.encode = util$5.bytesToHex, util$5.binary.hex.decode = function(A, e, t) {
        var g = e;
        g || (g = new Uint8Array(Math.ceil(A.length / 2)));
        var o = 0, I = t = t || 0;
        for (1 & A.length && (o = 1, g[I++] = parseInt(A[0], 16)); o < A.length; o += 2)
          g[I++] = parseInt(A.substr(o, 2), 16);
        return e ? I - t : g;
      }, util$5.binary.base64.encode = function(A, e) {
        for (var t, g, o, I = "", i2 = "", r = 0; r < A.byteLength; )
          t = A[r++], g = A[r++], o = A[r++], I += _base64.charAt(t >> 2), I += _base64.charAt((3 & t) << 4 | g >> 4), isNaN(g) ? I += "==" : (I += _base64.charAt((15 & g) << 2 | o >> 6), I += isNaN(o) ? "=" : _base64.charAt(63 & o)), e && I.length > e && (i2 += I.substr(0, e) + "\r\n", I = I.substr(e));
        return i2 += I;
      }, util$5.binary.base64.decode = function(A, e, t) {
        var g, o, I, i2, r = e;
        r || (r = new Uint8Array(3 * Math.ceil(A.length / 4))), A = A.replace(/[^A-Za-z0-9\+\/\=]/g, "");
        for (var n = 0, C = t = t || 0; n < A.length; )
          g = _base64Idx[A.charCodeAt(n++) - 43], o = _base64Idx[A.charCodeAt(n++) - 43], I = _base64Idx[A.charCodeAt(n++) - 43], i2 = _base64Idx[A.charCodeAt(n++) - 43], r[C++] = g << 2 | o >> 4, 64 !== I && (r[C++] = (15 & o) << 4 | I >> 2, 64 !== i2 && (r[C++] = (3 & I) << 6 | i2));
        return e ? C - t : r.subarray(0, C);
      }, util$5.binary.base58.encode = function(A, e) {
        return util$5.binary.baseN.encode(A, _base58, e);
      }, util$5.binary.base58.decode = function(A, e) {
        return util$5.binary.baseN.decode(A, _base58, e);
      }, util$5.text = { utf8: {}, utf16: {} }, util$5.text.utf8.encode = function(A, e, t) {
        A = util$5.encodeUtf8(A);
        var g = e;
        g || (g = new Uint8Array(A.length));
        for (var o = t = t || 0, I = 0; I < A.length; ++I)
          g[o++] = A.charCodeAt(I);
        return e ? o - t : g;
      }, util$5.text.utf8.decode = function(A) {
        return util$5.decodeUtf8(String.fromCharCode.apply(null, A));
      }, util$5.text.utf16.encode = function(A, e, t) {
        var g = e;
        g || (g = new Uint8Array(2 * A.length));
        for (var o = new Uint16Array(g.buffer), I = t = t || 0, i2 = t, r = 0; r < A.length; ++r)
          o[i2++] = A.charCodeAt(r), I += 2;
        return e ? I - t : g;
      }, util$5.text.utf16.decode = function(A) {
        return String.fromCharCode.apply(null, new Uint16Array(A.buffer));
      }, util$5.deflate = function(A, e, t) {
        if (e = util$5.decode64(A.deflate(util$5.encode64(e)).rval), t) {
          var g = 2;
          32 & e.charCodeAt(1) && (g = 6), e = e.substring(g, e.length - 4);
        }
        return e;
      }, util$5.inflate = function(A, e, t) {
        var g = A.inflate(util$5.encode64(e)).rval;
        return null === g ? null : util$5.decode64(g);
      };
      var _setStorageObject = function(A, e, t) {
        if (!A)
          throw new Error("WebStorage not available.");
        var g;
        if (null === t ? g = A.removeItem(e) : (t = util$5.encode64(JSON.stringify(t)), g = A.setItem(e, t)), void 0 !== g && true !== g.rval) {
          var o = new Error(g.error.message);
          throw o.id = g.error.id, o.name = g.error.name, o;
        }
      }, _getStorageObject = function(A, e) {
        if (!A)
          throw new Error("WebStorage not available.");
        var t = A.getItem(e);
        if (A.init)
          if (null === t.rval) {
            if (t.error) {
              var g = new Error(t.error.message);
              throw g.id = t.error.id, g.name = t.error.name, g;
            }
            t = null;
          } else
            t = t.rval;
        return null !== t && (t = JSON.parse(util$5.decode64(t))), t;
      }, _setItem = function(A, e, t, g) {
        var o = _getStorageObject(A, e);
        null === o && (o = {}), o[t] = g, _setStorageObject(A, e, o);
      }, _getItem = function(A, e, t) {
        var g = _getStorageObject(A, e);
        return null !== g && (g = t in g ? g[t] : null), g;
      }, _removeItem = function(A, e, t) {
        var g = _getStorageObject(A, e);
        if (null !== g && t in g) {
          delete g[t];
          var o = true;
          for (var I in g) {
            o = false;
            break;
          }
          o && (g = null), _setStorageObject(A, e, g);
        }
      }, _clearItems = function(A, e) {
        _setStorageObject(A, e, null);
      }, _callStorageFunction = function(A, e, t) {
        var g, o = null;
        void 0 === t && (t = ["web", "flash"]);
        var I = false, i2 = null;
        for (var r in t) {
          g = t[r];
          try {
            if ("flash" === g || "both" === g) {
              if (null === e[0])
                throw new Error("Flash local storage not available.");
              o = A.apply(this, e), I = "flash" === g;
            }
            "web" !== g && "both" !== g || (e[0] = localStorage, o = A.apply(this, e), I = true);
          } catch (A2) {
            i2 = A2;
          }
          if (I)
            break;
        }
        if (!I)
          throw i2;
        return o;
      };
      util$5.setItem = function(A, e, t, g, o) {
        _callStorageFunction(_setItem, arguments, o);
      }, util$5.getItem = function(A, e, t, g) {
        return _callStorageFunction(_getItem, arguments, g);
      }, util$5.removeItem = function(A, e, t, g) {
        _callStorageFunction(_removeItem, arguments, g);
      }, util$5.clearItems = function(A, e, t) {
        _callStorageFunction(_clearItems, arguments, t);
      }, util$5.isEmpty = function(A) {
        for (var e in A)
          if (A.hasOwnProperty(e))
            return false;
        return true;
      }, util$5.format = function(A) {
        for (var e, t, g = /%./g, o = 0, I = [], i2 = 0; e = g.exec(A); ) {
          (t = A.substring(i2, g.lastIndex - 2)).length > 0 && I.push(t), i2 = g.lastIndex;
          var r = e[0][1];
          switch (r) {
            case "s":
            case "o":
              o < arguments.length ? I.push(arguments[1 + o++]) : I.push("<?>");
              break;
            case "%":
              I.push("%");
              break;
            default:
              I.push("<%" + r + "?>");
          }
        }
        return I.push(A.substring(i2)), I.join("");
      }, util$5.formatNumber = function(A, e, t, g) {
        var o = A, I = isNaN(e = Math.abs(e)) ? 2 : e, i2 = void 0 === t ? "," : t, r = void 0 === g ? "." : g, n = o < 0 ? "-" : "", C = parseInt(o = Math.abs(+o || 0).toFixed(I), 10) + "", E = C.length > 3 ? C.length % 3 : 0;
        return n + (E ? C.substr(0, E) + r : "") + C.substr(E).replace(/(\d{3})(?=\d)/g, "$1" + r) + (I ? i2 + Math.abs(o - C).toFixed(I).slice(2) : "");
      }, util$5.formatSize = function(A) {
        return A = A >= 1073741824 ? util$5.formatNumber(A / 1073741824, 2, ".", "") + " GiB" : A >= 1048576 ? util$5.formatNumber(A / 1048576, 2, ".", "") + " MiB" : A >= 1024 ? util$5.formatNumber(A / 1024, 0) + " KiB" : util$5.formatNumber(A, 0) + " bytes";
      }, util$5.bytesFromIP = function(A) {
        return -1 !== A.indexOf(".") ? util$5.bytesFromIPv4(A) : -1 !== A.indexOf(":") ? util$5.bytesFromIPv6(A) : null;
      }, util$5.bytesFromIPv4 = function(A) {
        if (4 !== (A = A.split(".")).length)
          return null;
        for (var e = util$5.createBuffer(), t = 0; t < A.length; ++t) {
          var g = parseInt(A[t], 10);
          if (isNaN(g))
            return null;
          e.putByte(g);
        }
        return e.getBytes();
      }, util$5.bytesFromIPv6 = function(A) {
        for (var e = 0, t = 2 * (8 - (A = A.split(":").filter(function(A2) {
          return 0 === A2.length && ++e, true;
        })).length + e), g = util$5.createBuffer(), o = 0; o < 8; ++o)
          if (A[o] && 0 !== A[o].length) {
            var I = util$5.hexToBytes(A[o]);
            I.length < 2 && g.putByte(0), g.putBytes(I);
          } else
            g.fillWithByte(0, t), t = 0;
        return g.getBytes();
      }, util$5.bytesToIP = function(A) {
        return 4 === A.length ? util$5.bytesToIPv4(A) : 16 === A.length ? util$5.bytesToIPv6(A) : null;
      }, util$5.bytesToIPv4 = function(A) {
        if (4 !== A.length)
          return null;
        for (var e = [], t = 0; t < A.length; ++t)
          e.push(A.charCodeAt(t));
        return e.join(".");
      }, util$5.bytesToIPv6 = function(A) {
        if (16 !== A.length)
          return null;
        for (var e = [], t = [], g = 0, o = 0; o < A.length; o += 2) {
          for (var I = util$5.bytesToHex(A[o] + A[o + 1]); "0" === I[0] && "0" !== I; )
            I = I.substr(1);
          if ("0" === I) {
            var i2 = t[t.length - 1], r = e.length;
            i2 && r === i2.end + 1 ? (i2.end = r, i2.end - i2.start > t[g].end - t[g].start && (g = t.length - 1)) : t.push({ start: r, end: r });
          }
          e.push(I);
        }
        if (t.length > 0) {
          var n = t[g];
          n.end - n.start > 0 && (e.splice(n.start, n.end - n.start + 1, ""), 0 === n.start && e.unshift(""), 7 === n.end && e.push(""));
        }
        return e.join(":");
      }, util$5.estimateCores = function(A, e) {
        if ("function" == typeof A && (e = A, A = {}), A = A || {}, "cores" in util$5 && !A.update)
          return e(null, util$5.cores);
        if ("undefined" != typeof navigator && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0)
          return util$5.cores = navigator.hardwareConcurrency, e(null, util$5.cores);
        if ("undefined" == typeof Worker)
          return util$5.cores = 1, e(null, util$5.cores);
        if ("undefined" == typeof Blob)
          return util$5.cores = 2, e(null, util$5.cores);
        var t = URL.createObjectURL(new Blob(["(", (function() {
          self.addEventListener("message", function(A2) {
            var e2 = Date.now(), t2 = e2 + 4;
            self.postMessage({ st: e2, et: t2 });
          });
        }).toString(), ")()"], { type: "application/javascript" }));
        !function A2(g, o, I) {
          if (0 === o) {
            var i2 = Math.floor(g.reduce(function(A3, e2) {
              return A3 + e2;
            }, 0) / g.length);
            return util$5.cores = Math.max(1, i2), URL.revokeObjectURL(t), e(null, util$5.cores);
          }
          !function(A3, e2) {
            for (var g2 = [], o2 = [], I2 = 0; I2 < A3; ++I2) {
              var i3 = new Worker(t);
              i3.addEventListener("message", function(t2) {
                if (o2.push(t2.data), o2.length === A3) {
                  for (var I3 = 0; I3 < A3; ++I3)
                    g2[I3].terminate();
                  e2(null, o2);
                }
              }), g2.push(i3);
            }
            for (I2 = 0; I2 < A3; ++I2)
              g2[I2].postMessage(I2);
          }(I, function(e2, t2) {
            g.push(function(A3, e3) {
              for (var t3 = [], g2 = 0; g2 < A3; ++g2)
                for (var o2 = e3[g2], I2 = t3[g2] = [], i3 = 0; i3 < A3; ++i3)
                  if (g2 !== i3) {
                    var r = e3[i3];
                    (o2.st > r.st && o2.st < r.et || r.st > o2.st && r.st < o2.et) && I2.push(i3);
                  }
              return t3.reduce(function(A4, e4) {
                return Math.max(A4, e4.length);
              }, 0);
            }(I, t2)), A2(g, o - 1, I);
          });
        }([], 5, 16);
      };
      var utilExports = util$7.exports, util$6 = getDefaultExportFromCjs(utilExports), forge$6 = forge$8, cipher = forge$6.cipher = forge$6.cipher || {};
      forge$6.cipher.algorithms = forge$6.cipher.algorithms || {}, forge$6.cipher.createCipher = function(A, e) {
        var t = A;
        if ("string" == typeof t && (t = forge$6.cipher.getAlgorithm(t)) && (t = t()), !t)
          throw new Error("Unsupported algorithm: " + A);
        return new forge$6.cipher.BlockCipher({ algorithm: t, key: e, decrypt: false });
      }, forge$6.cipher.createDecipher = function(A, e) {
        var t = A;
        if ("string" == typeof t && (t = forge$6.cipher.getAlgorithm(t)) && (t = t()), !t)
          throw new Error("Unsupported algorithm: " + A);
        return new forge$6.cipher.BlockCipher({ algorithm: t, key: e, decrypt: true });
      }, forge$6.cipher.registerAlgorithm = function(A, e) {
        A = A.toUpperCase(), forge$6.cipher.algorithms[A] = e;
      }, forge$6.cipher.getAlgorithm = function(A) {
        return (A = A.toUpperCase()) in forge$6.cipher.algorithms ? forge$6.cipher.algorithms[A] : null;
      };
      var BlockCipher = forge$6.cipher.BlockCipher = function(A) {
        this.algorithm = A.algorithm, this.mode = this.algorithm.mode, this.blockSize = this.mode.blockSize, this._finish = false, this._input = null, this.output = null, this._op = A.decrypt ? this.mode.decrypt : this.mode.encrypt, this._decrypt = A.decrypt, this.algorithm.initialize(A);
      };
      BlockCipher.prototype.start = function(A) {
        A = A || {};
        var e = {};
        for (var t in A)
          e[t] = A[t];
        e.decrypt = this._decrypt, this._finish = false, this._input = forge$6.util.createBuffer(), this.output = A.output || forge$6.util.createBuffer(), this.mode.start(e);
      }, BlockCipher.prototype.update = function(A) {
        for (A && this._input.putBuffer(A); !this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish; )
          ;
        this._input.compact();
      }, BlockCipher.prototype.finish = function(A) {
        !A || "ECB" !== this.mode.name && "CBC" !== this.mode.name || (this.mode.pad = function(e2) {
          return A(this.blockSize, e2, false);
        }, this.mode.unpad = function(e2) {
          return A(this.blockSize, e2, true);
        });
        var e = {};
        return e.decrypt = this._decrypt, e.overflow = this._input.length() % this.blockSize, !(!this._decrypt && this.mode.pad && !this.mode.pad(this._input, e)) && (this._finish = true, this.update(), !(this._decrypt && this.mode.unpad && !this.mode.unpad(this.output, e)) && !(this.mode.afterFinish && !this.mode.afterFinish(this.output, e)));
      };
      var forgeCipher = getDefaultExportFromCjs(cipher), forge$5 = forge$8;
      forge$5.md = forge$5.md || {}, forge$5.md.algorithms = forge$5.md.algorithms || {};
      var forge$4 = forge$8, sha256 = forge$4.sha256 = forge$4.sha256 || {};
      forge$4.md.sha256 = forge$4.md.algorithms.sha256 = sha256, sha256.create = function() {
        _initialized || _init();
        var A = null, e = forge$4.util.createBuffer(), t = new Array(64), g = { algorithm: "sha256", blockLength: 64, digestLength: 32, messageLength: 0, fullMessageLength: null, messageLengthSize: 8, start: function() {
          g.messageLength = 0, g.fullMessageLength = g.messageLength64 = [];
          for (var t2 = g.messageLengthSize / 4, o = 0; o < t2; ++o)
            g.fullMessageLength.push(0);
          return e = forge$4.util.createBuffer(), A = { h0: 1779033703, h1: 3144134277, h2: 1013904242, h3: 2773480762, h4: 1359893119, h5: 2600822924, h6: 528734635, h7: 1541459225 }, g;
        } };
        return g.start(), g.update = function(o, I) {
          "utf8" === I && (o = forge$4.util.encodeUtf8(o));
          var i2 = o.length;
          g.messageLength += i2, i2 = [i2 / 4294967296 >>> 0, i2 >>> 0];
          for (var r = g.fullMessageLength.length - 1; r >= 0; --r)
            g.fullMessageLength[r] += i2[1], i2[1] = i2[0] + (g.fullMessageLength[r] / 4294967296 >>> 0), g.fullMessageLength[r] = g.fullMessageLength[r] >>> 0, i2[0] = i2[1] / 4294967296 >>> 0;
          return e.putBytes(o), _update(A, t, e), (e.read > 2048 || 0 === e.length()) && e.compact(), g;
        }, g.digest = function() {
          var o = forge$4.util.createBuffer();
          o.putBytes(e.bytes());
          var I, i2 = g.fullMessageLength[g.fullMessageLength.length - 1] + g.messageLengthSize & g.blockLength - 1;
          o.putBytes(_padding.substr(0, g.blockLength - i2));
          for (var r = 8 * g.fullMessageLength[0], n = 0; n < g.fullMessageLength.length - 1; ++n)
            r += (I = 8 * g.fullMessageLength[n + 1]) / 4294967296 >>> 0, o.putInt32(r >>> 0), r = I >>> 0;
          o.putInt32(r);
          var C = { h0: A.h0, h1: A.h1, h2: A.h2, h3: A.h3, h4: A.h4, h5: A.h5, h6: A.h6, h7: A.h7 };
          _update(C, t, o);
          var E = forge$4.util.createBuffer();
          return E.putInt32(C.h0), E.putInt32(C.h1), E.putInt32(C.h2), E.putInt32(C.h3), E.putInt32(C.h4), E.putInt32(C.h5), E.putInt32(C.h6), E.putInt32(C.h7), E;
        }, g;
      };
      var _padding = null, _initialized = false, _k = null;
      function _init() {
        _padding = String.fromCharCode(128), _padding += forge$4.util.fillString(String.fromCharCode(0), 64), _k = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], _initialized = true;
      }
      function _update(A, e, t) {
        for (var g, o, I, i2, r, n, C, E, s, B, a, Q, c, l = t.length(); l >= 64; ) {
          for (r = 0; r < 16; ++r)
            e[r] = t.getInt32();
          for (; r < 64; ++r)
            g = ((g = e[r - 2]) >>> 17 | g << 15) ^ (g >>> 19 | g << 13) ^ g >>> 10, o = ((o = e[r - 15]) >>> 7 | o << 25) ^ (o >>> 18 | o << 14) ^ o >>> 3, e[r] = g + e[r - 7] + o + e[r - 16] | 0;
          for (n = A.h0, C = A.h1, E = A.h2, s = A.h3, B = A.h4, a = A.h5, Q = A.h6, c = A.h7, r = 0; r < 64; ++r)
            I = (n >>> 2 | n << 30) ^ (n >>> 13 | n << 19) ^ (n >>> 22 | n << 10), i2 = n & C | E & (n ^ C), g = c + ((B >>> 6 | B << 26) ^ (B >>> 11 | B << 21) ^ (B >>> 25 | B << 7)) + (Q ^ B & (a ^ Q)) + _k[r] + e[r], c = Q, Q = a, a = B, B = s + g >>> 0, s = E, E = C, C = n, n = g + (o = I + i2) >>> 0;
          A.h0 = A.h0 + n | 0, A.h1 = A.h1 + C | 0, A.h2 = A.h2 + E | 0, A.h3 = A.h3 + s | 0, A.h4 = A.h4 + B | 0, A.h5 = A.h5 + a | 0, A.h6 = A.h6 + Q | 0, A.h7 = A.h7 + c | 0, l -= 64;
        }
      }
      var forge$3 = forge$8, hmac = forge$3.hmac = forge$3.hmac || {};
      hmac.create = function() {
        var A = null, e = null, t = null, g = null, o = { start: function(o2, I) {
          if (null !== o2)
            if ("string" == typeof o2) {
              if (!((o2 = o2.toLowerCase()) in forge$3.md.algorithms))
                throw new Error('Unknown hash algorithm "' + o2 + '"');
              e = forge$3.md.algorithms[o2].create();
            } else
              e = o2;
          if (null === I)
            I = A;
          else {
            if ("string" == typeof I)
              I = forge$3.util.createBuffer(I);
            else if (forge$3.util.isArray(I)) {
              var i2 = I;
              I = forge$3.util.createBuffer();
              for (var r = 0; r < i2.length; ++r)
                I.putByte(i2[r]);
            }
            var n = I.length();
            n > e.blockLength && (e.start(), e.update(I.bytes()), I = e.digest()), t = forge$3.util.createBuffer(), g = forge$3.util.createBuffer(), n = I.length();
            for (r = 0; r < n; ++r) {
              i2 = I.at(r);
              t.putByte(54 ^ i2), g.putByte(92 ^ i2);
            }
            if (n < e.blockLength)
              for (i2 = e.blockLength - n, r = 0; r < i2; ++r)
                t.putByte(54), g.putByte(92);
            A = I, t = t.bytes(), g = g.bytes();
          }
          e.start(), e.update(t);
        }, update: function(A2) {
          e.update(A2);
        }, getMac: function() {
          var A2 = e.digest().bytes();
          return e.start(), e.update(g), e.update(A2), e.digest();
        } };
        return o.digest = o.getMac, o;
      };
      var _nodeResolve_empty = {}, _nodeResolve_empty$1 = Object.freeze({ __proto__: null, default: _nodeResolve_empty }), require$$4 = getAugmentedNamespace(_nodeResolve_empty$1), forge$2 = forge$8, pkcs5 = forge$2.pkcs5 = forge$2.pkcs5 || {}, crypto$1;
      forge$2.util.isNodejs && !forge$2.options.usePureJavaScript && (crypto$1 = require$$4);
      var pbkdf2 = forge$2.pbkdf2 = pkcs5.pbkdf2 = function(A, e, t, g, o, I) {
        if ("function" == typeof o && (I = o, o = null), forge$2.util.isNodejs && !forge$2.options.usePureJavaScript && crypto$1.pbkdf2 && (null === o || "object" != typeof o) && (crypto$1.pbkdf2Sync.length > 4 || !o || "sha1" === o))
          return "string" != typeof o && (o = "sha1"), A = Buffer.from(A, "binary"), e = Buffer.from(e, "binary"), I ? 4 === crypto$1.pbkdf2Sync.length ? crypto$1.pbkdf2(A, e, t, g, function(A2, e2) {
            if (A2)
              return I(A2);
            I(null, e2.toString("binary"));
          }) : crypto$1.pbkdf2(A, e, t, g, o, function(A2, e2) {
            if (A2)
              return I(A2);
            I(null, e2.toString("binary"));
          }) : 4 === crypto$1.pbkdf2Sync.length ? crypto$1.pbkdf2Sync(A, e, t, g).toString("binary") : crypto$1.pbkdf2Sync(A, e, t, g, o).toString("binary");
        if (null == o && (o = "sha1"), "string" == typeof o) {
          if (!(o in forge$2.md.algorithms))
            throw new Error("Unknown hash algorithm: " + o);
          o = forge$2.md[o].create();
        }
        var i2 = o.digestLength;
        if (g > 4294967295 * i2) {
          var r = new Error("Derived key is too long.");
          if (I)
            return I(r);
          throw r;
        }
        var n = Math.ceil(g / i2), C = g - (n - 1) * i2, E = forge$2.hmac.create();
        E.start(o, A);
        var s, B, a, Q = "";
        if (!I) {
          for (var c = 1; c <= n; ++c) {
            E.start(null, null), E.update(e), E.update(forge$2.util.int32ToBytes(c)), s = a = E.digest().getBytes();
            for (var l = 2; l <= t; ++l)
              E.start(null, null), E.update(a), B = E.digest().getBytes(), s = forge$2.util.xorBytes(s, B, i2), a = B;
            Q += c < n ? s : s.substr(0, C);
          }
          return Q;
        }
        c = 1;
        function h() {
          if (c > n)
            return I(null, Q);
          E.start(null, null), E.update(e), E.update(forge$2.util.int32ToBytes(c)), s = a = E.digest().getBytes(), l = 2, u();
        }
        function u() {
          if (l <= t)
            return E.start(null, null), E.update(a), B = E.digest().getBytes(), s = forge$2.util.xorBytes(s, B, i2), a = B, ++l, forge$2.util.setImmediate(u);
          Q += c < n ? s : s.substr(0, C), ++c, h();
        }
        h();
      }, pkcs5$1 = getDefaultExportFromCjs(pbkdf2), forge$1 = forge$8;
      forge$1.cipher = forge$1.cipher || {};
      var modes = forge$1.cipher.modes = forge$1.cipher.modes || {};
      function transformIV(A, e) {
        if ("string" == typeof A && (A = forge$1.util.createBuffer(A)), forge$1.util.isArray(A) && A.length > 4) {
          var t = A;
          A = forge$1.util.createBuffer();
          for (var g = 0; g < t.length; ++g)
            A.putByte(t[g]);
        }
        if (A.length() < e)
          throw new Error("Invalid IV length; got " + A.length() + " bytes and expected " + e + " bytes.");
        if (!forge$1.util.isArray(A)) {
          var o = [], I = e / 4;
          for (g = 0; g < I; ++g)
            o.push(A.getInt32());
          A = o;
        }
        return A;
      }
      function inc32(A) {
        A[A.length - 1] = A[A.length - 1] + 1 & 4294967295;
      }
      function from64To32(A) {
        return [A / 4294967296 | 0, 4294967295 & A];
      }
      modes.ecb = function(A) {
        A = A || {}, this.name = "ECB", this.cipher = A.cipher, this.blockSize = A.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints);
      }, modes.ecb.prototype.start = function(A) {
      }, modes.ecb.prototype.encrypt = function(A, e, t) {
        if (A.length() < this.blockSize && !(t && A.length() > 0))
          return true;
        for (var g = 0; g < this._ints; ++g)
          this._inBlock[g] = A.getInt32();
        this.cipher.encrypt(this._inBlock, this._outBlock);
        for (g = 0; g < this._ints; ++g)
          e.putInt32(this._outBlock[g]);
      }, modes.ecb.prototype.decrypt = function(A, e, t) {
        if (A.length() < this.blockSize && !(t && A.length() > 0))
          return true;
        for (var g = 0; g < this._ints; ++g)
          this._inBlock[g] = A.getInt32();
        this.cipher.decrypt(this._inBlock, this._outBlock);
        for (g = 0; g < this._ints; ++g)
          e.putInt32(this._outBlock[g]);
      }, modes.ecb.prototype.pad = function(A, e) {
        var t = A.length() === this.blockSize ? this.blockSize : this.blockSize - A.length();
        return A.fillWithByte(t, t), true;
      }, modes.ecb.prototype.unpad = function(A, e) {
        if (e.overflow > 0)
          return false;
        var t = A.length(), g = A.at(t - 1);
        return !(g > this.blockSize << 2) && (A.truncate(g), true);
      }, modes.cbc = function(A) {
        A = A || {}, this.name = "CBC", this.cipher = A.cipher, this.blockSize = A.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints);
      }, modes.cbc.prototype.start = function(A) {
        if (null === A.iv) {
          if (!this._prev)
            throw new Error("Invalid IV parameter.");
          this._iv = this._prev.slice(0);
        } else {
          if (!("iv" in A))
            throw new Error("Invalid IV parameter.");
          this._iv = transformIV(A.iv, this.blockSize), this._prev = this._iv.slice(0);
        }
      }, modes.cbc.prototype.encrypt = function(A, e, t) {
        if (A.length() < this.blockSize && !(t && A.length() > 0))
          return true;
        for (var g = 0; g < this._ints; ++g)
          this._inBlock[g] = this._prev[g] ^ A.getInt32();
        this.cipher.encrypt(this._inBlock, this._outBlock);
        for (g = 0; g < this._ints; ++g)
          e.putInt32(this._outBlock[g]);
        this._prev = this._outBlock;
      }, modes.cbc.prototype.decrypt = function(A, e, t) {
        if (A.length() < this.blockSize && !(t && A.length() > 0))
          return true;
        for (var g = 0; g < this._ints; ++g)
          this._inBlock[g] = A.getInt32();
        this.cipher.decrypt(this._inBlock, this._outBlock);
        for (g = 0; g < this._ints; ++g)
          e.putInt32(this._prev[g] ^ this._outBlock[g]);
        this._prev = this._inBlock.slice(0);
      }, modes.cbc.prototype.pad = function(A, e) {
        var t = A.length() === this.blockSize ? this.blockSize : this.blockSize - A.length();
        return A.fillWithByte(t, t), true;
      }, modes.cbc.prototype.unpad = function(A, e) {
        if (e.overflow > 0)
          return false;
        var t = A.length(), g = A.at(t - 1);
        return !(g > this.blockSize << 2) && (A.truncate(g), true);
      }, modes.cfb = function(A) {
        A = A || {}, this.name = "CFB", this.cipher = A.cipher, this.blockSize = A.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialBlock = new Array(this._ints), this._partialOutput = forge$1.util.createBuffer(), this._partialBytes = 0;
      }, modes.cfb.prototype.start = function(A) {
        if (!("iv" in A))
          throw new Error("Invalid IV parameter.");
        this._iv = transformIV(A.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0;
      }, modes.cfb.prototype.encrypt = function(A, e, t) {
        var g = A.length();
        if (0 === g)
          return true;
        if (this.cipher.encrypt(this._inBlock, this._outBlock), 0 === this._partialBytes && g >= this.blockSize)
          for (var o = 0; o < this._ints; ++o)
            this._inBlock[o] = A.getInt32() ^ this._outBlock[o], e.putInt32(this._inBlock[o]);
        else {
          var I = (this.blockSize - g) % this.blockSize;
          I > 0 && (I = this.blockSize - I), this._partialOutput.clear();
          for (o = 0; o < this._ints; ++o)
            this._partialBlock[o] = A.getInt32() ^ this._outBlock[o], this._partialOutput.putInt32(this._partialBlock[o]);
          if (I > 0)
            A.read -= this.blockSize;
          else
            for (o = 0; o < this._ints; ++o)
              this._inBlock[o] = this._partialBlock[o];
          if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), I > 0 && !t)
            return e.putBytes(this._partialOutput.getBytes(I - this._partialBytes)), this._partialBytes = I, true;
          e.putBytes(this._partialOutput.getBytes(g - this._partialBytes)), this._partialBytes = 0;
        }
      }, modes.cfb.prototype.decrypt = function(A, e, t) {
        var g = A.length();
        if (0 === g)
          return true;
        if (this.cipher.encrypt(this._inBlock, this._outBlock), 0 === this._partialBytes && g >= this.blockSize)
          for (var o = 0; o < this._ints; ++o)
            this._inBlock[o] = A.getInt32(), e.putInt32(this._inBlock[o] ^ this._outBlock[o]);
        else {
          var I = (this.blockSize - g) % this.blockSize;
          I > 0 && (I = this.blockSize - I), this._partialOutput.clear();
          for (o = 0; o < this._ints; ++o)
            this._partialBlock[o] = A.getInt32(), this._partialOutput.putInt32(this._partialBlock[o] ^ this._outBlock[o]);
          if (I > 0)
            A.read -= this.blockSize;
          else
            for (o = 0; o < this._ints; ++o)
              this._inBlock[o] = this._partialBlock[o];
          if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), I > 0 && !t)
            return e.putBytes(this._partialOutput.getBytes(I - this._partialBytes)), this._partialBytes = I, true;
          e.putBytes(this._partialOutput.getBytes(g - this._partialBytes)), this._partialBytes = 0;
        }
      }, modes.ofb = function(A) {
        A = A || {}, this.name = "OFB", this.cipher = A.cipher, this.blockSize = A.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialOutput = forge$1.util.createBuffer(), this._partialBytes = 0;
      }, modes.ofb.prototype.start = function(A) {
        if (!("iv" in A))
          throw new Error("Invalid IV parameter.");
        this._iv = transformIV(A.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0;
      }, modes.ofb.prototype.encrypt = function(A, e, t) {
        var g = A.length();
        if (0 === A.length())
          return true;
        if (this.cipher.encrypt(this._inBlock, this._outBlock), 0 === this._partialBytes && g >= this.blockSize)
          for (var o = 0; o < this._ints; ++o)
            e.putInt32(A.getInt32() ^ this._outBlock[o]), this._inBlock[o] = this._outBlock[o];
        else {
          var I = (this.blockSize - g) % this.blockSize;
          I > 0 && (I = this.blockSize - I), this._partialOutput.clear();
          for (o = 0; o < this._ints; ++o)
            this._partialOutput.putInt32(A.getInt32() ^ this._outBlock[o]);
          if (I > 0)
            A.read -= this.blockSize;
          else
            for (o = 0; o < this._ints; ++o)
              this._inBlock[o] = this._outBlock[o];
          if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), I > 0 && !t)
            return e.putBytes(this._partialOutput.getBytes(I - this._partialBytes)), this._partialBytes = I, true;
          e.putBytes(this._partialOutput.getBytes(g - this._partialBytes)), this._partialBytes = 0;
        }
      }, modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt, modes.ctr = function(A) {
        A = A || {}, this.name = "CTR", this.cipher = A.cipher, this.blockSize = A.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialOutput = forge$1.util.createBuffer(), this._partialBytes = 0;
      }, modes.ctr.prototype.start = function(A) {
        if (!("iv" in A))
          throw new Error("Invalid IV parameter.");
        this._iv = transformIV(A.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0;
      }, modes.ctr.prototype.encrypt = function(A, e, t) {
        var g = A.length();
        if (0 === g)
          return true;
        if (this.cipher.encrypt(this._inBlock, this._outBlock), 0 === this._partialBytes && g >= this.blockSize)
          for (var o = 0; o < this._ints; ++o)
            e.putInt32(A.getInt32() ^ this._outBlock[o]);
        else {
          var I = (this.blockSize - g) % this.blockSize;
          I > 0 && (I = this.blockSize - I), this._partialOutput.clear();
          for (o = 0; o < this._ints; ++o)
            this._partialOutput.putInt32(A.getInt32() ^ this._outBlock[o]);
          if (I > 0 && (A.read -= this.blockSize), this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), I > 0 && !t)
            return e.putBytes(this._partialOutput.getBytes(I - this._partialBytes)), this._partialBytes = I, true;
          e.putBytes(this._partialOutput.getBytes(g - this._partialBytes)), this._partialBytes = 0;
        }
        inc32(this._inBlock);
      }, modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt, modes.gcm = function(A) {
        A = A || {}, this.name = "GCM", this.cipher = A.cipher, this.blockSize = A.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints), this._partialOutput = forge$1.util.createBuffer(), this._partialBytes = 0, this._R = 3774873600;
      }, modes.gcm.prototype.start = function(A) {
        if (!("iv" in A))
          throw new Error("Invalid IV parameter.");
        var e, t = forge$1.util.createBuffer(A.iv);
        if (this._cipherLength = 0, e = "additionalData" in A ? forge$1.util.createBuffer(A.additionalData) : forge$1.util.createBuffer(), this._tagLength = "tagLength" in A ? A.tagLength : 128, this._tag = null, A.decrypt && (this._tag = forge$1.util.createBuffer(A.tag).getBytes(), this._tag.length !== this._tagLength / 8))
          throw new Error("Authentication tag does not match tag length.");
        this._hashBlock = new Array(this._ints), this.tag = null, this._hashSubkey = new Array(this._ints), this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey), this.componentBits = 4, this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
        var g = t.length();
        if (12 === g)
          this._j0 = [t.getInt32(), t.getInt32(), t.getInt32(), 1];
        else {
          for (this._j0 = [0, 0, 0, 0]; t.length() > 0; )
            this._j0 = this.ghash(this._hashSubkey, this._j0, [t.getInt32(), t.getInt32(), t.getInt32(), t.getInt32()]);
          this._j0 = this.ghash(this._hashSubkey, this._j0, [0, 0].concat(from64To32(8 * g)));
        }
        this._inBlock = this._j0.slice(0), inc32(this._inBlock), this._partialBytes = 0, e = forge$1.util.createBuffer(e), this._aDataLength = from64To32(8 * e.length());
        var o = e.length() % this.blockSize;
        for (o && e.fillWithByte(0, this.blockSize - o), this._s = [0, 0, 0, 0]; e.length() > 0; )
          this._s = this.ghash(this._hashSubkey, this._s, [e.getInt32(), e.getInt32(), e.getInt32(), e.getInt32()]);
      }, modes.gcm.prototype.encrypt = function(A, e, t) {
        var g = A.length();
        if (0 === g)
          return true;
        if (this.cipher.encrypt(this._inBlock, this._outBlock), 0 === this._partialBytes && g >= this.blockSize) {
          for (var o = 0; o < this._ints; ++o)
            e.putInt32(this._outBlock[o] ^= A.getInt32());
          this._cipherLength += this.blockSize;
        } else {
          var I = (this.blockSize - g) % this.blockSize;
          I > 0 && (I = this.blockSize - I), this._partialOutput.clear();
          for (o = 0; o < this._ints; ++o)
            this._partialOutput.putInt32(A.getInt32() ^ this._outBlock[o]);
          if (I <= 0 || t) {
            if (t) {
              var i2 = g % this.blockSize;
              this._cipherLength += i2, this._partialOutput.truncate(this.blockSize - i2);
            } else
              this._cipherLength += this.blockSize;
            for (o = 0; o < this._ints; ++o)
              this._outBlock[o] = this._partialOutput.getInt32();
            this._partialOutput.read -= this.blockSize;
          }
          if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), I > 0 && !t)
            return A.read -= this.blockSize, e.putBytes(this._partialOutput.getBytes(I - this._partialBytes)), this._partialBytes = I, true;
          e.putBytes(this._partialOutput.getBytes(g - this._partialBytes)), this._partialBytes = 0;
        }
        this._s = this.ghash(this._hashSubkey, this._s, this._outBlock), inc32(this._inBlock);
      }, modes.gcm.prototype.decrypt = function(A, e, t) {
        var g = A.length();
        if (g < this.blockSize && !(t && g > 0))
          return true;
        this.cipher.encrypt(this._inBlock, this._outBlock), inc32(this._inBlock), this._hashBlock[0] = A.getInt32(), this._hashBlock[1] = A.getInt32(), this._hashBlock[2] = A.getInt32(), this._hashBlock[3] = A.getInt32(), this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
        for (var o = 0; o < this._ints; ++o)
          e.putInt32(this._outBlock[o] ^ this._hashBlock[o]);
        g < this.blockSize ? this._cipherLength += g % this.blockSize : this._cipherLength += this.blockSize;
      }, modes.gcm.prototype.afterFinish = function(A, e) {
        var t = true;
        e.decrypt && e.overflow && A.truncate(this.blockSize - e.overflow), this.tag = forge$1.util.createBuffer();
        var g = this._aDataLength.concat(from64To32(8 * this._cipherLength));
        this._s = this.ghash(this._hashSubkey, this._s, g);
        var o = [];
        this.cipher.encrypt(this._j0, o);
        for (var I = 0; I < this._ints; ++I)
          this.tag.putInt32(this._s[I] ^ o[I]);
        return this.tag.truncate(this.tag.length() % (this._tagLength / 8)), e.decrypt && this.tag.bytes() !== this._tag && (t = false), t;
      }, modes.gcm.prototype.multiply = function(A, e) {
        for (var t = [0, 0, 0, 0], g = e.slice(0), o = 0; o < 128; ++o) {
          A[o / 32 | 0] & 1 << 31 - o % 32 && (t[0] ^= g[0], t[1] ^= g[1], t[2] ^= g[2], t[3] ^= g[3]), this.pow(g, g);
        }
        return t;
      }, modes.gcm.prototype.pow = function(A, e) {
        for (var t = 1 & A[3], g = 3; g > 0; --g)
          e[g] = A[g] >>> 1 | (1 & A[g - 1]) << 31;
        e[0] = A[0] >>> 1, t && (e[0] ^= this._R);
      }, modes.gcm.prototype.tableMultiply = function(A) {
        for (var e = [0, 0, 0, 0], t = 0; t < 32; ++t) {
          var g = A[t / 8 | 0] >>> 4 * (7 - t % 8) & 15, o = this._m[t][g];
          e[0] ^= o[0], e[1] ^= o[1], e[2] ^= o[2], e[3] ^= o[3];
        }
        return e;
      }, modes.gcm.prototype.ghash = function(A, e, t) {
        return e[0] ^= t[0], e[1] ^= t[1], e[2] ^= t[2], e[3] ^= t[3], this.tableMultiply(e);
      }, modes.gcm.prototype.generateHashTable = function(A, e) {
        for (var t = 8 / e, g = 4 * t, o = 16 * t, I = new Array(o), i2 = 0; i2 < o; ++i2) {
          var r = [0, 0, 0, 0], n = (g - 1 - i2 % g) * e;
          r[i2 / g | 0] = 1 << e - 1 << n, I[i2] = this.generateSubHashTable(this.multiply(r, A), e);
        }
        return I;
      }, modes.gcm.prototype.generateSubHashTable = function(A, e) {
        var t = 1 << e, g = t >>> 1, o = new Array(t);
        o[g] = A.slice(0);
        for (var I = g >>> 1; I > 0; )
          this.pow(o[2 * I], o[I] = []), I >>= 1;
        for (I = 2; I < g; ) {
          for (var i2 = 1; i2 < I; ++i2) {
            var r = o[I], n = o[i2];
            o[I + i2] = [r[0] ^ n[0], r[1] ^ n[1], r[2] ^ n[2], r[3] ^ n[3]];
          }
          I *= 2;
        }
        for (o[0] = [0, 0, 0, 0], I = g + 1; I < t; ++I) {
          var C = o[I ^ g];
          o[I] = [A[0] ^ C[0], A[1] ^ C[1], A[2] ^ C[2], A[3] ^ C[3]];
        }
        return o;
      };
      var forge = forge$8;
      function registerAlgorithm(A, e) {
        forge.cipher.registerAlgorithm(A, function() {
          return new forge.aes.Algorithm(A, e);
        });
      }
      forge.aes = forge.aes || {}, forge.aes.startEncrypting = function(A, e, t, g) {
        var o = _createCipher({ key: A, output: t, decrypt: false, mode: g });
        return o.start(e), o;
      }, forge.aes.createEncryptionCipher = function(A, e) {
        return _createCipher({ key: A, output: null, decrypt: false, mode: e });
      }, forge.aes.startDecrypting = function(A, e, t, g) {
        var o = _createCipher({ key: A, output: t, decrypt: true, mode: g });
        return o.start(e), o;
      }, forge.aes.createDecryptionCipher = function(A, e) {
        return _createCipher({ key: A, output: null, decrypt: true, mode: e });
      }, forge.aes.Algorithm = function(A, e) {
        init || initialize();
        var t = this;
        t.name = A, t.mode = new e({ blockSize: 16, cipher: { encrypt: function(A2, e2) {
          return _updateBlock(t._w, A2, e2, false);
        }, decrypt: function(A2, e2) {
          return _updateBlock(t._w, A2, e2, true);
        } } }), t._init = false;
      }, forge.aes.Algorithm.prototype.initialize = function(A) {
        if (!this._init) {
          var e, t = A.key;
          if ("string" != typeof t || 16 !== t.length && 24 !== t.length && 32 !== t.length) {
            if (forge.util.isArray(t) && (16 === t.length || 24 === t.length || 32 === t.length)) {
              e = t, t = forge.util.createBuffer();
              for (var g = 0; g < e.length; ++g)
                t.putByte(e[g]);
            }
          } else
            t = forge.util.createBuffer(t);
          if (!forge.util.isArray(t)) {
            e = t, t = [];
            var o = e.length();
            if (16 === o || 24 === o || 32 === o) {
              o >>>= 2;
              for (g = 0; g < o; ++g)
                t.push(e.getInt32());
            }
          }
          if (!forge.util.isArray(t) || 4 !== t.length && 6 !== t.length && 8 !== t.length)
            throw new Error("Invalid key parameter.");
          var I = this.mode.name, i2 = -1 !== ["CFB", "OFB", "CTR", "GCM"].indexOf(I);
          this._w = _expandKey(t, A.decrypt && !i2), this._init = true;
        }
      }, forge.aes._expandKey = function(A, e) {
        return init || initialize(), _expandKey(A, e);
      }, forge.aes._updateBlock = _updateBlock, registerAlgorithm("AES-ECB", forge.cipher.modes.ecb), registerAlgorithm("AES-CBC", forge.cipher.modes.cbc), registerAlgorithm("AES-CFB", forge.cipher.modes.cfb), registerAlgorithm("AES-OFB", forge.cipher.modes.ofb), registerAlgorithm("AES-CTR", forge.cipher.modes.ctr), registerAlgorithm("AES-GCM", forge.cipher.modes.gcm);
      var init = false, Nb = 4, sbox, isbox, rcon, mix, imix;
      function initialize() {
        init = true, rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
        for (var A = new Array(256), e = 0; e < 128; ++e)
          A[e] = e << 1, A[e + 128] = e + 128 << 1 ^ 283;
        sbox = new Array(256), isbox = new Array(256), mix = new Array(4), imix = new Array(4);
        for (e = 0; e < 4; ++e)
          mix[e] = new Array(256), imix[e] = new Array(256);
        var t, g, o, I, i2, r, n, C = 0, E = 0;
        for (e = 0; e < 256; ++e) {
          I = (I = E ^ E << 1 ^ E << 2 ^ E << 3 ^ E << 4) >> 8 ^ 255 & I ^ 99, sbox[C] = I, isbox[I] = C, r = (i2 = A[I]) << 24 ^ I << 16 ^ I << 8 ^ I ^ i2, n = ((t = A[C]) ^ (g = A[t]) ^ (o = A[g])) << 24 ^ (C ^ o) << 16 ^ (C ^ g ^ o) << 8 ^ C ^ t ^ o;
          for (var s = 0; s < 4; ++s)
            mix[s][C] = r, imix[s][I] = n, r = r << 24 | r >>> 8, n = n << 24 | n >>> 8;
          0 === C ? C = E = 1 : (C = t ^ A[A[A[t ^ o]]], E ^= A[A[E]]);
        }
      }
      function _expandKey(A, e) {
        for (var t, g = A.slice(0), o = 1, I = g.length, i2 = Nb * (I + 6 + 1), r = I; r < i2; ++r)
          t = g[r - 1], r % I === 0 ? (t = sbox[t >>> 16 & 255] << 24 ^ sbox[t >>> 8 & 255] << 16 ^ sbox[255 & t] << 8 ^ sbox[t >>> 24] ^ rcon[o] << 24, o++) : I > 6 && r % I === 4 && (t = sbox[t >>> 24] << 24 ^ sbox[t >>> 16 & 255] << 16 ^ sbox[t >>> 8 & 255] << 8 ^ sbox[255 & t]), g[r] = g[r - I] ^ t;
        if (e) {
          for (var n, C = imix[0], E = imix[1], s = imix[2], B = imix[3], a = g.slice(0), Q = (r = 0, (i2 = g.length) - Nb); r < i2; r += Nb, Q -= Nb)
            if (0 === r || r === i2 - Nb)
              a[r] = g[Q], a[r + 1] = g[Q + 3], a[r + 2] = g[Q + 2], a[r + 3] = g[Q + 1];
            else
              for (var c = 0; c < Nb; ++c)
                n = g[Q + c], a[r + (3 & -c)] = C[sbox[n >>> 24]] ^ E[sbox[n >>> 16 & 255]] ^ s[sbox[n >>> 8 & 255]] ^ B[sbox[255 & n]];
          g = a;
        }
        return g;
      }
      function _updateBlock(A, e, t, g) {
        var o, I, i2, r, n, C, E, s, B, a, Q, c, l = A.length / 4 - 1;
        g ? (o = imix[0], I = imix[1], i2 = imix[2], r = imix[3], n = isbox) : (o = mix[0], I = mix[1], i2 = mix[2], r = mix[3], n = sbox), C = e[0] ^ A[0], E = e[g ? 3 : 1] ^ A[1], s = e[2] ^ A[2], B = e[g ? 1 : 3] ^ A[3];
        for (var h = 3, u = 1; u < l; ++u)
          a = o[C >>> 24] ^ I[E >>> 16 & 255] ^ i2[s >>> 8 & 255] ^ r[255 & B] ^ A[++h], Q = o[E >>> 24] ^ I[s >>> 16 & 255] ^ i2[B >>> 8 & 255] ^ r[255 & C] ^ A[++h], c = o[s >>> 24] ^ I[B >>> 16 & 255] ^ i2[C >>> 8 & 255] ^ r[255 & E] ^ A[++h], B = o[B >>> 24] ^ I[C >>> 16 & 255] ^ i2[E >>> 8 & 255] ^ r[255 & s] ^ A[++h], C = a, E = Q, s = c;
        t[0] = n[C >>> 24] << 24 ^ n[E >>> 16 & 255] << 16 ^ n[s >>> 8 & 255] << 8 ^ n[255 & B] ^ A[++h], t[g ? 3 : 1] = n[E >>> 24] << 24 ^ n[s >>> 16 & 255] << 16 ^ n[B >>> 8 & 255] << 8 ^ n[255 & C] ^ A[++h], t[2] = n[s >>> 24] << 24 ^ n[B >>> 16 & 255] << 16 ^ n[C >>> 8 & 255] << 8 ^ n[255 & E] ^ A[++h], t[g ? 1 : 3] = n[B >>> 24] << 24 ^ n[C >>> 16 & 255] << 16 ^ n[E >>> 8 & 255] << 8 ^ n[255 & s] ^ A[++h];
      }
      function _createCipher(A) {
        var e, t = "AES-" + ((A = A || {}).mode || "CBC").toUpperCase(), g = (e = A.decrypt ? forge.cipher.createDecipher(t, A.key) : forge.cipher.createCipher(t, A.key)).start;
        return e.start = function(A2, t2) {
          var o = null;
          t2 instanceof forge.util.ByteBuffer && (o = t2, t2 = {}), (t2 = t2 || {}).output = o, t2.iv = A2, g.call(e, t2);
        }, e;
      }
      function isNil(A) {
        return null == A;
      }
      var isNil_1 = isNil, isNil$1 = getDefaultExportFromCjs(isNil_1);
      function copyArray$3(A, e) {
        var t = -1, g = A.length;
        for (e || (e = Array(g)); ++t < g; )
          e[t] = A[t];
        return e;
      }
      var _copyArray = copyArray$3, nativeFloor = Math.floor, nativeRandom = Math.random;
      function baseRandom$2(A, e) {
        return A + nativeFloor(nativeRandom() * (e - A + 1));
      }
      var _baseRandom = baseRandom$2, baseRandom$1 = _baseRandom;
      function shuffleSelf$2(A, e) {
        var t = -1, g = A.length, o = g - 1;
        for (e = void 0 === e ? g : e; ++t < e; ) {
          var I = baseRandom$1(t, o), i2 = A[I];
          A[I] = A[t], A[t] = i2;
        }
        return A.length = e, A;
      }
      var _shuffleSelf = shuffleSelf$2, copyArray$2 = _copyArray, shuffleSelf$1 = _shuffleSelf;
      function arrayShuffle$1(A) {
        return shuffleSelf$1(copyArray$2(A));
      }
      var _arrayShuffle = arrayShuffle$1;
      function arrayMap$5(A, e) {
        for (var t = -1, g = null == A ? 0 : A.length, o = Array(g); ++t < g; )
          o[t] = e(A[t], t, A);
        return o;
      }
      var _arrayMap = arrayMap$5, arrayMap$4 = _arrayMap;
      function baseValues$1(A, e) {
        return arrayMap$4(e, function(e2) {
          return A[e2];
        });
      }
      var _baseValues = baseValues$1;
      function baseTimes$1(A, e) {
        for (var t = -1, g = Array(A); ++t < A; )
          g[t] = e(t);
        return g;
      }
      var _baseTimes = baseTimes$1, freeGlobal$1 = "object" == typeof commonjsGlobal && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal, _freeGlobal = freeGlobal$1, freeGlobal = _freeGlobal, freeSelf = "object" == typeof self && self && self.Object === Object && self, root$9 = freeGlobal || freeSelf || Function("return this")(), _root = root$9, root$8 = _root, Symbol$7 = root$8.Symbol, _Symbol = Symbol$7, Symbol$6 = _Symbol, objectProto$f = Object.prototype, hasOwnProperty$c = objectProto$f.hasOwnProperty, nativeObjectToString$1 = objectProto$f.toString, symToStringTag$1 = Symbol$6 ? Symbol$6.toStringTag : void 0;
      function getRawTag$1(A) {
        var e = hasOwnProperty$c.call(A, symToStringTag$1), t = A[symToStringTag$1];
        try {
          A[symToStringTag$1] = void 0;
          var g = true;
        } catch (A2) {
        }
        var o = nativeObjectToString$1.call(A);
        return g && (e ? A[symToStringTag$1] = t : delete A[symToStringTag$1]), o;
      }
      var _getRawTag = getRawTag$1, objectProto$e = Object.prototype, nativeObjectToString = objectProto$e.toString;
      function objectToString$1(A) {
        return nativeObjectToString.call(A);
      }
      var _objectToString = objectToString$1, Symbol$5 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString, nullTag = "[object Null]", undefinedTag = "[object Undefined]", symToStringTag = Symbol$5 ? Symbol$5.toStringTag : void 0;
      function baseGetTag$6(A) {
        return null == A ? void 0 === A ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(A) ? getRawTag(A) : objectToString(A);
      }
      var _baseGetTag = baseGetTag$6;
      function isObjectLike$9(A) {
        return null != A && "object" == typeof A;
      }
      var isObjectLike_1 = isObjectLike$9, baseGetTag$5 = _baseGetTag, isObjectLike$8 = isObjectLike_1, argsTag$3 = "[object Arguments]";
      function baseIsArguments$1(A) {
        return isObjectLike$8(A) && baseGetTag$5(A) == argsTag$3;
      }
      var _baseIsArguments = baseIsArguments$1, baseIsArguments = _baseIsArguments, isObjectLike$7 = isObjectLike_1, objectProto$d = Object.prototype, hasOwnProperty$b = objectProto$d.hasOwnProperty, propertyIsEnumerable$1 = objectProto$d.propertyIsEnumerable, isArguments$4 = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(A) {
        return isObjectLike$7(A) && hasOwnProperty$b.call(A, "callee") && !propertyIsEnumerable$1.call(A, "callee");
      }, isArguments_1 = isArguments$4, isArray$f = Array.isArray, isArray_1$1 = isArray$f, isBuffer$4 = { exports: {} };
      function stubFalse() {
        return false;
      }
      var stubFalse_1 = stubFalse;
      isBuffer$4.exports, function(A, e) {
        var t = _root, g = stubFalse_1, o = e && !e.nodeType && e, I = o && A && !A.nodeType && A, i2 = I && I.exports === o ? t.Buffer : void 0, r = (i2 ? i2.isBuffer : void 0) || g;
        A.exports = r;
      }(isBuffer$4, isBuffer$4.exports);
      var isBufferExports = isBuffer$4.exports, MAX_SAFE_INTEGER$1 = 9007199254740991, reIsUint = /^(?:0|[1-9]\d*)$/;
      function isIndex$4(A, e) {
        var t = typeof A;
        return !!(e = null == e ? MAX_SAFE_INTEGER$1 : e) && ("number" == t || "symbol" != t && reIsUint.test(A)) && A > -1 && A % 1 == 0 && A < e;
      }
      var _isIndex = isIndex$4, MAX_SAFE_INTEGER = 9007199254740991;
      function isLength$3(A) {
        return "number" == typeof A && A > -1 && A % 1 == 0 && A <= MAX_SAFE_INTEGER;
      }
      var isLength_1 = isLength$3, baseGetTag$4 = _baseGetTag, isLength$2 = isLength_1, isObjectLike$6 = isObjectLike_1, argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$2 = "[object Function]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", objectTag$4 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", weakMapTag$2 = "[object WeakMap]", arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]", typedArrayTags = {};
      function baseIsTypedArray$1(A) {
        return isObjectLike$6(A) && isLength$2(A.length) && !!typedArrayTags[baseGetTag$4(A)];
      }
      typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true, typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$2] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;
      var _baseIsTypedArray = baseIsTypedArray$1;
      function baseUnary$4(A) {
        return function(e) {
          return A(e);
        };
      }
      var _baseUnary = baseUnary$4, _nodeUtil = { exports: {} };
      _nodeUtil.exports, function(A, e) {
        var t = _freeGlobal, g = e && !e.nodeType && e, o = g && A && !A.nodeType && A, I = o && o.exports === g && t.process, i2 = function() {
          try {
            var A2 = o && o.require && o.require("util").types;
            return A2 || I && I.binding && I.binding("util");
          } catch (A3) {
          }
        }();
        A.exports = i2;
      }(_nodeUtil, _nodeUtil.exports);
      var _nodeUtilExports = _nodeUtil.exports, baseIsTypedArray = _baseIsTypedArray, baseUnary$3 = _baseUnary, nodeUtil$2 = _nodeUtilExports, nodeIsTypedArray = nodeUtil$2 && nodeUtil$2.isTypedArray, isTypedArray$3 = nodeIsTypedArray ? baseUnary$3(nodeIsTypedArray) : baseIsTypedArray, isTypedArray_1 = isTypedArray$3, baseTimes = _baseTimes, isArguments$3 = isArguments_1, isArray$e = isArray_1$1, isBuffer$3 = isBufferExports, isIndex$3 = _isIndex, isTypedArray$2 = isTypedArray_1, objectProto$c = Object.prototype, hasOwnProperty$a = objectProto$c.hasOwnProperty;
      function arrayLikeKeys$2(A, e) {
        var t = isArray$e(A), g = !t && isArguments$3(A), o = !t && !g && isBuffer$3(A), I = !t && !g && !o && isTypedArray$2(A), i2 = t || g || o || I, r = i2 ? baseTimes(A.length, String) : [], n = r.length;
        for (var C in A)
          !e && !hasOwnProperty$a.call(A, C) || i2 && ("length" == C || o && ("offset" == C || "parent" == C) || I && ("buffer" == C || "byteLength" == C || "byteOffset" == C) || isIndex$3(C, n)) || r.push(C);
        return r;
      }
      var _arrayLikeKeys = arrayLikeKeys$2, objectProto$b = Object.prototype;
      function isPrototype$3(A) {
        var e = A && A.constructor;
        return A === ("function" == typeof e && e.prototype || objectProto$b);
      }
      var _isPrototype = isPrototype$3;
      function overArg$2(A, e) {
        return function(t) {
          return A(e(t));
        };
      }
      var _overArg = overArg$2, overArg$1 = _overArg, nativeKeys$1 = overArg$1(Object.keys, Object), _nativeKeys = nativeKeys$1, isPrototype$2 = _isPrototype, nativeKeys = _nativeKeys, objectProto$a = Object.prototype, hasOwnProperty$9 = objectProto$a.hasOwnProperty;
      function baseKeys$1(A) {
        if (!isPrototype$2(A))
          return nativeKeys(A);
        var e = [];
        for (var t in Object(A))
          hasOwnProperty$9.call(A, t) && "constructor" != t && e.push(t);
        return e;
      }
      var _baseKeys = baseKeys$1;
      function isObject$d(A) {
        var e = typeof A;
        return null != A && ("object" == e || "function" == e);
      }
      var isObject_1$1 = isObject$d, baseGetTag$3 = _baseGetTag, isObject$c = isObject_1$1, asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
      function isFunction$6(A) {
        if (!isObject$c(A))
          return false;
        var e = baseGetTag$3(A);
        return e == funcTag$1 || e == genTag$1 || e == asyncTag || e == proxyTag;
      }
      var isFunction_1$1 = isFunction$6, isFunction$5 = isFunction_1$1, isLength$1 = isLength_1;
      function isArrayLike$8(A) {
        return null != A && isLength$1(A.length) && !isFunction$5(A);
      }
      var isArrayLike_1 = isArrayLike$8, arrayLikeKeys$1 = _arrayLikeKeys, baseKeys = _baseKeys, isArrayLike$7 = isArrayLike_1;
      function keys$7(A) {
        return isArrayLike$7(A) ? arrayLikeKeys$1(A) : baseKeys(A);
      }
      var keys_1 = keys$7, baseValues = _baseValues, keys$6 = keys_1;
      function values$2(A) {
        return null == A ? [] : baseValues(A, keys$6(A));
      }
      var values_1 = values$2, values$3 = getDefaultExportFromCjs(values_1), shuffleSelf = _shuffleSelf, values$1 = values_1;
      function baseShuffle$1(A) {
        return shuffleSelf(values$1(A));
      }
      var _baseShuffle = baseShuffle$1, arrayShuffle = _arrayShuffle, baseShuffle = _baseShuffle, isArray$d = isArray_1$1;
      function shuffle(A) {
        return (isArray$d(A) ? arrayShuffle : baseShuffle)(A);
      }
      var shuffle_1 = shuffle, shuffle$1 = getDefaultExportFromCjs(shuffle_1);
      function arraySome$1(A, e) {
        for (var t = -1, g = null == A ? 0 : A.length; ++t < g; )
          if (e(A[t], t, A))
            return true;
        return false;
      }
      var _arraySome = arraySome$1;
      function listCacheClear$1() {
        this.__data__ = [], this.size = 0;
      }
      var _listCacheClear = listCacheClear$1;
      function eq$5(A, e) {
        return A === e || A != A && e != e;
      }
      var eq_1 = eq$5, eq$4 = eq_1;
      function assocIndexOf$4(A, e) {
        for (var t = A.length; t--; )
          if (eq$4(A[t][0], e))
            return t;
        return -1;
      }
      var _assocIndexOf = assocIndexOf$4, assocIndexOf$3 = _assocIndexOf, arrayProto = Array.prototype, splice = arrayProto.splice;
      function listCacheDelete$1(A) {
        var e = this.__data__, t = assocIndexOf$3(e, A);
        return !(t < 0) && (t == e.length - 1 ? e.pop() : splice.call(e, t, 1), --this.size, true);
      }
      var _listCacheDelete = listCacheDelete$1, assocIndexOf$2 = _assocIndexOf;
      function listCacheGet$1(A) {
        var e = this.__data__, t = assocIndexOf$2(e, A);
        return t < 0 ? void 0 : e[t][1];
      }
      var _listCacheGet = listCacheGet$1, assocIndexOf$1 = _assocIndexOf;
      function listCacheHas$1(A) {
        return assocIndexOf$1(this.__data__, A) > -1;
      }
      var _listCacheHas = listCacheHas$1, assocIndexOf = _assocIndexOf;
      function listCacheSet$1(A, e) {
        var t = this.__data__, g = assocIndexOf(t, A);
        return g < 0 ? (++this.size, t.push([A, e])) : t[g][1] = e, this;
      }
      var _listCacheSet = listCacheSet$1, listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
      function ListCache$4(A) {
        var e = -1, t = null == A ? 0 : A.length;
        for (this.clear(); ++e < t; ) {
          var g = A[e];
          this.set(g[0], g[1]);
        }
      }
      ListCache$4.prototype.clear = listCacheClear, ListCache$4.prototype.delete = listCacheDelete, ListCache$4.prototype.get = listCacheGet, ListCache$4.prototype.has = listCacheHas, ListCache$4.prototype.set = listCacheSet;
      var _ListCache = ListCache$4, ListCache$3 = _ListCache;
      function stackClear$1() {
        this.__data__ = new ListCache$3(), this.size = 0;
      }
      var _stackClear = stackClear$1;
      function stackDelete$1(A) {
        var e = this.__data__, t = e.delete(A);
        return this.size = e.size, t;
      }
      var _stackDelete = stackDelete$1;
      function stackGet$1(A) {
        return this.__data__.get(A);
      }
      var _stackGet = stackGet$1;
      function stackHas$1(A) {
        return this.__data__.has(A);
      }
      var _stackHas = stackHas$1, root$7 = _root, coreJsData$1 = root$7["__core-js_shared__"], _coreJsData = coreJsData$1, coreJsData = _coreJsData, maskSrcKey = (uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || ""), uid ? "Symbol(src)_1." + uid : ""), uid;
      function isMasked$1(A) {
        return !!maskSrcKey && maskSrcKey in A;
      }
      var _isMasked = isMasked$1, funcProto$2 = Function.prototype, funcToString$2 = funcProto$2.toString;
      function toSource$2(A) {
        if (null != A) {
          try {
            return funcToString$2.call(A);
          } catch (A2) {
          }
          try {
            return A + "";
          } catch (A2) {
          }
        }
        return "";
      }
      var _toSource = toSource$2, isFunction$4 = isFunction_1$1, isMasked = _isMasked, isObject$b = isObject_1$1, toSource$1 = _toSource, reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor = /^\[object .+?Constructor\]$/, funcProto$1 = Function.prototype, objectProto$9 = Object.prototype, funcToString$1 = funcProto$1.toString, hasOwnProperty$8 = objectProto$9.hasOwnProperty, reIsNative = RegExp("^" + funcToString$1.call(hasOwnProperty$8).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      function baseIsNative$1(A) {
        return !(!isObject$b(A) || isMasked(A)) && (isFunction$4(A) ? reIsNative : reIsHostCtor).test(toSource$1(A));
      }
      var _baseIsNative = baseIsNative$1;
      function getValue$1(A, e) {
        return null == A ? void 0 : A[e];
      }
      var _getValue = getValue$1, baseIsNative = _baseIsNative, getValue = _getValue;
      function getNative$7(A, e) {
        var t = getValue(A, e);
        return baseIsNative(t) ? t : void 0;
      }
      var _getNative = getNative$7, getNative$6 = _getNative, root$6 = _root, Map$5 = getNative$6(root$6, "Map"), _Map = Map$5, getNative$5 = _getNative, nativeCreate$4 = getNative$5(Object, "create"), _nativeCreate = nativeCreate$4, nativeCreate$3 = _nativeCreate;
      function hashClear$1() {
        this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {}, this.size = 0;
      }
      var _hashClear = hashClear$1;
      function hashDelete$1(A) {
        var e = this.has(A) && delete this.__data__[A];
        return this.size -= e ? 1 : 0, e;
      }
      var _hashDelete = hashDelete$1, nativeCreate$2 = _nativeCreate, HASH_UNDEFINED$2 = "__lodash_hash_undefined__", objectProto$8 = Object.prototype, hasOwnProperty$7 = objectProto$8.hasOwnProperty;
      function hashGet$1(A) {
        var e = this.__data__;
        if (nativeCreate$2) {
          var t = e[A];
          return t === HASH_UNDEFINED$2 ? void 0 : t;
        }
        return hasOwnProperty$7.call(e, A) ? e[A] : void 0;
      }
      var _hashGet = hashGet$1, nativeCreate$1 = _nativeCreate, objectProto$7 = Object.prototype, hasOwnProperty$6 = objectProto$7.hasOwnProperty;
      function hashHas$1(A) {
        var e = this.__data__;
        return nativeCreate$1 ? void 0 !== e[A] : hasOwnProperty$6.call(e, A);
      }
      var _hashHas = hashHas$1, nativeCreate = _nativeCreate, HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
      function hashSet$1(A, e) {
        var t = this.__data__;
        return this.size += this.has(A) ? 0 : 1, t[A] = nativeCreate && void 0 === e ? HASH_UNDEFINED$1 : e, this;
      }
      var _hashSet = hashSet$1, hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
      function Hash$1(A) {
        var e = -1, t = null == A ? 0 : A.length;
        for (this.clear(); ++e < t; ) {
          var g = A[e];
          this.set(g[0], g[1]);
        }
      }
      Hash$1.prototype.clear = hashClear, Hash$1.prototype.delete = hashDelete, Hash$1.prototype.get = hashGet, Hash$1.prototype.has = hashHas, Hash$1.prototype.set = hashSet;
      var _Hash = Hash$1, Hash = _Hash, ListCache$2 = _ListCache, Map$4 = _Map;
      function mapCacheClear$1() {
        this.size = 0, this.__data__ = { hash: new Hash(), map: new (Map$4 || ListCache$2)(), string: new Hash() };
      }
      var _mapCacheClear = mapCacheClear$1;
      function isKeyable$1(A) {
        var e = typeof A;
        return "string" == e || "number" == e || "symbol" == e || "boolean" == e ? "__proto__" !== A : null === A;
      }
      var _isKeyable = isKeyable$1, isKeyable = _isKeyable;
      function getMapData$4(A, e) {
        var t = A.__data__;
        return isKeyable(e) ? t["string" == typeof e ? "string" : "hash"] : t.map;
      }
      var _getMapData = getMapData$4, getMapData$3 = _getMapData;
      function mapCacheDelete$1(A) {
        var e = getMapData$3(this, A).delete(A);
        return this.size -= e ? 1 : 0, e;
      }
      var _mapCacheDelete = mapCacheDelete$1, getMapData$2 = _getMapData;
      function mapCacheGet$1(A) {
        return getMapData$2(this, A).get(A);
      }
      var _mapCacheGet = mapCacheGet$1, getMapData$1 = _getMapData;
      function mapCacheHas$1(A) {
        return getMapData$1(this, A).has(A);
      }
      var _mapCacheHas = mapCacheHas$1, getMapData = _getMapData;
      function mapCacheSet$1(A, e) {
        var t = getMapData(this, A), g = t.size;
        return t.set(A, e), this.size += t.size == g ? 0 : 1, this;
      }
      var _mapCacheSet = mapCacheSet$1, mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
      function MapCache$3(A) {
        var e = -1, t = null == A ? 0 : A.length;
        for (this.clear(); ++e < t; ) {
          var g = A[e];
          this.set(g[0], g[1]);
        }
      }
      MapCache$3.prototype.clear = mapCacheClear, MapCache$3.prototype.delete = mapCacheDelete, MapCache$3.prototype.get = mapCacheGet, MapCache$3.prototype.has = mapCacheHas, MapCache$3.prototype.set = mapCacheSet;
      var _MapCache = MapCache$3, ListCache$1 = _ListCache, Map$3 = _Map, MapCache$2 = _MapCache, LARGE_ARRAY_SIZE$1 = 200;
      function stackSet$1(A, e) {
        var t = this.__data__;
        if (t instanceof ListCache$1) {
          var g = t.__data__;
          if (!Map$3 || g.length < LARGE_ARRAY_SIZE$1 - 1)
            return g.push([A, e]), this.size = ++t.size, this;
          t = this.__data__ = new MapCache$2(g);
        }
        return t.set(A, e), this.size = t.size, this;
      }
      var _stackSet = stackSet$1, ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;
      function Stack$4(A) {
        var e = this.__data__ = new ListCache(A);
        this.size = e.size;
      }
      Stack$4.prototype.clear = stackClear, Stack$4.prototype.delete = stackDelete, Stack$4.prototype.get = stackGet, Stack$4.prototype.has = stackHas, Stack$4.prototype.set = stackSet;
      var _Stack = Stack$4, HASH_UNDEFINED = "__lodash_hash_undefined__";
      function setCacheAdd$1(A) {
        return this.__data__.set(A, HASH_UNDEFINED), this;
      }
      var _setCacheAdd = setCacheAdd$1;
      function setCacheHas$1(A) {
        return this.__data__.has(A);
      }
      var _setCacheHas = setCacheHas$1, MapCache$1 = _MapCache, setCacheAdd = _setCacheAdd, setCacheHas = _setCacheHas;
      function SetCache$2(A) {
        var e = -1, t = null == A ? 0 : A.length;
        for (this.__data__ = new MapCache$1(); ++e < t; )
          this.add(A[e]);
      }
      SetCache$2.prototype.add = SetCache$2.prototype.push = setCacheAdd, SetCache$2.prototype.has = setCacheHas;
      var _SetCache = SetCache$2;
      function cacheHas$2(A, e) {
        return A.has(e);
      }
      var _cacheHas = cacheHas$2, SetCache$1 = _SetCache, arraySome = _arraySome, cacheHas$1 = _cacheHas, COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
      function equalArrays$2(A, e, t, g, o, I) {
        var i2 = t & COMPARE_PARTIAL_FLAG$5, r = A.length, n = e.length;
        if (r != n && !(i2 && n > r))
          return false;
        var C = I.get(A), E = I.get(e);
        if (C && E)
          return C == e && E == A;
        var s = -1, B = true, a = t & COMPARE_UNORDERED_FLAG$3 ? new SetCache$1() : void 0;
        for (I.set(A, e), I.set(e, A); ++s < r; ) {
          var Q = A[s], c = e[s];
          if (g)
            var l = i2 ? g(c, Q, s, e, A, I) : g(Q, c, s, A, e, I);
          if (void 0 !== l) {
            if (l)
              continue;
            B = false;
            break;
          }
          if (a) {
            if (!arraySome(e, function(A2, e2) {
              if (!cacheHas$1(a, e2) && (Q === A2 || o(Q, A2, t, g, I)))
                return a.push(e2);
            })) {
              B = false;
              break;
            }
          } else if (Q !== c && !o(Q, c, t, g, I)) {
            B = false;
            break;
          }
        }
        return I.delete(A), I.delete(e), B;
      }
      var _equalArrays = equalArrays$2, root$5 = _root, Uint8Array$3 = root$5.Uint8Array, _Uint8Array = Uint8Array$3;
      function mapToArray$1(A) {
        var e = -1, t = Array(A.size);
        return A.forEach(function(A2, g) {
          t[++e] = [g, A2];
        }), t;
      }
      var _mapToArray = mapToArray$1;
      function setToArray$3(A) {
        var e = -1, t = Array(A.size);
        return A.forEach(function(A2) {
          t[++e] = A2;
        }), t;
      }
      var _setToArray = setToArray$3, Symbol$4 = _Symbol, Uint8Array$2 = _Uint8Array, eq$3 = eq_1, equalArrays$1 = _equalArrays, mapToArray = _mapToArray, setToArray$2 = _setToArray, COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2, boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1 = "[object Error]", mapTag$4 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$2 = "[object String]", symbolTag$3 = "[object Symbol]", arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", symbolProto$2 = Symbol$4 ? Symbol$4.prototype : void 0, symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : void 0;
      function equalByTag$1(A, e, t, g, o, I, i2) {
        switch (t) {
          case dataViewTag$3:
            if (A.byteLength != e.byteLength || A.byteOffset != e.byteOffset)
              return false;
            A = A.buffer, e = e.buffer;
          case arrayBufferTag$2:
            return !(A.byteLength != e.byteLength || !I(new Uint8Array$2(A), new Uint8Array$2(e)));
          case boolTag$2:
          case dateTag$2:
          case numberTag$2:
            return eq$3(+A, +e);
          case errorTag$1:
            return A.name == e.name && A.message == e.message;
          case regexpTag$2:
          case stringTag$2:
            return A == e + "";
          case mapTag$4:
            var r = mapToArray;
          case setTag$4:
            var n = g & COMPARE_PARTIAL_FLAG$4;
            if (r || (r = setToArray$2), A.size != e.size && !n)
              return false;
            var C = i2.get(A);
            if (C)
              return C == e;
            g |= COMPARE_UNORDERED_FLAG$2, i2.set(A, e);
            var E = equalArrays$1(r(A), r(e), g, o, I, i2);
            return i2.delete(A), E;
          case symbolTag$3:
            if (symbolValueOf$1)
              return symbolValueOf$1.call(A) == symbolValueOf$1.call(e);
        }
        return false;
      }
      var _equalByTag = equalByTag$1;
      function arrayPush$3(A, e) {
        for (var t = -1, g = e.length, o = A.length; ++t < g; )
          A[o + t] = e[t];
        return A;
      }
      var _arrayPush = arrayPush$3, arrayPush$2 = _arrayPush, isArray$c = isArray_1$1;
      function baseGetAllKeys$2(A, e, t) {
        var g = e(A);
        return isArray$c(A) ? g : arrayPush$2(g, t(A));
      }
      var _baseGetAllKeys = baseGetAllKeys$2;
      function arrayFilter$1(A, e) {
        for (var t = -1, g = null == A ? 0 : A.length, o = 0, I = []; ++t < g; ) {
          var i2 = A[t];
          e(i2, t, A) && (I[o++] = i2);
        }
        return I;
      }
      var _arrayFilter = arrayFilter$1;
      function stubArray$2() {
        return [];
      }
      var stubArray_1 = stubArray$2, arrayFilter = _arrayFilter, stubArray$1 = stubArray_1, objectProto$6 = Object.prototype, propertyIsEnumerable = objectProto$6.propertyIsEnumerable, nativeGetSymbols$1 = Object.getOwnPropertySymbols, getSymbols$3 = nativeGetSymbols$1 ? function(A) {
        return null == A ? [] : (A = Object(A), arrayFilter(nativeGetSymbols$1(A), function(e) {
          return propertyIsEnumerable.call(A, e);
        }));
      } : stubArray$1, _getSymbols = getSymbols$3, baseGetAllKeys$1 = _baseGetAllKeys, getSymbols$2 = _getSymbols, keys$5 = keys_1;
      function getAllKeys$2(A) {
        return baseGetAllKeys$1(A, keys$5, getSymbols$2);
      }
      var _getAllKeys = getAllKeys$2, getAllKeys$1 = _getAllKeys, COMPARE_PARTIAL_FLAG$3 = 1, objectProto$5 = Object.prototype, hasOwnProperty$5 = objectProto$5.hasOwnProperty;
      function equalObjects$1(A, e, t, g, o, I) {
        var i2 = t & COMPARE_PARTIAL_FLAG$3, r = getAllKeys$1(A), n = r.length;
        if (n != getAllKeys$1(e).length && !i2)
          return false;
        for (var C = n; C--; ) {
          var E = r[C];
          if (!(i2 ? E in e : hasOwnProperty$5.call(e, E)))
            return false;
        }
        var s = I.get(A), B = I.get(e);
        if (s && B)
          return s == e && B == A;
        var a = true;
        I.set(A, e), I.set(e, A);
        for (var Q = i2; ++C < n; ) {
          var c = A[E = r[C]], l = e[E];
          if (g)
            var h = i2 ? g(l, c, E, e, A, I) : g(c, l, E, A, e, I);
          if (!(void 0 === h ? c === l || o(c, l, t, g, I) : h)) {
            a = false;
            break;
          }
          Q || (Q = "constructor" == E);
        }
        if (a && !Q) {
          var u = A.constructor, d = e.constructor;
          u == d || !("constructor" in A) || !("constructor" in e) || "function" == typeof u && u instanceof u && "function" == typeof d && d instanceof d || (a = false);
        }
        return I.delete(A), I.delete(e), a;
      }
      var _equalObjects = equalObjects$1, getNative$4 = _getNative, root$4 = _root, DataView$2 = getNative$4(root$4, "DataView"), _DataView = DataView$2, getNative$3 = _getNative, root$3 = _root, Promise$2 = getNative$3(root$3, "Promise"), _Promise = Promise$2, getNative$2 = _getNative, root$2 = _root, Set$3 = getNative$2(root$2, "Set"), _Set = Set$3, getNative$1 = _getNative, root$1 = _root, WeakMap$2 = getNative$1(root$1, "WeakMap"), _WeakMap = WeakMap$2, DataView$1 = _DataView, Map$2 = _Map, Promise$1 = _Promise, Set$2 = _Set, WeakMap$1 = _WeakMap, baseGetTag$2 = _baseGetTag, toSource = _toSource, mapTag$3 = "[object Map]", objectTag$3 = "[object Object]", promiseTag = "[object Promise]", setTag$3 = "[object Set]", weakMapTag$1 = "[object WeakMap]", dataViewTag$2 = "[object DataView]", dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$2), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$1), getTag$4 = baseGetTag$2;
      (DataView$1 && getTag$4(new DataView$1(new ArrayBuffer(1))) != dataViewTag$2 || Map$2 && getTag$4(new Map$2()) != mapTag$3 || Promise$1 && getTag$4(Promise$1.resolve()) != promiseTag || Set$2 && getTag$4(new Set$2()) != setTag$3 || WeakMap$1 && getTag$4(new WeakMap$1()) != weakMapTag$1) && (getTag$4 = function(A) {
        var e = baseGetTag$2(A), t = e == objectTag$3 ? A.constructor : void 0, g = t ? toSource(t) : "";
        if (g)
          switch (g) {
            case dataViewCtorString:
              return dataViewTag$2;
            case mapCtorString:
              return mapTag$3;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag$3;
            case weakMapCtorString:
              return weakMapTag$1;
          }
        return e;
      });
      var _getTag = getTag$4, Stack$3 = _Stack, equalArrays = _equalArrays, equalByTag = _equalByTag, equalObjects = _equalObjects, getTag$3 = _getTag, isArray$b = isArray_1$1, isBuffer$2 = isBufferExports, isTypedArray$1 = isTypedArray_1, COMPARE_PARTIAL_FLAG$2 = 1, argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", objectTag$2 = "[object Object]", objectProto$4 = Object.prototype, hasOwnProperty$4 = objectProto$4.hasOwnProperty;
      function baseIsEqualDeep$1(A, e, t, g, o, I) {
        var i2 = isArray$b(A), r = isArray$b(e), n = i2 ? arrayTag$1 : getTag$3(A), C = r ? arrayTag$1 : getTag$3(e), E = (n = n == argsTag$1 ? objectTag$2 : n) == objectTag$2, s = (C = C == argsTag$1 ? objectTag$2 : C) == objectTag$2, B = n == C;
        if (B && isBuffer$2(A)) {
          if (!isBuffer$2(e))
            return false;
          i2 = true, E = false;
        }
        if (B && !E)
          return I || (I = new Stack$3()), i2 || isTypedArray$1(A) ? equalArrays(A, e, t, g, o, I) : equalByTag(A, e, n, t, g, o, I);
        if (!(t & COMPARE_PARTIAL_FLAG$2)) {
          var a = E && hasOwnProperty$4.call(A, "__wrapped__"), Q = s && hasOwnProperty$4.call(e, "__wrapped__");
          if (a || Q) {
            var c = a ? A.value() : A, l = Q ? e.value() : e;
            return I || (I = new Stack$3()), o(c, l, t, g, I);
          }
        }
        return !!B && (I || (I = new Stack$3()), equalObjects(A, e, t, g, o, I));
      }
      var _baseIsEqualDeep = baseIsEqualDeep$1, baseIsEqualDeep = _baseIsEqualDeep, isObjectLike$5 = isObjectLike_1;
      function baseIsEqual$2(A, e, t, g, o) {
        return A === e || (null == A || null == e || !isObjectLike$5(A) && !isObjectLike$5(e) ? A != A && e != e : baseIsEqualDeep(A, e, t, g, baseIsEqual$2, o));
      }
      var _baseIsEqual = baseIsEqual$2, Stack$2 = _Stack, baseIsEqual$1 = _baseIsEqual, COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
      function baseIsMatch$1(A, e, t, g) {
        var o = t.length, I = o, i2 = !g;
        if (null == A)
          return !I;
        for (A = Object(A); o--; ) {
          var r = t[o];
          if (i2 && r[2] ? r[1] !== A[r[0]] : !(r[0] in A))
            return false;
        }
        for (; ++o < I; ) {
          var n = (r = t[o])[0], C = A[n], E = r[1];
          if (i2 && r[2]) {
            if (void 0 === C && !(n in A))
              return false;
          } else {
            var s = new Stack$2();
            if (g)
              var B = g(C, E, n, A, e, s);
            if (!(void 0 === B ? baseIsEqual$1(E, C, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, g, s) : B))
              return false;
          }
        }
        return true;
      }
      var _baseIsMatch = baseIsMatch$1, isObject$a = isObject_1$1;
      function isStrictComparable$2(A) {
        return A == A && !isObject$a(A);
      }
      var _isStrictComparable = isStrictComparable$2, isStrictComparable$1 = _isStrictComparable, keys$4 = keys_1;
      function getMatchData$1(A) {
        for (var e = keys$4(A), t = e.length; t--; ) {
          var g = e[t], o = A[g];
          e[t] = [g, o, isStrictComparable$1(o)];
        }
        return e;
      }
      var _getMatchData = getMatchData$1;
      function matchesStrictComparable$2(A, e) {
        return function(t) {
          return null != t && (t[A] === e && (void 0 !== e || A in Object(t)));
        };
      }
      var _matchesStrictComparable = matchesStrictComparable$2, baseIsMatch = _baseIsMatch, getMatchData = _getMatchData, matchesStrictComparable$1 = _matchesStrictComparable;
      function baseMatches$1(A) {
        var e = getMatchData(A);
        return 1 == e.length && e[0][2] ? matchesStrictComparable$1(e[0][0], e[0][1]) : function(t) {
          return t === A || baseIsMatch(t, A, e);
        };
      }
      var _baseMatches = baseMatches$1, baseGetTag$1 = _baseGetTag, isObjectLike$4 = isObjectLike_1, symbolTag$2 = "[object Symbol]";
      function isSymbol$6(A) {
        return "symbol" == typeof A || isObjectLike$4(A) && baseGetTag$1(A) == symbolTag$2;
      }
      var isSymbol_1 = isSymbol$6, isArray$a = isArray_1$1, isSymbol$5 = isSymbol_1, reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
      function isKey$3(A, e) {
        if (isArray$a(A))
          return false;
        var t = typeof A;
        return !("number" != t && "symbol" != t && "boolean" != t && null != A && !isSymbol$5(A)) || (reIsPlainProp.test(A) || !reIsDeepProp.test(A) || null != e && A in Object(e));
      }
      var _isKey = isKey$3, MapCache = _MapCache, FUNC_ERROR_TEXT$1 = "Expected a function";
      function memoize$1(A, e) {
        if ("function" != typeof A || null != e && "function" != typeof e)
          throw new TypeError(FUNC_ERROR_TEXT$1);
        var t = function() {
          var g = arguments, o = e ? e.apply(this, g) : g[0], I = t.cache;
          if (I.has(o))
            return I.get(o);
          var i2 = A.apply(this, g);
          return t.cache = I.set(o, i2) || I, i2;
        };
        return t.cache = new (memoize$1.Cache || MapCache)(), t;
      }
      memoize$1.Cache = MapCache;
      var memoize_1 = memoize$1, memoize = memoize_1, MAX_MEMOIZE_SIZE = 500;
      function memoizeCapped$1(A) {
        var e = memoize(A, function(A2) {
          return t.size === MAX_MEMOIZE_SIZE && t.clear(), A2;
        }), t = e.cache;
        return e;
      }
      var _memoizeCapped = memoizeCapped$1, memoizeCapped = _memoizeCapped, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reEscapeChar = /\\(\\)?/g, stringToPath$1 = memoizeCapped(function(A) {
        var e = [];
        return 46 === A.charCodeAt(0) && e.push(""), A.replace(rePropName, function(A2, t, g, o) {
          e.push(g ? o.replace(reEscapeChar, "$1") : t || A2);
        }), e;
      }), _stringToPath = stringToPath$1, Symbol$3 = _Symbol, arrayMap$3 = _arrayMap, isArray$9 = isArray_1$1, isSymbol$4 = isSymbol_1, symbolProto$1 = Symbol$3 ? Symbol$3.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
      function baseToString$1(A) {
        if ("string" == typeof A)
          return A;
        if (isArray$9(A))
          return arrayMap$3(A, baseToString$1) + "";
        if (isSymbol$4(A))
          return symbolToString ? symbolToString.call(A) : "";
        var e = A + "";
        return "0" == e && 1 / A == -1 / 0 ? "-0" : e;
      }
      var _baseToString = baseToString$1, baseToString = _baseToString;
      function toString$2(A) {
        return null == A ? "" : baseToString(A);
      }
      var toString_1 = toString$2, isArray$8 = isArray_1$1, isKey$2 = _isKey, stringToPath = _stringToPath, toString$1 = toString_1;
      function castPath$6(A, e) {
        return isArray$8(A) ? A : isKey$2(A, e) ? [A] : stringToPath(toString$1(A));
      }
      var _castPath = castPath$6, isSymbol$3 = isSymbol_1;
      function toKey$6(A) {
        if ("string" == typeof A || isSymbol$3(A))
          return A;
        var e = A + "";
        return "0" == e && 1 / A == -1 / 0 ? "-0" : e;
      }
      var _toKey = toKey$6, castPath$5 = _castPath, toKey$5 = _toKey;
      function baseGet$5(A, e) {
        for (var t = 0, g = (e = castPath$5(e, A)).length; null != A && t < g; )
          A = A[toKey$5(e[t++])];
        return t && t == g ? A : void 0;
      }
      var _baseGet = baseGet$5, baseGet$4 = _baseGet;
      function get$1(A, e, t) {
        var g = null == A ? void 0 : baseGet$4(A, e);
        return void 0 === g ? t : g;
      }
      var get_1 = get$1;
      function baseHasIn$1(A, e) {
        return null != A && e in Object(A);
      }
      var _baseHasIn = baseHasIn$1, castPath$4 = _castPath, isArguments$2 = isArguments_1, isArray$7 = isArray_1$1, isIndex$2 = _isIndex, isLength = isLength_1, toKey$4 = _toKey;
      function hasPath$1(A, e, t) {
        for (var g = -1, o = (e = castPath$4(e, A)).length, I = false; ++g < o; ) {
          var i2 = toKey$4(e[g]);
          if (!(I = null != A && t(A, i2)))
            break;
          A = A[i2];
        }
        return I || ++g != o ? I : !!(o = null == A ? 0 : A.length) && isLength(o) && isIndex$2(i2, o) && (isArray$7(A) || isArguments$2(A));
      }
      var _hasPath = hasPath$1, baseHasIn = _baseHasIn, hasPath = _hasPath;
      function hasIn$1(A, e) {
        return null != A && hasPath(A, e, baseHasIn);
      }
      var hasIn_1 = hasIn$1, baseIsEqual = _baseIsEqual, get = get_1, hasIn = hasIn_1, isKey$1 = _isKey, isStrictComparable = _isStrictComparable, matchesStrictComparable = _matchesStrictComparable, toKey$3 = _toKey, COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      function baseMatchesProperty$1(A, e) {
        return isKey$1(A) && isStrictComparable(e) ? matchesStrictComparable(toKey$3(A), e) : function(t) {
          var g = get(t, A);
          return void 0 === g && g === e ? hasIn(t, A) : baseIsEqual(e, g, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      var _baseMatchesProperty = baseMatchesProperty$1;
      function identity$4(A) {
        return A;
      }
      var identity_1 = identity$4;
      function baseProperty$1(A) {
        return function(e) {
          return null == e ? void 0 : e[A];
        };
      }
      var _baseProperty = baseProperty$1, baseGet$3 = _baseGet;
      function basePropertyDeep$1(A) {
        return function(e) {
          return baseGet$3(e, A);
        };
      }
      var _basePropertyDeep = basePropertyDeep$1, baseProperty = _baseProperty, basePropertyDeep = _basePropertyDeep, isKey = _isKey, toKey$2 = _toKey;
      function property$1(A) {
        return isKey(A) ? baseProperty(toKey$2(A)) : basePropertyDeep(A);
      }
      var property_1 = property$1, baseMatches = _baseMatches, baseMatchesProperty = _baseMatchesProperty, identity$3 = identity_1, isArray$6 = isArray_1$1, property = property_1;
      function baseIteratee$7(A) {
        return "function" == typeof A ? A : null == A ? identity$3 : "object" == typeof A ? isArray$6(A) ? baseMatchesProperty(A[0], A[1]) : baseMatches(A) : property(A);
      }
      var _baseIteratee = baseIteratee$7;
      function createBaseFor$1(A) {
        return function(e, t, g) {
          for (var o = -1, I = Object(e), i2 = g(e), r = i2.length; r--; ) {
            var n = i2[A ? r : ++o];
            if (false === t(I[n], n, I))
              break;
          }
          return e;
        };
      }
      var _createBaseFor = createBaseFor$1, createBaseFor = _createBaseFor, baseFor$2 = createBaseFor(), _baseFor = baseFor$2, baseFor$1 = _baseFor, keys$3 = keys_1;
      function baseForOwn$2(A, e) {
        return A && baseFor$1(A, e, keys$3);
      }
      var _baseForOwn = baseForOwn$2, isArrayLike$6 = isArrayLike_1;
      function createBaseEach$1(A, e) {
        return function(t, g) {
          if (null == t)
            return t;
          if (!isArrayLike$6(t))
            return A(t, g);
          for (var o = t.length, I = e ? o : -1, i2 = Object(t); (e ? I-- : ++I < o) && false !== g(i2[I], I, i2); )
            ;
          return t;
        };
      }
      var _createBaseEach = createBaseEach$1, baseForOwn$1 = _baseForOwn, createBaseEach = _createBaseEach, baseEach$1 = createBaseEach(baseForOwn$1), _baseEach = baseEach$1, eq$2 = eq_1, isArrayLike$5 = isArrayLike_1, isIndex$1 = _isIndex, isObject$9 = isObject_1$1;
      function isIterateeCall$2(A, e, t) {
        if (!isObject$9(t))
          return false;
        var g = typeof e;
        return !!("number" == g ? isArrayLike$5(t) && isIndex$1(e, t.length) : "string" == g && e in t) && eq$2(t[e], A);
      }
      var _isIterateeCall = isIterateeCall$2, Symbol$2 = _Symbol, isArguments$1 = isArguments_1, isArray$5 = isArray_1$1, spreadableSymbol = Symbol$2 ? Symbol$2.isConcatSpreadable : void 0;
      function isFlattenable$1(A) {
        return isArray$5(A) || isArguments$1(A) || !!(spreadableSymbol && A && A[spreadableSymbol]);
      }
      var _isFlattenable = isFlattenable$1, arrayPush$1 = _arrayPush, isFlattenable = _isFlattenable;
      function baseFlatten$2(A, e, t, g, o) {
        var I = -1, i2 = A.length;
        for (t || (t = isFlattenable), o || (o = []); ++I < i2; ) {
          var r = A[I];
          e > 0 && t(r) ? e > 1 ? baseFlatten$2(r, e - 1, t, g, o) : arrayPush$1(o, r) : g || (o[o.length] = r);
        }
        return o;
      }
      var _baseFlatten = baseFlatten$2, baseEach = _baseEach, isArrayLike$4 = isArrayLike_1;
      function baseMap$1(A, e) {
        var t = -1, g = isArrayLike$4(A) ? Array(A.length) : [];
        return baseEach(A, function(A2, o, I) {
          g[++t] = e(A2, o, I);
        }), g;
      }
      var _baseMap = baseMap$1;
      function baseSortBy$1(A, e) {
        var t = A.length;
        for (A.sort(e); t--; )
          A[t] = A[t].value;
        return A;
      }
      var _baseSortBy = baseSortBy$1, isSymbol$2 = isSymbol_1;
      function compareAscending$1(A, e) {
        if (A !== e) {
          var t = void 0 !== A, g = null === A, o = A == A, I = isSymbol$2(A), i2 = void 0 !== e, r = null === e, n = e == e, C = isSymbol$2(e);
          if (!r && !C && !I && A > e || I && i2 && n && !r && !C || g && i2 && n || !t && n || !o)
            return 1;
          if (!g && !I && !C && A < e || C && t && o && !g && !I || r && t && o || !i2 && o || !n)
            return -1;
        }
        return 0;
      }
      var _compareAscending = compareAscending$1, compareAscending = _compareAscending;
      function compareMultiple$1(A, e, t) {
        for (var g = -1, o = A.criteria, I = e.criteria, i2 = o.length, r = t.length; ++g < i2; ) {
          var n = compareAscending(o[g], I[g]);
          if (n)
            return g >= r ? n : n * ("desc" == t[g] ? -1 : 1);
        }
        return A.index - e.index;
      }
      var _compareMultiple = compareMultiple$1, arrayMap$2 = _arrayMap, baseGet$2 = _baseGet, baseIteratee$6 = _baseIteratee, baseMap = _baseMap, baseSortBy = _baseSortBy, baseUnary$2 = _baseUnary, compareMultiple = _compareMultiple, identity$2 = identity_1, isArray$4 = isArray_1$1;
      function baseOrderBy$1(A, e, t) {
        e = e.length ? arrayMap$2(e, function(A2) {
          return isArray$4(A2) ? function(e2) {
            return baseGet$2(e2, 1 === A2.length ? A2[0] : A2);
          } : A2;
        }) : [identity$2];
        var g = -1;
        e = arrayMap$2(e, baseUnary$2(baseIteratee$6));
        var o = baseMap(A, function(A2, t2, o2) {
          return { criteria: arrayMap$2(e, function(e2) {
            return e2(A2);
          }), index: ++g, value: A2 };
        });
        return baseSortBy(o, function(A2, e2) {
          return compareMultiple(A2, e2, t);
        });
      }
      var _baseOrderBy = baseOrderBy$1;
      function apply$1(A, e, t) {
        switch (t.length) {
          case 0:
            return A.call(e);
          case 1:
            return A.call(e, t[0]);
          case 2:
            return A.call(e, t[0], t[1]);
          case 3:
            return A.call(e, t[0], t[1], t[2]);
        }
        return A.apply(e, t);
      }
      var _apply = apply$1, apply = _apply, nativeMax$2 = Math.max;
      function overRest$2(A, e, t) {
        return e = nativeMax$2(void 0 === e ? A.length - 1 : e, 0), function() {
          for (var g = arguments, o = -1, I = nativeMax$2(g.length - e, 0), i2 = Array(I); ++o < I; )
            i2[o] = g[e + o];
          o = -1;
          for (var r = Array(e + 1); ++o < e; )
            r[o] = g[o];
          return r[e] = t(i2), apply(A, this, r);
        };
      }
      var _overRest = overRest$2;
      function constant$1(A) {
        return function() {
          return A;
        };
      }
      var constant_1 = constant$1, getNative = _getNative, defineProperty$2 = function() {
        try {
          var A = getNative(Object, "defineProperty");
          return A({}, "", {}), A;
        } catch (A2) {
        }
      }(), _defineProperty = defineProperty$2, constant = constant_1, defineProperty$1 = _defineProperty, identity$1 = identity_1, baseSetToString$1 = defineProperty$1 ? function(A, e) {
        return defineProperty$1(A, "toString", { configurable: true, enumerable: false, value: constant(e), writable: true });
      } : identity$1, _baseSetToString = baseSetToString$1, HOT_COUNT = 800, HOT_SPAN = 16, nativeNow = Date.now;
      function shortOut$1(A) {
        var e = 0, t = 0;
        return function() {
          var g = nativeNow(), o = HOT_SPAN - (g - t);
          if (t = g, o > 0) {
            if (++e >= HOT_COUNT)
              return arguments[0];
          } else
            e = 0;
          return A.apply(void 0, arguments);
        };
      }
      var _shortOut = shortOut$1, baseSetToString = _baseSetToString, shortOut = _shortOut, setToString$2 = shortOut(baseSetToString), _setToString = setToString$2, identity = identity_1, overRest$1 = _overRest, setToString$1 = _setToString;
      function baseRest$2(A, e) {
        return setToString$1(overRest$1(A, e, identity), A + "");
      }
      var _baseRest = baseRest$2, baseFlatten$1 = _baseFlatten, baseOrderBy = _baseOrderBy, baseRest$1 = _baseRest, isIterateeCall$1 = _isIterateeCall, sortBy = baseRest$1(function(A, e) {
        if (null == A)
          return [];
        var t = e.length;
        return t > 1 && isIterateeCall$1(A, e[0], e[1]) ? e = [] : t > 2 && isIterateeCall$1(e[0], e[1], e[2]) && (e = [e[0]]), baseOrderBy(A, baseFlatten$1(e, 1), []);
      }), sortBy_1 = sortBy, sortBy$1 = getDefaultExportFromCjs(sortBy_1), baseRandom = _baseRandom;
      function arraySample$2(A) {
        var e = A.length;
        return e ? A[baseRandom(0, e - 1)] : void 0;
      }
      var _arraySample = arraySample$2, arraySample$1 = _arraySample, values = values_1;
      function baseSample$1(A) {
        return arraySample$1(values(A));
      }
      var _baseSample = baseSample$1, arraySample = _arraySample, baseSample = _baseSample, isArray$3 = isArray_1$1;
      function sample(A) {
        return (isArray$3(A) ? arraySample : baseSample)(A);
      }
      var sample_1 = sample, sample$1 = getDefaultExportFromCjs(sample_1), reWhitespace = /\s/;
      function trimmedEndIndex$1(A) {
        for (var e = A.length; e-- && reWhitespace.test(A.charAt(e)); )
          ;
        return e;
      }
      var _trimmedEndIndex = trimmedEndIndex$1, trimmedEndIndex = _trimmedEndIndex, reTrimStart$1 = /^\s+/;
      function baseTrim$1(A) {
        return A ? A.slice(0, trimmedEndIndex(A) + 1).replace(reTrimStart$1, "") : A;
      }
      var _baseTrim = baseTrim$1, baseTrim = _baseTrim, isObject$8 = isObject_1$1, isSymbol$1 = isSymbol_1, NAN = NaN, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsOctal = /^0o[0-7]+$/i, freeParseInt = parseInt;
      function toNumber$1(A) {
        if ("number" == typeof A)
          return A;
        if (isSymbol$1(A))
          return NAN;
        if (isObject$8(A)) {
          var e = "function" == typeof A.valueOf ? A.valueOf() : A;
          A = isObject$8(e) ? e + "" : e;
        }
        if ("string" != typeof A)
          return 0 === A ? A : +A;
        A = baseTrim(A);
        var t = reIsBinary.test(A);
        return t || reIsOctal.test(A) ? freeParseInt(A.slice(2), t ? 2 : 8) : reIsBadHex.test(A) ? NAN : +A;
      }
      var toNumber_1 = toNumber$1, toNumber = toNumber_1, INFINITY$1 = 1 / 0, MAX_INTEGER = 17976931348623157e292;
      function toFinite$1(A) {
        return A ? (A = toNumber(A)) === INFINITY$1 || A === -INFINITY$1 ? (A < 0 ? -1 : 1) * MAX_INTEGER : A == A ? A : 0 : 0 === A ? A : 0;
      }
      var toFinite_1 = toFinite$1;
      function compact(A) {
        for (var e = -1, t = null == A ? 0 : A.length, g = 0, o = []; ++e < t; ) {
          var I = A[e];
          I && (o[g++] = I);
        }
        return o;
      }
      var compact_1 = compact, compact$1 = getDefaultExportFromCjs(compact_1);
      function arrayEach$1(A, e) {
        for (var t = -1, g = null == A ? 0 : A.length; ++t < g && false !== e(A[t], t, A); )
          ;
        return A;
      }
      var _arrayEach = arrayEach$1, defineProperty = _defineProperty;
      function baseAssignValue$4(A, e, t) {
        "__proto__" == e && defineProperty ? defineProperty(A, e, { configurable: true, enumerable: true, value: t, writable: true }) : A[e] = t;
      }
      var _baseAssignValue = baseAssignValue$4, baseAssignValue$3 = _baseAssignValue, eq$1 = eq_1, objectProto$3 = Object.prototype, hasOwnProperty$3 = objectProto$3.hasOwnProperty;
      function assignValue$3(A, e, t) {
        var g = A[e];
        hasOwnProperty$3.call(A, e) && eq$1(g, t) && (void 0 !== t || e in A) || baseAssignValue$3(A, e, t);
      }
      var _assignValue = assignValue$3, assignValue$2 = _assignValue, baseAssignValue$2 = _baseAssignValue;
      function copyObject$6(A, e, t, g) {
        var o = !t;
        t || (t = {});
        for (var I = -1, i2 = e.length; ++I < i2; ) {
          var r = e[I], n = g ? g(t[r], A[r], r, t, A) : void 0;
          void 0 === n && (n = A[r]), o ? baseAssignValue$2(t, r, n) : assignValue$2(t, r, n);
        }
        return t;
      }
      var _copyObject = copyObject$6, copyObject$5 = _copyObject, keys$2 = keys_1;
      function baseAssign$1(A, e) {
        return A && copyObject$5(e, keys$2(e), A);
      }
      var _baseAssign = baseAssign$1;
      function nativeKeysIn$1(A) {
        var e = [];
        if (null != A)
          for (var t in Object(A))
            e.push(t);
        return e;
      }
      var _nativeKeysIn = nativeKeysIn$1, isObject$7 = isObject_1$1, isPrototype$1 = _isPrototype, nativeKeysIn = _nativeKeysIn, objectProto$2 = Object.prototype, hasOwnProperty$2 = objectProto$2.hasOwnProperty;
      function baseKeysIn$1(A) {
        if (!isObject$7(A))
          return nativeKeysIn(A);
        var e = isPrototype$1(A), t = [];
        for (var g in A)
          ("constructor" != g || !e && hasOwnProperty$2.call(A, g)) && t.push(g);
        return t;
      }
      var _baseKeysIn = baseKeysIn$1, arrayLikeKeys = _arrayLikeKeys, baseKeysIn = _baseKeysIn, isArrayLike$3 = isArrayLike_1;
      function keysIn$5(A) {
        return isArrayLike$3(A) ? arrayLikeKeys(A, true) : baseKeysIn(A);
      }
      var keysIn_1 = keysIn$5, copyObject$4 = _copyObject, keysIn$4 = keysIn_1;
      function baseAssignIn$1(A, e) {
        return A && copyObject$4(e, keysIn$4(e), A);
      }
      var _baseAssignIn = baseAssignIn$1, _cloneBuffer = { exports: {} };
      _cloneBuffer.exports, function(A, e) {
        var t = _root, g = e && !e.nodeType && e, o = g && A && !A.nodeType && A, I = o && o.exports === g ? t.Buffer : void 0, i2 = I ? I.allocUnsafe : void 0;
        A.exports = function(A2, e2) {
          if (e2)
            return A2.slice();
          var t2 = A2.length, g2 = i2 ? i2(t2) : new A2.constructor(t2);
          return A2.copy(g2), g2;
        };
      }(_cloneBuffer, _cloneBuffer.exports);
      var _cloneBufferExports = _cloneBuffer.exports, copyObject$3 = _copyObject, getSymbols$1 = _getSymbols;
      function copySymbols$1(A, e) {
        return copyObject$3(A, getSymbols$1(A), e);
      }
      var _copySymbols = copySymbols$1, overArg = _overArg, getPrototype$3 = overArg(Object.getPrototypeOf, Object), _getPrototype = getPrototype$3, arrayPush = _arrayPush, getPrototype$2 = _getPrototype, getSymbols = _getSymbols, stubArray = stubArray_1, nativeGetSymbols = Object.getOwnPropertySymbols, getSymbolsIn$2 = nativeGetSymbols ? function(A) {
        for (var e = []; A; )
          arrayPush(e, getSymbols(A)), A = getPrototype$2(A);
        return e;
      } : stubArray, _getSymbolsIn = getSymbolsIn$2, copyObject$2 = _copyObject, getSymbolsIn$1 = _getSymbolsIn;
      function copySymbolsIn$1(A, e) {
        return copyObject$2(A, getSymbolsIn$1(A), e);
      }
      var _copySymbolsIn = copySymbolsIn$1, baseGetAllKeys = _baseGetAllKeys, getSymbolsIn = _getSymbolsIn, keysIn$3 = keysIn_1;
      function getAllKeysIn$3(A) {
        return baseGetAllKeys(A, keysIn$3, getSymbolsIn);
      }
      var _getAllKeysIn = getAllKeysIn$3, objectProto$1 = Object.prototype, hasOwnProperty$1 = objectProto$1.hasOwnProperty;
      function initCloneArray$1(A) {
        var e = A.length, t = new A.constructor(e);
        return e && "string" == typeof A[0] && hasOwnProperty$1.call(A, "index") && (t.index = A.index, t.input = A.input), t;
      }
      var _initCloneArray = initCloneArray$1, Uint8Array$1 = _Uint8Array;
      function cloneArrayBuffer$3(A) {
        var e = new A.constructor(A.byteLength);
        return new Uint8Array$1(e).set(new Uint8Array$1(A)), e;
      }
      var _cloneArrayBuffer = cloneArrayBuffer$3, cloneArrayBuffer$2 = _cloneArrayBuffer;
      function cloneDataView$1(A, e) {
        var t = e ? cloneArrayBuffer$2(A.buffer) : A.buffer;
        return new A.constructor(t, A.byteOffset, A.byteLength);
      }
      var _cloneDataView = cloneDataView$1, reFlags = /\w*$/;
      function cloneRegExp$1(A) {
        var e = new A.constructor(A.source, reFlags.exec(A));
        return e.lastIndex = A.lastIndex, e;
      }
      var _cloneRegExp = cloneRegExp$1, Symbol$1 = _Symbol, symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function cloneSymbol$1(A) {
        return symbolValueOf ? Object(symbolValueOf.call(A)) : {};
      }
      var _cloneSymbol = cloneSymbol$1, cloneArrayBuffer$1 = _cloneArrayBuffer;
      function cloneTypedArray$2(A, e) {
        var t = e ? cloneArrayBuffer$1(A.buffer) : A.buffer;
        return new A.constructor(t, A.byteOffset, A.length);
      }
      var _cloneTypedArray = cloneTypedArray$2, cloneArrayBuffer = _cloneArrayBuffer, cloneDataView = _cloneDataView, cloneRegExp = _cloneRegExp, cloneSymbol = _cloneSymbol, cloneTypedArray$1 = _cloneTypedArray, boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]", arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
      function initCloneByTag$1(A, e, t) {
        var g = A.constructor;
        switch (e) {
          case arrayBufferTag$1:
            return cloneArrayBuffer(A);
          case boolTag$1:
          case dateTag$1:
            return new g(+A);
          case dataViewTag$1:
            return cloneDataView(A, t);
          case float32Tag$1:
          case float64Tag$1:
          case int8Tag$1:
          case int16Tag$1:
          case int32Tag$1:
          case uint8Tag$1:
          case uint8ClampedTag$1:
          case uint16Tag$1:
          case uint32Tag$1:
            return cloneTypedArray$1(A, t);
          case mapTag$2:
            return new g();
          case numberTag$1:
          case stringTag$1:
            return new g(A);
          case regexpTag$1:
            return cloneRegExp(A);
          case setTag$2:
            return new g();
          case symbolTag$1:
            return cloneSymbol(A);
        }
      }
      var _initCloneByTag = initCloneByTag$1, isObject$6 = isObject_1$1, objectCreate = Object.create, baseCreate$1 = function() {
        function A() {
        }
        return function(e) {
          if (!isObject$6(e))
            return {};
          if (objectCreate)
            return objectCreate(e);
          A.prototype = e;
          var t = new A();
          return A.prototype = void 0, t;
        };
      }(), _baseCreate = baseCreate$1, baseCreate = _baseCreate, getPrototype$1 = _getPrototype, isPrototype = _isPrototype;
      function initCloneObject$2(A) {
        return "function" != typeof A.constructor || isPrototype(A) ? {} : baseCreate(getPrototype$1(A));
      }
      var _initCloneObject = initCloneObject$2, getTag$2 = _getTag, isObjectLike$3 = isObjectLike_1, mapTag$1 = "[object Map]";
      function baseIsMap$1(A) {
        return isObjectLike$3(A) && getTag$2(A) == mapTag$1;
      }
      var _baseIsMap = baseIsMap$1, baseIsMap = _baseIsMap, baseUnary$1 = _baseUnary, nodeUtil$1 = _nodeUtilExports, nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap, isMap$1 = nodeIsMap ? baseUnary$1(nodeIsMap) : baseIsMap, isMap_1 = isMap$1, getTag$1 = _getTag, isObjectLike$2 = isObjectLike_1, setTag$1 = "[object Set]";
      function baseIsSet$1(A) {
        return isObjectLike$2(A) && getTag$1(A) == setTag$1;
      }
      var _baseIsSet = baseIsSet$1, baseIsSet = _baseIsSet, baseUnary = _baseUnary, nodeUtil = _nodeUtilExports, nodeIsSet = nodeUtil && nodeUtil.isSet, isSet$1 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet, isSet_1 = isSet$1, Stack$1 = _Stack, arrayEach = _arrayEach, assignValue$1 = _assignValue, baseAssign = _baseAssign, baseAssignIn = _baseAssignIn, cloneBuffer$1 = _cloneBufferExports, copyArray$1 = _copyArray, copySymbols = _copySymbols, copySymbolsIn = _copySymbolsIn, getAllKeys = _getAllKeys, getAllKeysIn$2 = _getAllKeysIn, getTag = _getTag, initCloneArray = _initCloneArray, initCloneByTag = _initCloneByTag, initCloneObject$1 = _initCloneObject, isArray$2 = isArray_1$1, isBuffer$1 = isBufferExports, isMap = isMap_1, isObject$5 = isObject_1$1, isSet = isSet_1, keys$1 = keys_1, keysIn$2 = keysIn_1, CLONE_DEEP_FLAG$2 = 1, CLONE_FLAT_FLAG$1 = 2, CLONE_SYMBOLS_FLAG$2 = 4, argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag$1 = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", cloneableTags = {};
      function baseClone$2(A, e, t, g, o, I) {
        var i2, r = e & CLONE_DEEP_FLAG$2, n = e & CLONE_FLAT_FLAG$1, C = e & CLONE_SYMBOLS_FLAG$2;
        if (t && (i2 = o ? t(A, g, o, I) : t(A)), void 0 !== i2)
          return i2;
        if (!isObject$5(A))
          return A;
        var E = isArray$2(A);
        if (E) {
          if (i2 = initCloneArray(A), !r)
            return copyArray$1(A, i2);
        } else {
          var s = getTag(A), B = s == funcTag || s == genTag;
          if (isBuffer$1(A))
            return cloneBuffer$1(A, r);
          if (s == objectTag$1 || s == argsTag || B && !o) {
            if (i2 = n || B ? {} : initCloneObject$1(A), !r)
              return n ? copySymbolsIn(A, baseAssignIn(i2, A)) : copySymbols(A, baseAssign(i2, A));
          } else {
            if (!cloneableTags[s])
              return o ? A : {};
            i2 = initCloneByTag(A, s, r);
          }
        }
        I || (I = new Stack$1());
        var a = I.get(A);
        if (a)
          return a;
        I.set(A, i2), isSet(A) ? A.forEach(function(g2) {
          i2.add(baseClone$2(g2, e, t, g2, A, I));
        }) : isMap(A) && A.forEach(function(g2, o2) {
          i2.set(o2, baseClone$2(g2, e, t, o2, A, I));
        });
        var Q = E ? void 0 : (C ? n ? getAllKeysIn$2 : getAllKeys : n ? keysIn$2 : keys$1)(A);
        return arrayEach(Q || A, function(g2, o2) {
          Q && (g2 = A[o2 = g2]), assignValue$1(i2, o2, baseClone$2(g2, e, t, o2, A, I));
        }), i2;
      }
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag$1] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true, cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var _baseClone = baseClone$2, baseClone$1 = _baseClone, CLONE_DEEP_FLAG$1 = 1, CLONE_SYMBOLS_FLAG$1 = 4;
      function cloneDeep(A) {
        return baseClone$1(A, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);
      }
      var cloneDeep_1 = cloneDeep, cloneDeep$1 = getDefaultExportFromCjs(cloneDeep_1), baseAssignValue$1 = _baseAssignValue, baseForOwn = _baseForOwn, baseIteratee$5 = _baseIteratee;
      function mapValues(A, e) {
        var t = {};
        return e = baseIteratee$5(e), baseForOwn(A, function(A2, g, o) {
          baseAssignValue$1(t, g, e(A2, g, o));
        }), t;
      }
      var mapValues_1 = mapValues, mapValues$1 = getDefaultExportFromCjs(mapValues_1), baseAssignValue = _baseAssignValue, eq = eq_1;
      function assignMergeValue$2(A, e, t) {
        (void 0 !== t && !eq(A[e], t) || void 0 === t && !(e in A)) && baseAssignValue(A, e, t);
      }
      var _assignMergeValue = assignMergeValue$2, isArrayLike$2 = isArrayLike_1, isObjectLike$1 = isObjectLike_1;
      function isArrayLikeObject$1(A) {
        return isObjectLike$1(A) && isArrayLike$2(A);
      }
      var isArrayLikeObject_1 = isArrayLikeObject$1, baseGetTag = _baseGetTag, getPrototype = _getPrototype, isObjectLike = isObjectLike_1, objectTag = "[object Object]", funcProto = Function.prototype, objectProto = Object.prototype, funcToString = funcProto.toString, hasOwnProperty = objectProto.hasOwnProperty, objectCtorString = funcToString.call(Object);
      function isPlainObject$3(A) {
        if (!isObjectLike(A) || baseGetTag(A) != objectTag)
          return false;
        var e = getPrototype(A);
        if (null === e)
          return true;
        var t = hasOwnProperty.call(e, "constructor") && e.constructor;
        return "function" == typeof t && t instanceof t && funcToString.call(t) == objectCtorString;
      }
      var isPlainObject_1 = isPlainObject$3;
      function safeGet$2(A, e) {
        if (("constructor" !== e || "function" != typeof A[e]) && "__proto__" != e)
          return A[e];
      }
      var _safeGet = safeGet$2, copyObject$1 = _copyObject, keysIn$1 = keysIn_1;
      function toPlainObject$1(A) {
        return copyObject$1(A, keysIn$1(A));
      }
      var toPlainObject_1 = toPlainObject$1, assignMergeValue$1 = _assignMergeValue, cloneBuffer = _cloneBufferExports, cloneTypedArray = _cloneTypedArray, copyArray = _copyArray, initCloneObject = _initCloneObject, isArguments = isArguments_1, isArray$1 = isArray_1$1, isArrayLikeObject = isArrayLikeObject_1, isBuffer = isBufferExports, isFunction$3 = isFunction_1$1, isObject$4 = isObject_1$1, isPlainObject$2 = isPlainObject_1, isTypedArray = isTypedArray_1, safeGet$1 = _safeGet, toPlainObject = toPlainObject_1;
      function baseMergeDeep$1(A, e, t, g, o, I, i2) {
        var r = safeGet$1(A, t), n = safeGet$1(e, t), C = i2.get(n);
        if (C)
          assignMergeValue$1(A, t, C);
        else {
          var E = I ? I(r, n, t + "", A, e, i2) : void 0, s = void 0 === E;
          if (s) {
            var B = isArray$1(n), a = !B && isBuffer(n), Q = !B && !a && isTypedArray(n);
            E = n, B || a || Q ? isArray$1(r) ? E = r : isArrayLikeObject(r) ? E = copyArray(r) : a ? (s = false, E = cloneBuffer(n, true)) : Q ? (s = false, E = cloneTypedArray(n, true)) : E = [] : isPlainObject$2(n) || isArguments(n) ? (E = r, isArguments(r) ? E = toPlainObject(r) : isObject$4(r) && !isFunction$3(r) || (E = initCloneObject(n))) : s = false;
          }
          s && (i2.set(n, E), o(E, n, g, I, i2), i2.delete(n)), assignMergeValue$1(A, t, E);
        }
      }
      var _baseMergeDeep = baseMergeDeep$1, Stack = _Stack, assignMergeValue = _assignMergeValue, baseFor = _baseFor, baseMergeDeep = _baseMergeDeep, isObject$3 = isObject_1$1, keysIn = keysIn_1, safeGet = _safeGet;
      function baseMerge$1(A, e, t, g, o) {
        A !== e && baseFor(e, function(I, i2) {
          if (o || (o = new Stack()), isObject$3(I))
            baseMergeDeep(A, e, i2, t, baseMerge$1, g, o);
          else {
            var r = g ? g(safeGet(A, i2), I, i2 + "", A, e, o) : void 0;
            void 0 === r && (r = I), assignMergeValue(A, i2, r);
          }
        }, keysIn);
      }
      var _baseMerge = baseMerge$1, baseRest = _baseRest, isIterateeCall = _isIterateeCall;
      function createAssigner$1(A) {
        return baseRest(function(e, t) {
          var g = -1, o = t.length, I = o > 1 ? t[o - 1] : void 0, i2 = o > 2 ? t[2] : void 0;
          for (I = A.length > 3 && "function" == typeof I ? (o--, I) : void 0, i2 && isIterateeCall(t[0], t[1], i2) && (I = o < 3 ? void 0 : I, o = 1), e = Object(e); ++g < o; ) {
            var r = t[g];
            r && A(e, r, g, I);
          }
          return e;
        });
      }
      var _createAssigner = createAssigner$1, baseMerge = _baseMerge, createAssigner = _createAssigner, mergeWith = createAssigner(function(A, e, t, g) {
        baseMerge(A, e, t, g);
      }), mergeWith_1 = mergeWith, mergeWith$1 = getDefaultExportFromCjs(mergeWith_1);
      function last$1(A) {
        var e = null == A ? 0 : A.length;
        return e ? A[e - 1] : void 0;
      }
      var last_1 = last$1;
      function baseSlice$1(A, e, t) {
        var g = -1, o = A.length;
        e < 0 && (e = -e > o ? 0 : o + e), (t = t > o ? o : t) < 0 && (t += o), o = e > t ? 0 : t - e >>> 0, e >>>= 0;
        for (var I = Array(o); ++g < o; )
          I[g] = A[g + e];
        return I;
      }
      var _baseSlice = baseSlice$1, baseGet$1 = _baseGet, baseSlice = _baseSlice;
      function parent$1(A, e) {
        return e.length < 2 ? A : baseGet$1(A, baseSlice(e, 0, -1));
      }
      var _parent = parent$1, castPath$3 = _castPath, last = last_1, parent = _parent, toKey$1 = _toKey;
      function baseUnset$1(A, e) {
        return e = castPath$3(e, A), null == (A = parent(A, e)) || delete A[toKey$1(last(e))];
      }
      var _baseUnset = baseUnset$1, isPlainObject$1 = isPlainObject_1;
      function customOmitClone$1(A) {
        return isPlainObject$1(A) ? void 0 : A;
      }
      var _customOmitClone = customOmitClone$1, baseFlatten = _baseFlatten;
      function flatten$1(A) {
        return (null == A ? 0 : A.length) ? baseFlatten(A, 1) : [];
      }
      var flatten_1 = flatten$1, flatten = flatten_1, overRest = _overRest, setToString = _setToString;
      function flatRest$1(A) {
        return setToString(overRest(A, void 0, flatten), A + "");
      }
      var _flatRest = flatRest$1, arrayMap$1 = _arrayMap, baseClone = _baseClone, baseUnset = _baseUnset, castPath$2 = _castPath, copyObject = _copyObject, customOmitClone = _customOmitClone, flatRest = _flatRest, getAllKeysIn$1 = _getAllKeysIn, CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4, omit = flatRest(function(A, e) {
        var t = {};
        if (null == A)
          return t;
        var g = false;
        e = arrayMap$1(e, function(e2) {
          return e2 = castPath$2(e2, A), g || (g = e2.length > 1), e2;
        }), copyObject(A, getAllKeysIn$1(A), t), g && (t = baseClone(t, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone));
        for (var o = e.length; o--; )
          baseUnset(t, e[o]);
        return t;
      }), omit_1 = omit, omit$1 = getDefaultExportFromCjs(omit_1), root = _root, toString = toString_1, reTrimStart = /^\s+/, nativeParseInt = root.parseInt;
      function parseInt$1(A, e, t) {
        return t || null == e ? e = 0 : e && (e = +e), nativeParseInt(toString(A).replace(reTrimStart, ""), e || 0);
      }
      var _parseInt = parseInt$1, parseInt$2 = getDefaultExportFromCjs(_parseInt);
      function isUndefined$1(A) {
        return void 0 === A;
      }
      var isUndefined_1 = isUndefined$1, isUndefined$2 = getDefaultExportFromCjs(isUndefined_1), FUNC_ERROR_TEXT = "Expected a function";
      function negate$1(A) {
        if ("function" != typeof A)
          throw new TypeError(FUNC_ERROR_TEXT);
        return function() {
          var e = arguments;
          switch (e.length) {
            case 0:
              return !A.call(this);
            case 1:
              return !A.call(this, e[0]);
            case 2:
              return !A.call(this, e[0], e[1]);
            case 3:
              return !A.call(this, e[0], e[1], e[2]);
          }
          return !A.apply(this, e);
        };
      }
      var negate_1 = negate$1, assignValue = _assignValue, castPath$1 = _castPath, isIndex = _isIndex, isObject$2 = isObject_1$1, toKey = _toKey;
      function baseSet$1(A, e, t, g) {
        if (!isObject$2(A))
          return A;
        for (var o = -1, I = (e = castPath$1(e, A)).length, i2 = I - 1, r = A; null != r && ++o < I; ) {
          var n = toKey(e[o]), C = t;
          if ("__proto__" === n || "constructor" === n || "prototype" === n)
            return A;
          if (o != i2) {
            var E = r[n];
            void 0 === (C = g ? g(E, n, r) : void 0) && (C = isObject$2(E) ? E : isIndex(e[o + 1]) ? [] : {});
          }
          assignValue(r, n, C), r = r[n];
        }
        return A;
      }
      var _baseSet = baseSet$1, baseGet = _baseGet, baseSet = _baseSet, castPath = _castPath;
      function basePickBy$1(A, e, t) {
        for (var g = -1, o = e.length, I = {}; ++g < o; ) {
          var i2 = e[g], r = baseGet(A, i2);
          t(r, i2) && baseSet(I, castPath(i2, A), r);
        }
        return I;
      }
      var _basePickBy = basePickBy$1, arrayMap = _arrayMap, baseIteratee$4 = _baseIteratee, basePickBy = _basePickBy, getAllKeysIn = _getAllKeysIn;
      function pickBy$1(A, e) {
        if (null == A)
          return {};
        var t = arrayMap(getAllKeysIn(A), function(A2) {
          return [A2];
        });
        return e = baseIteratee$4(e), basePickBy(A, t, function(A2, t2) {
          return e(A2, t2[0]);
        });
      }
      var pickBy_1 = pickBy$1, baseIteratee$3 = _baseIteratee, negate = negate_1, pickBy = pickBy_1;
      function omitBy(A, e) {
        return pickBy(A, negate(baseIteratee$3(e)));
      }
      var omitBy_1 = omitBy, omitBy$1 = getDefaultExportFromCjs(omitBy_1);
      function isNull$1(A) {
        return null === A;
      }
      var isNull_1 = isNull$1, isNull$2 = getDefaultExportFromCjs(isNull_1), baseIteratee$2 = _baseIteratee, isArrayLike$1 = isArrayLike_1, keys = keys_1;
      function createFind$1(A) {
        return function(e, t, g) {
          var o = Object(e);
          if (!isArrayLike$1(e)) {
            var I = baseIteratee$2(t);
            e = keys(e), t = function(A2) {
              return I(o[A2], A2, o);
            };
          }
          var i2 = A(e, t, g);
          return i2 > -1 ? o[I ? e[i2] : i2] : void 0;
        };
      }
      var _createFind = createFind$1;
      function baseFindIndex$3(A, e, t, g) {
        for (var o = A.length, I = t + (g ? 1 : -1); g ? I-- : ++I < o; )
          if (e(A[I], I, A))
            return I;
        return -1;
      }
      var _baseFindIndex = baseFindIndex$3, toFinite = toFinite_1;
      function toInteger$2(A) {
        var e = toFinite(A), t = e % 1;
        return e == e ? t ? e - t : e : 0;
      }
      var toInteger_1 = toInteger$2, baseFindIndex$2 = _baseFindIndex, baseIteratee$1 = _baseIteratee, toInteger$1 = toInteger_1, nativeMax$1 = Math.max;
      function findIndex$1(A, e, t) {
        var g = null == A ? 0 : A.length;
        if (!g)
          return -1;
        var o = null == t ? 0 : toInteger$1(t);
        return o < 0 && (o = nativeMax$1(g + o, 0)), baseFindIndex$2(A, baseIteratee$1(e), o);
      }
      var findIndex_1 = findIndex$1, createFind = _createFind, findIndex = findIndex_1, find = createFind(findIndex), find_1 = find, find$1 = getDefaultExportFromCjs(find_1);
      function baseIsNaN$1(A) {
        return A != A;
      }
      var _baseIsNaN = baseIsNaN$1;
      function strictIndexOf$1(A, e, t) {
        for (var g = t - 1, o = A.length; ++g < o; )
          if (A[g] === e)
            return g;
        return -1;
      }
      var _strictIndexOf = strictIndexOf$1, baseFindIndex$1 = _baseFindIndex, baseIsNaN = _baseIsNaN, strictIndexOf = _strictIndexOf;
      function baseIndexOf$1(A, e, t) {
        return e == e ? strictIndexOf(A, e, t) : baseFindIndex$1(A, baseIsNaN, t);
      }
      var _baseIndexOf = baseIndexOf$1, baseIndexOf = _baseIndexOf;
      function arrayIncludes$1(A, e) {
        return !!(null == A ? 0 : A.length) && baseIndexOf(A, e, 0) > -1;
      }
      var _arrayIncludes = arrayIncludes$1;
      function arrayIncludesWith$1(A, e, t) {
        for (var g = -1, o = null == A ? 0 : A.length; ++g < o; )
          if (t(e, A[g]))
            return true;
        return false;
      }
      var _arrayIncludesWith = arrayIncludesWith$1;
      function noop$2() {
      }
      var noop_1 = noop$2, Set$1 = _Set, noop$1 = noop_1, setToArray$1 = _setToArray, INFINITY = 1 / 0, createSet$1 = Set$1 && 1 / setToArray$1(new Set$1([, -0]))[1] == INFINITY ? function(A) {
        return new Set$1(A);
      } : noop$1, _createSet = createSet$1, SetCache = _SetCache, arrayIncludes = _arrayIncludes, arrayIncludesWith = _arrayIncludesWith, cacheHas = _cacheHas, createSet = _createSet, setToArray = _setToArray, LARGE_ARRAY_SIZE = 200;
      function baseUniq$1(A, e, t) {
        var g = -1, o = arrayIncludes, I = A.length, i2 = true, r = [], n = r;
        if (t)
          i2 = false, o = arrayIncludesWith;
        else if (I >= LARGE_ARRAY_SIZE) {
          var C = e ? null : createSet(A);
          if (C)
            return setToArray(C);
          i2 = false, o = cacheHas, n = new SetCache();
        } else
          n = e ? [] : r;
        A:
          for (; ++g < I; ) {
            var E = A[g], s = e ? e(E) : E;
            if (E = t || 0 !== E ? E : 0, i2 && s == s) {
              for (var B = n.length; B--; )
                if (n[B] === s)
                  continue A;
              e && n.push(s), r.push(E);
            } else
              o(n, s, t) || (n !== r && n.push(s), r.push(E));
          }
        return r;
      }
      var _baseUniq = baseUniq$1, baseUniq = _baseUniq;
      function uniqWith(A, e) {
        return e = "function" == typeof e ? e : void 0, A && A.length ? baseUniq(A, void 0, e) : [];
      }
      var uniqWith_1 = uniqWith, uniqWith$1 = getDefaultExportFromCjs(uniqWith_1), baseFindIndex = _baseFindIndex, baseIteratee = _baseIteratee, toInteger = toInteger_1, nativeMax = Math.max, nativeMin = Math.min;
      function findLastIndex(A, e, t) {
        var g = null == A ? 0 : A.length;
        if (!g)
          return -1;
        var o = g - 1;
        return void 0 !== t && (o = toInteger(t), o = t < 0 ? nativeMax(g + o, 0) : nativeMin(o, g - 1)), baseFindIndex(A, baseIteratee(e), o, true);
      }
      var findLastIndex_1 = findLastIndex, findLastIndex$1 = getDefaultExportFromCjs(findLastIndex_1);
      const EDGE_ENV_PORT_DEFAULT = EDGE_ENV_PORT, DEFAULT_API_RATE_LIMIT = /* @__PURE__ */ new Map([["removeLock", 20], ["setLock", 20], ["acquireLock", 10], ["releaseLock", 20], ["revokeLock", 20], ["getLock", 20], ["userMetaModify", 20], ["userMetaGet", 20], ["userMetaSub", 20], ["channelMetaModify", 20], ["channelMetaGet", 20], ["login", 20], ["renewToken", 20], ["whoNow", 20], ["whereNow", 20], ["modifyState", 20], ["getState", 20], ["subscribe", 20], ["join", 20], ["joinTopic", 20], ["subscribeTopic", 20], ["publish", 60], ["publishTopicMsg", 200], ["getMessages", 20]]), loginConfig = { AP_DOMAIN_LIST: void 0, EDGE_DOMAIN_TLD_LIST: void 0, EDGE_IP_LIST: void 0, EDGE_ENV_PORT: EDGE_ENV_PORT_DEFAULT, REGISTRAR_USE_WS: false }, consoleConfig = { RTM2_ENABLED: true, LOCK_ENABLED: void 0, STORAGE_ENABLED: void 0, STORAGE_CHANNEL_SUB_ENABLED: void 0, STORAGE_USER_SUB_ENABLED: void 0, PRESENCE_INTERVAL: void 0, PRESENCE_THRESHOLD: void 0, PRESENCE_DEBOUNCE: void 0, PRESENCE_TIMEOUT: K_PRESENCE_TIMEOUT_DEFAULT, PRESENCE_RPC_TIMEOUT: DEFAULT_RPC_TIMEOUT_TIME, API_RATE_LIMIT: DEFAULT_API_RATE_LIMIT, ENABLE_API_RATE_LIMIT: true }, MUTABLE_PARAMS = _objectSpread2(_objectSpread2({ RECONNECTING_AP_INTERVAL: 2500, CONCURRENT_AP_NUM: void 0, DISABLE_MESSAGE_COMPRESSION: false, LOG_UPLOAD_INTERVAL: 5e3, LOG_HANDLER: void 0, ENABLE_EDGE_AUTO_FALLBACK: true, MAX_STATE_COUNT, PRINT_TICK_LOG: false, RTM_LINK_KEEP_ALIVE_TIMEOUT: void 0, HEART_BEAT: void 0, VID: /* @__PURE__ */ new Map(), STREAM_CHANNEL_COUNT: SUB_STREAM_CHANNEL_LIMITATION, MESSAGE_CHANNEL_COUNT: MAX_JOINED_CHANNELS, HISTORY_MSG_COUNT_LIMIT: GET_MESSAGE_MAX_COUNT, LOG_PING_PONG: false, AREA_CONFIG: void 0, DECOUPLE_SYNC: true, LOCK_TTL: LOCK_DEFAULT_TTL, EDGE_USE_IP: false, SENSITIVE_LOG: true, PRESENCE_BACKOFF_EVENT_INTERVAL: void 0, TDS_DOMAINS: void 0, CONFIG_QUERY_INTERVAL: void 0, LOG_UPLOAD_DOMAIN_LIST: void 0, EVENT_REPORT_DOMAIN_LIST: void 0, DISABLE_PRESENCE: false, P2P_MSG_REORDER_TIMEOUT: void 0, CHANNEL_MSG_REORDER_TIMEOUT: void 0 }, consoleConfig), loginConfig);
      class Parameter {
        _setParameter(A, e) {
          if (console.log(JSON.stringify({ key: A, value: e }), "RTM setParameter"), !Object.keys(MUTABLE_PARAMS).includes(A)) {
            console.warn("setParameter: key is not in MUTABLE_PARAMS");
            const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_INVALID_PARAMETER);
            throw new RtmInvalidArgumentError("set parameter", [e2], A2);
          }
          switch (A) {
            case "STREAM_CHANNEL_COUNT":
              const t = "number" == typeof e && e > 100 ? 100 : "number" == typeof e ? e : SUB_STREAM_CHANNEL_LIMITATION;
              MUTABLE_PARAMS.STREAM_CHANNEL_COUNT = t;
              break;
            case "MESSAGE_CHANNEL_COUNT":
              MUTABLE_PARAMS.MESSAGE_CHANNEL_COUNT = "number" == typeof e ? e : MAX_JOINED_CHANNELS;
            case "HISTORY_MSG_COUNT_LIMIT":
              MUTABLE_PARAMS.HISTORY_MSG_COUNT_LIMIT = "number" == typeof e ? e : GET_MESSAGE_MAX_COUNT;
              break;
            case "API_RATE_LIMIT":
              if (isNil$1(e))
                MUTABLE_PARAMS.API_RATE_LIMIT = DEFAULT_API_RATE_LIMIT;
              else {
                if (!(e instanceof Map)) {
                  console.warn("setParameter: API_RATE_LIMIT value is not a Map");
                  const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_INVALID_PARAMETER);
                  throw new RtmInvalidArgumentError("set parameter", [e2], A2);
                }
                {
                  const A2 = e.entries();
                  Array.from(A2).forEach((A3) => {
                    let [e2, t2] = A3;
                    "number" == typeof t2 && MUTABLE_PARAMS.API_RATE_LIMIT.set(e2, t2);
                  });
                }
              }
              break;
            default:
              MUTABLE_PARAMS[A] = e;
          }
        }
        _getParameter(A) {
          return MUTABLE_PARAMS[A];
        }
        setParameter(A, e) {
          return this._setParameter(A, e);
        }
        getParameter(A) {
          return this._getParameter(A);
        }
      }
      const p = new Parameter(), setParameter = p.setParameter.bind(p), getParameter = p.getParameter.bind(p);
      function setVidParameter(A, e) {
        const t = getParameter("VID");
        t.set(A, e), setParameter("VID", t);
      }
      function catchError(A) {
        return function(e) {
          var t = new CatchOperator(A), g = e.lift(t);
          return t.caught = g;
        };
      }
      var CatchOperator = function() {
        function A(A2) {
          this.selector = A2;
        }
        return A.prototype.call = function(A2, e) {
          return e.subscribe(new CatchSubscriber(A2, this.selector, this.caught));
        }, A;
      }(), CatchSubscriber = function(A) {
        function e(e2, t, g) {
          var o = A.call(this, e2) || this;
          return o.selector = t, o.caught = g, o;
        }
        return __extends$3(e, A), e.prototype.error = function(e2) {
          if (!this.isStopped) {
            var t = void 0;
            try {
              t = this.selector(e2, this.caught);
            } catch (e3) {
              return void A.prototype.error.call(this, e3);
            }
            this._unsubscribeAndRecycle();
            var g = new SimpleInnerSubscriber(this);
            this.add(g);
            var o = innerSubscribe(t, g);
            o !== g && this.add(o);
          }
        }, e;
      }(SimpleOuterSubscriber);
      function concatMap(A, e) {
        return mergeMap(A, e, 1);
      }
      function defaultIfEmpty(A) {
        return void 0 === A && (A = null), function(e) {
          return e.lift(new DefaultIfEmptyOperator(A));
        };
      }
      var DefaultIfEmptyOperator = function() {
        function A(A2) {
          this.defaultValue = A2;
        }
        return A.prototype.call = function(A2, e) {
          return e.subscribe(new DefaultIfEmptySubscriber(A2, this.defaultValue));
        }, A;
      }(), DefaultIfEmptySubscriber = function(A) {
        function e(e2, t) {
          var g = A.call(this, e2) || this;
          return g.defaultValue = t, g.isEmpty = true, g;
        }
        return __extends$3(e, A), e.prototype._next = function(A2) {
          this.isEmpty = false, this.destination.next(A2);
        }, e.prototype._complete = function() {
          this.isEmpty && this.destination.next(this.defaultValue), this.destination.complete();
        }, e;
      }(Subscriber);
      function isDate(A) {
        return A instanceof Date && !isNaN(+A);
      }
      function delay(A, e) {
        void 0 === e && (e = async);
        var t = isDate(A) ? +A - e.now() : Math.abs(A);
        return function(A2) {
          return A2.lift(new DelayOperator(t, e));
        };
      }
      var DelayOperator = function() {
        function A(A2, e) {
          this.delay = A2, this.scheduler = e;
        }
        return A.prototype.call = function(A2, e) {
          return e.subscribe(new DelaySubscriber(A2, this.delay, this.scheduler));
        }, A;
      }(), DelaySubscriber = function(A) {
        function e(e2, t, g) {
          var o = A.call(this, e2) || this;
          return o.delay = t, o.scheduler = g, o.queue = [], o.active = false, o.errored = false, o;
        }
        return __extends$3(e, A), e.dispatch = function(A2) {
          for (var e2 = A2.source, t = e2.queue, g = A2.scheduler, o = A2.destination; t.length > 0 && t[0].time - g.now() <= 0; )
            t.shift().notification.observe(o);
          if (t.length > 0) {
            var I = Math.max(0, t[0].time - g.now());
            this.schedule(A2, I);
          } else
            this.unsubscribe(), e2.active = false;
        }, e.prototype._schedule = function(A2) {
          this.active = true, this.destination.add(A2.schedule(e.dispatch, this.delay, { source: this, destination: this.destination, scheduler: A2 }));
        }, e.prototype.scheduleNotification = function(A2) {
          if (true !== this.errored) {
            var e2 = this.scheduler, t = new DelayMessage(e2.now() + this.delay, A2);
            this.queue.push(t), false === this.active && this._schedule(e2);
          }
        }, e.prototype._next = function(A2) {
          this.scheduleNotification(Notification.createNext(A2));
        }, e.prototype._error = function(A2) {
          this.errored = true, this.queue = [], this.destination.error(A2), this.unsubscribe();
        }, e.prototype._complete = function() {
          this.scheduleNotification(Notification.createComplete()), this.unsubscribe();
        }, e;
      }(Subscriber), DelayMessage = function() {
        return function(A, e) {
          this.time = A, this.notification = e;
        };
      }();
      function distinct(A, e) {
        return function(t) {
          return t.lift(new DistinctOperator(A, e));
        };
      }
      var DistinctOperator = function() {
        function A(A2, e) {
          this.keySelector = A2, this.flushes = e;
        }
        return A.prototype.call = function(A2, e) {
          return e.subscribe(new DistinctSubscriber(A2, this.keySelector, this.flushes));
        }, A;
      }(), DistinctSubscriber = function(A) {
        function e(e2, t, g) {
          var o = A.call(this, e2) || this;
          return o.keySelector = t, o.values = /* @__PURE__ */ new Set(), g && o.add(innerSubscribe(g, new SimpleInnerSubscriber(o))), o;
        }
        return __extends$3(e, A), e.prototype.notifyNext = function() {
          this.values.clear();
        }, e.prototype.notifyError = function(A2) {
          this._error(A2);
        }, e.prototype._next = function(A2) {
          this.keySelector ? this._useKeySelector(A2) : this._finalizeNext(A2, A2);
        }, e.prototype._useKeySelector = function(A2) {
          var e2, t = this.destination;
          try {
            e2 = this.keySelector(A2);
          } catch (A3) {
            return void t.error(A3);
          }
          this._finalizeNext(e2, A2);
        }, e.prototype._finalizeNext = function(A2, e2) {
          var t = this.values;
          t.has(A2) || (t.add(A2), this.destination.next(e2));
        }, e;
      }(SimpleOuterSubscriber);
      function throwIfEmpty(A) {
        return void 0 === A && (A = defaultErrorFactory), function(e) {
          return e.lift(new ThrowIfEmptyOperator(A));
        };
      }
      var ThrowIfEmptyOperator = function() {
        function A(A2) {
          this.errorFactory = A2;
        }
        return A.prototype.call = function(A2, e) {
          return e.subscribe(new ThrowIfEmptySubscriber(A2, this.errorFactory));
        }, A;
      }(), ThrowIfEmptySubscriber = function(A) {
        function e(e2, t) {
          var g = A.call(this, e2) || this;
          return g.errorFactory = t, g.hasValue = false, g;
        }
        return __extends$3(e, A), e.prototype._next = function(A2) {
          this.hasValue = true, this.destination.next(A2);
        }, e.prototype._complete = function() {
          if (this.hasValue)
            return this.destination.complete();
          var A2 = void 0;
          try {
            A2 = this.errorFactory();
          } catch (e2) {
            A2 = e2;
          }
          this.destination.error(A2);
        }, e;
      }(Subscriber);
      function defaultErrorFactory() {
        return new EmptyError();
      }
      function take(A) {
        return function(e) {
          return 0 === A ? empty() : e.lift(new TakeOperator(A));
        };
      }
      var TakeOperator = function() {
        function A(A2) {
          if (this.total = A2, this.total < 0)
            throw new ArgumentOutOfRangeError();
        }
        return A.prototype.call = function(A2, e) {
          return e.subscribe(new TakeSubscriber(A2, this.total));
        }, A;
      }(), TakeSubscriber = function(A) {
        function e(e2, t) {
          var g = A.call(this, e2) || this;
          return g.total = t, g.count = 0, g;
        }
        return __extends$3(e, A), e.prototype._next = function(A2) {
          var e2 = this.total, t = ++this.count;
          t <= e2 && (this.destination.next(A2), t === e2 && (this.destination.complete(), this.unsubscribe()));
        }, e;
      }(Subscriber);
      function finalize(A) {
        return function(e) {
          return e.lift(new FinallyOperator(A));
        };
      }
      var FinallyOperator = function() {
        function A(A2) {
          this.callback = A2;
        }
        return A.prototype.call = function(A2, e) {
          return e.subscribe(new FinallySubscriber(A2, this.callback));
        }, A;
      }(), FinallySubscriber = function(A) {
        function e(e2, t) {
          var g = A.call(this, e2) || this;
          return g.add(new Subscription$2(t)), g;
        }
        return __extends$3(e, A), e;
      }(Subscriber);
      function first(A, e) {
        var t = arguments.length >= 2;
        return function(g) {
          return g.pipe(A ? filter(function(e2, t2) {
            return A(e2, t2, g);
          }) : identity$5, take(1), t ? defaultIfEmpty(e) : throwIfEmpty(function() {
            return new EmptyError();
          }));
        };
      }
      function ignoreElements() {
        return function(A) {
          return A.lift(new IgnoreElementsOperator());
        };
      }
      var IgnoreElementsOperator = function() {
        function A() {
        }
        return A.prototype.call = function(A2, e) {
          return e.subscribe(new IgnoreElementsSubscriber(A2));
        }, A;
      }(), IgnoreElementsSubscriber = function(A) {
        function e() {
          return null !== A && A.apply(this, arguments) || this;
        }
        return __extends$3(e, A), e.prototype._next = function(A2) {
        }, e;
      }(Subscriber);
      function takeLast(A) {
        return function(e) {
          return e.lift(new TakeLastOperator(A));
        };
      }
      var TakeLastOperator = function() {
        function A(A2) {
          if (this.total = A2, this.total < 0)
            throw new ArgumentOutOfRangeError();
        }
        return A.prototype.call = function(A2, e) {
          return e.subscribe(new TakeLastSubscriber(A2, this.total));
        }, A;
      }(), TakeLastSubscriber = function(A) {
        function e(e2, t) {
          var g = A.call(this, e2) || this;
          return g.total = t, g.ring = new Array(), g.count = 0, g;
        }
        return __extends$3(e, A), e.prototype._next = function(A2) {
          var e2 = this.ring, t = this.total, g = this.count++;
          e2.length < t ? e2.push(A2) : e2[g % t] = A2;
        }, e.prototype._complete = function() {
          var A2 = this.destination, e2 = this.count;
          if (e2 > 0)
            for (var t = this.count >= this.total ? this.total : this.count, g = this.ring, o = 0; o < t; o++) {
              var I = e2++ % t;
              A2.next(g[I]);
            }
          A2.complete();
        }, e;
      }(Subscriber);
      function mapTo(A) {
        return function(e) {
          return e.lift(new MapToOperator(A));
        };
      }
      var MapToOperator = function() {
        function A(A2) {
          this.value = A2;
        }
        return A.prototype.call = function(A2, e) {
          return e.subscribe(new MapToSubscriber(A2, this.value));
        }, A;
      }(), MapToSubscriber = function(A) {
        function e(e2, t) {
          var g = A.call(this, e2) || this;
          return g.value = t, g;
        }
        return __extends$3(e, A), e.prototype._next = function(A2) {
          this.destination.next(this.value);
        }, e;
      }(Subscriber);
      function scan(A, e) {
        var t = false;
        return arguments.length >= 2 && (t = true), function(g) {
          return g.lift(new ScanOperator(A, e, t));
        };
      }
      var ScanOperator = function() {
        function A(A2, e, t) {
          void 0 === t && (t = false), this.accumulator = A2, this.seed = e, this.hasSeed = t;
        }
        return A.prototype.call = function(A2, e) {
          return e.subscribe(new ScanSubscriber(A2, this.accumulator, this.seed, this.hasSeed));
        }, A;
      }(), ScanSubscriber = function(A) {
        function e(e2, t, g, o) {
          var I = A.call(this, e2) || this;
          return I.accumulator = t, I._seed = g, I.hasSeed = o, I.index = 0, I;
        }
        return __extends$3(e, A), Object.defineProperty(e.prototype, "seed", { get: function() {
          return this._seed;
        }, set: function(A2) {
          this.hasSeed = true, this._seed = A2;
        }, enumerable: true, configurable: true }), e.prototype._next = function(A2) {
          if (this.hasSeed)
            return this._tryNext(A2);
          this.seed = A2, this.destination.next(A2);
        }, e.prototype._tryNext = function(A2) {
          var e2, t = this.index++;
          try {
            e2 = this.accumulator(this.seed, A2, t);
          } catch (A3) {
            this.destination.error(A3);
          }
          this.seed = e2, this.destination.next(e2);
        }, e;
      }(Subscriber);
      function reduce(A, e) {
        return arguments.length >= 2 ? function(t) {
          return pipe(scan(A, e), takeLast(1), defaultIfEmpty(e))(t);
        } : function(e2) {
          return pipe(scan(function(e3, t, g) {
            return A(e3, t, g + 1);
          }), takeLast(1))(e2);
        };
      }
      function multicast(A, e) {
        return function(e2) {
          var t;
          t = "function" == typeof A ? A : function() {
            return A;
          };
          var g = Object.create(e2, connectableObservableDescriptor);
          return g.source = e2, g.subjectFactory = t, g;
        };
      }
      function retryWhen(A) {
        return function(e) {
          return e.lift(new RetryWhenOperator(A, e));
        };
      }
      var RetryWhenOperator = function() {
        function A(A2, e) {
          this.notifier = A2, this.source = e;
        }
        return A.prototype.call = function(A2, e) {
          return e.subscribe(new RetryWhenSubscriber(A2, this.notifier, this.source));
        }, A;
      }(), RetryWhenSubscriber = function(A) {
        function e(e2, t, g) {
          var o = A.call(this, e2) || this;
          return o.notifier = t, o.source = g, o;
        }
        return __extends$3(e, A), e.prototype.error = function(e2) {
          if (!this.isStopped) {
            var t = this.errors, g = this.retries, o = this.retriesSubscription;
            if (g)
              this.errors = void 0, this.retriesSubscription = void 0;
            else {
              t = new Subject();
              try {
                g = (0, this.notifier)(t);
              } catch (e3) {
                return A.prototype.error.call(this, e3);
              }
              o = innerSubscribe(g, new SimpleInnerSubscriber(this));
            }
            this._unsubscribeAndRecycle(), this.errors = t, this.retries = g, this.retriesSubscription = o, t.next(e2);
          }
        }, e.prototype._unsubscribe = function() {
          var A2 = this.errors, e2 = this.retriesSubscription;
          A2 && (A2.unsubscribe(), this.errors = void 0), e2 && (e2.unsubscribe(), this.retriesSubscription = void 0), this.retries = void 0;
        }, e.prototype.notifyNext = function() {
          var A2 = this._unsubscribe;
          this._unsubscribe = null, this._unsubscribeAndRecycle(), this._unsubscribe = A2, this.source.subscribe(this);
        }, e;
      }(SimpleOuterSubscriber);
      function shareSubjectFactory() {
        return new Subject();
      }
      function share() {
        return function(A) {
          return refCount()(multicast(shareSubjectFactory)(A));
        };
      }
      function shareReplay(A, e, t) {
        var g;
        return g = { bufferSize: A, windowTime: e, refCount: false, scheduler: t }, function(A2) {
          return A2.lift(shareReplayOperator(g));
        };
      }
      function shareReplayOperator(A) {
        var e, t, g = A.bufferSize, o = void 0 === g ? Number.POSITIVE_INFINITY : g, I = A.windowTime, i2 = void 0 === I ? Number.POSITIVE_INFINITY : I, r = A.refCount, n = A.scheduler, C = 0, E = false, s = false;
        return function(A2) {
          var g2;
          C++, !e || E ? (E = false, e = new ReplaySubject(o, i2, n), g2 = e.subscribe(this), t = A2.subscribe({ next: function(A3) {
            e.next(A3);
          }, error: function(A3) {
            E = true, e.error(A3);
          }, complete: function() {
            s = true, t = void 0, e.complete();
          } }), s && (t = void 0)) : g2 = e.subscribe(this), this.add(function() {
            C--, g2.unsubscribe(), g2 = void 0, t && !s && r && 0 === C && (t.unsubscribe(), t = void 0, e = void 0);
          });
        };
      }
      function switchMap(A, e) {
        return function(e2) {
          return e2.lift(new SwitchMapOperator(A));
        };
      }
      var SwitchMapOperator = function() {
        function A(A2) {
          this.project = A2;
        }
        return A.prototype.call = function(A2, e) {
          return e.subscribe(new SwitchMapSubscriber(A2, this.project));
        }, A;
      }(), SwitchMapSubscriber = function(A) {
        function e(e2, t) {
          var g = A.call(this, e2) || this;
          return g.project = t, g.index = 0, g;
        }
        return __extends$3(e, A), e.prototype._next = function(A2) {
          var e2, t = this.index++;
          try {
            e2 = this.project(A2, t);
          } catch (A3) {
            return void this.destination.error(A3);
          }
          this._innerSub(e2);
        }, e.prototype._innerSub = function(A2) {
          var e2 = this.innerSubscription;
          e2 && e2.unsubscribe();
          var t = new SimpleInnerSubscriber(this), g = this.destination;
          g.add(t), this.innerSubscription = innerSubscribe(A2, t), this.innerSubscription !== t && g.add(this.innerSubscription);
        }, e.prototype._complete = function() {
          var e2 = this.innerSubscription;
          e2 && !e2.closed || A.prototype._complete.call(this), this.unsubscribe();
        }, e.prototype._unsubscribe = function() {
          this.innerSubscription = void 0;
        }, e.prototype.notifyComplete = function() {
          this.innerSubscription = void 0, this.isStopped && A.prototype._complete.call(this);
        }, e.prototype.notifyNext = function(A2) {
          this.destination.next(A2);
        }, e;
      }(SimpleOuterSubscriber);
      function switchAll() {
        return switchMap(identity$5);
      }
      function takeUntil(A) {
        return function(e) {
          return e.lift(new TakeUntilOperator(A));
        };
      }
      var TakeUntilOperator = function() {
        function A(A2) {
          this.notifier = A2;
        }
        return A.prototype.call = function(A2, e) {
          var t = new TakeUntilSubscriber(A2), g = innerSubscribe(this.notifier, new SimpleInnerSubscriber(t));
          return g && !t.seenValue ? (t.add(g), e.subscribe(t)) : t;
        }, A;
      }(), TakeUntilSubscriber = function(A) {
        function e(e2) {
          var t = A.call(this, e2) || this;
          return t.seenValue = false, t;
        }
        return __extends$3(e, A), e.prototype.notifyNext = function() {
          this.seenValue = true, this.complete();
        }, e.prototype.notifyComplete = function() {
        }, e;
      }(SimpleOuterSubscriber);
      function tap(A, e, t) {
        return function(g) {
          return g.lift(new DoOperator(A, e, t));
        };
      }
      var DoOperator = function() {
        function A(A2, e, t) {
          this.nextOrObserver = A2, this.error = e, this.complete = t;
        }
        return A.prototype.call = function(A2, e) {
          return e.subscribe(new TapSubscriber(A2, this.nextOrObserver, this.error, this.complete));
        }, A;
      }(), TapSubscriber = function(A) {
        function e(e2, t, g, o) {
          var I = A.call(this, e2) || this;
          return I._tapNext = noop$3, I._tapError = noop$3, I._tapComplete = noop$3, I._tapError = g || noop$3, I._tapComplete = o || noop$3, isFunction$7(t) ? (I._context = I, I._tapNext = t) : t && (I._context = t, I._tapNext = t.next || noop$3, I._tapError = t.error || noop$3, I._tapComplete = t.complete || noop$3), I;
        }
        return __extends$3(e, A), e.prototype._next = function(A2) {
          try {
            this._tapNext.call(this._context, A2);
          } catch (A3) {
            return void this.destination.error(A3);
          }
          this.destination.next(A2);
        }, e.prototype._error = function(A2) {
          try {
            this._tapError.call(this._context, A2);
          } catch (A3) {
            return void this.destination.error(A3);
          }
          this.destination.error(A2);
        }, e.prototype._complete = function() {
          try {
            this._tapComplete.call(this._context);
          } catch (A2) {
            return void this.destination.error(A2);
          }
          return this.destination.complete();
        }, e;
      }(Subscriber), defaultThrottleConfig = { leading: true, trailing: false };
      function throttleTime(A, e, t) {
        return void 0 === e && (e = async), void 0 === t && (t = defaultThrottleConfig), function(g) {
          return g.lift(new ThrottleTimeOperator(A, e, t.leading, t.trailing));
        };
      }
      var ThrottleTimeOperator = function() {
        function A(A2, e, t, g) {
          this.duration = A2, this.scheduler = e, this.leading = t, this.trailing = g;
        }
        return A.prototype.call = function(A2, e) {
          return e.subscribe(new ThrottleTimeSubscriber(A2, this.duration, this.scheduler, this.leading, this.trailing));
        }, A;
      }(), ThrottleTimeSubscriber = function(A) {
        function e(e2, t, g, o, I) {
          var i2 = A.call(this, e2) || this;
          return i2.duration = t, i2.scheduler = g, i2.leading = o, i2.trailing = I, i2._hasTrailingValue = false, i2._trailingValue = null, i2;
        }
        return __extends$3(e, A), e.prototype._next = function(A2) {
          this.throttled ? this.trailing && (this._trailingValue = A2, this._hasTrailingValue = true) : (this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this })), this.leading ? this.destination.next(A2) : this.trailing && (this._trailingValue = A2, this._hasTrailingValue = true));
        }, e.prototype._complete = function() {
          this._hasTrailingValue ? (this.destination.next(this._trailingValue), this.destination.complete()) : this.destination.complete();
        }, e.prototype.clearThrottle = function() {
          var A2 = this.throttled;
          A2 && (this.trailing && this._hasTrailingValue && (this.destination.next(this._trailingValue), this._trailingValue = null, this._hasTrailingValue = false), A2.unsubscribe(), this.remove(A2), this.throttled = null);
        }, e;
      }(Subscriber);
      function dispatchNext(A) {
        A.subscriber.clearThrottle();
      }
      function timeoutWith(A, e, t) {
        return void 0 === t && (t = async), function(g) {
          var o = isDate(A), I = o ? +A - t.now() : Math.abs(A);
          return g.lift(new TimeoutWithOperator(I, o, e, t));
        };
      }
      var TimeoutWithOperator = function() {
        function A(A2, e, t, g) {
          this.waitFor = A2, this.absoluteTimeout = e, this.withObservable = t, this.scheduler = g;
        }
        return A.prototype.call = function(A2, e) {
          return e.subscribe(new TimeoutWithSubscriber(A2, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
        }, A;
      }(), TimeoutWithSubscriber = function(A) {
        function e(e2, t, g, o, I) {
          var i2 = A.call(this, e2) || this;
          return i2.absoluteTimeout = t, i2.waitFor = g, i2.withObservable = o, i2.scheduler = I, i2.scheduleTimeout(), i2;
        }
        return __extends$3(e, A), e.dispatchTimeout = function(A2) {
          var e2 = A2.withObservable;
          A2._unsubscribeAndRecycle(), A2.add(innerSubscribe(e2, new SimpleInnerSubscriber(A2)));
        }, e.prototype.scheduleTimeout = function() {
          var A2 = this.action;
          A2 ? this.action = A2.schedule(this, this.waitFor) : this.add(this.action = this.scheduler.schedule(e.dispatchTimeout, this.waitFor, this));
        }, e.prototype._next = function(e2) {
          this.absoluteTimeout || this.scheduleTimeout(), A.prototype._next.call(this, e2);
        }, e.prototype._unsubscribe = function() {
          this.action = void 0, this.scheduler = null, this.withObservable = null;
        }, e;
      }(SimpleOuterSubscriber);
      function timeout(A, e) {
        return void 0 === e && (e = async), timeoutWith(A, throwError(new TimeoutError()), e);
      }
      const UINT32_MAX = 4294967295, ipKeywords = ["ip", "1", "502"];
      function getRandomInt(A, e) {
        const t = Math.ceil(A), g = Math.floor(e);
        return Math.floor(Math.random() * (g - t + 1)) + A;
      }
      function getRandomUInt64() {
        const A = getRandomInt(0, UINT32_MAX), e = getRandomInt(1, UINT32_MAX);
        return new Long$1(A, e, true);
      }
      function getSid(A) {
        return A.toString().padEnd(32, "0");
      }
      function calIpDistance(A, e) {
        const t = A.split(".").map((A2) => Number(A2)), g = e.split(".").map((A2) => Number(A2));
        return Math.sqrt(1e3 * (t[0] - g[0]) ** 2 + 100 * (t[1] - g[1]) ** 2 + 10 * (t[2] - g[2]) ** 2 + 1 * (t[3] - g[3]) ** 2);
      }
      function longToStringIfNeeded(A) {
        return A.lessThanOrEqual(Number.MAX_SAFE_INTEGER) ? A.toNumber() : A.toString();
      }
      const prefixSeqMap = /* @__PURE__ */ new Map();
      function uniquePrefixedId(A, e) {
        const t = "".concat(A).concat(e || ""), g = prefixSeqMap.get(t) || 1;
        return prefixSeqMap.set(t, g + 1), "".concat(A).concat(g);
      }
      const getKeys = Object.keys, getEntries = Object.entries.bind(Object);
      function isLongNum(A) {
        return "number" == typeof A || Long$1.isLong(A);
      }
      async function mockPromiseDelay(A, e) {
        return new Promise((e2) => {
          setTimeout(e2, A);
        });
      }
      function replaceRange(A, e, t, g) {
        return "string" != typeof A ? "[Sensitive Info]" : A.substring(0, e) + g + A.substring(t);
      }
      function maskIp(A) {
        if (getParameter("SENSITIVE_LOG")) {
          const e = /(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})(?::(\d+))?/g;
          return A.replace(e, (A2, e2, t, g, o, I) => I ? "".concat(e2, ".*.*.").concat(o, ":").concat(I) : "".concat(e2, ".*.*.").concat(o));
        }
        return A;
      }
      function replaceRangeWithAsterisk(A) {
        const e = String(A), t = Math.floor(0.7 * e.length), g = e.length, o = g - t;
        return getParameter("SENSITIVE_LOG") ? replaceRange(e, t, g, "*".repeat(o)) : e;
      }
      function decodeUint8ArrayToString(A) {
        return new TextDecoder("utf-8").decode(A.buffer.slice(A.byteOffset, A.byteOffset + A.byteLength));
      }
      function concatenateUint8Array() {
        let A = 0;
        for (var e = arguments.length, t = new Array(e), g = 0; g < e; g++)
          t[g] = arguments[g];
        for (let e2 = 0; e2 < t.length; e2++) {
          A += t[e2].length;
        }
        const o = new Uint8Array(A);
        let I = 0;
        for (let A2 = 0; A2 < t.length; A2++) {
          const e2 = t[A2];
          o.set(e2, I), I += e2.length;
        }
        return o;
      }
      function appendQueryParameter(A, e, t) {
        const g = A.match(/([^?#]+)(\?[^#]*)?(\#.*)?/), o = null == g ? void 0 : g[1], I = null == g ? void 0 : g[2];
        if (I) {
          const A2 = I.substr(1).split("&");
          let g2;
          for (g2 = 0; g2 < A2.length; g2++) {
            if (A2[g2].split("=")[0] == e) {
              A2[g2] = e + "=" + encodeURIComponent(t);
              break;
            }
          }
          return g2 == A2.length && A2.push(e + "=" + encodeURIComponent(t)), o + "?" + A2.join("&");
        }
        return o + "?" + e + "=" + encodeURIComponent(t);
      }
      function getPrefixLockName(A) {
        return "".concat("*l*").concat(A);
      }
      function getChannelNameByType(A, e) {
        return "STREAM" === e ? "".concat(STREAM_CHANNEL_PREFIX).concat(A) : A;
      }
      function getChannelDetailByName(A) {
        return A.startsWith(STREAM_CHANNEL_PREFIX) ? { channelName: A.slice(3), channelType: "STREAM" } : { channelName: A, channelType: "MESSAGE" };
      }
      function roundUp(A) {
        const e = (1 << ROUNDUP_BIT_SIZE) - 1;
        return A + e & ~e;
      }
      function encrypt(A, e, t, g) {
        let o = "string" == typeof A ? new TextEncoder().encode(A) : A;
        const I = roundUp(o.length);
        if (I > o.byteLength) {
          const A2 = new Uint8Array(I - o.byteLength);
          o = new Uint8Array([...o, ...A2]);
        }
        const i2 = util$6.createBuffer(o), r = forgeCipher.createCipher("AES-GCM", util$6.createBuffer(e.slice(0, g)));
        r.start({ iv: t }), r.update(i2);
        if (r.finish()) {
          const A2 = r.output.getBytes() + r.mode.tag.getBytes(), e2 = [];
          for (let t2 = 0; t2 < A2.length; t2++)
            e2.push(A2.charCodeAt(t2));
          return new Uint8Array(e2);
        }
        throw new Error();
      }
      function decrypt(A, e, t, g) {
        const o = util$6.createBuffer(A), I = util$6.createBuffer(A), i2 = util$6.createBuffer(o.getBytes(o.length()).slice(-TAG_LENGTH)), r = I.getBytes(I.length()).slice(0, o.getBytes().length - TAG_LENGTH), n = forgeCipher.createDecipher("AES-GCM", util$6.createBuffer(e.slice(0, g)));
        n.start({ iv: t, tag: i2, tagLength: 128 }), n.update(util$6.createBuffer(r)), n.finish();
        const C = n.output.data, E = [];
        for (let A2 = 0; A2 < C.length; A2++)
          E.push(C.charCodeAt(A2));
        return new Uint8Array(E);
      }
      function getGlobalPresenceString(A) {
        return K_PRESENCE_PREFIX + A + K_GLOBAL_ONLINE;
      }
      function getChannelQueryString(A, e) {
        return K_PRESENCE_PREFIX + A + K_CHANNEL_ONLINE + e + K_USER_COLLECTION;
      }
      function extractPrefixChannelName(A) {
        const e = new RegExp("^".concat(K_PRESENCE_PREFIX, "([^/]+)").concat(K_CHANNEL_ONLINE, "([^/]+)").concat(K_USER_COLLECTION, "$")), t = A.match(e);
        return t ? { vid: t[1], prefixChannelName: t[2] } : {};
      }
      function getErrorInfoByCode(A) {
        return { code: A, reason: RTMErrorDescription[A] };
      }
      function getUTCTimeBaseREG(A) {
        return (/* @__PURE__ */ new Date()).getTime() + A;
      }
      function parseHost(A, e) {
        let t = e;
        const g = A.indexOf(":");
        if (-1 !== g) {
          const e2 = A.length - g;
          t = Number(A.slice(g + 1));
          return { domain: A.slice(0, A.length - e2), port: t };
        }
        return { domain: A, port: t };
      }
      function getPrivateSettingsPortAndDomains(A, e) {
        let t = e;
        return { hostname: A.map((A2) => {
          const g = parseHost(A2, e);
          return g.port && (t = g.port), g.domain;
        }), port: t };
      }
      function getSyncPacketUri(A) {
        const e = Array.from(A.slice(2, 4)), t = e[0], g = e[1];
        return new DataView(new Uint8Array([g, t]).buffer).getInt16(0);
      }
      function handleJoinOptionsAsDefault(A) {
        var e, t, g, o;
        return { withLock: null !== (e = null == A ? void 0 : A.withLock) && void 0 !== e && e, withMetadata: null !== (t = null == A ? void 0 : A.withMetadata) && void 0 !== t && t, withPresence: null === (g = null == A ? void 0 : A.withPresence) || void 0 === g || g, beQuiet: null !== (o = null == A ? void 0 : A.beQuiet) && void 0 !== o && o };
      }
      function handleSubOptionsAsDefault(A) {
        var e;
        return _objectSpread2(_objectSpread2({}, handleJoinOptionsAsDefault(A)), {}, { withMessage: null === (e = null == A ? void 0 : A.withMessage) || void 0 === e || e });
      }
      async function timeoutPromise(A, e, t, g, o) {
        if (A)
          return new Promise(async (I, i2) => {
            const r = setTimeout(() => {
              clearTimeout(r);
              const { code: A2, reason: e2 } = getErrorInfoByCode(g), o2 = new RtmTimeoutError(t, [e2 + "timeout occurred"], A2);
              i2(o2);
            }, e);
            try {
              const e2 = await A;
              clearTimeout(r), I(e2);
            } catch (A2) {
              if (clearTimeout(r), isRtmError(A2) || o)
                i2(A2);
              else {
                const { code: A3, reason: e2 } = getErrorInfoByCode(g), o2 = new RtmTimeoutError(t, [e2 + "timeout occurred"], A3);
                i2(o2);
              }
            }
          });
      }
      const getReportLts = () => Long$1.fromNumber(Date.now()), genTimeoutError = (A, e) => of(void 0).pipe(delay(COMMON_REQUEST_TIMEOUT), map$1(() => {
        throw new RtmTimeoutError(OperationName.rtm, [getErrorInfoByCode(A).reason || "Request timed out after ".concat(COMMON_REQUEST_TIMEOUT / 1e3, "s")], A);
      })), addPeriodIfNeeded = (A) => "string" == typeof A ? A.endsWith(".") ? A : "".concat(A, ".") : A, throwInvalidPrivateConfig = function(A) {
        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
        const { code: t, reason: g } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_INVALID_PRIVATE_CONFIG);
        throw new RtmInvalidArgumentError(A, [g + e], t);
      };
      function genErrorMessage(A, e) {
        const t = "number" == typeof e ? e : void 0 !== e && "string" != typeof e ? e.code : void 0, g = "number" != typeof e && "string" != typeof e && void 0 !== e && void 0 !== e.serverCode ? e.serverCode : void 0, o = "".concat(void 0 !== t ? "Error Code ".concat(t) : "").concat(void 0 !== g ? ", server Code ".concat(g) : "");
        let I;
        return I = "string" == typeof A && A ? addPeriodIfNeeded(A) : Array.isArray(A) && "string" == typeof A[0] && A[0] ? addPeriodIfNeeded(format$1(A[0], ...A.slice(1))) : "", "".concat("" === o ? "" : "".concat(o, " - ")).concat(I);
      }
      class RTMBaseError extends Error {
        constructor(A, e, t) {
          var g;
          let o;
          super(genErrorMessage(e, t)), _defineProperty$1(this, "originalError", void 0), _defineProperty$1(this, "code", void 0), _defineProperty$1(this, "serverCode", void 0), _defineProperty$1(this, "error", void 0), _defineProperty$1(this, "reason", void 0), _defineProperty$1(this, "operation", void 0), _defineProperty$1(this, "errorCode", void 0), "number" == typeof t ? this.code = t : "string" == typeof t ? this.name = t : void 0 !== t && (t.originalError && (this.originalError = t.originalError), void 0 !== t.code && (this.code = t.code), void 0 !== t.serverCode && (this.serverCode = t.serverCode)), o = "string" == typeof e && e ? addPeriodIfNeeded(e) : Array.isArray(e) && "string" == typeof e[0] && e[0] ? addPeriodIfNeeded(format$1(e[0], ...e.slice(1))) : "", this.error = true, this.errorCode = null !== (g = this.code) && void 0 !== g ? g : 0, this.operation = null != A ? A : "", this.reason = o;
        }
      }
      class RtmInternalError extends Error {
        constructor(A, e) {
          super(genErrorMessage(A, e)), _defineProperty$1(this, "name", "RtmInternalError"), _defineProperty$1(this, "code", void 0), this.code = e;
        }
      }
      const genError = () => class extends RtmInternalError {
        constructor(A) {
          const e = Object.keys(A);
          super(A[e[0]], e[0]);
        }
      }, CommonError = genError();
      class RtmTimeoutError extends RTMBaseError {
        constructor() {
          super(...arguments), _defineProperty$1(this, "name", "RtmTimeoutError");
        }
      }
      class RtmInvalidArgumentError extends RTMBaseError {
        constructor() {
          super(...arguments), _defineProperty$1(this, "name", "RtmInvalidArgumentError");
        }
      }
      class RtmInvalidStatusError extends RTMBaseError {
        constructor() {
          super(...arguments), _defineProperty$1(this, "name", "RtmInvalidStatusError");
        }
      }
      class RtmLimitExceededError extends RTMBaseError {
        constructor() {
          super(...arguments), _defineProperty$1(this, "name", "RtmLimitExceededError");
        }
      }
      class RtmInvokeTooOftenError extends RTMBaseError {
        constructor() {
          super(...arguments), _defineProperty$1(this, "name", "RtmInvokeTooOftenError");
        }
      }
      class RtmUnavailableError extends RTMBaseError {
        constructor() {
          super(...arguments), _defineProperty$1(this, "name", "RtmUnavailableError"), _defineProperty$1(this, "statusCode", void 0);
        }
      }
      class RtmUnauthenticatedError extends RTMBaseError {
        constructor() {
          super(...arguments), _defineProperty$1(this, "name", "RtmUnauthenticatedError"), _defineProperty$1(this, "serverCode", void 0);
        }
      }
      class RtmUnknownError extends RTMBaseError {
        constructor() {
          super(...arguments), _defineProperty$1(this, "name", "RtmUnknownError");
        }
      }
      const isTimeout = (A) => A instanceof RtmTimeoutError || A instanceof TimeoutError, isRtmError = (A) => A instanceof RTMBaseError, isNoLogged = (A) => A instanceof RtmInvalidStatusError, _excluded = ["CODE"];
      function deepFreeze(A) {
        return Object.getOwnPropertyNames(A).forEach(function(e) {
          const t = A[e];
          "object" == typeof t && null !== t && deepFreeze(t);
        }), Object.freeze(A);
      }
      const AREA_DOMAIN_MAP = deepFreeze(AREA_DOMAIN_MAP$1), isContinent = (A) => A in continentCountryMap, isCountry = (A) => Object.values(continentCountryMap).flat().includes(A), getContinentByCountry = (A) => {
        var e;
        return null === (e = getEntries(continentCountryMap).find((e2) => {
          let [t, g] = e2;
          return g.includes(A);
        })) || void 0 === e ? void 0 : e[0];
      }, sortAreasByWeight = (A) => A.sort((A2, e) => areaWeights.indexOf(A2) - areaWeights.indexOf(e)), getAreaDomainConfig = (A) => {
        const e = /* @__PURE__ */ new Set(), t = sortAreasByWeight(A).slice(0, 3).map((A2) => {
          const t2 = AREA_DOMAIN_MAP[A2];
          if (void 0 === t2)
            throw new RtmInternalError("invalid area key");
          const { CODE: g } = t2, o = _objectWithoutProperties(t2, _excluded);
          return e.add(g), o;
        });
        if (0 === t.length)
          throw new RtmInternalError("areas cannot be empty");
        return _objectSpread2({ CODES: e }, t.reduce((A2, e2) => {
          for (let t2 = 0, g = getEntries(A2); t2 < g.length; t2++) {
            const [o, I] = g[t2];
            A2[o] = Array.from(/* @__PURE__ */ new Set([...e2[o], ...I]));
          }
          return A2;
        }));
      };
      function getAreaDomainConfigWithExclusion(A) {
        let { areas: e, excludedArea: t } = A;
        if (1 === e.length && e[0] === AreaCodeMap.GLOBAL && t === AreaCodeMap.CHINA)
          return getAreaDomainConfig([AreaCodeMap.OVERSEA]);
        if (e.includes(AreaCodeMap.GLOBAL)) {
          const A2 = getKeys(AREA_DOMAIN_MAP).filter((A3) => A3 !== AreaCodeMap.GLOBAL && A3 !== AreaCodeMap.OVERSEA);
          if (isContinent(t)) {
            const e2 = continentCountryMap[t], g = [...null != e2 ? e2 : [], t];
            return getAreaDomainConfig(A2.filter((A3) => !g.includes(A3)));
          }
          if (isCountry(t)) {
            const e2 = getContinentByCountry(t);
            return getAreaDomainConfig(A2.filter((A3) => A3 !== t && A3 !== e2));
          }
        }
        if (isCountry(t) || isContinent(t))
          return getAreaDomainConfig(e);
        throw new RtmInvalidArgumentError("setArea", "Invalid excludedArea area config");
      }
      let areaConfig;
      function setAreaConfig(A) {
        areaConfig = A;
      }
      const isInvalidAreaConfig = (A) => {
        let e, { areaCodes: t, excludedArea: g } = A, o = "", I = false;
        if (Array.isArray(t) && t.every((A2) => A2 in AreaCode) ? void 0 !== g && g === AreaCode.GLOBAL ? (I = true, o = "Excluded area cannot be global") : g && t.includes(g) ? (I = true, o = "Excluded area cannot be in areaCodes") : g && !(g in AreaCodeMap) && (I = true, o = "Invalid excludedArea", e = g) : (I = true, o = "Invalid area config"), I)
          throw areaConfig = void 0, setParameter("AREA_CONFIG", void 0), new RtmInvalidArgumentError("setArea", o, e);
      };
      function setArea(A) {
        let { areaCodes: e, excludedArea: t } = A;
        if (isInvalidAreaConfig({ areaCodes: e, excludedArea: t }), 0 === e.length && void 0 === t)
          return areaConfig = void 0, void setParameter("AREA_CONFIG", void 0);
        console.log(JSON.stringify({ areaCodes: e, excludedArea: t }), "RTM setArea"), setAreaConfig(void 0 === t ? getAreaDomainConfig(e.map((A2) => AreaCodeMap[A2])) : getAreaDomainConfigWithExclusion({ areas: e.map((A2) => AreaCodeMap[A2]), excludedArea: AreaCodeMap[t] })), setParameter("AREA_CONFIG", { areaCodes: e, excludedArea: t });
      }
      function getDomain(A) {
        let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], t = A.replace(/(https?:\/\/)?(www.)?/i, "");
        return e || (t = t.split(".").slice(t.split(".").length - 2).join(".")), -1 !== t.indexOf("/") ? t.split("/")[0] : t;
      }
      const getAreaCodeByApUrl = (A) => {
        const e = getKeys(AREA_DOMAIN_MAP), t = getDomain(A);
        for (let A2 = 0; A2 < e.length; A2++) {
          const g = e[A2], o = AREA_DOMAIN_MAP[g];
          if (null != o && o.AP_DOMAINS.includes(t) || null != o && o.AP_BACKUP_DOMAINS.includes(t) || null != o && o.PROXY_AP.includes(t))
            return [o.CODE];
        }
        return [AreaCodeMap.CHINA, AreaCodeMap.GLOBAL];
      };
      var rngBrowser = { exports: {} }, getRandomValues = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof window.msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto);
      if (getRandomValues) {
        var rnds8 = new Uint8Array(16);
        rngBrowser.exports = function() {
          return getRandomValues(rnds8), rnds8;
        };
      } else {
        var rnds = new Array(16);
        rngBrowser.exports = function() {
          for (var A, e = 0; e < 16; e++)
            3 & e || (A = 4294967296 * Math.random()), rnds[e] = A >>> ((3 & e) << 3) & 255;
          return rnds;
        };
      }
      for (var rngBrowserExports = rngBrowser.exports, byteToHex = [], i = 0; i < 256; ++i)
        byteToHex[i] = (i + 256).toString(16).substr(1);
      function bytesToUuid$2(A, e) {
        var t = e || 0, g = byteToHex;
        return [g[A[t++]], g[A[t++]], g[A[t++]], g[A[t++]], "-", g[A[t++]], g[A[t++]], "-", g[A[t++]], g[A[t++]], "-", g[A[t++]], g[A[t++]], "-", g[A[t++]], g[A[t++]], g[A[t++]], g[A[t++]], g[A[t++]], g[A[t++]]].join("");
      }
      var bytesToUuid_1 = bytesToUuid$2, rng$1 = rngBrowserExports, bytesToUuid$1 = bytesToUuid_1, _nodeId, _clockseq, _lastMSecs = 0, _lastNSecs = 0;
      function v1$1(A, e, t) {
        var g = e && t || 0, o = e || [], I = (A = A || {}).node || _nodeId, i2 = void 0 !== A.clockseq ? A.clockseq : _clockseq;
        if (null == I || null == i2) {
          var r = rng$1();
          null == I && (I = _nodeId = [1 | r[0], r[1], r[2], r[3], r[4], r[5]]), null == i2 && (i2 = _clockseq = 16383 & (r[6] << 8 | r[7]));
        }
        var n = void 0 !== A.msecs ? A.msecs : (/* @__PURE__ */ new Date()).getTime(), C = void 0 !== A.nsecs ? A.nsecs : _lastNSecs + 1, E = n - _lastMSecs + (C - _lastNSecs) / 1e4;
        if (E < 0 && void 0 === A.clockseq && (i2 = i2 + 1 & 16383), (E < 0 || n > _lastMSecs) && void 0 === A.nsecs && (C = 0), C >= 1e4)
          throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
        _lastMSecs = n, _lastNSecs = C, _clockseq = i2;
        var s = (1e4 * (268435455 & (n += 122192928e5)) + C) % 4294967296;
        o[g++] = s >>> 24 & 255, o[g++] = s >>> 16 & 255, o[g++] = s >>> 8 & 255, o[g++] = 255 & s;
        var B = n / 4294967296 * 1e4 & 268435455;
        o[g++] = B >>> 8 & 255, o[g++] = 255 & B, o[g++] = B >>> 24 & 15 | 16, o[g++] = B >>> 16 & 255, o[g++] = i2 >>> 8 | 128, o[g++] = 255 & i2;
        for (var a = 0; a < 6; ++a)
          o[g + a] = I[a];
        return e || bytesToUuid$1(o);
      }
      var v1_1 = v1$1, rng = rngBrowserExports, bytesToUuid = bytesToUuid_1;
      function v4$1(A, e, t) {
        var g = e && t || 0;
        "string" == typeof A && (e = "binary" === A ? new Array(16) : null, A = null);
        var o = (A = A || {}).random || (A.rng || rng)();
        if (o[6] = 15 & o[6] | 64, o[8] = 63 & o[8] | 128, e)
          for (var I = 0; I < 16; ++I)
            e[g + I] = o[I];
        return e || bytesToUuid(o);
      }
      var v4_1 = v4$1, v1 = v1_1, v4 = v4_1, uuid = v4;
      uuid.v1 = v1, uuid.v4 = v4;
      var uuid_1 = uuid, uuid$1 = getDefaultExportFromCjs(uuid_1), events = { exports: {} }, R = "object" == typeof Reflect ? Reflect : null, ReflectApply = R && "function" == typeof R.apply ? R.apply : function(A, e, t) {
        return Function.prototype.apply.call(A, e, t);
      }, ReflectOwnKeys;
      function ProcessEmitWarning(A) {
        console && console.warn && console.warn(A);
      }
      ReflectOwnKeys = R && "function" == typeof R.ownKeys ? R.ownKeys : Object.getOwnPropertySymbols ? function(A) {
        return Object.getOwnPropertyNames(A).concat(Object.getOwnPropertySymbols(A));
      } : function(A) {
        return Object.getOwnPropertyNames(A);
      };
      var NumberIsNaN = Number.isNaN || function(A) {
        return A != A;
      };
      function EventEmitter() {
        EventEmitter.init.call(this);
      }
      events.exports = EventEmitter, events.exports.once = once, EventEmitter.EventEmitter = EventEmitter, EventEmitter.prototype._events = void 0, EventEmitter.prototype._eventsCount = 0, EventEmitter.prototype._maxListeners = void 0;
      var defaultMaxListeners = 10;
      function checkListener(A) {
        if ("function" != typeof A)
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof A);
      }
      function _getMaxListeners(A) {
        return void 0 === A._maxListeners ? EventEmitter.defaultMaxListeners : A._maxListeners;
      }
      function _addListener(A, e, t, g) {
        var o, I, i2;
        if (checkListener(t), void 0 === (I = A._events) ? (I = A._events = /* @__PURE__ */ Object.create(null), A._eventsCount = 0) : (void 0 !== I.newListener && (A.emit("newListener", e, t.listener ? t.listener : t), I = A._events), i2 = I[e]), void 0 === i2)
          i2 = I[e] = t, ++A._eventsCount;
        else if ("function" == typeof i2 ? i2 = I[e] = g ? [t, i2] : [i2, t] : g ? i2.unshift(t) : i2.push(t), (o = _getMaxListeners(A)) > 0 && i2.length > o && !i2.warned) {
          i2.warned = true;
          var r = new Error("Possible EventEmitter memory leak detected. " + i2.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          r.name = "MaxListenersExceededWarning", r.emitter = A, r.type = e, r.count = i2.length, ProcessEmitWarning(r);
        }
        return A;
      }
      function onceWrapper() {
        if (!this.fired)
          return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
      }
      function _onceWrap(A, e, t) {
        var g = { fired: false, wrapFn: void 0, target: A, type: e, listener: t }, o = onceWrapper.bind(g);
        return o.listener = t, g.wrapFn = o, o;
      }
      function _listeners(A, e, t) {
        var g = A._events;
        if (void 0 === g)
          return [];
        var o = g[e];
        return void 0 === o ? [] : "function" == typeof o ? t ? [o.listener || o] : [o] : t ? unwrapListeners(o) : arrayClone(o, o.length);
      }
      function listenerCount(A) {
        var e = this._events;
        if (void 0 !== e) {
          var t = e[A];
          if ("function" == typeof t)
            return 1;
          if (void 0 !== t)
            return t.length;
        }
        return 0;
      }
      function arrayClone(A, e) {
        for (var t = new Array(e), g = 0; g < e; ++g)
          t[g] = A[g];
        return t;
      }
      function spliceOne(A, e) {
        for (; e + 1 < A.length; e++)
          A[e] = A[e + 1];
        A.pop();
      }
      function unwrapListeners(A) {
        for (var e = new Array(A.length), t = 0; t < e.length; ++t)
          e[t] = A[t].listener || A[t];
        return e;
      }
      function once(A, e) {
        return new Promise(function(t, g) {
          function o(t2) {
            A.removeListener(e, I), g(t2);
          }
          function I() {
            "function" == typeof A.removeListener && A.removeListener("error", o), t([].slice.call(arguments));
          }
          eventTargetAgnosticAddListener(A, e, I, { once: true }), "error" !== e && addErrorHandlerIfEventEmitter(A, o, { once: true });
        });
      }
      function addErrorHandlerIfEventEmitter(A, e, t) {
        "function" == typeof A.on && eventTargetAgnosticAddListener(A, "error", e, t);
      }
      function eventTargetAgnosticAddListener(A, e, t, g) {
        if ("function" == typeof A.on)
          g.once ? A.once(e, t) : A.on(e, t);
        else {
          if ("function" != typeof A.addEventListener)
            throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof A);
          A.addEventListener(e, function o(I) {
            g.once && A.removeEventListener(e, o), t(I);
          });
        }
      }
      Object.defineProperty(EventEmitter, "defaultMaxListeners", { enumerable: true, get: function() {
        return defaultMaxListeners;
      }, set: function(A) {
        if ("number" != typeof A || A < 0 || NumberIsNaN(A))
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + A + ".");
        defaultMaxListeners = A;
      } }), EventEmitter.init = function() {
        void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
      }, EventEmitter.prototype.setMaxListeners = function(A) {
        if ("number" != typeof A || A < 0 || NumberIsNaN(A))
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + A + ".");
        return this._maxListeners = A, this;
      }, EventEmitter.prototype.getMaxListeners = function() {
        return _getMaxListeners(this);
      }, EventEmitter.prototype.emit = function(A) {
        for (var e = [], t = 1; t < arguments.length; t++)
          e.push(arguments[t]);
        var g = "error" === A, o = this._events;
        if (void 0 !== o)
          g = g && void 0 === o.error;
        else if (!g)
          return false;
        if (g) {
          var I;
          if (e.length > 0 && (I = e[0]), I instanceof Error)
            throw I;
          var i2 = new Error("Unhandled error." + (I ? " (" + I.message + ")" : ""));
          throw i2.context = I, i2;
        }
        var r = o[A];
        if (void 0 === r)
          return false;
        if ("function" == typeof r)
          ReflectApply(r, this, e);
        else {
          var n = r.length, C = arrayClone(r, n);
          for (t = 0; t < n; ++t)
            ReflectApply(C[t], this, e);
        }
        return true;
      }, EventEmitter.prototype.addListener = function(A, e) {
        return _addListener(this, A, e, false);
      }, EventEmitter.prototype.on = EventEmitter.prototype.addListener, EventEmitter.prototype.prependListener = function(A, e) {
        return _addListener(this, A, e, true);
      }, EventEmitter.prototype.once = function(A, e) {
        return checkListener(e), this.on(A, _onceWrap(this, A, e)), this;
      }, EventEmitter.prototype.prependOnceListener = function(A, e) {
        return checkListener(e), this.prependListener(A, _onceWrap(this, A, e)), this;
      }, EventEmitter.prototype.removeListener = function(A, e) {
        var t, g, o, I, i2;
        if (checkListener(e), void 0 === (g = this._events))
          return this;
        if (void 0 === (t = g[A]))
          return this;
        if (t === e || t.listener === e)
          0 === --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete g[A], g.removeListener && this.emit("removeListener", A, t.listener || e));
        else if ("function" != typeof t) {
          for (o = -1, I = t.length - 1; I >= 0; I--)
            if (t[I] === e || t[I].listener === e) {
              i2 = t[I].listener, o = I;
              break;
            }
          if (o < 0)
            return this;
          0 === o ? t.shift() : spliceOne(t, o), 1 === t.length && (g[A] = t[0]), void 0 !== g.removeListener && this.emit("removeListener", A, i2 || e);
        }
        return this;
      }, EventEmitter.prototype.off = EventEmitter.prototype.removeListener, EventEmitter.prototype.removeAllListeners = function(A) {
        var e, t, g;
        if (void 0 === (t = this._events))
          return this;
        if (void 0 === t.removeListener)
          return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== t[A] && (0 === --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete t[A]), this;
        if (0 === arguments.length) {
          var o, I = Object.keys(t);
          for (g = 0; g < I.length; ++g)
            "removeListener" !== (o = I[g]) && this.removeAllListeners(o);
          return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
        }
        if ("function" == typeof (e = t[A]))
          this.removeListener(A, e);
        else if (void 0 !== e)
          for (g = e.length - 1; g >= 0; g--)
            this.removeListener(A, e[g]);
        return this;
      }, EventEmitter.prototype.listeners = function(A) {
        return _listeners(this, A, true);
      }, EventEmitter.prototype.rawListeners = function(A) {
        return _listeners(this, A, false);
      }, EventEmitter.listenerCount = function(A, e) {
        return "function" == typeof A.listenerCount ? A.listenerCount(e) : listenerCount.call(A, e);
      }, EventEmitter.prototype.listenerCount = listenerCount, EventEmitter.prototype.eventNames = function() {
        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
      };
      var eventsExports = events.exports, EventEmitter$1 = getDefaultExportFromCjs(eventsExports), key = "__global_unique_id__", gud = function() {
        return commonjsGlobal[key] = (commonjsGlobal[key] || 0) + 1;
      }, gud$1 = getDefaultExportFromCjs(gud);
      function getType(A) {
        return Object.prototype.toString.call(A).slice(8, -1);
      }
      function isUndefined(A) {
        return "Undefined" === getType(A);
      }
      function isNull(A) {
        return "Null" === getType(A);
      }
      function isPlainObject(A) {
        return "Object" === getType(A) && (A.constructor === Object && Object.getPrototypeOf(A) === Object.prototype);
      }
      function isEmptyObject(A) {
        return isPlainObject(A) && 0 === Object.keys(A).length;
      }
      function isAnyObject(A) {
        return "Object" === getType(A);
      }
      function isFunction$2(A) {
        return "function" == typeof A;
      }
      function isString(A) {
        return "String" === getType(A);
      }
      function isNumber(A) {
        return "Number" === getType(A) && !isNaN(A);
      }
      function isBoolean(A) {
        return "Boolean" === getType(A);
      }
      function isSymbol(A) {
        return "Symbol" === getType(A);
      }
      function isPrimitive(A) {
        return isBoolean(A) || isNull(A) || isUndefined(A) || isNumber(A) || isString(A) || isSymbol(A);
      }
      var safeJsonStringify$1 = { exports: {} }, hasProp = Object.prototype.hasOwnProperty;
      function throwsMessage(A) {
        return "[Throws: " + (A ? A.message : "?") + "]";
      }
      function safeGetValueFromPropertyOnObject(A, e) {
        if (hasProp.call(A, e))
          try {
            return A[e];
          } catch (A2) {
            return throwsMessage(A2);
          }
        return A[e];
      }
      function ensureProperties(A) {
        var e = [];
        return function A2(t) {
          if (null === t || "object" != typeof t)
            return t;
          if (-1 !== e.indexOf(t))
            return "[Circular]";
          if (e.push(t), "function" == typeof t.toJSON)
            try {
              var g = A2(t.toJSON());
              return e.pop(), g;
            } catch (A3) {
              return throwsMessage(A3);
            }
          if (Array.isArray(t)) {
            var o = t.map(A2);
            return e.pop(), o;
          }
          var I = Object.keys(t).reduce(function(e2, g2) {
            return e2[g2] = A2(safeGetValueFromPropertyOnObject(t, g2)), e2;
          }, {});
          return e.pop(), I;
        }(A);
      }
      safeJsonStringify$1.exports = function(A, e, t) {
        return JSON.stringify(ensureProperties(A), e, t);
      }, safeJsonStringify$1.exports.ensureProperties = ensureProperties;
      var safeJsonStringifyExports = safeJsonStringify$1.exports, safeJsonStringify = getDefaultExportFromCjs(safeJsonStringifyExports), browser = { exports: {} }, ms, hasRequiredMs;
      function requireMs() {
        if (hasRequiredMs)
          return ms;
        hasRequiredMs = 1;
        var A = 1e3, e = 60 * A, t = 60 * e, g = 24 * t, o = 7 * g, I = 365.25 * g;
        function i2(A2, e2, t2, g2) {
          var o2 = e2 >= 1.5 * t2;
          return Math.round(A2 / t2) + " " + g2 + (o2 ? "s" : "");
        }
        return ms = function(r, n) {
          n = n || {};
          var C = typeof r;
          if ("string" === C && r.length > 0)
            return function(i3) {
              if ((i3 = String(i3)).length > 100)
                return;
              var r2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(i3);
              if (!r2)
                return;
              var n2 = parseFloat(r2[1]);
              switch ((r2[2] || "ms").toLowerCase()) {
                case "years":
                case "year":
                case "yrs":
                case "yr":
                case "y":
                  return n2 * I;
                case "weeks":
                case "week":
                case "w":
                  return n2 * o;
                case "days":
                case "day":
                case "d":
                  return n2 * g;
                case "hours":
                case "hour":
                case "hrs":
                case "hr":
                case "h":
                  return n2 * t;
                case "minutes":
                case "minute":
                case "mins":
                case "min":
                case "m":
                  return n2 * e;
                case "seconds":
                case "second":
                case "secs":
                case "sec":
                case "s":
                  return n2 * A;
                case "milliseconds":
                case "millisecond":
                case "msecs":
                case "msec":
                case "ms":
                  return n2;
                default:
                  return;
              }
            }(r);
          if ("number" === C && isFinite(r))
            return n.long ? function(o2) {
              var I2 = Math.abs(o2);
              if (I2 >= g)
                return i2(o2, I2, g, "day");
              if (I2 >= t)
                return i2(o2, I2, t, "hour");
              if (I2 >= e)
                return i2(o2, I2, e, "minute");
              if (I2 >= A)
                return i2(o2, I2, A, "second");
              return o2 + " ms";
            }(r) : function(o2) {
              var I2 = Math.abs(o2);
              if (I2 >= g)
                return Math.round(o2 / g) + "d";
              if (I2 >= t)
                return Math.round(o2 / t) + "h";
              if (I2 >= e)
                return Math.round(o2 / e) + "m";
              if (I2 >= A)
                return Math.round(o2 / A) + "s";
              return o2 + "ms";
            }(r);
          throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(r));
        };
      }
      function setup(A) {
        function e(A2) {
          let g2, o, I, i2 = null;
          function r() {
            for (var A3 = arguments.length, t2 = new Array(A3), o2 = 0; o2 < A3; o2++)
              t2[o2] = arguments[o2];
            if (!r.enabled)
              return;
            const I2 = r, i3 = Number(/* @__PURE__ */ new Date()), n = i3 - (g2 || i3);
            I2.diff = n, I2.prev = g2, I2.curr = i3, g2 = i3, t2[0] = e.coerce(t2[0]), "string" != typeof t2[0] && t2.unshift("%O");
            let C = 0;
            t2[0] = t2[0].replace(/%([a-zA-Z%])/g, (A4, g3) => {
              if ("%%" === A4)
                return "%";
              C++;
              const o3 = e.formatters[g3];
              if ("function" == typeof o3) {
                const e2 = t2[C];
                A4 = o3.call(I2, e2), t2.splice(C, 1), C--;
              }
              return A4;
            }), e.formatArgs.call(I2, t2);
            (I2.log || e.log).apply(I2, t2);
          }
          return r.namespace = A2, r.useColors = e.useColors(), r.color = e.selectColor(A2), r.extend = t, r.destroy = e.destroy, Object.defineProperty(r, "enabled", { enumerable: true, configurable: false, get: () => null !== i2 ? i2 : (o !== e.namespaces && (o = e.namespaces, I = e.enabled(A2)), I), set: (A3) => {
            i2 = A3;
          } }), "function" == typeof e.init && e.init(r), r;
        }
        function t(A2, t2) {
          const g2 = e(this.namespace + (void 0 === t2 ? ":" : t2) + A2);
          return g2.log = this.log, g2;
        }
        function g(A2, e2) {
          let t2 = 0, g2 = 0, o = -1, I = 0;
          for (; t2 < A2.length; )
            if (g2 < e2.length && (e2[g2] === A2[t2] || "*" === e2[g2]))
              "*" === e2[g2] ? (o = g2, I = t2, g2++) : (t2++, g2++);
            else {
              if (-1 === o)
                return false;
              g2 = o + 1, I++, t2 = I;
            }
          for (; g2 < e2.length && "*" === e2[g2]; )
            g2++;
          return g2 === e2.length;
        }
        return e.debug = e, e.default = e, e.coerce = function(A2) {
          if (A2 instanceof Error)
            return A2.stack || A2.message;
          return A2;
        }, e.disable = function() {
          const A2 = [...e.names, ...e.skips.map((A3) => "-" + A3)].join(",");
          return e.enable(""), A2;
        }, e.enable = function(A2) {
          e.save(A2), e.namespaces = A2, e.names = [], e.skips = [];
          const t2 = ("string" == typeof A2 ? A2 : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
          for (let A3 = 0; A3 < t2.length; A3++) {
            const g2 = t2[A3];
            "-" === g2[0] ? e.skips.push(g2.slice(1)) : e.names.push(g2);
          }
        }, e.enabled = function(A2) {
          for (let t2 = 0, o = e.skips; t2 < o.length; t2++) {
            if (g(A2, o[t2]))
              return false;
          }
          for (let t2 = 0, o = e.names; t2 < o.length; t2++) {
            if (g(A2, o[t2]))
              return true;
          }
          return false;
        }, e.humanize = requireMs(), e.destroy = function() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }, Object.keys(A).forEach((t2) => {
          e[t2] = A[t2];
        }), e.names = [], e.skips = [], e.formatters = {}, e.selectColor = function(A2) {
          let t2 = 0;
          for (let e2 = 0; e2 < A2.length; e2++)
            t2 = (t2 << 5) - t2 + A2.charCodeAt(e2), t2 |= 0;
          return e.colors[Math.abs(t2) % e.colors.length];
        }, e.enable(e.load()), e;
      }
      var common = setup;
      !function(A, e) {
        e.formatArgs = function(e2) {
          if (e2[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e2[0] + (this.useColors ? "%c " : " ") + "+" + A.exports.humanize(this.diff), !this.useColors)
            return;
          const t2 = "color: " + this.color;
          e2.splice(1, 0, t2, "color: inherit");
          let g = 0, o = 0;
          e2[0].replace(/%[a-zA-Z%]/g, (A2) => {
            "%%" !== A2 && (g++, "%c" === A2 && (o = g));
          }), e2.splice(o, 0, t2);
        }, e.save = function(A2) {
          try {
            A2 ? e.storage.setItem("debug", A2) : e.storage.removeItem("debug");
          } catch (A3) {
          }
        }, e.load = function() {
          let A2;
          try {
            A2 = e.storage.getItem("debug") || e.storage.getItem("DEBUG");
          } catch (A3) {
          }
          !A2 && "undefined" != typeof process && "env" in process && (A2 = process.env.DEBUG);
          return A2;
        }, e.useColors = function() {
          if ("undefined" != typeof window && window.process && ("renderer" === window.process.type || window.process.__nwjs))
            return true;
          if ("undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
            return false;
          let A2;
          return "undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && (A2 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(A2[1], 10) >= 31 || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
        }, e.storage = function() {
          try {
            return localStorage;
          } catch (A2) {
          }
        }(), e.destroy = (() => {
          let A2 = false;
          return () => {
            A2 || (A2 = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
          };
        })(), e.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], e.log = console.debug || console.log || (() => {
        }), A.exports = common(e);
        const { formatters: t } = A.exports;
        t.j = function(A2) {
          try {
            return JSON.stringify(A2);
          } catch (A3) {
            return "[UnexpectedJSONParseError]: " + A3.message;
          }
        };
      }(browser, browser.exports);
      var browserExports = browser.exports, Debug = getDefaultExportFromCjs(browserExports);
      const uploadLog = Debug("RTM:DEBUG");
      uploadLog.enabled = isDev;
      var UploadState = function(A) {
        return A[A.Uploading = 0] = "Uploading", A[A.Free = 1] = "Free", A;
      }(UploadState || {});
      class LogUploader {
        constructor(A) {
          _defineProperty$1(this, "uploadRequest", void 0), _defineProperty$1(this, "uploadState", void 0), _defineProperty$1(this, "uploadResendCount", void 0), _defineProperty$1(this, "LogCache", void 0), _defineProperty$1(this, "LogsToPost", void 0), _defineProperty$1(this, "processId", void 0), _defineProperty$1(this, "sdkVersion", void 0), _defineProperty$1(this, "logId", void 0), _defineProperty$1(this, "PrivateConfig", void 0), _defineProperty$1(this, "privateLogUploadHosts", void 0), this.processId = A.processId, this.sdkVersion = A.sdkVersion, this.PrivateConfig = A.PrivateConfig, this.uploadRequest = A.uploadRequest, this.uploadState = UploadState.Free, this.uploadResendCount = 0, this.LogCache = [], this.LogsToPost = [], this.logId = 0, this.privateLogUploadHosts = A.privateLogUploadHosts;
        }
        upload(A, e) {
          this.LogCache.push(e), this.uploadState === UploadState.Free && navigator.onLine && void 0 !== getParameter("VID").get(A) && (this.LogsToPost = this.LogCache.length < LOG_UPLOAD_MAX_ITEMS ? this.LogCache.splice(0, this.LogCache.length) : this.LogCache.splice(0, LOG_UPLOAD_MAX_ITEMS), this.postLog(A, this.LogsToPost));
        }
        postLog(A, e) {
          this.uploadState = UploadState.Uploading, setTimeout(async () => {
            const t = { sdk_version: this.sdkVersion, process_id: this.processId, payload: JSON.stringify(e) };
            try {
              var g;
              await this.uploadRequest(A, t, null !== (g = this.PrivateConfig.cloudProxy) && void 0 !== g && g, this.privateLogUploadHosts);
            } catch (e2) {
              const t2 = this.uploadResendCount++ < 2 ? 2e3 : 1e4;
              return void setTimeout(() => this.postLog(A, this.LogsToPost), t2);
            }
            0 !== this.LogCache.length ? (this.uploadResendCount = 0, this.LogsToPost = this.LogCache.length < LOG_UPLOAD_MAX_ITEMS ? this.LogCache.splice(0, this.LogCache.length) : this.LogCache.splice(0, LOG_UPLOAD_MAX_ITEMS), this.postLog(A, this.LogsToPost)) : this.uploadState = UploadState.Free;
          }, getParameter("LOG_UPLOAD_INTERVAL"));
        }
      }
      async function postWithAbortSignal(A, e, t) {
        let { body: g, headers: o = {}, timeout: I = 1e4, signal: i2, withCredentials: r = false } = e;
        if (false === navigator.onLine)
          throw new Error("network is offline, not permit send request: url(".concat(A, ")"));
        const n = OperationName.rtm, { useBinaryResponse: C = false } = {}, E = new XMLHttpRequest();
        E.open("POST", A, true), E.responseType = C ? "arraybuffer" : "text", E.withCredentials = r, E.timeout = I;
        const s = g instanceof FormData, B = g instanceof Uint8Array, a = Object.keys(o).filter((A2) => "content-type" === A2.toLowerCase());
        if (a.length > 1)
          throw new RangeError("multiple content-type");
        if (0 === a.length && (B ? o["Content-Type"] = "application/octet-stream" : s || (o["Content-Type"] = "application/json")), !("setRequestHeader" in E)) {
          E.abort();
          try {
            const e2 = await fetch(A, { body: s || B ? g : JSON.stringify(g), cache: "no-cache", credentials: r ? "include" : "same-origin", headers: o, method: "POST", mode: "cors", referrer: "no-referrer", signal: i2 }), { status: t2 } = e2;
            if (t2 >= 200 && t2 < 300 || 304 === t2) {
              if (C) {
                return { status: t2, responseData: await e2.arrayBuffer() };
              }
              return { status: t2, responseText: await e2.text() };
            }
            const I2 = new RtmUnavailableError(n, ["Post XHR failure, status %d", t2]);
            try {
              const A2 = await e2.text();
              throw I2.statusCode = t2, I2.message = A2 || "Request failed, status ".concat(t2), I2;
            } catch (A2) {
              throw I2.statusCode = t2, I2.message = "Request failed, status ".concat(t2), I2;
            }
          } catch (A2) {
            throw new RtmUnavailableError(n, ["Post XHR failure, detail: %s", A2.message]);
          }
        }
        if (0 !== Object.keys(o).length)
          for (let A2 = 0, e2 = Object.entries(o); A2 < e2.length; A2++) {
            const [t2, g2] = e2[A2];
            E.setRequestHeader(t2, g2);
          }
        if (void 0 !== i2) {
          const A2 = () => {
            E.abort(), i2.removeEventListener("abort", A2);
          };
          i2.addEventListener("abort", A2);
        }
        return s || B ? E.send(g) : E.send(JSON.stringify(g)), new Promise((A2, e2) => {
          const t2 = () => {
            try {
              e2(new DOMException("The request aborted.", "AbortError"));
            } catch (A3) {
              const t3 = new Error("The request aborted.");
              t3.name = "AbortError", e2(t3);
            }
          };
          E.onload = () => {
            const { status: g2 } = E;
            if (0 === g2)
              t2();
            else if (g2 >= 200 && g2 < 300 || 304 === g2)
              A2(C ? { status: g2, responseData: E.response } : { status: g2, responseText: E.responseText });
            else {
              const A3 = new RtmUnavailableError(n, ["Post XHR failure, status %d", g2]);
              A3.statusCode = g2, A3.message = E.response || "Request failed, status ".concat(E.status), e2(A3);
            }
          }, E.ontimeout = (A3) => {
            e2(new RtmTimeoutError(n, ["XHR request timed out after %d ms", I], { originalError: A3 }));
          }, E.onerror = () => {
            0 === E.status && t2();
            const A3 = new RtmUnavailableError(n, ["Post XHR failure, status %d", E.status]);
            A3.statusCode = E.status, A3.message = E.response || "Request failed, status ".concat(E.status), e2(A3);
          }, E.onabort = () => {
            t2();
          };
        });
      }
      const LOG_SERVICE_MAIN_DOMAIN = "logservice-rtm.agora.io", LOG_SERVICE_BACKUP_DOMAIN = "rtm.logservice.sd-rtn.com";
      let logUploadDomainIdx = 0;
      function getLogUploadDomain() {
        try {
          var A;
          const e = null !== (A = getParameter("LOG_UPLOAD_DOMAIN_LIST")) && void 0 !== A ? A : [];
          logUploadDomainIdx >= e.length && (logUploadDomainIdx = 0);
          return e[logUploadDomainIdx];
        } catch (A2) {
          return console.error(A2), "";
        }
      }
      const getUTCTimestamp$1 = () => {
        const A = /* @__PURE__ */ new Date(), [e, t] = A.toISOString().split("T"), [g, o, I] = e.split("-");
        return "".concat(o, "-").concat(I, " ").concat(t.replace(/\..+/, ""), ".").concat(A.getMilliseconds());
      }, _uploadRequest = async function(A, e, t, g) {
        var o, I;
        let i2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
        if (!getParameter("VID").get(A))
          return;
        if (i2 > 2)
          return;
        const r = { withCredentials: true, body: e, timeout: 2e4, headers: { vid: getParameter("VID").get(A), "Content-Encoding": "gzip" } }, n = g && getPrivateSettingsPortAndDomains(g), C = null == n ? void 0 : n.hostname, E = null !== (o = null == C ? void 0 : C.length) && void 0 !== o ? o : 0, s = null == n ? void 0 : n.port, B = C && C[0], a = C && C[E - 1], Q = i2 > 0 ? (null == areaConfig ? void 0 : areaConfig.LOG_UPLOAD_SERVER[0]) || getLogUploadDomain() || (null != a ? a : LOG_SERVICE_BACKUP_DOMAIN) : (null == areaConfig ? void 0 : areaConfig.LOG_UPLOAD_SERVER[0]) || getLogUploadDomain() || (null != B ? B : LOG_SERVICE_MAIN_DOMAIN), c = t && !g ? "https://".concat(null !== (I = null == areaConfig ? void 0 : areaConfig.PROXY_NGINX[0]) && void 0 !== I ? I : "webrtc-cloud-proxy.sd-rtn.com", "/ls/?h=").concat(Q, "&p=").concat(null != s ? s : 443, "&d=upload/v1") : "https://".concat(Q).concat(s ? ":".concat(s) : "", "/upload/v1");
        await postWithAbortSignal(c, r).catch((o2) => (logUploadDomainIdx++, _uploadRequest(A, e, t, g, i2 + 1)));
      }, logUploaders = /* @__PURE__ */ new Map(), logUploader = (A, e) => {
        if (logUploaders.has(A) && logUploaders.get(A) instanceof LogUploader)
          return logUploaders.get(A);
        {
          const t = new LogUploader({ processId: "process-".concat(A), sdkVersion: "Agora_RTM_SDK_for_Web_".concat(BUILD), uploadRequest: _uploadRequest, PrivateConfig: {}, privateLogUploadHosts: e });
          return logUploaders.set(A, t), t;
        }
      }, blacklistedKeywords = ["text", "payload", "rawMessage", "thumbnail", "attributeInfos", "keys", "value", "extra", "ticket"], sensitiveKeywords = ["account", "ticket", "uid", "detail", "token", "fileName", "cname", "user", "group", "key", "origin", "users", "src", "dst", "lastUpdateUserId", "channel", "cert", "wan_ip", "userId", "authorUid", "target", "lockName", "appTicket", "channelName", "publisher", "succeedUsers", "failedUsers", "10", ...ipKeywords], whitelistedKeywords = ["serverReceivedTs", "hasPeerReceived", "messageType", "enableNotificationToChannelMembers", "lastUpdateTs"], sensitiveEvents = ["message", "presence", "topic", "lock", "storage", "MessageFromPeer", "LocalInvitationRefused", "LocalInvitationAccepted", "RemoteInvitationCanceled", "PeersOnlineStatusChanged", "AttributesUpdated", "MemberJoined"], sensitiveArgsHandler = (A) => {
        if ("string" == typeof A)
          return replaceRangeWithAsterisk(A);
        if (Array.isArray(A) && A.every((A2) => "string" == typeof A2))
          return A.map((A2) => replaceRangeWithAsterisk(A2));
        if (!isPrimitive(A)) {
          const e = {};
          for (let t = 0; t < whitelistedKeywords.length; t++) {
            const g = whitelistedKeywords[t];
            g in A && (e[g] = A[g]);
          }
          if (Object.keys(e).length > 0)
            return e;
          if (Object.keys(A).length < 5) {
            for (let t = 0, g = Object.entries(A); t < g.length; t++) {
              const [A2, o] = g[t];
              (getParameter("SENSITIVE_LOG") ? blacklistedKeywords : []).includes(A2) ? e[A2] = "[Hidden Info]" : e[replaceRangeWithAsterisk(A2)] = replaceRangeWithAsterisk(o);
            }
            return e;
          }
          return "object" == typeof A && null !== A ? safeJsonStringify(Array.isArray(A) ? A.map(getPlain) : getPlain(A)) : "[Sensitive Info]";
        }
        return A;
      };
      function maskMiddleOfString(A) {
        const e = String(A);
        if ("string" != typeof e)
          return "[Sensitive Info]";
        const t = e.length;
        if (t <= 2)
          return e;
        const g = t / 3, o = t / 3 * 2, I = "*".repeat(o - g);
        return e.substring(0, g) + I + e.substring(o);
      }
      function handleLogObject(A, e, t) {
        function g(o) {
          if (isPrimitive(o))
            return o;
          if (A instanceof Uint8Array)
            return "[Hidden Info]";
          if (Array.isArray(o))
            return o.map(g);
          const I = {};
          for (let A2 = 0, i2 = Object.entries(o); A2 < i2.length; A2++) {
            const [o2, r] = i2[A2], n = "number" == typeof r ? r.toString() : r;
            n instanceof Uint8Array || e.includes(o2) ? I[o2] = "[Hidden Info]" : t.includes(o2) ? I[o2] = "string" == typeof n ? ipKeywords.includes(o2) ? maskIp(n) : maskMiddleOfString(n) : Array.isArray(n) ? n.map(g) : g(n) : I[o2] = isNil$1(n) ? n : g(n);
          }
          return I;
        }
        return Array.isArray(A) ? A.map(g) : g(A);
      }
      const filterLogObject = (A) => handleLogObject(cloneDeep$1(A), getParameter("SENSITIVE_LOG") ? blacklistedKeywords : [], getParameter("SENSITIVE_LOG") ? sensitiveKeywords : []), getPlain = (A) => "object" == typeof A ? isPlainObject(A) ? filterLogObject(A) : A.constructor && A.constructor.name : A, formatLogTextAndParameters = (A, e) => {
        if (A instanceof Error)
          return A.message;
        if ("string" != typeof A)
          return JSON.stringify(filterLogObject(A));
        const t = e.map((A2) => A2 instanceof Error ? A2.message : "object" == typeof A2 && null !== A2 ? safeJsonStringify(Array.isArray(A2) ? A2.map(getPlain) : getPlain(A2)) : A2);
        return format$1(A.replace(/%[%Oo]/g, (A2) => "%%" === A2 ? "%" : "%o" === A2 || "%O" === A2 ? "%s" : A2), ...t);
      }, logAndUploadGenerator = (A, e, t, g, o, I, i2, r) => {
        const n = Debug(t);
        n.enabled = true, n.log = i2, n.useColors = false;
        const C = "Ins#".concat(e, " ");
        return function(e2) {
          for (var i3 = arguments.length, E = new Array(i3 > 1 ? i3 - 1 : 0), s = 1; s < i3; s++)
            E[s - 1] = arguments[s];
          if (I.logUpload) {
            const I2 = addPeriodIfNeeded(e2);
            var B = formatLogTextAndParameters(I2, E);
            const i4 = logUploader(g, r), n2 = "".concat(i4.logId++);
            i4.upload(A, { log_item_id: n2, log_level: t, payload_str: "[".concat(getUTCTimestamp$1(), "] - ").concat(String(o).slice(0, 7)).concat(o.length > 7 ? "..." : "", " - ").concat(C).concat(t, " - ").concat(B.length > 256 ? B.slice(0, 256) : B) });
          }
          const a = (A2) => {
            const g2 = B || formatLogTextAndParameters(addPeriodIfNeeded(e2), E), I2 = getParameter("LOG_HANDLER"), i4 = "".concat(t, " [UTC_Time: ").concat(getUTCTimestamp$1(), "]");
            isFunction$2(I2) ? I2({ level: A2, message: C + g2, prefix: i4 }) : n("[UTC_Time: ".concat(getUTCTimestamp$1(), "][uid: ").concat(getParameter("SENSITIVE_LOG") ? maskMiddleOfString(o) : o, "]").concat(g2));
          };
          switch (t) {
            case "RTM:INFO":
              I.logFilter.info && a("log");
              break;
            case "RTM:WARN":
              I.logFilter.warn && a("warning");
              break;
            case "RTM:ERROR":
              I.logFilter.error && a("error");
              break;
            case "RTM:TRACK":
              I.logFilter.track && a("log");
              break;
            case "RTM:MSG:RECV":
            case "RTM:MSG:SEND":
            case "RTM:DEBUG":
              I.logFilter.debug && a("debug");
          }
        };
      };
      let loggerId;
      function initLoggerId(A, e) {
        loggerId = gud$1();
        const t = new LogUploader({ processId: "process-".concat(A), sdkVersion: "Agora_RTM_SDK_for_Web_".concat(BUILD), uploadRequest: _uploadRequest, PrivateConfig: {}, privateLogUploadHosts: e });
        return logUploaders.set(A, t), loggerId;
      }
      const loggerGenerator = (A, e, t, g, o, I, i2, r) => logAndUploadGenerator(A, e, "RTM:".concat(g), I, i2, o, function(A2) {
        return t((g2 = A2, "Ins#".concat(e, " ").concat(g2)));
        var g2;
      }, r), genInfoLogger = (A, e, t, g, o, I) => loggerGenerator(A, e, console.debug, "INFO", t, g, o, I), genWarnLogger = (A, e, t, g, o, I) => loggerGenerator(A, e, console.warn, "WARN", t, g, o, I), genErrorLogger = (A, e, t, g, o, I) => loggerGenerator(A, e, console.error, "ERROR", t, g, o, I), debugLoggerGenerator = (A, e, t, g, o, I) => function(i2) {
        let r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
        const n = console.debug || console.log, C = logAndUploadGenerator(A, e, i2, g, o, t, function(A2) {
          return n((t2 = A2, "Ins#".concat(e, " ").concat(t2)));
          var t2;
        }, I);
        return function(A2) {
          for (var e2 = arguments.length, t2 = new Array(e2 > 1 ? e2 - 1 : 0), g2 = 1; g2 < e2; g2++)
            t2[g2 - 1] = arguments[g2];
          return C(r + A2, ...t2);
        };
      }, trackLoggerGenerator = (A, e, t, g, o, I) => (i2) => debugLoggerGenerator(A, e, t, g, o, I)("RTM:TRACK", "[".concat(i2, "] "));
      function loggedSensitive(A, e, t) {
        let g = t;
        void 0 === g && (g = Object.getOwnPropertyDescriptor(A, e));
        const o = g.value;
        return g.value = function() {
          for (var A2 = arguments.length, t2 = new Array(A2), g2 = 0; g2 < A2; g2++)
            t2[g2] = arguments[g2];
          this.invokeTracker("%s: ".concat(t2.length > 0 ? "%s with args: ".concat(t2.map(() => "%o")) : "%s"), this.name, e, ...t2.map(sensitiveArgsHandler));
          try {
            var I = o.apply(this, t2);
          } catch (A3) {
            throw this.logError("".concat(void 0 !== A3.code ? "Error Code ".concat(A3.code, ": ") : "", "%s failed").concat(t2.length > 0 ? " with args: ".concat(t2.map(() => "%o")) : ""), e, ...t2.map(sensitiveArgsHandler)), A3.originalError && this.logError(A3.originalError), this.errorTracker(A3), A3;
          }
          const i2 = Date.now();
          return (async () => {
            let A3;
            try {
              A3 = await I;
            } catch (A4) {
              return this.logError("".concat(void 0 !== A4.code ? "Error Code ".concat(A4.code, ": ") : "", "%s failed").concat(t2.length > 0 ? " with args: ".concat(t2.map(() => "%o")) : ""), e, ...t2.map(sensitiveArgsHandler)), A4.originalError && this.logError(A4.originalError), void this.errorTracker(A4);
            }
            var g3;
            A3 !== I ? void 0 === A3 ? this.resultTracker("%s promise resolves after %dms", e, Date.now() - i2) : this.resultTracker("%s promise resolves after %dms, result is %o", e, Date.now() - i2, sensitiveArgsHandler(A3)) : isAnyObject(A3) && !isPlainObject(A3) ? this.resultTracker("%s result is %s", e, A3.name || (null === (g3 = A3.constructor) || void 0 === g3 ? void 0 : g3.name)) : this.resultTracker("%s result is %o", e, A3 ? sensitiveArgsHandler(A3) : "void");
          })(), I;
        }, g;
      }
      class EventBase extends EventEmitter$1 {
        constructor(A, e) {
          var t;
          let g = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], o = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
          super(), t = this, _defineProperty$1(this, "logError", void 0), _defineProperty$1(this, "invokeTracker", void 0), _defineProperty$1(this, "resultTracker", void 0), _defineProperty$1(this, "errorTracker", void 0), _defineProperty$1(this, "eventTracker", void 0), _defineProperty$1(this, "info", void 0), _defineProperty$1(this, "warn", void 0), _defineProperty$1(this, "log", void 0), _defineProperty$1(this, "genLogger", void 0), _defineProperty$1(this, "loggerId", void 0), _defineProperty$1(this, "logger", void 0), _defineProperty$1(this, "name", void 0), _defineProperty$1(this, "config", void 0), _defineProperty$1(this, "debug", void 0);
          const { appId: I, userId: i2, config: r, processId: n } = A;
          this.config = A.config, this.logger = A, this.name = e, this.loggerId = this.logger.loggerId, this.info = genInfoLogger(I, this.loggerId, r, n, i2), this.log = this.info, this.warn = genWarnLogger(I, this.loggerId, r, n, i2), this.logError = genErrorLogger(I, this.loggerId, r, n, i2), this.genLogger = debugLoggerGenerator(I, this.loggerId, r, n, i2);
          const C = trackLoggerGenerator(I, this.loggerId, r, n, i2);
          if (this.debug = this.genLogger("RTM:DEBUG", "<".concat(e, "> ")), this.invokeTracker = C("Invoke"), this.eventTracker = C("Event"), this.resultTracker = C("Result"), this.errorTracker = C("Error"), g) {
            const A2 = this.emit.bind(this), g2 = function() {
              for (var g3 = arguments.length, o2 = new Array(g3), I2 = 0; I2 < g3; I2++)
                o2[I2] = arguments[I2];
              const [i3, ...r2] = o2, n2 = sensitiveEvents.includes(i3);
              t.eventTracker("%s: ".concat(r2.length > 0 ? "%s emitted with args: ".concat(r2.map(() => "%o")) : "%s emitted"), e, i3, ...getParameter("SENSITIVE_LOG") && n2 ? r2.map(sensitiveArgsHandler) : r2);
              try {
                return A2(...o2), true;
              } catch (A3) {
                return t.logError("Caught in the callback function of the event %s", i3, A3), false;
              }
            };
            this.emit = g2;
          }
          o && (Object.defineProperty(this, "addListener", { value: void 0, writable: false, configurable: false }), Object.defineProperty(this, "removeListener", { value: void 0, writable: false, configurable: false }));
        }
      }
      const updateLogLevel = (A, e) => {
        switch (A) {
          case "debug":
            e.logFilter = LogFilter.LOG_FILTER_DEBUG;
            break;
          case "info":
            e.logFilter = LogFilter.LOG_FILTER_INFO;
            break;
          case "warn":
            e.logFilter = LogFilter.LOG_FILTER_WARN;
            break;
          case "none":
            e.logFilter = LogFilter.LOG_FILTER_NONE;
            break;
          default:
            e.logFilter = LogFilter.LOG_FILTER_ERROR;
        }
      };
      var UZIP = {}, u16, u32;
      "object" == typeof module && (module.exports = UZIP), UZIP.parse = function(A, e) {
        for (var t = UZIP.bin.readUshort, g = UZIP.bin.readUint, o = 0, I = {}, i2 = new Uint8Array(A), r = i2.length - 4; 101010256 != g(i2, r); )
          r--;
        o = r;
        o += 4;
        var n = t(i2, o += 4);
        t(i2, o += 2);
        var C = g(i2, o += 2), E = g(i2, o += 4);
        o += 4, o = E;
        for (var s = 0; s < n; s++) {
          g(i2, o), o += 4, o += 4, o += 4, g(i2, o += 4);
          C = g(i2, o += 4);
          var B = g(i2, o += 4), a = t(i2, o += 4), Q = t(i2, o + 2), c = t(i2, o + 4);
          o += 6;
          var l = g(i2, o += 8);
          o += 4, o += a + Q + c, UZIP._readLocal(i2, l, I, C, B, e);
        }
        return I;
      }, UZIP._readLocal = function(A, e, t, g, o, I) {
        var i2 = UZIP.bin.readUshort, r = UZIP.bin.readUint;
        r(A, e), i2(A, e += 4), i2(A, e += 2);
        var n = i2(A, e += 2);
        r(A, e += 2), r(A, e += 4), e += 4;
        var C = i2(A, e += 8), E = i2(A, e += 2);
        e += 2;
        var s = UZIP.bin.readUTF8(A, e, C);
        if (e += C, e += E, I)
          t[s] = { size: o, csize: g };
        else {
          var B = new Uint8Array(A.buffer, e);
          if (0 == n)
            t[s] = new Uint8Array(B.buffer.slice(e, e + g));
          else {
            if (8 != n)
              throw "unknown compression method: " + n;
            var a = new Uint8Array(o);
            UZIP.inflateRaw(B, a), t[s] = a;
          }
        }
      }, UZIP.inflateRaw = function(A, e) {
        return UZIP.F.inflate(A, e);
      }, UZIP.inflate = function(A, e) {
        return A[0], A[1], UZIP.inflateRaw(new Uint8Array(A.buffer, A.byteOffset + 2, A.length - 2), e);
      }, UZIP.deflate = function(A, e) {
        null == e && (e = { level: 6 });
        var t = 0, g = new Uint8Array(50 + Math.floor(1.1 * A.length));
        g[t] = 120, g[t + 1] = 156, t += 2, t = UZIP.F.deflateRaw(A, g, t, e.level);
        var o = UZIP.adler(A, 0, A.length);
        return g[t + 0] = o >>> 24 & 255, g[t + 1] = o >>> 16 & 255, g[t + 2] = o >>> 8 & 255, g[t + 3] = o >>> 0 & 255, new Uint8Array(g.buffer, 0, t + 4);
      }, UZIP.deflateRaw = function(A, e) {
        null == e && (e = { level: 6 });
        var t = new Uint8Array(50 + Math.floor(1.1 * A.length)), g = UZIP.F.deflateRaw(A, t, g, e.level);
        return new Uint8Array(t.buffer, 0, g);
      }, UZIP.encode = function(A, e) {
        null == e && (e = false);
        var t = 0, g = UZIP.bin.writeUint, o = UZIP.bin.writeUshort, I = {};
        for (var i2 in A) {
          var r = !UZIP._noNeed(i2) && !e, n = A[i2], C = UZIP.crc.crc(n, 0, n.length);
          I[i2] = { cpr: r, usize: n.length, crc: C, file: r ? UZIP.deflateRaw(n) : n };
        }
        for (var i2 in I)
          t += I[i2].file.length + 30 + 46 + 2 * UZIP.bin.sizeUTF8(i2);
        t += 22;
        var E = new Uint8Array(t), s = 0, B = [];
        for (var i2 in I) {
          var a = I[i2];
          B.push(s), s = UZIP._writeHeader(E, s, i2, a, 0);
        }
        var Q = 0, c = s;
        for (var i2 in I) {
          a = I[i2];
          B.push(s), s = UZIP._writeHeader(E, s, i2, a, 1, B[Q++]);
        }
        var l = s - c;
        return g(E, s, 101010256), s += 4, o(E, s += 4, Q), o(E, s += 2, Q), g(E, s += 2, l), g(E, s += 4, c), s += 4, s += 2, E.buffer;
      }, UZIP._noNeed = function(A) {
        var e = A.split(".").pop().toLowerCase();
        return -1 != "png,jpg,jpeg,zip".indexOf(e);
      }, UZIP._writeHeader = function(A, e, t, g, o, I) {
        var i2 = UZIP.bin.writeUint, r = UZIP.bin.writeUshort, n = g.file;
        return i2(A, e, 0 == o ? 67324752 : 33639248), e += 4, 1 == o && (e += 2), r(A, e, 20), r(A, e += 2, 0), r(A, e += 2, g.cpr ? 8 : 0), i2(A, e += 2, 0), i2(A, e += 4, g.crc), i2(A, e += 4, n.length), i2(A, e += 4, g.usize), r(A, e += 4, UZIP.bin.sizeUTF8(t)), r(A, e += 2, 0), e += 2, 1 == o && (e += 2, e += 2, i2(A, e += 6, I), e += 4), e += UZIP.bin.writeUTF8(A, e, t), 0 == o && (A.set(n, e), e += n.length), e;
      }, UZIP.crc = { table: function() {
        for (var A = new Uint32Array(256), e = 0; e < 256; e++) {
          for (var t = e, g = 0; g < 8; g++)
            1 & t ? t = 3988292384 ^ t >>> 1 : t >>>= 1;
          A[e] = t;
        }
        return A;
      }(), update: function(A, e, t, g) {
        for (var o = 0; o < g; o++)
          A = UZIP.crc.table[255 & (A ^ e[t + o])] ^ A >>> 8;
        return A;
      }, crc: function(A, e, t) {
        return 4294967295 ^ UZIP.crc.update(4294967295, A, e, t);
      } }, UZIP.adler = function(A, e, t) {
        for (var g = 1, o = 0, I = e, i2 = e + t; I < i2; ) {
          for (var r = Math.min(I + 5552, i2); I < r; )
            o += g += A[I++];
          g %= 65521, o %= 65521;
        }
        return o << 16 | g;
      }, UZIP.bin = { readUshort: function(A, e) {
        return A[e] | A[e + 1] << 8;
      }, writeUshort: function(A, e, t) {
        A[e] = 255 & t, A[e + 1] = t >> 8 & 255;
      }, readUint: function(A, e) {
        return 16777216 * A[e + 3] + (A[e + 2] << 16 | A[e + 1] << 8 | A[e]);
      }, writeUint: function(A, e, t) {
        A[e] = 255 & t, A[e + 1] = t >> 8 & 255, A[e + 2] = t >> 16 & 255, A[e + 3] = t >> 24 & 255;
      }, readASCII: function(A, e, t) {
        for (var g = "", o = 0; o < t; o++)
          g += String.fromCharCode(A[e + o]);
        return g;
      }, writeASCII: function(A, e, t) {
        for (var g = 0; g < t.length; g++)
          A[e + g] = t.charCodeAt(g);
      }, pad: function(A) {
        return A.length < 2 ? "0" + A : A;
      }, readUTF8: function(A, e, t) {
        for (var g, o = "", I = 0; I < t; I++)
          o += "%" + UZIP.bin.pad(A[e + I].toString(16));
        try {
          g = decodeURIComponent(o);
        } catch (g2) {
          return UZIP.bin.readASCII(A, e, t);
        }
        return g;
      }, writeUTF8: function(A, e, t) {
        for (var g = t.length, o = 0, I = 0; I < g; I++) {
          var i2 = t.charCodeAt(I);
          if (4294967168 & i2)
            if (4294965248 & i2)
              if (4294901760 & i2) {
                if (4292870144 & i2)
                  throw "e";
                A[e + o] = 240 | i2 >> 18, A[e + o + 1] = 128 | i2 >> 12 & 63, A[e + o + 2] = 128 | i2 >> 6 & 63, A[e + o + 3] = 128 | 63 & i2, o += 4;
              } else
                A[e + o] = 224 | i2 >> 12, A[e + o + 1] = 128 | i2 >> 6 & 63, A[e + o + 2] = 128 | 63 & i2, o += 3;
            else
              A[e + o] = 192 | i2 >> 6, A[e + o + 1] = 128 | 63 & i2, o += 2;
          else
            A[e + o] = i2, o++;
        }
        return o;
      }, sizeUTF8: function(A) {
        for (var e = A.length, t = 0, g = 0; g < e; g++) {
          var o = A.charCodeAt(g);
          if (4294967168 & o)
            if (4294965248 & o)
              if (4294901760 & o) {
                if (4292870144 & o)
                  throw "e";
                t += 4;
              } else
                t += 3;
            else
              t += 2;
          else
            t++;
        }
        return t;
      } }, UZIP.F = {}, UZIP.F.deflateRaw = function(A, e, t, g) {
        var o = [[0, 0, 0, 0, 0], [4, 4, 8, 4, 0], [4, 5, 16, 8, 0], [4, 6, 16, 16, 0], [4, 10, 16, 32, 0], [8, 16, 32, 32, 0], [8, 16, 128, 128, 0], [8, 32, 128, 256, 0], [32, 128, 258, 1024, 1], [32, 258, 258, 4096, 1]][g], I = UZIP.F.U, i2 = UZIP.F._goodIndex;
        UZIP.F._hash;
        var r = UZIP.F._putsE, n = 0, C = t << 3, E = 0, s = A.length;
        if (0 == g) {
          for (; n < s; ) {
            r(e, C, n + (R2 = Math.min(65535, s - n)) == s ? 1 : 0), C = UZIP.F._copyExact(A, n, R2, e, C + 8), n += R2;
          }
          return C >>> 3;
        }
        var B = I.lits, a = I.strt, Q = I.prev, c = 0, l = 0, h = 0, u = 0, d = 0, D = 0;
        for (s > 2 && (a[D = UZIP.F._hash(A, 0)] = 0), n = 0; n < s; n++) {
          if (d = D, n + 1 < s - 2) {
            D = UZIP.F._hash(A, n + 1);
            var y = n + 1 & 32767;
            Q[y] = a[D], a[D] = y;
          }
          if (E <= n) {
            (c > 14e3 || l > 26697) && s - n > 100 && (E < n && (B[c] = n - E, c += 2, E = n), C = UZIP.F._writeBlock(n == s - 1 || E == s ? 1 : 0, B, c, u, A, h, n - h, e, C), c = l = u = 0, h = n);
            var p2 = 0;
            n < s - 2 && (p2 = UZIP.F._bestMatch(A, n, Q, d, Math.min(o[2], s - n), o[3]));
            var R2 = p2 >>> 16, w = 65535 & p2;
            if (0 != p2) {
              w = 65535 & p2;
              var _ = i2(R2 = p2 >>> 16, I.of0);
              I.lhst[257 + _]++;
              var S = i2(w, I.df0);
              I.dhst[S]++, u += I.exb[_] + I.dxb[S], B[c] = R2 << 23 | n - E, B[c + 1] = w << 16 | _ << 8 | S, c += 2, E = n + R2;
            } else
              I.lhst[A[n]]++;
            l++;
          }
        }
        for (h == n && 0 != A.length || (E < n && (B[c] = n - E, c += 2, E = n), C = UZIP.F._writeBlock(1, B, c, u, A, h, n - h, e, C), c = 0, l = 0, c = l = u = 0, h = n); 7 & C; )
          C++;
        return C >>> 3;
      }, UZIP.F._bestMatch = function(A, e, t, g, o, I) {
        var i2 = 32767 & e, r = t[i2], n = i2 - r + 32768 & 32767;
        if (r == i2 || g != UZIP.F._hash(A, e - n))
          return 0;
        for (var C = 0, E = 0, s = Math.min(32767, e); n <= s && 0 != --I && r != i2; ) {
          if (0 == C || A[e + C] == A[e + C - n]) {
            var B = UZIP.F._howLong(A, e, n);
            if (B > C) {
              if (E = n, (C = B) >= o)
                break;
              n + 2 < B && (B = n + 2);
              for (var a = 0, Q = 0; Q < B - 2; Q++) {
                var c = e - n + Q + 32768 & 32767, l = c - t[c] + 32768 & 32767;
                l > a && (a = l, r = c);
              }
            }
          }
          n += (i2 = r) - (r = t[i2]) + 32768 & 32767;
        }
        return C << 16 | E;
      }, UZIP.F._howLong = function(A, e, t) {
        if (A[e] != A[e - t] || A[e + 1] != A[e + 1 - t] || A[e + 2] != A[e + 2 - t])
          return 0;
        var g = e, o = Math.min(A.length, e + 258);
        for (e += 3; e < o && A[e] == A[e - t]; )
          e++;
        return e - g;
      }, UZIP.F._hash = function(A, e) {
        return (A[e] << 8 | A[e + 1]) + (A[e + 2] << 4) & 65535;
      }, UZIP.saved = 0, UZIP.F._writeBlock = function(A, e, t, g, o, I, i2, r, n) {
        var C, E, s, B, a, Q, c, l, h, u = UZIP.F.U, d = UZIP.F._putsF, D = UZIP.F._putsE;
        u.lhst[256]++, E = (C = UZIP.F.getTrees())[0], s = C[1], B = C[2], a = C[3], Q = C[4], c = C[5], l = C[6], h = C[7];
        var y = 32 + (n + 3 & 7 ? 8 - (n + 3 & 7) : 0) + (i2 << 3), p2 = g + UZIP.F.contSize(u.fltree, u.lhst) + UZIP.F.contSize(u.fdtree, u.dhst), R2 = g + UZIP.F.contSize(u.ltree, u.lhst) + UZIP.F.contSize(u.dtree, u.dhst);
        R2 += 14 + 3 * c + UZIP.F.contSize(u.itree, u.ihst) + (2 * u.ihst[16] + 3 * u.ihst[17] + 7 * u.ihst[18]);
        for (var w = 0; w < 286; w++)
          u.lhst[w] = 0;
        for (w = 0; w < 30; w++)
          u.dhst[w] = 0;
        for (w = 0; w < 19; w++)
          u.ihst[w] = 0;
        var _ = y < p2 && y < R2 ? 0 : p2 < R2 ? 1 : 2;
        if (d(r, n, A), d(r, n + 1, _), n += 3, 0 == _) {
          for (; 7 & n; )
            n++;
          n = UZIP.F._copyExact(o, I, i2, r, n);
        } else {
          var S, f;
          if (1 == _ && (S = u.fltree, f = u.fdtree), 2 == _) {
            UZIP.F.makeCodes(u.ltree, E), UZIP.F.revCodes(u.ltree, E), UZIP.F.makeCodes(u.dtree, s), UZIP.F.revCodes(u.dtree, s), UZIP.F.makeCodes(u.itree, B), UZIP.F.revCodes(u.itree, B), S = u.ltree, f = u.dtree, D(r, n, a - 257), D(r, n += 5, Q - 1), D(r, n += 5, c - 4), n += 4;
            for (var N = 0; N < c; N++)
              D(r, n + 3 * N, u.itree[1 + (u.ordr[N] << 1)]);
            n += 3 * c, n = UZIP.F._codeTiny(l, u.itree, r, n), n = UZIP.F._codeTiny(h, u.itree, r, n);
          }
          for (var M = I, k = 0; k < t; k += 2) {
            for (var L = e[k], G = L >>> 23, b = M + (8388607 & L); M < b; )
              n = UZIP.F._writeLit(o[M++], S, r, n);
            if (0 != G) {
              var U = e[k + 1], m = U >> 16, T = U >> 8 & 255, O = 255 & U;
              D(r, n = UZIP.F._writeLit(257 + T, S, r, n), G - u.of0[T]), n += u.exb[T], d(r, n = UZIP.F._writeLit(O, f, r, n), m - u.df0[O]), n += u.dxb[O], M += G;
            }
          }
          n = UZIP.F._writeLit(256, S, r, n);
        }
        return n;
      }, UZIP.F._copyExact = function(A, e, t, g, o) {
        var I = o >>> 3;
        return g[I] = t, g[I + 1] = t >>> 8, g[I + 2] = 255 - g[I], g[I + 3] = 255 - g[I + 1], I += 4, g.set(new Uint8Array(A.buffer, e, t), I), o + (t + 4 << 3);
      }, UZIP.F.getTrees = function() {
        for (var A = UZIP.F.U, e = UZIP.F._hufTree(A.lhst, A.ltree, 15), t = UZIP.F._hufTree(A.dhst, A.dtree, 15), g = [], o = UZIP.F._lenCodes(A.ltree, g), I = [], i2 = UZIP.F._lenCodes(A.dtree, I), r = 0; r < g.length; r += 2)
          A.ihst[g[r]]++;
        for (r = 0; r < I.length; r += 2)
          A.ihst[I[r]]++;
        for (var n = UZIP.F._hufTree(A.ihst, A.itree, 7), C = 19; C > 4 && 0 == A.itree[1 + (A.ordr[C - 1] << 1)]; )
          C--;
        return [e, t, n, o, i2, C, g, I];
      }, UZIP.F.getSecond = function(A) {
        for (var e = [], t = 0; t < A.length; t += 2)
          e.push(A[t + 1]);
        return e;
      }, UZIP.F.nonZero = function(A) {
        for (var e = "", t = 0; t < A.length; t += 2)
          0 != A[t + 1] && (e += (t >> 1) + ",");
        return e;
      }, UZIP.F.contSize = function(A, e) {
        for (var t = 0, g = 0; g < e.length; g++)
          t += e[g] * A[1 + (g << 1)];
        return t;
      }, UZIP.F._codeTiny = function(A, e, t, g) {
        for (var o = 0; o < A.length; o += 2) {
          var I = A[o], i2 = A[o + 1];
          g = UZIP.F._writeLit(I, e, t, g);
          var r = 16 == I ? 2 : 17 == I ? 3 : 7;
          I > 15 && (UZIP.F._putsE(t, g, i2, r), g += r);
        }
        return g;
      }, UZIP.F._lenCodes = function(A, e) {
        for (var t = A.length; 2 != t && 0 == A[t - 1]; )
          t -= 2;
        for (var g = 0; g < t; g += 2) {
          var o = A[g + 1], I = g + 3 < t ? A[g + 3] : -1, i2 = g + 5 < t ? A[g + 5] : -1, r = 0 == g ? -1 : A[g - 1];
          if (0 == o && I == o && i2 == o) {
            for (var n = g + 5; n + 2 < t && A[n + 2] == o; )
              n += 2;
            (C = Math.min(n + 1 - g >>> 1, 138)) < 11 ? e.push(17, C - 3) : e.push(18, C - 11), g += 2 * C - 2;
          } else if (o == r && I == o && i2 == o) {
            for (n = g + 5; n + 2 < t && A[n + 2] == o; )
              n += 2;
            var C = Math.min(n + 1 - g >>> 1, 6);
            e.push(16, C - 3), g += 2 * C - 2;
          } else
            e.push(o, 0);
        }
        return t >>> 1;
      }, UZIP.F._hufTree = function(A, e, t) {
        var g = [], o = A.length, I = e.length, i2 = 0;
        for (i2 = 0; i2 < I; i2 += 2)
          e[i2] = 0, e[i2 + 1] = 0;
        for (i2 = 0; i2 < o; i2++)
          0 != A[i2] && g.push({ lit: i2, f: A[i2] });
        var r = g.length, n = g.slice(0);
        if (0 == r)
          return 0;
        if (1 == r) {
          var C = g[0].lit;
          n = 0 == C ? 1 : 0;
          return e[1 + (C << 1)] = 1, e[1 + (n << 1)] = 1, 1;
        }
        g.sort(function(A2, e2) {
          return A2.f - e2.f;
        });
        var E = g[0], s = g[1], B = 0, a = 1, Q = 2;
        for (g[0] = { lit: -1, f: E.f + s.f, l: E, r: s, d: 0 }; a != r - 1; )
          E = B != a && (Q == r || g[B].f < g[Q].f) ? g[B++] : g[Q++], s = B != a && (Q == r || g[B].f < g[Q].f) ? g[B++] : g[Q++], g[a++] = { lit: -1, f: E.f + s.f, l: E, r: s };
        var c = UZIP.F.setDepth(g[a - 1], 0);
        for (c > t && (UZIP.F.restrictDepth(n, t, c), c = t), i2 = 0; i2 < r; i2++)
          e[1 + (n[i2].lit << 1)] = n[i2].d;
        return c;
      }, UZIP.F.setDepth = function(A, e) {
        return -1 != A.lit ? (A.d = e, e) : Math.max(UZIP.F.setDepth(A.l, e + 1), UZIP.F.setDepth(A.r, e + 1));
      }, UZIP.F.restrictDepth = function(A, e, t) {
        var g = 0, o = 1 << t - e, I = 0;
        for (A.sort(function(A2, e2) {
          return e2.d == A2.d ? A2.f - e2.f : e2.d - A2.d;
        }), g = 0; g < A.length && A[g].d > e; g++) {
          var i2 = A[g].d;
          A[g].d = e, I += o - (1 << t - i2);
        }
        for (I >>>= t - e; I > 0; ) {
          (i2 = A[g].d) < e ? (A[g].d++, I -= 1 << e - i2 - 1) : g++;
        }
        for (; g >= 0; g--)
          A[g].d == e && I < 0 && (A[g].d--, I++);
        0 != I && console.log("debt left");
      }, UZIP.F._goodIndex = function(A, e) {
        var t = 0;
        return e[16 | t] <= A && (t |= 16), e[8 | t] <= A && (t |= 8), e[4 | t] <= A && (t |= 4), e[2 | t] <= A && (t |= 2), e[1 | t] <= A && (t |= 1), t;
      }, UZIP.F._writeLit = function(A, e, t, g) {
        return UZIP.F._putsF(t, g, e[A << 1]), g + e[1 + (A << 1)];
      }, UZIP.F.inflate = function(A, e) {
        var t = Uint8Array;
        if (3 == A[0] && 0 == A[1])
          return e || new t(0);
        var g = UZIP.F, o = g._bitsF, I = g._bitsE, i2 = g._decodeTiny, r = g.makeCodes, n = g.codes2map, C = g._get17, E = g.U, s = null == e;
        s && (e = new t(A.length >>> 2 << 3));
        for (var B, a, Q = 0, c = 0, l = 0, h = 0, u = 0, d = 0, D = 0, y = 0, p2 = 0; 0 == Q; )
          if (Q = o(A, p2, 1), c = o(A, p2 + 1, 2), p2 += 3, 0 != c) {
            if (s && (e = UZIP.F._check(e, y + (1 << 17))), 1 == c && (B = E.flmap, a = E.fdmap, d = 511, D = 31), 2 == c) {
              l = I(A, p2, 5) + 257, h = I(A, p2 + 5, 5) + 1, u = I(A, p2 + 10, 4) + 4, p2 += 14;
              for (var R2 = 0; R2 < 38; R2 += 2)
                E.itree[R2] = 0, E.itree[R2 + 1] = 0;
              var w = 1;
              for (R2 = 0; R2 < u; R2++) {
                var _ = I(A, p2 + 3 * R2, 3);
                E.itree[1 + (E.ordr[R2] << 1)] = _, _ > w && (w = _);
              }
              p2 += 3 * u, r(E.itree, w), n(E.itree, w, E.imap), B = E.lmap, a = E.dmap, p2 = i2(E.imap, (1 << w) - 1, l + h, A, p2, E.ttree);
              var S = g._copyOut(E.ttree, 0, l, E.ltree);
              d = (1 << S) - 1;
              var f = g._copyOut(E.ttree, l, h, E.dtree);
              D = (1 << f) - 1, r(E.ltree, S), n(E.ltree, S, B), r(E.dtree, f), n(E.dtree, f, a);
            }
            for (; ; ) {
              var N = B[C(A, p2) & d];
              p2 += 15 & N;
              var M = N >>> 4;
              if (M >>> 8 == 0)
                e[y++] = M;
              else {
                if (256 == M)
                  break;
                var k = y + M - 254;
                if (M > 264) {
                  var L = E.ldef[M - 257];
                  k = y + (L >>> 3) + I(A, p2, 7 & L), p2 += 7 & L;
                }
                var G = a[C(A, p2) & D];
                p2 += 15 & G;
                var b = G >>> 4, U = E.ddef[b], m = (U >>> 4) + o(A, p2, 15 & U);
                for (p2 += 15 & U, s && (e = UZIP.F._check(e, y + (1 << 17))); y < k; )
                  e[y] = e[y++ - m], e[y] = e[y++ - m], e[y] = e[y++ - m], e[y] = e[y++ - m];
                y = k;
              }
            }
          } else {
            7 & p2 && (p2 += 8 - (7 & p2));
            var T = (p2 >>> 3) + 4, O = A[T - 4] | A[T - 3] << 8;
            s && (e = UZIP.F._check(e, y + O)), e.set(new t(A.buffer, A.byteOffset + T, O), y), p2 = T + O << 3, y += O;
          }
        return e.length == y ? e : e.slice(0, y);
      }, UZIP.F._check = function(A, e) {
        var t = A.length;
        if (e <= t)
          return A;
        var g = new Uint8Array(Math.max(t << 1, e));
        return g.set(A, 0), g;
      }, UZIP.F._decodeTiny = function(A, e, t, g, o, I) {
        for (var i2 = UZIP.F._bitsE, r = UZIP.F._get17, n = 0; n < t; ) {
          var C = A[r(g, o) & e];
          o += 15 & C;
          var E = C >>> 4;
          if (E <= 15)
            I[n] = E, n++;
          else {
            var s = 0, B = 0;
            16 == E ? (B = 3 + i2(g, o, 2), o += 2, s = I[n - 1]) : 17 == E ? (B = 3 + i2(g, o, 3), o += 3) : 18 == E && (B = 11 + i2(g, o, 7), o += 7);
            for (var a = n + B; n < a; )
              I[n] = s, n++;
          }
        }
        return o;
      }, UZIP.F._copyOut = function(A, e, t, g) {
        for (var o = 0, I = 0, i2 = g.length >>> 1; I < t; ) {
          var r = A[I + e];
          g[I << 1] = 0, g[1 + (I << 1)] = r, r > o && (o = r), I++;
        }
        for (; I < i2; )
          g[I << 1] = 0, g[1 + (I << 1)] = 0, I++;
        return o;
      }, UZIP.F.makeCodes = function(A, e) {
        for (var t, g, o, I, i2 = UZIP.F.U, r = A.length, n = i2.bl_count, C = 0; C <= e; C++)
          n[C] = 0;
        for (C = 1; C < r; C += 2)
          n[A[C]]++;
        var E = i2.next_code;
        for (t = 0, n[0] = 0, g = 1; g <= e; g++)
          t = t + n[g - 1] << 1, E[g] = t;
        for (o = 0; o < r; o += 2)
          0 != (I = A[o + 1]) && (A[o] = E[I], E[I]++);
      }, UZIP.F.codes2map = function(A, e, t) {
        for (var g = A.length, o = UZIP.F.U.rev15, I = 0; I < g; I += 2)
          if (0 != A[I + 1])
            for (var i2 = I >> 1, r = A[I + 1], n = i2 << 4 | r, C = e - r, E = A[I] << C, s = E + (1 << C); E != s; ) {
              t[o[E] >>> 15 - e] = n, E++;
            }
      }, UZIP.F.revCodes = function(A, e) {
        for (var t = UZIP.F.U.rev15, g = 15 - e, o = 0; o < A.length; o += 2) {
          var I = A[o] << e - A[o + 1];
          A[o] = t[I] >>> g;
        }
      }, UZIP.F._putsE = function(A, e, t) {
        t <<= 7 & e;
        var g = e >>> 3;
        A[g] |= t, A[g + 1] |= t >>> 8;
      }, UZIP.F._putsF = function(A, e, t) {
        t <<= 7 & e;
        var g = e >>> 3;
        A[g] |= t, A[g + 1] |= t >>> 8, A[g + 2] |= t >>> 16;
      }, UZIP.F._bitsE = function(A, e, t) {
        return (A[e >>> 3] | A[(e >>> 3) + 1] << 8) >>> (7 & e) & (1 << t) - 1;
      }, UZIP.F._bitsF = function(A, e, t) {
        return (A[e >>> 3] | A[(e >>> 3) + 1] << 8 | A[(e >>> 3) + 2] << 16) >>> (7 & e) & (1 << t) - 1;
      }, UZIP.F._get17 = function(A, e) {
        return (A[e >>> 3] | A[(e >>> 3) + 1] << 8 | A[(e >>> 3) + 2] << 16) >>> (7 & e);
      }, UZIP.F._get25 = function(A, e) {
        return (A[e >>> 3] | A[(e >>> 3) + 1] << 8 | A[(e >>> 3) + 2] << 16 | A[(e >>> 3) + 3] << 24) >>> (7 & e);
      }, UZIP.F.U = (u16 = Uint16Array, u32 = Uint32Array, { next_code: new u16(16), bl_count: new u16(16), ordr: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], of0: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999], exb: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0], ldef: new u16(32), df0: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535], dxb: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0], ddef: new u32(32), flmap: new u16(512), fltree: [], fdmap: new u16(32), fdtree: [], lmap: new u16(32768), ltree: [], ttree: [], dmap: new u16(32768), dtree: [], imap: new u16(512), itree: [], rev15: new u16(32768), lhst: new u32(286), dhst: new u32(30), ihst: new u32(19), lits: new u32(15e3), strt: new u16(65536), prev: new u16(32768) }), function() {
        for (var A = UZIP.F.U, e = 0; e < 32768; e++) {
          var t = e;
          t = (4278255360 & (t = (4042322160 & (t = (3435973836 & (t = (2863311530 & t) >>> 1 | (1431655765 & t) << 1)) >>> 2 | (858993459 & t) << 2)) >>> 4 | (252645135 & t) << 4)) >>> 8 | (16711935 & t) << 8, A.rev15[e] = (t >>> 16 | t << 16) >>> 17;
        }
        function g(A2, e2, t2) {
          for (; 0 != e2--; )
            A2.push(0, t2);
        }
        for (e = 0; e < 32; e++)
          A.ldef[e] = A.of0[e] << 3 | A.exb[e], A.ddef[e] = A.df0[e] << 4 | A.dxb[e];
        g(A.fltree, 144, 8), g(A.fltree, 112, 9), g(A.fltree, 24, 7), g(A.fltree, 8, 8), UZIP.F.makeCodes(A.fltree, 9), UZIP.F.codes2map(A.fltree, 9, A.flmap), UZIP.F.revCodes(A.fltree, 9), g(A.fdtree, 32, 5), UZIP.F.makeCodes(A.fdtree, 5), UZIP.F.codes2map(A.fdtree, 5, A.fdmap), UZIP.F.revCodes(A.fdtree, 5), g(A.itree, 19, 0), g(A.ltree, 286, 0), g(A.dtree, 30, 0), g(A.ttree, 320, 0);
      }();
      const { inflate: inflate$1, deflate } = UZIP;
      function isValidAppId(A) {
        return /^[\dA-Za-z]{32}$/.test(A);
      }
      function isValidId(A) {
        return "string" == typeof A && !A.startsWith("_") && /^[a-zA-Z0-9 \!\#\$\%\&\(\)\+\,\-\:\;\<\=\>\?\@\[\]\^\_\{\|\}\~]{1,64}$/.test(A);
      }
      function isValidTopic(A) {
        return "string" == typeof A && A.length > 0 && !A.startsWith("_") && isValidId(A);
      }
      function validateTopicName(A, e) {
        const { code: t, reason: g } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_INVALID_TOPIC_NAME);
        if (!isValidTopic(A))
          throw new RtmInvalidArgumentError(e, [g], t);
        if (0 === A.length || new Blob([null != A ? A : ""]).size > TOPIC_NAME_SIZE)
          throw new RtmInvalidArgumentError(e, [g], t);
      }
      function isUintString(A) {
        const e = Number(A);
        return Number.isInteger(e) && e >= 0;
      }
      function isValidIp(A) {
        let e;
        try {
          e = A.split(".").map((A2) => Number(A2));
        } catch (A2) {
          return false;
        }
        if (4 !== e.length)
          return false;
        if (0 === e[0])
          return false;
        for (let A2 = 0, t = e; A2 < t.length; A2++) {
          const e2 = t[A2];
          if (!Number.isInteger(e2))
            return false;
          if (e2 < 0 || e2 > 255)
            return false;
        }
        return true;
      }
      function validMetaDataItem(A, e) {
        let { items: t, maxMetaDataCount: g, maxMetaValueSize: o, majorRevision: I, type: i2 } = e;
        if (!Array.isArray(t)) {
          const { code: e2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_INVALID_METADATA_ITEM);
          throw new RtmInvalidArgumentError(A, [t2], e2);
        }
        const r = t.map((A2) => [A2.getKey(), A2.getValue()]);
        if (r.length > g) {
          const { code: e2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_METADATA_ITEM_EXCEED_LIMITATION);
          throw new RtmLimitExceededError(A, [t2], e2);
        }
        if (0 === r.length) {
          const { code: e2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_INVALID_METADATA_ITEM);
          throw new RtmInvalidArgumentError(A, [t2], e2);
        }
        if ("number" != typeof I || I < -1 || I % 1 != 0) {
          const { code: e2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_INVALID_REVISION);
          throw new RtmInvalidArgumentError(A, [t2], e2);
        }
        if (t.map((e2) => {
          if ((null == e2 ? void 0 : e2.getRevision()) < -1) {
            const { code: e3, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_INVALID_REVISION);
            throw new RtmInvalidArgumentError(A, [t2], e3);
          }
        }), ("Update" === i2 || "Delete" === i2) && 0 === I) {
          const { code: e2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_INVALID_REVISION);
          throw new RtmInvalidArgumentError(A, [t2], e2);
        }
        if (("Update" === i2 || "Delete" === i2) && t.map((A2) => A2.getRevision()).includes(0)) {
          const { code: e2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_INVALID_REVISION);
          throw new RtmInvalidArgumentError(A, [t2], e2);
        }
        for (let e2 = 0; e2 < r.length; e2++) {
          const [t2, g2] = r[e2], I2 = new Blob([null != t2 ? t2 : ""]).size, n = new Blob([null != g2 ? g2 : ""]).size;
          if ("string" != typeof t2 || 0 === I2 || "_" === (null == t2 ? void 0 : t2[0]) || !isValidId(t2)) {
            const { code: e3, reason: t3 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_INVALID_KEY);
            throw new RtmInvalidArgumentError(A, [t3], e3);
          }
          if (I2 > RTM_METADATA_KEY_MAX_LENGTH) {
            const { code: e3, reason: t3 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_KEY_LENGTH_OVERFLOW);
            throw new RtmInvalidArgumentError(A, [t3], e3);
          }
          if ("Delete" !== i2 && "string" != typeof g2) {
            const { code: e3, reason: t3 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_INVALID_VALUE);
            throw new RtmInvalidArgumentError(A, [t3], e3);
          }
          if ("Delete" !== i2 && n > o) {
            const { code: e3, reason: t3 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_VALUE_LENGTH_OVERFLOW);
            throw new RtmLimitExceededError(A, [t3], e3);
          }
        }
      }
      function validateMetaDataSize(A, e) {
        if (new Blob([null != e ? e : ""]).size > RTM_METADATA_MAX_LENGTH) {
          const { code: e2, reason: t } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_METADATA_LENGTH_OVERFLOW);
          throw new RtmLimitExceededError(A, [t], e2);
        }
      }
      function validMetaDataMajorRevisionForRemove(A, e) {
        if (e < -1) {
          const { code: e2, reason: t } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_INVALID_REVISION);
          throw new RtmInvalidArgumentError(A, [t], e2);
        }
        if (e % 1 != 0) {
          const { code: e2, reason: t } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_INVALID_REVISION);
          throw new RtmInvalidArgumentError(A, [t], e2);
        }
        if (0 === e) {
          const { code: e2, reason: t } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_INVALID_REVISION);
          throw new RtmInvalidArgumentError(A, [t], e2);
        }
      }
      function validStateOfPresence(A, e) {
        for (const g in A) {
          var t;
          const o = new Blob([null !== (t = A[g]) && void 0 !== t ? t : ""]).size;
          if (validStateKeyOfPresence(g, e), o > MAX_STATE_VALUE_SIZE) {
            const { code: A2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_PRESENCE_STATE_VALUE_SIZE_OVERFLOW);
            throw new RtmLimitExceededError(e, [t2], A2);
          }
        }
      }
      function validStateKeyOfPresence(A, e) {
        const t = new Blob([null != A ? A : ""]).size;
        if (t > MAX_STATE_KEY_SIZE) {
          const { code: A2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_PRESENCE_STATE_KEY_SIZE_OVERFLOW);
          throw new RtmInvalidArgumentError(e, [t2], A2);
        }
        if (0 === t || !isValidId(A)) {
          const { code: A2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_PRESENCE_INVALID_STATE_KEY);
          throw new RtmInvalidArgumentError(e, [t2], A2);
        }
      }
      function checkKeyValidity(A) {
        return 0 !== A.length && A[0] !== K_SYNC_INTERNAL_KEY_PREFIX;
      }
      function validateMessageSize(A, e) {
        if (!A || "string" != typeof A && !(A instanceof Uint8Array)) {
          const { code: A2, reason: t } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_INVALID_MESSAGE);
          throw new RtmInvalidArgumentError(e, [t], A2);
        }
        if (("string" == typeof A ? new Blob([null != A ? A : ""]).size : A.byteLength) > PUBLISH_MESSAGE_SIZE) {
          const { code: A2, reason: t } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_MESSAGE_LENGTH_EXCEED_LIMITATION);
          throw new RtmInvalidArgumentError(e, [t], A2);
        }
      }
      function validateCustomType(A, e) {
        const t = new Blob([A]);
        if (t.size > CUSTOM_TYPE_SIZE) {
          const { code: A2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_CUSTOM_TYPE_LENGTH_OVERFLOW);
          throw new RtmInvalidArgumentError(e, [t2], A2);
        }
        if ("string" != typeof A || 0 === t.size) {
          const { code: A2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_INVALID_CUSTOM_TYPE);
          throw new RtmInvalidArgumentError(e, [t2], A2);
        }
      }
      function validateChannelName(A) {
        return isValidId(A);
      }
      function validateChannelType(A, e) {
        if ("MESSAGE" !== e && "STREAM" !== e) {
          const { code: e2, reason: t } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_INVALID_CHANNEL_TYPE);
          throw new RtmInvalidArgumentError(A, [t], e2);
        }
      }
      function validateHistoryChannelType(A, e) {
        if ("MESSAGE" !== e && "USER" !== e) {
          const { code: e2, reason: t } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_INVALID_CHANNEL_TYPE);
          throw new RtmInvalidArgumentError(A, [t], e2);
        }
      }
      function validMessage(A, e) {
        const t = OperationName.publish, { code: g, reason: o } = getErrorInfoByCode(e);
        if (!isPlainObject(A))
          throw new RtmInvalidArgumentError(t, [o], g);
        if (void 0 === A.messageType)
          if (A.rawMessage instanceof Uint8Array) {
            if (A.messageType = "RAW", void 0 !== A.text)
              throw new RtmInvalidArgumentError(t, [o], g);
          } else {
            if ("string" != typeof A.text)
              throw new RtmInvalidArgumentError(t, [o], g);
            if (A.messageType = "TEXT", void 0 !== A.rawMessage)
              throw new RtmInvalidArgumentError(t, [o], g);
          }
      }
      function isValidEnvString(A) {
        return false;
      }
      function validDomain(A) {
        return /^(?:(?:(?:[a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)+[a-zA-Z]{2,}|(?:\d{1,3}\.){3}\d{1,3})(?::\d{1,5})?$/.test(A);
      }
      function validateIpPort(A) {
        return /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|\d{1,2})\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|\d{1,2})(?::([1-9]\d{0,4}))?$/.test(A);
      }
      function validatePrivateConfig(A) {
        var e, t, g, o, I, i2, r, n, C;
        if (isEmptyObject(null == A ? void 0 : A.privateConfig) || isEmptyObject(null == A || null === (e = A.privateConfig) || void 0 === e ? void 0 : e.serviceType) || null == A || !A.privateConfig)
          return false;
        let E = false, s = "";
        const B = null == A || null === (t = A.privateConfig) || void 0 === t ? void 0 : t.serviceType, a = null == A || null === (g = A.privateConfig) || void 0 === g ? void 0 : g.accessPointHosts, Q = null == A || null === (o = A.privateConfig) || void 0 === o ? void 0 : o.eventUploadHosts, c = null == A || null === (I = A.privateConfig) || void 0 === I ? void 0 : I.logUploadHosts, l = null == A || null === (i2 = A.privateConfig) || void 0 === i2 ? void 0 : i2.originDomains;
        return 0 !== (null == B ? void 0 : B.length) && (0 === (null !== (r = null == B ? void 0 : B.length) && void 0 !== r ? r : 0) || null != B && B.includes("MESSAGE") || null != B && B.includes("STREAM") || (s = " ServiceType is illegal.", E = true), 0 !== (null !== (n = null == B ? void 0 : B.length) && void 0 !== n ? n : 0) && 0 === (null !== (C = null == a ? void 0 : a.length) && void 0 !== C ? C : 0) && (E = true), (null != a && a.some((A2) => !validDomain(A2)) || null != l && l.some((A2) => !validDomain(A2)) || null != Q && Q.some((A2) => !validDomain(A2)) || null != c && c.some((A2) => !validDomain(A2))) && (E = true, s += " Hosts or domains is illegal."), E && throwInvalidPrivateConfig(OperationName.initRTM, s), true);
      }
      function validateKey(A, e, t) {
        switch (t) {
          case "channel":
            if (!validateChannelName(A)) {
              const { code: A2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_INVALID_CHANNEL_NAME);
              throw new RtmInvalidArgumentError(e, [t2], A2);
            }
            break;
          case "uid":
            if (!isValidId(A)) {
              const A2 = RTMErrorCode.RTM_ERROR_INVALID_USER_ID, { code: t2, reason: g } = getErrorInfoByCode(A2);
              throw new RtmInvalidArgumentError(e, [g], t2);
            }
            break;
          case "lock-name":
            if (!isValidId(A)) {
              const { code: A2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_LOCK_INVALID_NAME);
              throw new RtmInvalidArgumentError(e, [t2], A2);
            }
            break;
          case "metadata-lock":
            if (!isValidId(A)) {
              const { code: A2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_INVALID_LOCK_NAME);
              throw new RtmInvalidArgumentError(e, [t2], A2);
            }
        }
      }
      class ReadByteBuffer {
        constructor(A) {
          _defineProperty$1(this, "view", void 0), _defineProperty$1(this, "offset", void 0), this.view = new DataView(A), this.offset = 0;
        }
        getString() {
          const A = this.view.getUint16(this.offset, true);
          this.offset += 2;
          const e = new Uint8Array(this.view.buffer, this.offset, A);
          return this.offset += A, new TextDecoder().decode(e);
        }
        getUint32() {
          const A = this.view.getUint32(this.offset, true);
          return this.offset += 4, A;
        }
        getUint16() {
          const A = this.view.getUint16(this.offset, true);
          return this.offset += 2, A;
        }
        pack() {
          return this.view.buffer.slice(this.offset);
        }
      }
      function decodeBase64(A) {
        const e = atob(A), t = new Uint8Array(e.length);
        for (let A2 = 0; A2 < e.length; A2++)
          t[A2] = e.charCodeAt(A2);
        return t;
      }
      function fromStringWith006(A) {
        return A.slice(VERSION_LENGTH, APP_ID_LENGTH + VERSION_LENGTH);
      }
      function fromStringWith007(A) {
        const e = A.substring(VERSION_LENGTH), t = inflate$1(decodeBase64(e)), g = new ReadByteBuffer(t.buffer);
        g.getString();
        return g.getString();
      }
      const get007Version = () => "007", get006Version = () => "006";
      function validateToken(A, e, t, g) {
        if (e === A)
          return;
        function o() {
          const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_INCONSISTENT_APPID);
          throw new RtmInvalidArgumentError(t, [e2], A2);
        }
        function I() {
          const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_INVALID_TOKEN);
          throw new RtmInvalidArgumentError(t, [e2], A2);
        }
        const i2 = null == A ? void 0 : A.slice(0, 3);
        try {
          const t2 = i2 === get006Version() ? fromStringWith006(A) : i2 !== get007Version() || fromStringWith007(A);
          "string" == typeof t2 && t2 !== e && (isValidAppId(t2) || I(), g("appId from token is '".concat(t2, "', not match the appId of config.")), o()), t2 && t2 !== e && o();
        } catch (A2) {
          g(A2), I();
        }
      }
      function __awaiter(A, e, t, g) {
        return new (t || (t = Promise))(function(e2, o) {
          function I(A2) {
            try {
              r(g.next(A2));
            } catch (A3) {
              o(A3);
            }
          }
          function i2(A2) {
            try {
              r(g.throw(A2));
            } catch (A3) {
              o(A3);
            }
          }
          function r(A2) {
            var g2;
            A2.done ? e2(A2.value) : (g2 = A2.value, g2 instanceof t ? g2 : new t(function(A3) {
              A3(g2);
            })).then(I, i2);
          }
          r((g = g.apply(A, [])).next());
        });
      }
      function __generator(A, e) {
        var t, g, o, I, i2 = { label: 0, sent: function() {
          if (1 & o[0])
            throw o[1];
          return o[1];
        }, trys: [], ops: [] };
        return I = { next: r(0), throw: r(1), return: r(2) }, "function" == typeof Symbol && (I[Symbol.iterator] = function() {
          return this;
        }), I;
        function r(I2) {
          return function(r2) {
            return function(I3) {
              if (t)
                throw new TypeError("Generator is already executing.");
              for (; i2; )
                try {
                  if (t = 1, g && (o = 2 & I3[0] ? g.return : I3[0] ? g.throw || ((o = g.return) && o.call(g), 0) : g.next) && !(o = o.call(g, I3[1])).done)
                    return o;
                  switch (g = 0, o && (I3 = [2 & I3[0], o.value]), I3[0]) {
                    case 0:
                    case 1:
                      o = I3;
                      break;
                    case 4:
                      return i2.label++, { value: I3[1], done: false };
                    case 5:
                      i2.label++, g = I3[1], I3 = [0];
                      continue;
                    case 7:
                      I3 = i2.ops.pop(), i2.trys.pop();
                      continue;
                    default:
                      if (!(o = i2.trys, (o = o.length > 0 && o[o.length - 1]) || 6 !== I3[0] && 2 !== I3[0])) {
                        i2 = 0;
                        continue;
                      }
                      if (3 === I3[0] && (!o || I3[1] > o[0] && I3[1] < o[3])) {
                        i2.label = I3[1];
                        break;
                      }
                      if (6 === I3[0] && i2.label < o[1]) {
                        i2.label = o[1], o = I3;
                        break;
                      }
                      if (o && i2.label < o[2]) {
                        i2.label = o[2], i2.ops.push(I3);
                        break;
                      }
                      o[2] && i2.ops.pop(), i2.trys.pop();
                      continue;
                  }
                  I3 = e.call(A, i2);
                } catch (A2) {
                  I3 = [6, A2], g = 0;
                } finally {
                  t = o = 0;
                }
              if (5 & I3[0])
                throw I3[1];
              return { value: I3[0] ? I3[1] : void 0, done: true };
            }([I2, r2]);
          };
        }
      }
      function __read(A, e) {
        var t = "function" == typeof Symbol && A[Symbol.iterator];
        if (!t)
          return A;
        var g, o, I = t.call(A), i2 = [];
        try {
          for (; (void 0 === e || e-- > 0) && !(g = I.next()).done; )
            i2.push(g.value);
        } catch (A2) {
          o = { error: A2 };
        } finally {
          try {
            g && !g.done && (t = I.return) && t.call(I);
          } finally {
            if (o)
              throw o.error;
          }
        }
        return i2;
      }
      function __spreadArray(A, e, t) {
        if (2 === arguments.length)
          for (var g, o = 0, I = e.length; o < I; o++)
            !g && o in e || (g || (g = Array.prototype.slice.call(e, 0, o)), g[o] = e[o]);
        return A.concat(g || Array.prototype.slice.call(e));
      }
      var defaultErrorConfig = { withStackTrace: false }, createNeverThrowError = function(A, e, t) {
        return void 0 === t && (t = defaultErrorConfig), { data: e.isOk() ? { type: "Ok", value: e.value } : { type: "Err", value: e.error }, message: A, stack: t.withStackTrace ? new Error().stack : void 0 };
      }, ResultAsync = function() {
        function A(A2) {
          this._promise = A2;
        }
        return A.fromSafePromise = function(e) {
          return new A(e.then(function(A2) {
            return new Ok(A2);
          }));
        }, A.fromPromise = function(e, t) {
          return new A(e.then(function(A2) {
            return new Ok(A2);
          }).catch(function(A2) {
            return new Err(t(A2));
          }));
        }, A.combine = function(A2) {
          return combineResultAsyncList(A2);
        }, A.combineWithAllErrors = function(A2) {
          return combineResultAsyncListWithAllErrors(A2);
        }, A.prototype.map = function(e) {
          var t = this;
          return new A(this._promise.then(function(A2) {
            return __awaiter(t, void 0, void 0, function() {
              var t2;
              return __generator(this, function(g) {
                switch (g.label) {
                  case 0:
                    return A2.isErr() ? [2, new Err(A2.error)] : (t2 = Ok.bind, [4, e(A2.value)]);
                  case 1:
                    return [2, new (t2.apply(Ok, [void 0, g.sent()]))()];
                }
              });
            });
          }));
        }, A.prototype.mapErr = function(e) {
          var t = this;
          return new A(this._promise.then(function(A2) {
            return __awaiter(t, void 0, void 0, function() {
              var t2;
              return __generator(this, function(g) {
                switch (g.label) {
                  case 0:
                    return A2.isOk() ? [2, new Ok(A2.value)] : (t2 = Err.bind, [4, e(A2.error)]);
                  case 1:
                    return [2, new (t2.apply(Err, [void 0, g.sent()]))()];
                }
              });
            });
          }));
        }, A.prototype.andThen = function(e) {
          return new A(this._promise.then(function(t) {
            if (t.isErr())
              return new Err(t.error);
            var g = e(t.value);
            return g instanceof A ? g._promise : g;
          }));
        }, A.prototype.orElse = function(e) {
          var t = this;
          return new A(this._promise.then(function(A2) {
            return __awaiter(t, void 0, void 0, function() {
              return __generator(this, function(t2) {
                return A2.isErr() ? [2, e(A2.error)] : [2, new Ok(A2.value)];
              });
            });
          }));
        }, A.prototype.match = function(A2, e) {
          return this._promise.then(function(t) {
            return t.match(A2, e);
          });
        }, A.prototype.unwrapOr = function(A2) {
          return this._promise.then(function(e) {
            return e.unwrapOr(A2);
          });
        }, A.prototype.then = function(A2, e) {
          return this._promise.then(A2, e);
        }, A;
      }(), errAsync = function(A) {
        return new ResultAsync(Promise.resolve(new Err(A)));
      }, fromPromise = ResultAsync.fromPromise;
      ResultAsync.fromSafePromise;
      var appendValueToEndOfList = function(A) {
        return function(e) {
          return __spreadArray(__spreadArray([], __read(e), false), [A], false);
        };
      }, combineResultList = function(A) {
        return A.reduce(function(A2, e) {
          return A2.isOk() ? e.isErr() ? err(e.error) : A2.map(appendValueToEndOfList(e.value)) : A2;
        }, ok([]));
      }, combineResultAsyncList = function(A) {
        return ResultAsync.fromSafePromise(Promise.all(A)).andThen(combineResultList);
      }, combineResultListWithAllErrors = function(A) {
        return A.reduce(function(A2, e) {
          return e.isErr() ? A2.isErr() ? err(__spreadArray(__spreadArray([], __read(A2.error), false), [e.error], false)) : err([e.error]) : A2.isErr() ? A2 : ok(__spreadArray(__spreadArray([], __read(A2.value), false), [e.value], false));
        }, ok([]));
      }, combineResultAsyncListWithAllErrors = function(A) {
        return ResultAsync.fromSafePromise(Promise.all(A)).andThen(combineResultListWithAllErrors);
      }, Result;
      !function(A) {
        A.fromThrowable = function(A2, e) {
          return function() {
            for (var t = [], g = 0; g < arguments.length; g++)
              t[g] = arguments[g];
            try {
              var o = A2.apply(void 0, __spreadArray([], __read(t), false));
              return ok(o);
            } catch (A3) {
              return err(e ? e(A3) : A3);
            }
          };
        }, A.combine = function(A2) {
          return combineResultList(A2);
        }, A.combineWithAllErrors = function(A2) {
          return combineResultListWithAllErrors(A2);
        };
      }(Result || (Result = {}));
      var ok = function(A) {
        return new Ok(A);
      }, err = function(A) {
        return new Err(A);
      }, Ok = function() {
        function A(A2) {
          this.value = A2;
        }
        return A.prototype.isOk = function() {
          return true;
        }, A.prototype.isErr = function() {
          return !this.isOk();
        }, A.prototype.map = function(A2) {
          return ok(A2(this.value));
        }, A.prototype.mapErr = function(A2) {
          return ok(this.value);
        }, A.prototype.andThen = function(A2) {
          return A2(this.value);
        }, A.prototype.orElse = function(A2) {
          return ok(this.value);
        }, A.prototype.asyncAndThen = function(A2) {
          return A2(this.value);
        }, A.prototype.asyncMap = function(A2) {
          return ResultAsync.fromSafePromise(A2(this.value));
        }, A.prototype.unwrapOr = function(A2) {
          return this.value;
        }, A.prototype.match = function(A2, e) {
          return A2(this.value);
        }, A.prototype._unsafeUnwrap = function(A2) {
          return this.value;
        }, A.prototype._unsafeUnwrapErr = function(A2) {
          throw createNeverThrowError("Called `_unsafeUnwrapErr` on an Ok", this, A2);
        }, A;
      }(), Err = function() {
        function A(A2) {
          this.error = A2;
        }
        return A.prototype.isOk = function() {
          return false;
        }, A.prototype.isErr = function() {
          return !this.isOk();
        }, A.prototype.map = function(A2) {
          return err(this.error);
        }, A.prototype.mapErr = function(A2) {
          return err(A2(this.error));
        }, A.prototype.andThen = function(A2) {
          return err(this.error);
        }, A.prototype.orElse = function(A2) {
          return A2(this.error);
        }, A.prototype.asyncAndThen = function(A2) {
          return errAsync(this.error);
        }, A.prototype.asyncMap = function(A2) {
          return errAsync(this.error);
        }, A.prototype.unwrapOr = function(A2) {
          return A2;
        }, A.prototype.match = function(A2, e) {
          return e(this.error);
        }, A.prototype._unsafeUnwrap = function(A2) {
          throw createNeverThrowError("Called `_unsafeUnwrap` on an Err", this, A2);
        }, A.prototype._unsafeUnwrapErr = function(A2) {
          return this.error;
        }, A;
      }();
      Result.fromThrowable;
      let AgoraRTCErrorCode = function(A) {
        return A.UNEXPECTED_ERROR = "UNEXPECTED_ERROR", A.UNEXPECTED_RESPONSE = "UNEXPECTED_RESPONSE", A.TIMEOUT = "TIMEOUT", A.INVALID_PARAMS = "INVALID_PARAMS", A.NOT_READABLE = "NOT_READABLE", A.NOT_SUPPORTED = "NOT_SUPPORTED", A.INVALID_OPERATION = "INVALID_OPERATION", A.OPERATION_ABORTED = "OPERATION_ABORTED", A.WEB_SECURITY_RESTRICT = "WEB_SECURITY_RESTRICT", A.EXCHANGE_SDP_FAILED = "EXCHANGE_SDP_FAILED", A.ADD_CANDIDATE_FAILED = "ADD_CANDIDATE_FAILED", A.DATACHANNEL_FAILED = "DATACHANNEL_FAILED", A.NETWORK_ERROR = "NETWORK_ERROR", A.NETWORK_TIMEOUT = "NETWORK_TIMEOUT", A.NETWORK_RESPONSE_ERROR = "NETWORK_RESPONSE_ERROR", A.API_INVOKE_TIMEOUT = "API_INVOKE_TIMEOUT", A.ENUMERATE_DEVICES_FAILED = "ENUMERATE_DEVICES_FAILED", A.DEVICE_NOT_FOUND = "DEVICE_NOT_FOUND", A.ELECTRON_IS_NULL = "ELECTRON_IS_NULL", A.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR = "ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR", A.CHROME_PLUGIN_NO_RESPONSE = "CHROME_PLUGIN_NO_RESPONSE", A.CHROME_PLUGIN_NOT_INSTALL = "CHROME_PLUGIN_NOT_INSTALL", A.MEDIA_OPTION_INVALID = "MEDIA_OPTION_INVALID", A.PERMISSION_DENIED = "PERMISSION_DENIED", A.CONSTRAINT_NOT_SATISFIED = "CONSTRAINT_NOT_SATISFIED", A.TRACK_IS_DISABLED = "TRACK_IS_DISABLED", A.GET_VIDEO_ELEMENT_VISIBLE_ERROR = "GET_VIDEO_ELEMENT_VISIBLE_ERROR", A.SHARE_AUDIO_NOT_ALLOWED = "SHARE_AUDIO_NOT_ALLOWED", A.LOW_STREAM_ENCODING_ERROR = "LOW_STREAM_ENCODING_ERROR", A.SET_ENCODING_PARAMETER_ERROR = "SET_ENCODING_PARAMETER_ERROR", A.TRACK_STATE_UNREACHABLE = "TRACK_STATE_UNREACHABLE", A.INVALID_UINT_UID_FROM_STRING_UID = "INVALID_UINT_UID_FROM_STRING_UID", A.CAN_NOT_GET_PROXY_SERVER = "CAN_NOT_GET_PROXY_SERVER", A.CAN_NOT_GET_GATEWAY_SERVER = "CAN_NOT_GET_GATEWAY_SERVER", A.VOID_GATEWAY_ADDRESS = "VOID_GATEWAY_ADDRESS", A.UID_CONFLICT = "UID_CONFLICT", A.MULTI_UNILBS_RESPONSE_ERROR = "MULTI_UNILBS_RESPONSE_ERROR", A.UPDATE_TICKET_FAILED = "UPDATE_TICKET_FAILED", A.TOKEN_EXPIRE = "TOKEN_EXPIRE", A.INVALID_LOCAL_TRACK = "INVALID_LOCAL_TRACK", A.INVALID_TRACK = "INVALID_TRACK", A.SENDER_NOT_FOUND = "SENDER_NOT_FOUND", A.CREATE_OFFER_FAILED = "CREATE_OFFER_FAILED", A.SET_ANSWER_FAILED = "SET_ANSWER_FAILED", A.ICE_FAILED = "ICE_FAILED", A.PC_CLOSED = "PC_CLOSED", A.SENDER_REPLACE_FAILED = "SENDER_REPLACE_FAILED", A.GET_LOCAL_CAPABILITIES_FAILED = "GET_LOCAL_CAPABILITIES_FAILED", A.GET_LOCAL_CONNECTION_PARAMS_FAILED = "GET_LOCAL_CONNECTION_PARAMS_FAILED", A.SUBSCRIBE_FAILED = "SUBSCRIBE_FAILED", A.UNSUBSCRIBE_FAILED = "UNSUBSCRIBE_FAILED", A.GATEWAY_P2P_LOST = "GATEWAY_P2P_LOST", A.NO_ICE_CANDIDATE = "NO_ICE_CANDIDATE", A.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS = "CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS", A.EXIST_DISABLED_VIDEO_TRACK = "EXIST_DISABLED_VIDEO_TRACK", A.INVALID_REMOTE_USER = "INVALID_REMOTE_USER", A.REMOTE_USER_IS_NOT_PUBLISHED = "REMOTE_USER_IS_NOT_PUBLISHED", A.CUSTOM_REPORT_SEND_FAILED = "CUSTOM_REPORT_SEND_FAILED", A.CUSTOM_REPORT_FREQUENCY_TOO_HIGH = "CUSTOM_REPORT_FREQUENCY_TOO_HIGH", A.FETCH_AUDIO_FILE_FAILED = "FETCH_AUDIO_FILE_FAILED", A.READ_LOCAL_AUDIO_FILE_ERROR = "READ_LOCAL_AUDIO_FILE_ERROR", A.DECODE_AUDIO_FILE_FAILED = "DECODE_AUDIO_FILE_FAILED", A.WS_ABORT = "WS_ABORT", A.WS_DISCONNECT = "WS_DISCONNECT", A.WS_ERR = "WS_ERR", A.EXTERNAL_SIGNAL_ABORT = "EXTERNAL_SIGNAL_ABORT", A.LIVE_STREAMING_TASK_CONFLICT = "LIVE_STREAMING_TASK_CONFLICT", A.LIVE_STREAMING_INVALID_ARGUMENT = "LIVE_STREAMING_INVALID_ARGUMENT", A.LIVE_STREAMING_INTERNAL_SERVER_ERROR = "LIVE_STREAMING_INTERNAL_SERVER_ERROR", A.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED = "LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED", A.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED = "LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED", A.LIVE_STREAMING_CDN_ERROR = "LIVE_STREAMING_CDN_ERROR", A.LIVE_STREAMING_INVALID_RAW_STREAM = "LIVE_STREAMING_INVALID_RAW_STREAM", A.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT = "LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT", A.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE = "LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE", A.LIVE_STREAMING_WARN_FREQUENT_REQUEST = "LIVE_STREAMING_WARN_FREQUENT_REQUEST", A.WEBGL_INTERNAL_ERROR = "WEBGL_INTERNAL_ERROR", A.BEAUTY_PROCESSOR_INTERNAL_ERROR = "BEAUTY_PROCESSOR_INTERNAL_ERROR", A.CROSS_CHANNEL_WAIT_STATUS_ERROR = "CROSS_CHANNEL_WAIT_STATUS_ERROR", A.CROSS_CHANNEL_FAILED_JOIN_SRC = "CROSS_CHANNEL_FAILED_JOIN_SEC", A.CROSS_CHANNEL_FAILED_JOIN_DEST = "CROSS_CHANNEL_FAILED_JOIN_DEST", A.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST = "CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST", A.CROSS_CHANNEL_SERVER_ERROR_RESPONSE = "CROSS_CHANNEL_SERVER_ERROR_RESPONSE", A.METADATA_OUT_OF_RANGE = "METADATA_OUT_OF_RANGE", A.LOCAL_AEC_ERROR = "LOCAL_AEC_ERROR", A.INVALID_PLUGIN = "INVALID_PLUGIN", A.DISCONNECT_P2P = "DISCONNECT_P2P", A.CONVERTING_IMAGEDATA_TO_BLOB_FAILED = "CONVERTING_IMAGEDATA_TO_BLOB_FAILED", A.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED = "CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED", A.INIT_DATACHANNEL_TIMEOUT = "INIT_DATACHANNEL_TIMEOUT", A.CREATE_DATACHANNEL_ERROR = "CREATE_DATACHANNEL_ERROR", A.DATACHANNEL_CONNECTION_TIMEOUT = "DATACHANNEL_CONNECTION_TIMEOUT", A.PROHIBITED_OPERATION = "PROHIBITED_OPERATION", A.IMAGE_MODERATION_UPLOAD_FAILED = "IMAGE_MODERATION_UPLOAD_FAILED", A.P2P_MESSAGE_FAILED = "P2P_MESSAGE_FAILED", A;
      }({});
      var indexMinimal = {}, minimal$1 = {}, aspromise, hasRequiredAspromise;
      function requireAspromise() {
        if (hasRequiredAspromise)
          return aspromise;
        return hasRequiredAspromise = 1, aspromise = function(A, e) {
          var t = new Array(arguments.length - 1), g = 0, o = 2, I = true;
          for (; o < arguments.length; )
            t[g++] = arguments[o++];
          return new Promise(function(o2, i2) {
            t[g] = function(A2) {
              if (I)
                if (I = false, A2)
                  i2(A2);
                else {
                  for (var e2 = new Array(arguments.length - 1), t2 = 0; t2 < e2.length; )
                    e2[t2++] = arguments[t2];
                  o2.apply(null, e2);
                }
            };
            try {
              A.apply(e || null, t);
            } catch (A2) {
              I && (I = false, i2(A2));
            }
          });
        }, aspromise;
      }
      var base64$1 = {}, hasRequiredBase64, eventemitter, hasRequiredEventemitter, float, hasRequiredFloat, inquire_1, hasRequiredInquire;
      function requireBase64() {
        return hasRequiredBase64 || (hasRequiredBase64 = 1, function(A) {
          var e = A;
          e.length = function(A2) {
            var e2 = A2.length;
            if (!e2)
              return 0;
            for (var t2 = 0; --e2 % 4 > 1 && "=" === A2.charAt(e2); )
              ++t2;
            return Math.ceil(3 * A2.length) / 4 - t2;
          };
          for (var t = new Array(64), g = new Array(123), o = 0; o < 64; )
            g[t[o] = o < 26 ? o + 65 : o < 52 ? o + 71 : o < 62 ? o - 4 : o - 59 | 43] = o++;
          e.encode = function(A2, e2, g2) {
            for (var o2, I2 = null, i2 = [], r = 0, n = 0; e2 < g2; ) {
              var C = A2[e2++];
              switch (n) {
                case 0:
                  i2[r++] = t[C >> 2], o2 = (3 & C) << 4, n = 1;
                  break;
                case 1:
                  i2[r++] = t[o2 | C >> 4], o2 = (15 & C) << 2, n = 2;
                  break;
                case 2:
                  i2[r++] = t[o2 | C >> 6], i2[r++] = t[63 & C], n = 0;
              }
              r > 8191 && ((I2 || (I2 = [])).push(String.fromCharCode.apply(String, i2)), r = 0);
            }
            return n && (i2[r++] = t[o2], i2[r++] = 61, 1 === n && (i2[r++] = 61)), I2 ? (r && I2.push(String.fromCharCode.apply(String, i2.slice(0, r))), I2.join("")) : String.fromCharCode.apply(String, i2.slice(0, r));
          };
          var I = "invalid encoding";
          e.decode = function(A2, e2, t2) {
            for (var o2, i2 = t2, r = 0, n = 0; n < A2.length; ) {
              var C = A2.charCodeAt(n++);
              if (61 === C && r > 1)
                break;
              if (void 0 === (C = g[C]))
                throw Error(I);
              switch (r) {
                case 0:
                  o2 = C, r = 1;
                  break;
                case 1:
                  e2[t2++] = o2 << 2 | (48 & C) >> 4, o2 = C, r = 2;
                  break;
                case 2:
                  e2[t2++] = (15 & o2) << 4 | (60 & C) >> 2, o2 = C, r = 3;
                  break;
                case 3:
                  e2[t2++] = (3 & o2) << 6 | C, r = 0;
              }
            }
            if (1 === r)
              throw Error(I);
            return t2 - i2;
          }, e.test = function(A2) {
            return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(A2);
          };
        }(base64$1)), base64$1;
      }
      function requireEventemitter() {
        if (hasRequiredEventemitter)
          return eventemitter;
        function A() {
          this._listeners = {};
        }
        return hasRequiredEventemitter = 1, eventemitter = A, A.prototype.on = function(A2, e, t) {
          return (this._listeners[A2] || (this._listeners[A2] = [])).push({ fn: e, ctx: t || this }), this;
        }, A.prototype.off = function(A2, e) {
          if (void 0 === A2)
            this._listeners = {};
          else if (void 0 === e)
            this._listeners[A2] = [];
          else
            for (var t = this._listeners[A2], g = 0; g < t.length; )
              t[g].fn === e ? t.splice(g, 1) : ++g;
          return this;
        }, A.prototype.emit = function(A2) {
          var e = this._listeners[A2];
          if (e) {
            for (var t = [], g = 1; g < arguments.length; )
              t.push(arguments[g++]);
            for (g = 0; g < e.length; )
              e[g].fn.apply(e[g++].ctx, t);
          }
          return this;
        }, eventemitter;
      }
      function requireFloat() {
        if (hasRequiredFloat)
          return float;
        function A(A2) {
          return "undefined" != typeof Float32Array ? function() {
            var e2 = new Float32Array([-0]), t2 = new Uint8Array(e2.buffer), g2 = 128 === t2[3];
            function o2(A3, g3, o3) {
              e2[0] = A3, g3[o3] = t2[0], g3[o3 + 1] = t2[1], g3[o3 + 2] = t2[2], g3[o3 + 3] = t2[3];
            }
            function I(A3, g3, o3) {
              e2[0] = A3, g3[o3] = t2[3], g3[o3 + 1] = t2[2], g3[o3 + 2] = t2[1], g3[o3 + 3] = t2[0];
            }
            function i2(A3, g3) {
              return t2[0] = A3[g3], t2[1] = A3[g3 + 1], t2[2] = A3[g3 + 2], t2[3] = A3[g3 + 3], e2[0];
            }
            function r(A3, g3) {
              return t2[3] = A3[g3], t2[2] = A3[g3 + 1], t2[1] = A3[g3 + 2], t2[0] = A3[g3 + 3], e2[0];
            }
            A2.writeFloatLE = g2 ? o2 : I, A2.writeFloatBE = g2 ? I : o2, A2.readFloatLE = g2 ? i2 : r, A2.readFloatBE = g2 ? r : i2;
          }() : function() {
            function I(A3, e2, t2, g2) {
              var o2 = e2 < 0 ? 1 : 0;
              if (o2 && (e2 = -e2), 0 === e2)
                A3(1 / e2 > 0 ? 0 : 2147483648, t2, g2);
              else if (isNaN(e2))
                A3(2143289344, t2, g2);
              else if (e2 > 34028234663852886e22)
                A3((o2 << 31 | 2139095040) >>> 0, t2, g2);
              else if (e2 < 11754943508222875e-54)
                A3((o2 << 31 | Math.round(e2 / 1401298464324817e-60)) >>> 0, t2, g2);
              else {
                var I2 = Math.floor(Math.log(e2) / Math.LN2);
                A3((o2 << 31 | I2 + 127 << 23 | 8388607 & Math.round(e2 * Math.pow(2, -I2) * 8388608)) >>> 0, t2, g2);
              }
            }
            function i2(A3, e2, t2) {
              var g2 = A3(e2, t2), o2 = 2 * (g2 >> 31) + 1, I2 = g2 >>> 23 & 255, i3 = 8388607 & g2;
              return 255 === I2 ? i3 ? NaN : o2 * (1 / 0) : 0 === I2 ? 1401298464324817e-60 * o2 * i3 : o2 * Math.pow(2, I2 - 150) * (i3 + 8388608);
            }
            A2.writeFloatLE = I.bind(null, e), A2.writeFloatBE = I.bind(null, t), A2.readFloatLE = i2.bind(null, g), A2.readFloatBE = i2.bind(null, o);
          }(), "undefined" != typeof Float64Array ? function() {
            var e2 = new Float64Array([-0]), t2 = new Uint8Array(e2.buffer), g2 = 128 === t2[7];
            function o2(A3, g3, o3) {
              e2[0] = A3, g3[o3] = t2[0], g3[o3 + 1] = t2[1], g3[o3 + 2] = t2[2], g3[o3 + 3] = t2[3], g3[o3 + 4] = t2[4], g3[o3 + 5] = t2[5], g3[o3 + 6] = t2[6], g3[o3 + 7] = t2[7];
            }
            function I(A3, g3, o3) {
              e2[0] = A3, g3[o3] = t2[7], g3[o3 + 1] = t2[6], g3[o3 + 2] = t2[5], g3[o3 + 3] = t2[4], g3[o3 + 4] = t2[3], g3[o3 + 5] = t2[2], g3[o3 + 6] = t2[1], g3[o3 + 7] = t2[0];
            }
            function i2(A3, g3) {
              return t2[0] = A3[g3], t2[1] = A3[g3 + 1], t2[2] = A3[g3 + 2], t2[3] = A3[g3 + 3], t2[4] = A3[g3 + 4], t2[5] = A3[g3 + 5], t2[6] = A3[g3 + 6], t2[7] = A3[g3 + 7], e2[0];
            }
            function r(A3, g3) {
              return t2[7] = A3[g3], t2[6] = A3[g3 + 1], t2[5] = A3[g3 + 2], t2[4] = A3[g3 + 3], t2[3] = A3[g3 + 4], t2[2] = A3[g3 + 5], t2[1] = A3[g3 + 6], t2[0] = A3[g3 + 7], e2[0];
            }
            A2.writeDoubleLE = g2 ? o2 : I, A2.writeDoubleBE = g2 ? I : o2, A2.readDoubleLE = g2 ? i2 : r, A2.readDoubleBE = g2 ? r : i2;
          }() : function() {
            function I(A3, e2, t2, g2, o2, I2) {
              var i3 = g2 < 0 ? 1 : 0;
              if (i3 && (g2 = -g2), 0 === g2)
                A3(0, o2, I2 + e2), A3(1 / g2 > 0 ? 0 : 2147483648, o2, I2 + t2);
              else if (isNaN(g2))
                A3(0, o2, I2 + e2), A3(2146959360, o2, I2 + t2);
              else if (g2 > 17976931348623157e292)
                A3(0, o2, I2 + e2), A3((i3 << 31 | 2146435072) >>> 0, o2, I2 + t2);
              else {
                var r;
                if (g2 < 22250738585072014e-324)
                  A3((r = g2 / 5e-324) >>> 0, o2, I2 + e2), A3((i3 << 31 | r / 4294967296) >>> 0, o2, I2 + t2);
                else {
                  var n = Math.floor(Math.log(g2) / Math.LN2);
                  1024 === n && (n = 1023), A3(4503599627370496 * (r = g2 * Math.pow(2, -n)) >>> 0, o2, I2 + e2), A3((i3 << 31 | n + 1023 << 20 | 1048576 * r & 1048575) >>> 0, o2, I2 + t2);
                }
              }
            }
            function i2(A3, e2, t2, g2, o2) {
              var I2 = A3(g2, o2 + e2), i3 = A3(g2, o2 + t2), r = 2 * (i3 >> 31) + 1, n = i3 >>> 20 & 2047, C = 4294967296 * (1048575 & i3) + I2;
              return 2047 === n ? C ? NaN : r * (1 / 0) : 0 === n ? 5e-324 * r * C : r * Math.pow(2, n - 1075) * (C + 4503599627370496);
            }
            A2.writeDoubleLE = I.bind(null, e, 0, 4), A2.writeDoubleBE = I.bind(null, t, 4, 0), A2.readDoubleLE = i2.bind(null, g, 0, 4), A2.readDoubleBE = i2.bind(null, o, 4, 0);
          }(), A2;
        }
        function e(A2, e2, t2) {
          e2[t2] = 255 & A2, e2[t2 + 1] = A2 >>> 8 & 255, e2[t2 + 2] = A2 >>> 16 & 255, e2[t2 + 3] = A2 >>> 24;
        }
        function t(A2, e2, t2) {
          e2[t2] = A2 >>> 24, e2[t2 + 1] = A2 >>> 16 & 255, e2[t2 + 2] = A2 >>> 8 & 255, e2[t2 + 3] = 255 & A2;
        }
        function g(A2, e2) {
          return (A2[e2] | A2[e2 + 1] << 8 | A2[e2 + 2] << 16 | A2[e2 + 3] << 24) >>> 0;
        }
        function o(A2, e2) {
          return (A2[e2] << 24 | A2[e2 + 1] << 16 | A2[e2 + 2] << 8 | A2[e2 + 3]) >>> 0;
        }
        return hasRequiredFloat = 1, float = A(A);
      }
      function requireInquire() {
        if (hasRequiredInquire)
          return inquire_1;
        function inquire(moduleName) {
          try {
            var mod = eval("quire".replace(/^/, "re"))(moduleName);
            if (mod && (mod.length || Object.keys(mod).length))
              return mod;
          } catch (A) {
          }
          return null;
        }
        return hasRequiredInquire = 1, inquire_1 = inquire, inquire_1;
      }
      var utf8$2 = {}, hasRequiredUtf8, pool_1, hasRequiredPool, longbits, hasRequiredLongbits, hasRequiredMinimal;
      function requireUtf8() {
        return hasRequiredUtf8 || (hasRequiredUtf8 = 1, function(A) {
          var e = A;
          e.length = function(A2) {
            for (var e2 = 0, t = 0, g = 0; g < A2.length; ++g)
              (t = A2.charCodeAt(g)) < 128 ? e2 += 1 : t < 2048 ? e2 += 2 : 55296 == (64512 & t) && 56320 == (64512 & A2.charCodeAt(g + 1)) ? (++g, e2 += 4) : e2 += 3;
            return e2;
          }, e.read = function(A2, e2, t) {
            if (t - e2 < 1)
              return "";
            for (var g, o = null, I = [], i2 = 0; e2 < t; )
              (g = A2[e2++]) < 128 ? I[i2++] = g : g > 191 && g < 224 ? I[i2++] = (31 & g) << 6 | 63 & A2[e2++] : g > 239 && g < 365 ? (g = ((7 & g) << 18 | (63 & A2[e2++]) << 12 | (63 & A2[e2++]) << 6 | 63 & A2[e2++]) - 65536, I[i2++] = 55296 + (g >> 10), I[i2++] = 56320 + (1023 & g)) : I[i2++] = (15 & g) << 12 | (63 & A2[e2++]) << 6 | 63 & A2[e2++], i2 > 8191 && ((o || (o = [])).push(String.fromCharCode.apply(String, I)), i2 = 0);
            return o ? (i2 && o.push(String.fromCharCode.apply(String, I.slice(0, i2))), o.join("")) : String.fromCharCode.apply(String, I.slice(0, i2));
          }, e.write = function(A2, e2, t) {
            for (var g, o, I = t, i2 = 0; i2 < A2.length; ++i2)
              (g = A2.charCodeAt(i2)) < 128 ? e2[t++] = g : g < 2048 ? (e2[t++] = g >> 6 | 192, e2[t++] = 63 & g | 128) : 55296 == (64512 & g) && 56320 == (64512 & (o = A2.charCodeAt(i2 + 1))) ? (g = 65536 + ((1023 & g) << 10) + (1023 & o), ++i2, e2[t++] = g >> 18 | 240, e2[t++] = g >> 12 & 63 | 128, e2[t++] = g >> 6 & 63 | 128, e2[t++] = 63 & g | 128) : (e2[t++] = g >> 12 | 224, e2[t++] = g >> 6 & 63 | 128, e2[t++] = 63 & g | 128);
            return t - I;
          };
        }(utf8$2)), utf8$2;
      }
      function requirePool() {
        if (hasRequiredPool)
          return pool_1;
        return hasRequiredPool = 1, pool_1 = function(A, e, t) {
          var g = t || 8192, o = g >>> 1, I = null, i2 = g;
          return function(t2) {
            if (t2 < 1 || t2 > o)
              return A(t2);
            i2 + t2 > g && (I = A(g), i2 = 0);
            var r = e.call(I, i2, i2 += t2);
            return 7 & i2 && (i2 = 1 + (7 | i2)), r;
          };
        };
      }
      function requireLongbits() {
        if (hasRequiredLongbits)
          return longbits;
        hasRequiredLongbits = 1, longbits = e;
        var A = requireMinimal();
        function e(A2, e2) {
          this.lo = A2 >>> 0, this.hi = e2 >>> 0;
        }
        var t = e.zero = new e(0, 0);
        t.toNumber = function() {
          return 0;
        }, t.zzEncode = t.zzDecode = function() {
          return this;
        }, t.length = function() {
          return 1;
        };
        var g = e.zeroHash = "\0\0\0\0\0\0\0\0";
        e.fromNumber = function(A2) {
          if (0 === A2)
            return t;
          var g2 = A2 < 0;
          g2 && (A2 = -A2);
          var o2 = A2 >>> 0, I = (A2 - o2) / 4294967296 >>> 0;
          return g2 && (I = ~I >>> 0, o2 = ~o2 >>> 0, ++o2 > 4294967295 && (o2 = 0, ++I > 4294967295 && (I = 0))), new e(o2, I);
        }, e.from = function(g2) {
          if ("number" == typeof g2)
            return e.fromNumber(g2);
          if (A.isString(g2)) {
            if (!A.Long)
              return e.fromNumber(parseInt(g2, 10));
            g2 = A.Long.fromString(g2);
          }
          return g2.low || g2.high ? new e(g2.low >>> 0, g2.high >>> 0) : t;
        }, e.prototype.toNumber = function(A2) {
          if (!A2 && this.hi >>> 31) {
            var e2 = 1 + ~this.lo >>> 0, t2 = ~this.hi >>> 0;
            return e2 || (t2 = t2 + 1 >>> 0), -(e2 + 4294967296 * t2);
          }
          return this.lo + 4294967296 * this.hi;
        }, e.prototype.toLong = function(e2) {
          return A.Long ? new A.Long(0 | this.lo, 0 | this.hi, Boolean(e2)) : { low: 0 | this.lo, high: 0 | this.hi, unsigned: Boolean(e2) };
        };
        var o = String.prototype.charCodeAt;
        return e.fromHash = function(A2) {
          return A2 === g ? t : new e((o.call(A2, 0) | o.call(A2, 1) << 8 | o.call(A2, 2) << 16 | o.call(A2, 3) << 24) >>> 0, (o.call(A2, 4) | o.call(A2, 5) << 8 | o.call(A2, 6) << 16 | o.call(A2, 7) << 24) >>> 0);
        }, e.prototype.toHash = function() {
          return String.fromCharCode(255 & this.lo, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, 255 & this.hi, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
        }, e.prototype.zzEncode = function() {
          var A2 = this.hi >> 31;
          return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ A2) >>> 0, this.lo = (this.lo << 1 ^ A2) >>> 0, this;
        }, e.prototype.zzDecode = function() {
          var A2 = -(1 & this.lo);
          return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ A2) >>> 0, this.hi = (this.hi >>> 1 ^ A2) >>> 0, this;
        }, e.prototype.length = function() {
          var A2 = this.lo, e2 = (this.lo >>> 28 | this.hi << 4) >>> 0, t2 = this.hi >>> 24;
          return 0 === t2 ? 0 === e2 ? A2 < 16384 ? A2 < 128 ? 1 : 2 : A2 < 2097152 ? 3 : 4 : e2 < 16384 ? e2 < 128 ? 5 : 6 : e2 < 2097152 ? 7 : 8 : t2 < 128 ? 9 : 10;
        }, longbits;
      }
      function requireMinimal() {
        return hasRequiredMinimal || (hasRequiredMinimal = 1, function(A) {
          var e = A;
          function t(A2, e2, t2) {
            for (var g2 = Object.keys(e2), o = 0; o < g2.length; ++o)
              void 0 !== A2[g2[o]] && t2 || (A2[g2[o]] = e2[g2[o]]);
            return A2;
          }
          function g(A2) {
            function e2(A3, g2) {
              if (!(this instanceof e2))
                return new e2(A3, g2);
              Object.defineProperty(this, "message", { get: function() {
                return A3;
              } }), Error.captureStackTrace ? Error.captureStackTrace(this, e2) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), g2 && t(this, g2);
            }
            return e2.prototype = Object.create(Error.prototype, { constructor: { value: e2, writable: true, enumerable: false, configurable: true }, name: { get: function() {
              return A2;
            }, set: void 0, enumerable: false, configurable: true }, toString: { value: function() {
              return this.name + ": " + this.message;
            }, writable: true, enumerable: false, configurable: true } }), e2;
          }
          e.asPromise = requireAspromise(), e.base64 = requireBase64(), e.EventEmitter = requireEventemitter(), e.float = requireFloat(), e.inquire = requireInquire(), e.utf8 = requireUtf8(), e.pool = requirePool(), e.LongBits = requireLongbits(), e.isNode = Boolean(void 0 !== commonjsGlobal && commonjsGlobal && commonjsGlobal.process && commonjsGlobal.process.versions && commonjsGlobal.process.versions.node), e.global = e.isNode && commonjsGlobal || "undefined" != typeof window && window || "undefined" != typeof self && self || commonjsGlobal, e.emptyArray = Object.freeze ? Object.freeze([]) : [], e.emptyObject = Object.freeze ? Object.freeze({}) : {}, e.isInteger = Number.isInteger || function(A2) {
            return "number" == typeof A2 && isFinite(A2) && Math.floor(A2) === A2;
          }, e.isString = function(A2) {
            return "string" == typeof A2 || A2 instanceof String;
          }, e.isObject = function(A2) {
            return A2 && "object" == typeof A2;
          }, e.isset = e.isSet = function(A2, e2) {
            var t2 = A2[e2];
            return !(null == t2 || !A2.hasOwnProperty(e2)) && ("object" != typeof t2 || (Array.isArray(t2) ? t2.length : Object.keys(t2).length) > 0);
          }, e.Buffer = function() {
            try {
              var A2 = e.inquire("buffer").Buffer;
              return A2.prototype.utf8Write ? A2 : null;
            } catch (A3) {
              return null;
            }
          }(), e._Buffer_from = null, e._Buffer_allocUnsafe = null, e.newBuffer = function(A2) {
            return "number" == typeof A2 ? e.Buffer ? e._Buffer_allocUnsafe(A2) : new e.Array(A2) : e.Buffer ? e._Buffer_from(A2) : "undefined" == typeof Uint8Array ? A2 : new Uint8Array(A2);
          }, e.Array = "undefined" != typeof Uint8Array ? Uint8Array : Array, e.Long = e.global.dcodeIO && e.global.dcodeIO.Long || e.global.Long || e.inquire("long"), e.key2Re = /^true|false|0|1$/, e.key32Re = /^-?(?:0|[1-9][0-9]*)$/, e.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, e.longToHash = function(A2) {
            return A2 ? e.LongBits.from(A2).toHash() : e.LongBits.zeroHash;
          }, e.longFromHash = function(A2, t2) {
            var g2 = e.LongBits.fromHash(A2);
            return e.Long ? e.Long.fromBits(g2.lo, g2.hi, t2) : g2.toNumber(Boolean(t2));
          }, e.merge = t, e.lcFirst = function(A2) {
            return A2.charAt(0).toLowerCase() + A2.substring(1);
          }, e.newError = g, e.ProtocolError = g("ProtocolError"), e.oneOfGetter = function(A2) {
            for (var e2 = {}, t2 = 0; t2 < A2.length; ++t2)
              e2[A2[t2]] = 1;
            return function() {
              for (var A3 = Object.keys(this), t3 = A3.length - 1; t3 > -1; --t3)
                if (1 === e2[A3[t3]] && void 0 !== this[A3[t3]] && null !== this[A3[t3]])
                  return A3[t3];
            };
          }, e.oneOfSetter = function(A2) {
            return function(e2) {
              for (var t2 = 0; t2 < A2.length; ++t2)
                A2[t2] !== e2 && delete this[A2[t2]];
            };
          }, e.toJSONOptions = { longs: String, enums: String, bytes: String, json: true }, e._configure = function() {
            var A2 = e.Buffer;
            A2 ? (e._Buffer_from = A2.from !== Uint8Array.from && A2.from || function(e2, t2) {
              return new A2(e2, t2);
            }, e._Buffer_allocUnsafe = A2.allocUnsafe || function(e2) {
              return new A2(e2);
            }) : e._Buffer_from = e._Buffer_allocUnsafe = null;
          };
        }(minimal$1)), minimal$1;
      }
      var writer = Writer$1, util$4 = requireMinimal(), BufferWriter$1, LongBits$1 = util$4.LongBits, base64 = util$4.base64, utf8$1 = util$4.utf8;
      function Op(A, e, t) {
        this.fn = A, this.len = e, this.next = void 0, this.val = t;
      }
      function noop() {
      }
      function State(A) {
        this.head = A.head, this.tail = A.tail, this.len = A.len, this.next = A.states;
      }
      function Writer$1() {
        this.len = 0, this.head = new Op(noop, 0, 0), this.tail = this.head, this.states = null;
      }
      var create$1 = function() {
        return util$4.Buffer ? function() {
          return (Writer$1.create = function() {
            return new BufferWriter$1();
          })();
        } : function() {
          return new Writer$1();
        };
      };
      function writeByte(A, e, t) {
        e[t] = 255 & A;
      }
      function writeVarint32(A, e, t) {
        for (; A > 127; )
          e[t++] = 127 & A | 128, A >>>= 7;
        e[t] = A;
      }
      function VarintOp(A, e) {
        this.len = A, this.next = void 0, this.val = e;
      }
      function writeVarint64(A, e, t) {
        for (; A.hi; )
          e[t++] = 127 & A.lo | 128, A.lo = (A.lo >>> 7 | A.hi << 25) >>> 0, A.hi >>>= 7;
        for (; A.lo > 127; )
          e[t++] = 127 & A.lo | 128, A.lo = A.lo >>> 7;
        e[t++] = A.lo;
      }
      function writeFixed32(A, e, t) {
        e[t] = 255 & A, e[t + 1] = A >>> 8 & 255, e[t + 2] = A >>> 16 & 255, e[t + 3] = A >>> 24;
      }
      Writer$1.create = create$1(), Writer$1.alloc = function(A) {
        return new util$4.Array(A);
      }, util$4.Array !== Array && (Writer$1.alloc = util$4.pool(Writer$1.alloc, util$4.Array.prototype.subarray)), Writer$1.prototype._push = function(A, e, t) {
        return this.tail = this.tail.next = new Op(A, e, t), this.len += e, this;
      }, VarintOp.prototype = Object.create(Op.prototype), VarintOp.prototype.fn = writeVarint32, Writer$1.prototype.uint32 = function(A) {
        return this.len += (this.tail = this.tail.next = new VarintOp((A >>>= 0) < 128 ? 1 : A < 16384 ? 2 : A < 2097152 ? 3 : A < 268435456 ? 4 : 5, A)).len, this;
      }, Writer$1.prototype.int32 = function(A) {
        return A < 0 ? this._push(writeVarint64, 10, LongBits$1.fromNumber(A)) : this.uint32(A);
      }, Writer$1.prototype.sint32 = function(A) {
        return this.uint32((A << 1 ^ A >> 31) >>> 0);
      }, Writer$1.prototype.uint64 = function(A) {
        var e = LongBits$1.from(A);
        return this._push(writeVarint64, e.length(), e);
      }, Writer$1.prototype.int64 = Writer$1.prototype.uint64, Writer$1.prototype.sint64 = function(A) {
        var e = LongBits$1.from(A).zzEncode();
        return this._push(writeVarint64, e.length(), e);
      }, Writer$1.prototype.bool = function(A) {
        return this._push(writeByte, 1, A ? 1 : 0);
      }, Writer$1.prototype.fixed32 = function(A) {
        return this._push(writeFixed32, 4, A >>> 0);
      }, Writer$1.prototype.sfixed32 = Writer$1.prototype.fixed32, Writer$1.prototype.fixed64 = function(A) {
        var e = LongBits$1.from(A);
        return this._push(writeFixed32, 4, e.lo)._push(writeFixed32, 4, e.hi);
      }, Writer$1.prototype.sfixed64 = Writer$1.prototype.fixed64, Writer$1.prototype.float = function(A) {
        return this._push(util$4.float.writeFloatLE, 4, A);
      }, Writer$1.prototype.double = function(A) {
        return this._push(util$4.float.writeDoubleLE, 8, A);
      };
      var writeBytes = util$4.Array.prototype.set ? function(A, e, t) {
        e.set(A, t);
      } : function(A, e, t) {
        for (var g = 0; g < A.length; ++g)
          e[t + g] = A[g];
      };
      Writer$1.prototype.bytes = function(A) {
        var e = A.length >>> 0;
        if (!e)
          return this._push(writeByte, 1, 0);
        if (util$4.isString(A)) {
          var t = Writer$1.alloc(e = base64.length(A));
          base64.decode(A, t, 0), A = t;
        }
        return this.uint32(e)._push(writeBytes, e, A);
      }, Writer$1.prototype.string = function(A) {
        var e = utf8$1.length(A);
        return e ? this.uint32(e)._push(utf8$1.write, e, A) : this._push(writeByte, 1, 0);
      }, Writer$1.prototype.fork = function() {
        return this.states = new State(this), this.head = this.tail = new Op(noop, 0, 0), this.len = 0, this;
      }, Writer$1.prototype.reset = function() {
        return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new Op(noop, 0, 0), this.len = 0), this;
      }, Writer$1.prototype.ldelim = function() {
        var A = this.head, e = this.tail, t = this.len;
        return this.reset().uint32(t), t && (this.tail.next = A.next, this.tail = e, this.len += t), this;
      }, Writer$1.prototype.finish = function() {
        for (var A = this.head.next, e = this.constructor.alloc(this.len), t = 0; A; )
          A.fn(A.val, e, t), t += A.len, A = A.next;
        return e;
      }, Writer$1._configure = function(A) {
        BufferWriter$1 = A, Writer$1.create = create$1(), BufferWriter$1._configure();
      };
      var writer_buffer = BufferWriter, Writer = writer;
      (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
      var util$3 = requireMinimal();
      function BufferWriter() {
        Writer.call(this);
      }
      function writeStringBuffer(A, e, t) {
        A.length < 40 ? util$3.utf8.write(A, e, t) : e.utf8Write ? e.utf8Write(A, t) : e.write(A, t);
      }
      BufferWriter._configure = function() {
        BufferWriter.alloc = util$3._Buffer_allocUnsafe, BufferWriter.writeBytesBuffer = util$3.Buffer && util$3.Buffer.prototype instanceof Uint8Array && "set" === util$3.Buffer.prototype.set.name ? function(A, e, t) {
          e.set(A, t);
        } : function(A, e, t) {
          if (A.copy)
            A.copy(e, t, 0, A.length);
          else
            for (var g = 0; g < A.length; )
              e[t++] = A[g++];
        };
      }, BufferWriter.prototype.bytes = function(A) {
        util$3.isString(A) && (A = util$3._Buffer_from(A, "base64"));
        var e = A.length >>> 0;
        return this.uint32(e), e && this._push(BufferWriter.writeBytesBuffer, e, A), this;
      }, BufferWriter.prototype.string = function(A) {
        var e = util$3.Buffer.byteLength(A);
        return this.uint32(e), e && this._push(writeStringBuffer, e, A), this;
      }, BufferWriter._configure();
      var reader = Reader$1, util$2 = requireMinimal(), BufferReader$1, LongBits = util$2.LongBits, utf8 = util$2.utf8;
      function indexOutOfRange(A, e) {
        return RangeError("index out of range: " + A.pos + " + " + (e || 1) + " > " + A.len);
      }
      function Reader$1(A) {
        this.buf = A, this.pos = 0, this.len = A.length;
      }
      var create_array = "undefined" != typeof Uint8Array ? function(A) {
        if (A instanceof Uint8Array || Array.isArray(A))
          return new Reader$1(A);
        throw Error("illegal buffer");
      } : function(A) {
        if (Array.isArray(A))
          return new Reader$1(A);
        throw Error("illegal buffer");
      }, create = function() {
        return util$2.Buffer ? function(A) {
          return (Reader$1.create = function(A2) {
            return util$2.Buffer.isBuffer(A2) ? new BufferReader$1(A2) : create_array(A2);
          })(A);
        } : create_array;
      }, value;
      function readLongVarint() {
        var A = new LongBits(0, 0), e = 0;
        if (!(this.len - this.pos > 4)) {
          for (; e < 3; ++e) {
            if (this.pos >= this.len)
              throw indexOutOfRange(this);
            if (A.lo = (A.lo | (127 & this.buf[this.pos]) << 7 * e) >>> 0, this.buf[this.pos++] < 128)
              return A;
          }
          return A.lo = (A.lo | (127 & this.buf[this.pos++]) << 7 * e) >>> 0, A;
        }
        for (; e < 4; ++e)
          if (A.lo = (A.lo | (127 & this.buf[this.pos]) << 7 * e) >>> 0, this.buf[this.pos++] < 128)
            return A;
        if (A.lo = (A.lo | (127 & this.buf[this.pos]) << 28) >>> 0, A.hi = (A.hi | (127 & this.buf[this.pos]) >> 4) >>> 0, this.buf[this.pos++] < 128)
          return A;
        if (e = 0, this.len - this.pos > 4) {
          for (; e < 5; ++e)
            if (A.hi = (A.hi | (127 & this.buf[this.pos]) << 7 * e + 3) >>> 0, this.buf[this.pos++] < 128)
              return A;
        } else
          for (; e < 5; ++e) {
            if (this.pos >= this.len)
              throw indexOutOfRange(this);
            if (A.hi = (A.hi | (127 & this.buf[this.pos]) << 7 * e + 3) >>> 0, this.buf[this.pos++] < 128)
              return A;
          }
        throw Error("invalid varint encoding");
      }
      function readFixed32_end(A, e) {
        return (A[e - 4] | A[e - 3] << 8 | A[e - 2] << 16 | A[e - 1] << 24) >>> 0;
      }
      function readFixed64() {
        if (this.pos + 8 > this.len)
          throw indexOutOfRange(this, 8);
        return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
      }
      Reader$1.create = create(), Reader$1.prototype._slice = util$2.Array.prototype.subarray || util$2.Array.prototype.slice, Reader$1.prototype.uint32 = (value = 4294967295, function() {
        if (value = (127 & this.buf[this.pos]) >>> 0, this.buf[this.pos++] < 128)
          return value;
        if (value = (value | (127 & this.buf[this.pos]) << 7) >>> 0, this.buf[this.pos++] < 128)
          return value;
        if (value = (value | (127 & this.buf[this.pos]) << 14) >>> 0, this.buf[this.pos++] < 128)
          return value;
        if (value = (value | (127 & this.buf[this.pos]) << 21) >>> 0, this.buf[this.pos++] < 128)
          return value;
        if (value = (value | (15 & this.buf[this.pos]) << 28) >>> 0, this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len)
          throw this.pos = this.len, indexOutOfRange(this, 10);
        return value;
      }), Reader$1.prototype.int32 = function() {
        return 0 | this.uint32();
      }, Reader$1.prototype.sint32 = function() {
        var A = this.uint32();
        return A >>> 1 ^ -(1 & A);
      }, Reader$1.prototype.bool = function() {
        return 0 !== this.uint32();
      }, Reader$1.prototype.fixed32 = function() {
        if (this.pos + 4 > this.len)
          throw indexOutOfRange(this, 4);
        return readFixed32_end(this.buf, this.pos += 4);
      }, Reader$1.prototype.sfixed32 = function() {
        if (this.pos + 4 > this.len)
          throw indexOutOfRange(this, 4);
        return 0 | readFixed32_end(this.buf, this.pos += 4);
      }, Reader$1.prototype.float = function() {
        if (this.pos + 4 > this.len)
          throw indexOutOfRange(this, 4);
        var A = util$2.float.readFloatLE(this.buf, this.pos);
        return this.pos += 4, A;
      }, Reader$1.prototype.double = function() {
        if (this.pos + 8 > this.len)
          throw indexOutOfRange(this, 4);
        var A = util$2.float.readDoubleLE(this.buf, this.pos);
        return this.pos += 8, A;
      }, Reader$1.prototype.bytes = function() {
        var A = this.uint32(), e = this.pos, t = this.pos + A;
        if (t > this.len)
          throw indexOutOfRange(this, A);
        if (this.pos += A, Array.isArray(this.buf))
          return this.buf.slice(e, t);
        if (e === t) {
          var g = util$2.Buffer;
          return g ? g.alloc(0) : new this.buf.constructor(0);
        }
        return this._slice.call(this.buf, e, t);
      }, Reader$1.prototype.string = function() {
        var A = this.bytes();
        return utf8.read(A, 0, A.length);
      }, Reader$1.prototype.skip = function(A) {
        if ("number" == typeof A) {
          if (this.pos + A > this.len)
            throw indexOutOfRange(this, A);
          this.pos += A;
        } else
          do {
            if (this.pos >= this.len)
              throw indexOutOfRange(this);
          } while (128 & this.buf[this.pos++]);
        return this;
      }, Reader$1.prototype.skipType = function(A) {
        switch (A) {
          case 0:
            this.skip();
            break;
          case 1:
            this.skip(8);
            break;
          case 2:
            this.skip(this.uint32());
            break;
          case 3:
            for (; 4 != (A = 7 & this.uint32()); )
              this.skipType(A);
            break;
          case 5:
            this.skip(4);
            break;
          default:
            throw Error("invalid wire type " + A + " at offset " + this.pos);
        }
        return this;
      }, Reader$1._configure = function(A) {
        BufferReader$1 = A, Reader$1.create = create(), BufferReader$1._configure();
        var e = util$2.Long ? "toLong" : "toNumber";
        util$2.merge(Reader$1.prototype, { int64: function() {
          return readLongVarint.call(this)[e](false);
        }, uint64: function() {
          return readLongVarint.call(this)[e](true);
        }, sint64: function() {
          return readLongVarint.call(this).zzDecode()[e](false);
        }, fixed64: function() {
          return readFixed64.call(this)[e](true);
        }, sfixed64: function() {
          return readFixed64.call(this)[e](false);
        } });
      };
      var reader_buffer = BufferReader, Reader = reader;
      (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
      var util$1 = requireMinimal();
      function BufferReader(A) {
        Reader.call(this, A);
      }
      BufferReader._configure = function() {
        util$1.Buffer && (BufferReader.prototype._slice = util$1.Buffer.prototype.slice);
      }, BufferReader.prototype.string = function() {
        var A = this.uint32();
        return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + A, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + A, this.len));
      }, BufferReader._configure();
      var rpc = {}, service = Service, util = requireMinimal();
      function Service(A, e, t) {
        if ("function" != typeof A)
          throw TypeError("rpcImpl must be a function");
        util.EventEmitter.call(this), this.rpcImpl = A, this.requestDelimited = Boolean(e), this.responseDelimited = Boolean(t);
      }
      (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service, Service.prototype.rpcCall = function A(e, t, g, o, I) {
        if (!o)
          throw TypeError("request must be specified");
        var i2 = this;
        if (!I)
          return util.asPromise(A, i2, e, t, g, o);
        if (i2.rpcImpl)
          try {
            return i2.rpcImpl(e, t[i2.requestDelimited ? "encodeDelimited" : "encode"](o).finish(), function(A2, t2) {
              if (A2)
                return i2.emit("error", A2, e), I(A2);
              if (null !== t2) {
                if (!(t2 instanceof g))
                  try {
                    t2 = g[i2.responseDelimited ? "decodeDelimited" : "decode"](t2);
                  } catch (A3) {
                    return i2.emit("error", A3, e), I(A3);
                  }
                return i2.emit("data", t2, e), I(null, t2);
              }
              i2.end(true);
            });
          } catch (A2) {
            return i2.emit("error", A2, e), void setTimeout(function() {
              I(A2);
            }, 0);
          }
        else
          setTimeout(function() {
            I(Error("already ended"));
          }, 0);
      }, Service.prototype.end = function(A) {
        return this.rpcImpl && (A || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;
      }, function(A) {
        A.Service = service;
      }(rpc);
      var roots = {};
      !function(A) {
        var e = A;
        function t() {
          e.util._configure(), e.Writer._configure(e.BufferWriter), e.Reader._configure(e.BufferReader);
        }
        e.build = "minimal", e.Writer = writer, e.BufferWriter = writer_buffer, e.Reader = reader, e.BufferReader = reader_buffer, e.util = requireMinimal(), e.rpc = rpc, e.roots = roots, e.configure = t, t();
      }(indexMinimal);
      const Long = umdExports, minimal = indexMinimal;
      minimal.util.Long = Long, minimal.configure();
      var minimal_1 = minimal;
      const $Reader$1 = minimal_1.Reader, $Writer$2 = minimal_1.Writer, $util$2 = minimal_1.util, $root$2 = minimal_1.roots.default || (minimal_1.roots.default = {}), TopicMetadata = $root$2.TopicMetadata = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.topic = "", A.prototype.metadata = "", A.encode = function(A2, e) {
          return e || (e = $Writer$2.create()), null != A2.topic && Object.hasOwnProperty.call(A2, "topic") && e.uint32(10).string(A2.topic), null != A2.metadata && Object.hasOwnProperty.call(A2, "metadata") && e.uint32(18).string(A2.metadata), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader$1 || (A2 = $Reader$1.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$2.TopicMetadata();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.topic = A2.string();
                break;
              case 2:
                o.metadata = A2.string();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/TopicMetadata";
        }, A;
      })(), StreamMessageProtocol = $root$2.StreamMessageProtocol = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.messageType = 0, A.prototype.payload = $util$2.newBuffer([]), A.prototype.payloadLength = 0, A.prototype.sequence = $util$2.Long ? $util$2.Long.fromBits(0, 0, false) : 0, A.prototype.sendTs = $util$2.Long ? $util$2.Long.fromBits(0, 0, false) : 0, A.prototype.encrypted = false, A.prototype.customType = "", A.encode = function(A2, e) {
          return e || (e = $Writer$2.create()), null != A2.messageType && Object.hasOwnProperty.call(A2, "messageType") && e.uint32(8).int32(A2.messageType), null != A2.payload && Object.hasOwnProperty.call(A2, "payload") && e.uint32(18).bytes(A2.payload), null != A2.payloadLength && Object.hasOwnProperty.call(A2, "payloadLength") && e.uint32(24).int32(A2.payloadLength), null != A2.sequence && Object.hasOwnProperty.call(A2, "sequence") && e.uint32(32).int64(A2.sequence), null != A2.sendTs && Object.hasOwnProperty.call(A2, "sendTs") && e.uint32(40).int64(A2.sendTs), null != A2.encrypted && Object.hasOwnProperty.call(A2, "encrypted") && e.uint32(48).bool(A2.encrypted), null != A2.customType && Object.hasOwnProperty.call(A2, "customType") && e.uint32(58).string(A2.customType), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader$1 || (A2 = $Reader$1.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$2.StreamMessageProtocol();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.messageType = A2.int32();
                break;
              case 2:
                o.payload = A2.bytes();
                break;
              case 3:
                o.payloadLength = A2.int32();
                break;
              case 4:
                o.sequence = A2.int64();
                break;
              case 5:
                o.sendTs = A2.int64();
                break;
              case 6:
                o.encrypted = A2.bool();
                break;
              case 7:
                o.customType = A2.string();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/StreamMessageProtocol";
        }, A;
      })();
      let RTMStreamChannelStatusCode;
      !function(A) {
        let e = function(A2) {
          return A2[A2.NO_ERROR = 0] = "NO_ERROR", A2[A2.PARTIALLY_SUCCESSFUL = 1] = "PARTIALLY_SUCCESSFUL", A2[A2.ALL_FAILED = 2] = "ALL_FAILED", A2[A2.UNKNOWN_ERROR = 3] = "UNKNOWN_ERROR", A2[A2.INVALID_PARAMS = 4] = "INVALID_PARAMS", A2[A2.REMOTE_USER_IS_NOT_PUBLISHED = 5] = "REMOTE_USER_IS_NOT_PUBLISHED", A2[A2.INVALID_REMOTE_USER = 6] = "INVALID_REMOTE_USER", A2[A2.TIMEOUT = 7] = "TIMEOUT", A2[A2.ALREADY_SUBSCRIBED_USER = 20001] = "ALREADY_SUBSCRIBED_USER", A2[A2.SUB_USER_EXCEED_LIMITATION = 20003] = "SUB_USER_EXCEED_LIMITATION", A2[A2.NOT_SUBSCRIBED_USER = 20004] = "NOT_SUBSCRIBED_USER", A2;
        }({});
        A.SubscribeTopicErrorCode = e;
      }(RTMStreamChannelStatusCode || (RTMStreamChannelStatusCode = {}));
      var isMobile$2 = { exports: {} };
      isMobile$2.exports = isMobile, isMobile$2.exports.isMobile = isMobile, isMobile$2.exports.default = isMobile;
      const mobileRE = /(android|bb\d+|meego).+mobile|armv7l|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series[46]0|samsungbrowser|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i, notMobileRE = /CrOS/, tabletRE = /android|ipad|playbook|silk/i;
      function isMobile(A) {
        A || (A = {});
        let e = A.ua;
        if (e || "undefined" == typeof navigator || (e = navigator.userAgent), e && e.headers && "string" == typeof e.headers["user-agent"] && (e = e.headers["user-agent"]), "string" != typeof e)
          return false;
        let t = mobileRE.test(e) && !notMobileRE.test(e) || !!A.tablet && tabletRE.test(e);
        return !t && A.tablet && A.featureDetect && navigator && navigator.maxTouchPoints > 1 && -1 !== e.indexOf("Macintosh") && -1 !== e.indexOf("Safari") && (t = true), t;
      }
      var isMobileExports = isMobile$2.exports, isMobile$1 = getDefaultExportFromCjs(isMobileExports), defaultProtocols = [], defaultWebsocketFactory = function(A, e) {
        return new WebSocket(A, e);
      }, normalClosureMessage = "Normal closure";
      function makeWebSocketObservable(A, e) {
        var t = void 0 === e ? { protocols: defaultProtocols, makeWebSocket: defaultWebsocketFactory } : e, g = t.protocols, o = void 0 === g ? defaultProtocols : g, I = t.makeWebSocket, i2 = void 0 === I ? defaultWebsocketFactory : I;
        return new Observable(function(e2) {
          var t2, g2 = new Subject(), I2 = i2(A, o), r = false, n = false, C = false, E = function() {
            r = true;
          }, s = function(A2) {
            if (t2) {
              E();
              var o2 = new Error("Web socket message factory function called more than once");
              throw e2.error(o2), o2;
            }
            return t2 = A2.subscribe(function(A3) {
              I2.send(A3);
            }), g2;
          };
          return I2.onopen = function() {
            C = true, n ? (r = true, I2.close()) : e2.next(s);
          }, I2.onmessage = function(A2) {
            g2.next(A2.data);
          }, I2.onerror = function(A2) {
            E(), e2.error(new Error(A2.message));
          }, I2.onclose = function(A2) {
            r || (E(), n ? (e2.complete(), g2.complete()) : e2.error(new Error(1e3 === A2.code ? normalClosureMessage : A2.reason)));
          }, function() {
            n = true, t2 && t2.unsubscribe(), r || (E(), C && I2.close());
          };
        });
      }
      const $Reader = minimal_1.Reader, $Writer$1 = minimal_1.Writer, $util$1 = minimal_1.util, $root$1 = minimal_1.roots.default || (minimal_1.roots.default = {}), Wrapper$1 = $root$1.Wrapper = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.uri = 0, A.prototype.data = $util$1.newBuffer([]), A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.uri && Object.hasOwnProperty.call(A2, "uri") && e.uint32(8).int32(A2.uri), null != A2.data && Object.hasOwnProperty.call(A2, "data") && e.uint32(18).bytes(A2.data), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.Wrapper();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.uri = A2.int32();
                break;
              case 2:
                o.data = A2.bytes();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/Wrapper";
        }, A;
      })(), Ping3 = $root$1.Ping3 = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.seq = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.ms = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.flags = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.seq && Object.hasOwnProperty.call(A2, "seq") && e.uint32(8).uint64(A2.seq), null != A2.ms && Object.hasOwnProperty.call(A2, "ms") && e.uint32(16).uint64(A2.ms), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(24).uint64(A2.flags), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.Ping3();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.seq = A2.uint64();
                break;
              case 2:
                o.ms = A2.uint64();
                break;
              case 3:
                o.flags = A2.uint64();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/Ping3";
        }, A;
      })(), Pong3 = $root$1.Pong3 = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.seq = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.ms = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.serverMs = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.seq && Object.hasOwnProperty.call(A2, "seq") && e.uint32(8).uint64(A2.seq), null != A2.ms && Object.hasOwnProperty.call(A2, "ms") && e.uint32(16).uint64(A2.ms), null != A2.serverMs && Object.hasOwnProperty.call(A2, "serverMs") && e.uint32(24).uint64(A2.serverMs), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.Pong3();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.seq = A2.uint64();
                break;
              case 2:
                o.ms = A2.uint64();
                break;
              case 3:
                o.serverMs = A2.uint64();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/Pong3";
        }, A;
      })(), UserJoin2 = $root$1.UserJoin2 = (() => {
        function A(A2) {
          if (this.detail = {}, A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.seq = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.opt = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.instance = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.account = "", A.prototype.ticket = "", A.prototype.detail = $util$1.emptyObject, A.encode = function(A2, e) {
          if (e || (e = $Writer$1.create()), null != A2.seq && Object.hasOwnProperty.call(A2, "seq") && e.uint32(8).uint64(A2.seq), null != A2.opt && Object.hasOwnProperty.call(A2, "opt") && e.uint32(16).uint64(A2.opt), null != A2.instance && Object.hasOwnProperty.call(A2, "instance") && e.uint32(24).uint64(A2.instance), null != A2.account && Object.hasOwnProperty.call(A2, "account") && e.uint32(34).string(A2.account), null != A2.ticket && Object.hasOwnProperty.call(A2, "ticket") && e.uint32(42).string(A2.ticket), null != A2.detail && Object.hasOwnProperty.call(A2, "detail"))
            for (let t = Object.keys(A2.detail), g = 0; g < t.length; ++g)
              e.uint32(50).fork().uint32(8).uint32(t[g]).uint32(18).bytes(A2.detail[t[g]]).ldelim();
          return e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g, o, I = void 0 === e ? A2.len : A2.pos + e, i2 = new $root$1.UserJoin2();
          for (; A2.pos < I; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                i2.seq = A2.uint64();
                break;
              case 2:
                i2.opt = A2.uint64();
                break;
              case 3:
                i2.instance = A2.uint64();
                break;
              case 4:
                i2.account = A2.string();
                break;
              case 5:
                i2.ticket = A2.string();
                break;
              case 6: {
                i2.detail === $util$1.emptyObject && (i2.detail = {});
                let e3 = A2.uint32() + A2.pos;
                for (g = 0, o = []; A2.pos < e3; ) {
                  let e4 = A2.uint32();
                  switch (e4 >>> 3) {
                    case 1:
                      g = A2.uint32();
                      break;
                    case 2:
                      o = A2.bytes();
                      break;
                    default:
                      A2.skipType(7 & e4);
                  }
                }
                i2.detail[g] = o;
                break;
              }
              default:
                A2.skipType(7 & e2);
            }
          }
          return i2;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/UserJoin2";
        }, A;
      })(), UserResp2 = $root$1.UserResp2 = (() => {
        function A(A2) {
          if (this.detail = {}, A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.seq = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.account = "", A.prototype.code = 0, A.prototype.serverTs = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.detail = $util$1.emptyObject, A.encode = function(A2, e) {
          if (e || (e = $Writer$1.create()), null != A2.seq && Object.hasOwnProperty.call(A2, "seq") && e.uint32(8).uint64(A2.seq), null != A2.account && Object.hasOwnProperty.call(A2, "account") && e.uint32(18).string(A2.account), null != A2.code && Object.hasOwnProperty.call(A2, "code") && e.uint32(24).uint32(A2.code), null != A2.serverTs && Object.hasOwnProperty.call(A2, "serverTs") && e.uint32(32).uint64(A2.serverTs), null != A2.detail && Object.hasOwnProperty.call(A2, "detail"))
            for (let t = Object.keys(A2.detail), g = 0; g < t.length; ++g)
              e.uint32(42).fork().uint32(8).uint32(t[g]).uint32(18).bytes(A2.detail[t[g]]).ldelim();
          return e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g, o, I = void 0 === e ? A2.len : A2.pos + e, i2 = new $root$1.UserResp2();
          for (; A2.pos < I; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                i2.seq = A2.uint64();
                break;
              case 2:
                i2.account = A2.string();
                break;
              case 3:
                i2.code = A2.uint32();
                break;
              case 4:
                i2.serverTs = A2.uint64();
                break;
              case 5: {
                i2.detail === $util$1.emptyObject && (i2.detail = {});
                let e3 = A2.uint32() + A2.pos;
                for (g = 0, o = []; A2.pos < e3; ) {
                  let e4 = A2.uint32();
                  switch (e4 >>> 3) {
                    case 1:
                      g = A2.uint32();
                      break;
                    case 2:
                      o = A2.bytes();
                      break;
                    default:
                      A2.skipType(7 & e4);
                  }
                }
                i2.detail[g] = o;
                break;
              }
              default:
                A2.skipType(7 & e2);
            }
          }
          return i2;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/UserResp2";
        }, A;
      })(), UserQuit2 = $root$1.UserQuit2 = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.flags = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(8).uint64(A2.flags), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.UserQuit2();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            if (e2 >>> 3 == 1)
              o.flags = A2.uint64();
            else
              A2.skipType(7 & e2);
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/UserQuit2";
        }, A;
      })(), UserDrop = $root$1.UserDrop = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.code = 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.code && Object.hasOwnProperty.call(A2, "code") && e.uint32(8).uint32(A2.code), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.UserDrop();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            if (e2 >>> 3 == 1)
              o.code = A2.uint32();
            else
              A2.skipType(7 & e2);
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/UserDrop";
        }, A;
      })(), UserTicketNearlyExpire = $root$1.UserTicketNearlyExpire = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.expireTs = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.ticket = "", A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.expireTs && Object.hasOwnProperty.call(A2, "expireTs") && e.uint32(8).uint64(A2.expireTs), null != A2.ticket && Object.hasOwnProperty.call(A2, "ticket") && e.uint32(18).string(A2.ticket), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.UserTicketNearlyExpire();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.expireTs = A2.uint64();
                break;
              case 2:
                o.ticket = A2.string();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/UserTicketNearlyExpire";
        }, A;
      })(), UserTicketNearlyExpire2 = $root$1.UserTicketNearlyExpire2 = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.expireTs = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.ticket = "", A.prototype.resources = "", A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.expireTs && Object.hasOwnProperty.call(A2, "expireTs") && e.uint32(8).uint64(A2.expireTs), null != A2.ticket && Object.hasOwnProperty.call(A2, "ticket") && e.uint32(18).string(A2.ticket), null != A2.resources && Object.hasOwnProperty.call(A2, "resources") && e.uint32(26).string(A2.resources), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.UserTicketNearlyExpire2();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.expireTs = A2.uint64();
                break;
              case 2:
                o.ticket = A2.string();
                break;
              case 3:
                o.resources = A2.string();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/UserTicketNearlyExpire2";
        }, A;
      })(), UserRenewTokenReq = $root$1.UserRenewTokenReq = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.instance = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.seq = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.account = "", A.prototype.ticket = "", A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.instance && Object.hasOwnProperty.call(A2, "instance") && e.uint32(8).uint64(A2.instance), null != A2.seq && Object.hasOwnProperty.call(A2, "seq") && e.uint32(16).uint64(A2.seq), null != A2.account && Object.hasOwnProperty.call(A2, "account") && e.uint32(26).string(A2.account), null != A2.ticket && Object.hasOwnProperty.call(A2, "ticket") && e.uint32(34).string(A2.ticket), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.UserRenewTokenReq();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.instance = A2.uint64();
                break;
              case 2:
                o.seq = A2.uint64();
                break;
              case 3:
                o.account = A2.string();
                break;
              case 4:
                o.ticket = A2.string();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/UserRenewTokenReq";
        }, A;
      })(), UserRenewTokenResp = $root$1.UserRenewTokenResp = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.seq = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.code = 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.seq && Object.hasOwnProperty.call(A2, "seq") && e.uint32(8).uint64(A2.seq), null != A2.code && Object.hasOwnProperty.call(A2, "code") && e.uint32(16).uint32(A2.code), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.UserRenewTokenResp();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.seq = A2.uint64();
                break;
              case 2:
                o.code = A2.uint32();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/UserRenewTokenResp";
        }, A;
      })(), UserRenewToken2Req = $root$1.UserRenewToken2Req = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.instance = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.seq = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.account = "", A.prototype.ticket = "", A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.instance && Object.hasOwnProperty.call(A2, "instance") && e.uint32(8).uint64(A2.instance), null != A2.seq && Object.hasOwnProperty.call(A2, "seq") && e.uint32(16).uint64(A2.seq), null != A2.account && Object.hasOwnProperty.call(A2, "account") && e.uint32(26).string(A2.account), null != A2.ticket && Object.hasOwnProperty.call(A2, "ticket") && e.uint32(34).string(A2.ticket), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.UserRenewToken2Req();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.instance = A2.uint64();
                break;
              case 2:
                o.seq = A2.uint64();
                break;
              case 3:
                o.account = A2.string();
                break;
              case 4:
                o.ticket = A2.string();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/UserRenewToken2Req";
        }, A;
      })(), UserRenewToken2Resp = $root$1.UserRenewToken2Resp = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.seq = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.code = 0, A.prototype.revoked = "", A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.seq && Object.hasOwnProperty.call(A2, "seq") && e.uint32(8).uint64(A2.seq), null != A2.code && Object.hasOwnProperty.call(A2, "code") && e.uint32(16).uint32(A2.code), null != A2.revoked && Object.hasOwnProperty.call(A2, "revoked") && e.uint32(26).string(A2.revoked), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.UserRenewToken2Resp();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.seq = A2.uint64();
                break;
              case 2:
                o.code = A2.uint32();
                break;
              case 3:
                o.revoked = A2.string();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/UserRenewToken2Resp";
        }, A;
      })(), GroupEnter = $root$1.GroupEnter = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.seq = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.account = "", A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.seq && Object.hasOwnProperty.call(A2, "seq") && e.uint32(8).uint64(A2.seq), null != A2.account && Object.hasOwnProperty.call(A2, "account") && e.uint32(18).string(A2.account), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.GroupEnter();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.seq = A2.uint64();
                break;
              case 2:
                o.account = A2.string();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/GroupEnter";
        }, A;
      })(), GroupLeave = $root$1.GroupLeave = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.account = "", A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.account && Object.hasOwnProperty.call(A2, "account") && e.uint32(10).string(A2.account), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.GroupLeave();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            if (e2 >>> 3 == 1)
              o.account = A2.string();
            else
              A2.skipType(7 & e2);
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/GroupLeave";
        }, A;
      })(), GroupLeave2 = $root$1.GroupLeave2 = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.account = "", A.prototype.flags = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.account && Object.hasOwnProperty.call(A2, "account") && e.uint32(10).string(A2.account), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(16).uint64(A2.flags), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.GroupLeave2();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.account = A2.string();
                break;
              case 2:
                o.flags = A2.uint64();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/GroupLeave2";
        }, A;
      })(), GroupReply = $root$1.GroupReply = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.seq = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.account = "", A.prototype.code = 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.seq && Object.hasOwnProperty.call(A2, "seq") && e.uint32(8).uint64(A2.seq), null != A2.account && Object.hasOwnProperty.call(A2, "account") && e.uint32(18).string(A2.account), null != A2.code && Object.hasOwnProperty.call(A2, "code") && e.uint32(24).uint32(A2.code), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.GroupReply();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.seq = A2.uint64();
                break;
              case 2:
                o.account = A2.string();
                break;
              case 3:
                o.code = A2.uint32();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/GroupReply";
        }, A;
      })(), GroupLeaveNotice = $root$1.GroupLeaveNotice = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.seq = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.user = "", A.prototype.group = "", A.prototype.instance = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.size = 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.seq && Object.hasOwnProperty.call(A2, "seq") && e.uint32(8).uint64(A2.seq), null != A2.user && Object.hasOwnProperty.call(A2, "user") && e.uint32(18).string(A2.user), null != A2.group && Object.hasOwnProperty.call(A2, "group") && e.uint32(26).string(A2.group), null != A2.instance && Object.hasOwnProperty.call(A2, "instance") && e.uint32(32).uint64(A2.instance), null != A2.size && Object.hasOwnProperty.call(A2, "size") && e.uint32(40).uint32(A2.size), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.GroupLeaveNotice();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.seq = A2.uint64();
                break;
              case 2:
                o.user = A2.string();
                break;
              case 3:
                o.group = A2.string();
                break;
              case 4:
                o.instance = A2.uint64();
                break;
              case 5:
                o.size = A2.uint32();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/GroupLeaveNotice";
        }, A;
      })(), GroupEnterNotice = $root$1.GroupEnterNotice = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.seq = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.user = "", A.prototype.group = "", A.prototype.instance = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.size = 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.seq && Object.hasOwnProperty.call(A2, "seq") && e.uint32(8).uint64(A2.seq), null != A2.user && Object.hasOwnProperty.call(A2, "user") && e.uint32(18).string(A2.user), null != A2.group && Object.hasOwnProperty.call(A2, "group") && e.uint32(26).string(A2.group), null != A2.instance && Object.hasOwnProperty.call(A2, "instance") && e.uint32(32).uint64(A2.instance), null != A2.size && Object.hasOwnProperty.call(A2, "size") && e.uint32(40).uint32(A2.size), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.GroupEnterNotice();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.seq = A2.uint64();
                break;
              case 2:
                o.user = A2.string();
                break;
              case 3:
                o.group = A2.string();
                break;
              case 4:
                o.instance = A2.uint64();
                break;
              case 5:
                o.size = A2.uint32();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/GroupEnterNotice";
        }, A;
      })(), Message = $root$1.Message = (() => {
        function A(A2) {
          if (this.MiscMap = {}, A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.instance = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.dialogue = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.sequence = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.options = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.src = "", A.prototype.dst = "", A.prototype.payload = $util$1.newBuffer([]), A.prototype.MiscMap = $util$1.emptyObject, A.prototype.ms = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.encode = function(A2, e) {
          if (e || (e = $Writer$1.create()), null != A2.instance && Object.hasOwnProperty.call(A2, "instance") && e.uint32(8).uint64(A2.instance), null != A2.dialogue && Object.hasOwnProperty.call(A2, "dialogue") && e.uint32(16).uint64(A2.dialogue), null != A2.sequence && Object.hasOwnProperty.call(A2, "sequence") && e.uint32(24).uint64(A2.sequence), null != A2.options && Object.hasOwnProperty.call(A2, "options") && e.uint32(32).uint64(A2.options), null != A2.src && Object.hasOwnProperty.call(A2, "src") && e.uint32(42).string(A2.src), null != A2.dst && Object.hasOwnProperty.call(A2, "dst") && e.uint32(50).string(A2.dst), null != A2.payload && Object.hasOwnProperty.call(A2, "payload") && e.uint32(58).bytes(A2.payload), null != A2.MiscMap && Object.hasOwnProperty.call(A2, "MiscMap"))
            for (let t = Object.keys(A2.MiscMap), g = 0; g < t.length; ++g)
              e.uint32(66).fork().uint32(10).string(t[g]).uint32(18).bytes(A2.MiscMap[t[g]]).ldelim();
          return null != A2.ms && Object.hasOwnProperty.call(A2, "ms") && e.uint32(72).uint64(A2.ms), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g, o, I = void 0 === e ? A2.len : A2.pos + e, i2 = new $root$1.Message();
          for (; A2.pos < I; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                i2.instance = A2.uint64();
                break;
              case 2:
                i2.dialogue = A2.uint64();
                break;
              case 3:
                i2.sequence = A2.uint64();
                break;
              case 4:
                i2.options = A2.uint64();
                break;
              case 5:
                i2.src = A2.string();
                break;
              case 6:
                i2.dst = A2.string();
                break;
              case 7:
                i2.payload = A2.bytes();
                break;
              case 8: {
                i2.MiscMap === $util$1.emptyObject && (i2.MiscMap = {});
                let e3 = A2.uint32() + A2.pos;
                for (g = "", o = []; A2.pos < e3; ) {
                  let e4 = A2.uint32();
                  switch (e4 >>> 3) {
                    case 1:
                      g = A2.string();
                      break;
                    case 2:
                      o = A2.bytes();
                      break;
                    default:
                      A2.skipType(7 & e4);
                  }
                }
                i2.MiscMap[g] = o;
                break;
              }
              case 9:
                i2.ms = A2.uint64();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return i2;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/Message";
        }, A;
      })(), Ack = $root$1.Ack = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.instance = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.dialogue = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.sequence = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.code = 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.instance && Object.hasOwnProperty.call(A2, "instance") && e.uint32(8).uint64(A2.instance), null != A2.dialogue && Object.hasOwnProperty.call(A2, "dialogue") && e.uint32(16).uint64(A2.dialogue), null != A2.sequence && Object.hasOwnProperty.call(A2, "sequence") && e.uint32(24).uint64(A2.sequence), null != A2.code && Object.hasOwnProperty.call(A2, "code") && e.uint32(32).uint32(A2.code), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.Ack();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.instance = A2.uint64();
                break;
              case 2:
                o.dialogue = A2.uint64();
                break;
              case 3:
                o.sequence = A2.uint64();
                break;
              case 4:
                o.code = A2.uint32();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/Ack";
        }, A;
      })(), GroupDrop = $root$1.GroupDrop = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.account = "", A.prototype.code = 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.account && Object.hasOwnProperty.call(A2, "account") && e.uint32(10).string(A2.account), null != A2.code && Object.hasOwnProperty.call(A2, "code") && e.uint32(16).uint32(A2.code), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.GroupDrop();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.account = A2.string();
                break;
              case 2:
                o.code = A2.uint32();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/GroupDrop";
        }, A;
      })(), GroupAllUsersList = $root$1.GroupAllUsersList = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.seq = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.group = "", A.prototype.pageSize = 0, A.prototype.pageNumber = 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.seq && Object.hasOwnProperty.call(A2, "seq") && e.uint32(8).uint64(A2.seq), null != A2.group && Object.hasOwnProperty.call(A2, "group") && e.uint32(18).string(A2.group), null != A2.pageSize && Object.hasOwnProperty.call(A2, "pageSize") && e.uint32(24).uint32(A2.pageSize), null != A2.pageNumber && Object.hasOwnProperty.call(A2, "pageNumber") && e.uint32(32).uint32(A2.pageNumber), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.GroupAllUsersList();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.seq = A2.uint64();
                break;
              case 2:
                o.group = A2.string();
                break;
              case 3:
                o.pageSize = A2.uint32();
                break;
              case 4:
                o.pageNumber = A2.uint32();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/GroupAllUsersList";
        }, A;
      })(), GroupAllUsersResult = $root$1.GroupAllUsersResult = (() => {
        function A(A2) {
          if (this.memberInfos = [], A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.seq = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.group = "", A.prototype.totalSize = 0, A.prototype.pageSize = 0, A.prototype.pageNumber = 0, A.prototype.memberInfos = $util$1.emptyArray, A.encode = function(A2, e) {
          if (e || (e = $Writer$1.create()), null != A2.seq && Object.hasOwnProperty.call(A2, "seq") && e.uint32(8).uint64(A2.seq), null != A2.group && Object.hasOwnProperty.call(A2, "group") && e.uint32(18).string(A2.group), null != A2.totalSize && Object.hasOwnProperty.call(A2, "totalSize") && e.uint32(24).uint32(A2.totalSize), null != A2.pageSize && Object.hasOwnProperty.call(A2, "pageSize") && e.uint32(32).uint32(A2.pageSize), null != A2.pageNumber && Object.hasOwnProperty.call(A2, "pageNumber") && e.uint32(40).uint32(A2.pageNumber), null != A2.memberInfos && A2.memberInfos.length)
            for (let t = 0; t < A2.memberInfos.length; ++t)
              $root$1.GroupAllUsersResult.MemberInfo.encode(A2.memberInfos[t], e.uint32(50).fork()).ldelim();
          return e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.GroupAllUsersResult();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.seq = A2.uint64();
                break;
              case 2:
                o.group = A2.string();
                break;
              case 3:
                o.totalSize = A2.uint32();
                break;
              case 4:
                o.pageSize = A2.uint32();
                break;
              case 5:
                o.pageNumber = A2.uint32();
                break;
              case 6:
                o.memberInfos && o.memberInfos.length || (o.memberInfos = []), o.memberInfos.push($root$1.GroupAllUsersResult.MemberInfo.decode(A2, A2.uint32()));
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/GroupAllUsersResult";
        }, A.MemberInfo = function() {
          function A2(A3) {
            if (A3)
              for (let e = Object.keys(A3), t = 0; t < e.length; ++t)
                null != A3[e[t]] && (this[e[t]] = A3[e[t]]);
          }
          return A2.prototype.account = "", A2.prototype.ts = 0, A2.encode = function(A3, e) {
            return e || (e = $Writer$1.create()), null != A3.account && Object.hasOwnProperty.call(A3, "account") && e.uint32(10).string(A3.account), null != A3.ts && Object.hasOwnProperty.call(A3, "ts") && e.uint32(16).uint32(A3.ts), e;
          }, A2.decode = function(A3, e, t) {
            A3 instanceof $Reader || (A3 = $Reader.create(A3));
            let g = void 0 === e ? A3.len : A3.pos + e, o = new $root$1.GroupAllUsersResult.MemberInfo();
            for (; A3.pos < g; ) {
              let e2 = A3.uint32();
              if (e2 === t)
                break;
              switch (e2 >>> 3) {
                case 1:
                  o.account = A3.string();
                  break;
                case 2:
                  o.ts = A3.uint32();
                  break;
                default:
                  A3.skipType(7 & e2);
              }
            }
            return o;
          }, A2.getTypeUrl = function(A3) {
            return void 0 === A3 && (A3 = "type.googleapis.com"), A3 + "/GroupAllUsersResult.MemberInfo";
          }, A2;
        }(), A;
      })(), GroupCountNotice = $root$1.GroupCountNotice = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.instance = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.sequence = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.group = "", A.prototype.size = 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.instance && Object.hasOwnProperty.call(A2, "instance") && e.uint32(8).uint64(A2.instance), null != A2.sequence && Object.hasOwnProperty.call(A2, "sequence") && e.uint32(16).uint64(A2.sequence), null != A2.group && Object.hasOwnProperty.call(A2, "group") && e.uint32(26).string(A2.group), null != A2.size && Object.hasOwnProperty.call(A2, "size") && e.uint32(32).uint32(A2.size), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.GroupCountNotice();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.instance = A2.uint64();
                break;
              case 2:
                o.sequence = A2.uint64();
                break;
              case 3:
                o.group = A2.string();
                break;
              case 4:
                o.size = A2.uint32();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/GroupCountNotice";
        }, A;
      })(), StateSubscribe = $root$1.StateSubscribe = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.target = "", A.prototype.subTarget = "", A.prototype.sequence = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.flags = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.target && Object.hasOwnProperty.call(A2, "target") && e.uint32(10).string(A2.target), null != A2.subTarget && Object.hasOwnProperty.call(A2, "subTarget") && e.uint32(18).string(A2.subTarget), null != A2.sequence && Object.hasOwnProperty.call(A2, "sequence") && e.uint32(24).uint64(A2.sequence), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(32).uint64(A2.flags), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.StateSubscribe();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.target = A2.string();
                break;
              case 2:
                o.subTarget = A2.string();
                break;
              case 3:
                o.sequence = A2.uint64();
                break;
              case 4:
                o.flags = A2.uint64();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/StateSubscribe";
        }, A;
      })(), StateUpdate = $root$1.StateUpdate = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.target = "", A.prototype.subTarget = "", A.prototype.allStates = "", A.prototype.flags = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.target && Object.hasOwnProperty.call(A2, "target") && e.uint32(10).string(A2.target), null != A2.subTarget && Object.hasOwnProperty.call(A2, "subTarget") && e.uint32(18).string(A2.subTarget), null != A2.allStates && Object.hasOwnProperty.call(A2, "allStates") && e.uint32(26).string(A2.allStates), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(32).uint64(A2.flags), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.StateUpdate();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.target = A2.string();
                break;
              case 2:
                o.subTarget = A2.string();
                break;
              case 3:
                o.allStates = A2.string();
                break;
              case 4:
                o.flags = A2.uint64();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/StateUpdate";
        }, A;
      })(), StateSubscribeResult = $root$1.StateSubscribeResult = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.target = "", A.prototype.subTarget = "", A.prototype.sequence = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.flags = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.code = 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.target && Object.hasOwnProperty.call(A2, "target") && e.uint32(10).string(A2.target), null != A2.subTarget && Object.hasOwnProperty.call(A2, "subTarget") && e.uint32(18).string(A2.subTarget), null != A2.sequence && Object.hasOwnProperty.call(A2, "sequence") && e.uint32(24).uint64(A2.sequence), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(32).uint64(A2.flags), null != A2.code && Object.hasOwnProperty.call(A2, "code") && e.uint32(40).uint32(A2.code), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.StateSubscribeResult();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.target = A2.string();
                break;
              case 2:
                o.subTarget = A2.string();
                break;
              case 3:
                o.sequence = A2.uint64();
                break;
              case 4:
                o.flags = A2.uint64();
                break;
              case 5:
                o.code = A2.uint32();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/StateSubscribeResult";
        }, A;
      })(), StateUnsubscribe = $root$1.StateUnsubscribe = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.target = "", A.prototype.subTarget = "", A.prototype.sequence = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.flags = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.target && Object.hasOwnProperty.call(A2, "target") && e.uint32(10).string(A2.target), null != A2.subTarget && Object.hasOwnProperty.call(A2, "subTarget") && e.uint32(18).string(A2.subTarget), null != A2.sequence && Object.hasOwnProperty.call(A2, "sequence") && e.uint32(24).uint64(A2.sequence), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(32).uint64(A2.flags), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.StateUnsubscribe();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.target = A2.string();
                break;
              case 2:
                o.subTarget = A2.string();
                break;
              case 3:
                o.sequence = A2.uint64();
                break;
              case 4:
                o.flags = A2.uint64();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/StateUnsubscribe";
        }, A;
      })(), StateSet = $root$1.StateSet = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.target = "", A.prototype.author = "", A.prototype.value = "", A.prototype.lock = "", A.prototype.requestUuid = "", A.prototype.sequence = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.flags = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.baseRevision = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.lockRev = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.target && Object.hasOwnProperty.call(A2, "target") && e.uint32(10).string(A2.target), null != A2.author && Object.hasOwnProperty.call(A2, "author") && e.uint32(18).string(A2.author), null != A2.value && Object.hasOwnProperty.call(A2, "value") && e.uint32(26).string(A2.value), null != A2.lock && Object.hasOwnProperty.call(A2, "lock") && e.uint32(34).string(A2.lock), null != A2.requestUuid && Object.hasOwnProperty.call(A2, "requestUuid") && e.uint32(42).string(A2.requestUuid), null != A2.sequence && Object.hasOwnProperty.call(A2, "sequence") && e.uint32(48).uint64(A2.sequence), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(56).uint64(A2.flags), null != A2.baseRevision && Object.hasOwnProperty.call(A2, "baseRevision") && e.uint32(64).uint64(A2.baseRevision), null != A2.lockRev && Object.hasOwnProperty.call(A2, "lockRev") && e.uint32(72).uint64(A2.lockRev), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.StateSet();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.target = A2.string();
                break;
              case 2:
                o.author = A2.string();
                break;
              case 3:
                o.value = A2.string();
                break;
              case 4:
                o.lock = A2.string();
                break;
              case 5:
                o.requestUuid = A2.string();
                break;
              case 6:
                o.sequence = A2.uint64();
                break;
              case 7:
                o.flags = A2.uint64();
                break;
              case 8:
                o.baseRevision = A2.uint64();
                break;
              case 9:
                o.lockRev = A2.uint64();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/StateSet";
        }, A;
      })(), StateModify = $root$1.StateModify = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.target = "", A.prototype.author = "", A.prototype.value = "", A.prototype.lock = "", A.prototype.requestUuid = "", A.prototype.sequence = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.flags = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.baseRevision = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.lockRev = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.target && Object.hasOwnProperty.call(A2, "target") && e.uint32(10).string(A2.target), null != A2.author && Object.hasOwnProperty.call(A2, "author") && e.uint32(18).string(A2.author), null != A2.value && Object.hasOwnProperty.call(A2, "value") && e.uint32(26).string(A2.value), null != A2.lock && Object.hasOwnProperty.call(A2, "lock") && e.uint32(34).string(A2.lock), null != A2.requestUuid && Object.hasOwnProperty.call(A2, "requestUuid") && e.uint32(42).string(A2.requestUuid), null != A2.sequence && Object.hasOwnProperty.call(A2, "sequence") && e.uint32(48).uint64(A2.sequence), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(56).uint64(A2.flags), null != A2.baseRevision && Object.hasOwnProperty.call(A2, "baseRevision") && e.uint32(64).uint64(A2.baseRevision), null != A2.lockRev && Object.hasOwnProperty.call(A2, "lockRev") && e.uint32(72).uint64(A2.lockRev), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.StateModify();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.target = A2.string();
                break;
              case 2:
                o.author = A2.string();
                break;
              case 3:
                o.value = A2.string();
                break;
              case 4:
                o.lock = A2.string();
                break;
              case 5:
                o.requestUuid = A2.string();
                break;
              case 6:
                o.sequence = A2.uint64();
                break;
              case 7:
                o.flags = A2.uint64();
                break;
              case 8:
                o.baseRevision = A2.uint64();
                break;
              case 9:
                o.lockRev = A2.uint64();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/StateModify";
        }, A;
      })(), StateRequestResult = $root$1.StateRequestResult = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.requestUuid = "", A.prototype.sequence = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.code = 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.requestUuid && Object.hasOwnProperty.call(A2, "requestUuid") && e.uint32(10).string(A2.requestUuid), null != A2.sequence && Object.hasOwnProperty.call(A2, "sequence") && e.uint32(16).uint64(A2.sequence), null != A2.code && Object.hasOwnProperty.call(A2, "code") && e.uint32(24).uint32(A2.code), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.StateRequestResult();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.requestUuid = A2.string();
                break;
              case 2:
                o.sequence = A2.uint64();
                break;
              case 3:
                o.code = A2.uint32();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/StateRequestResult";
        }, A;
      })(), StateGet = $root$1.StateGet = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.target = "", A.prototype.subTarget = "", A.prototype.lock = "", A.prototype.sequence = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.flags = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.lockRev = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.target && Object.hasOwnProperty.call(A2, "target") && e.uint32(10).string(A2.target), null != A2.subTarget && Object.hasOwnProperty.call(A2, "subTarget") && e.uint32(18).string(A2.subTarget), null != A2.lock && Object.hasOwnProperty.call(A2, "lock") && e.uint32(26).string(A2.lock), null != A2.sequence && Object.hasOwnProperty.call(A2, "sequence") && e.uint32(32).uint64(A2.sequence), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(40).uint64(A2.flags), null != A2.lockRev && Object.hasOwnProperty.call(A2, "lockRev") && e.uint32(48).uint64(A2.lockRev), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.StateGet();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.target = A2.string();
                break;
              case 2:
                o.subTarget = A2.string();
                break;
              case 3:
                o.lock = A2.string();
                break;
              case 4:
                o.sequence = A2.uint64();
                break;
              case 5:
                o.flags = A2.uint64();
                break;
              case 6:
                o.lockRev = A2.uint64();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/StateGet";
        }, A;
      })(), StateGetResult = $root$1.StateGetResult = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.target = "", A.prototype.subTarget = "", A.prototype.allStates = "", A.prototype.sequence = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.flags = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.code = 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.target && Object.hasOwnProperty.call(A2, "target") && e.uint32(10).string(A2.target), null != A2.subTarget && Object.hasOwnProperty.call(A2, "subTarget") && e.uint32(18).string(A2.subTarget), null != A2.allStates && Object.hasOwnProperty.call(A2, "allStates") && e.uint32(26).string(A2.allStates), null != A2.sequence && Object.hasOwnProperty.call(A2, "sequence") && e.uint32(32).uint64(A2.sequence), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(40).uint64(A2.flags), null != A2.code && Object.hasOwnProperty.call(A2, "code") && e.uint32(48).uint32(A2.code), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.StateGetResult();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.target = A2.string();
                break;
              case 2:
                o.subTarget = A2.string();
                break;
              case 3:
                o.allStates = A2.string();
                break;
              case 4:
                o.sequence = A2.uint64();
                break;
              case 5:
                o.flags = A2.uint64();
                break;
              case 6:
                o.code = A2.uint32();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/StateGetResult";
        }, A;
      })(), StateLockAcquire = $root$1.StateLockAcquire = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.target = "", A.prototype.lock = "", A.prototype.requestUuid = "", A.prototype.flags = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.ttl = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.target && Object.hasOwnProperty.call(A2, "target") && e.uint32(10).string(A2.target), null != A2.lock && Object.hasOwnProperty.call(A2, "lock") && e.uint32(18).string(A2.lock), null != A2.requestUuid && Object.hasOwnProperty.call(A2, "requestUuid") && e.uint32(26).string(A2.requestUuid), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(32).uint64(A2.flags), null != A2.ttl && Object.hasOwnProperty.call(A2, "ttl") && e.uint32(40).uint64(A2.ttl), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.StateLockAcquire();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.target = A2.string();
                break;
              case 2:
                o.lock = A2.string();
                break;
              case 3:
                o.requestUuid = A2.string();
                break;
              case 4:
                o.flags = A2.uint64();
                break;
              case 5:
                o.ttl = A2.uint64();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/StateLockAcquire";
        }, A;
      })(), StateLockRelease = $root$1.StateLockRelease = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.target = "", A.prototype.lock = "", A.prototype.requestUuid = "", A.prototype.flags = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.target && Object.hasOwnProperty.call(A2, "target") && e.uint32(10).string(A2.target), null != A2.lock && Object.hasOwnProperty.call(A2, "lock") && e.uint32(18).string(A2.lock), null != A2.requestUuid && Object.hasOwnProperty.call(A2, "requestUuid") && e.uint32(26).string(A2.requestUuid), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(32).uint64(A2.flags), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.StateLockRelease();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.target = A2.string();
                break;
              case 2:
                o.lock = A2.string();
                break;
              case 3:
                o.requestUuid = A2.string();
                break;
              case 4:
                o.flags = A2.uint64();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/StateLockRelease";
        }, A;
      })(), StateLockAcquireResult = $root$1.StateLockAcquireResult = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.target = "", A.prototype.lock = "", A.prototype.requestUuid = "", A.prototype.flags = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.lockRev = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.code = 0, A.prototype.reason = "", A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.target && Object.hasOwnProperty.call(A2, "target") && e.uint32(10).string(A2.target), null != A2.lock && Object.hasOwnProperty.call(A2, "lock") && e.uint32(18).string(A2.lock), null != A2.requestUuid && Object.hasOwnProperty.call(A2, "requestUuid") && e.uint32(26).string(A2.requestUuid), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(32).uint64(A2.flags), null != A2.lockRev && Object.hasOwnProperty.call(A2, "lockRev") && e.uint32(40).uint64(A2.lockRev), null != A2.code && Object.hasOwnProperty.call(A2, "code") && e.uint32(48).uint32(A2.code), null != A2.reason && Object.hasOwnProperty.call(A2, "reason") && e.uint32(58).string(A2.reason), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.StateLockAcquireResult();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.target = A2.string();
                break;
              case 2:
                o.lock = A2.string();
                break;
              case 3:
                o.requestUuid = A2.string();
                break;
              case 4:
                o.flags = A2.uint64();
                break;
              case 5:
                o.lockRev = A2.uint64();
                break;
              case 6:
                o.code = A2.uint32();
                break;
              case 7:
                o.reason = A2.string();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/StateLockAcquireResult";
        }, A;
      })(), StateLockUpdate = $root$1.StateLockUpdate = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.target = "", A.prototype.lock = "", A.prototype.flags = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.code = 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.target && Object.hasOwnProperty.call(A2, "target") && e.uint32(10).string(A2.target), null != A2.lock && Object.hasOwnProperty.call(A2, "lock") && e.uint32(18).string(A2.lock), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(24).uint64(A2.flags), null != A2.code && Object.hasOwnProperty.call(A2, "code") && e.uint32(32).uint32(A2.code), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.StateLockUpdate();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.target = A2.string();
                break;
              case 2:
                o.lock = A2.string();
                break;
              case 3:
                o.flags = A2.uint64();
                break;
              case 4:
                o.code = A2.uint32();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/StateLockUpdate";
        }, A;
      })(), StateLockReleaseResult = $root$1.StateLockReleaseResult = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.target = "", A.prototype.lock = "", A.prototype.requestUuid = "", A.prototype.flags = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.code = 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.target && Object.hasOwnProperty.call(A2, "target") && e.uint32(10).string(A2.target), null != A2.lock && Object.hasOwnProperty.call(A2, "lock") && e.uint32(18).string(A2.lock), null != A2.requestUuid && Object.hasOwnProperty.call(A2, "requestUuid") && e.uint32(26).string(A2.requestUuid), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(32).uint64(A2.flags), null != A2.code && Object.hasOwnProperty.call(A2, "code") && e.uint32(40).uint32(A2.code), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.StateLockReleaseResult();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.target = A2.string();
                break;
              case 2:
                o.lock = A2.string();
                break;
              case 3:
                o.requestUuid = A2.string();
                break;
              case 4:
                o.flags = A2.uint64();
                break;
              case 5:
                o.code = A2.uint32();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/StateLockReleaseResult";
        }, A;
      })(), StateLockDisable = $root$1.StateLockDisable = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.target = "", A.prototype.lock = "", A.prototype.userId = "", A.prototype.requestUuid = "", A.prototype.flags = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.target && Object.hasOwnProperty.call(A2, "target") && e.uint32(10).string(A2.target), null != A2.lock && Object.hasOwnProperty.call(A2, "lock") && e.uint32(18).string(A2.lock), null != A2.userId && Object.hasOwnProperty.call(A2, "userId") && e.uint32(26).string(A2.userId), null != A2.requestUuid && Object.hasOwnProperty.call(A2, "requestUuid") && e.uint32(34).string(A2.requestUuid), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(40).uint64(A2.flags), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.StateLockDisable();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.target = A2.string();
                break;
              case 2:
                o.lock = A2.string();
                break;
              case 3:
                o.userId = A2.string();
                break;
              case 4:
                o.requestUuid = A2.string();
                break;
              case 5:
                o.flags = A2.uint64();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/StateLockDisable";
        }, A;
      })(), StateLockDisableResult = $root$1.StateLockDisableResult = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.target = "", A.prototype.lock = "", A.prototype.requestUuid = "", A.prototype.flags = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.code = 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.target && Object.hasOwnProperty.call(A2, "target") && e.uint32(10).string(A2.target), null != A2.lock && Object.hasOwnProperty.call(A2, "lock") && e.uint32(18).string(A2.lock), null != A2.requestUuid && Object.hasOwnProperty.call(A2, "requestUuid") && e.uint32(26).string(A2.requestUuid), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(32).uint64(A2.flags), null != A2.code && Object.hasOwnProperty.call(A2, "code") && e.uint32(40).uint32(A2.code), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.StateLockDisableResult();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.target = A2.string();
                break;
              case 2:
                o.lock = A2.string();
                break;
              case 3:
                o.requestUuid = A2.string();
                break;
              case 4:
                o.flags = A2.uint64();
                break;
              case 5:
                o.code = A2.uint32();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/StateLockDisableResult";
        }, A;
      })(), StateLockSubscribe = $root$1.StateLockSubscribe = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.target = "", A.prototype.sequence = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.flags = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.target && Object.hasOwnProperty.call(A2, "target") && e.uint32(10).string(A2.target), null != A2.sequence && Object.hasOwnProperty.call(A2, "sequence") && e.uint32(16).uint64(A2.sequence), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(24).uint64(A2.flags), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.StateLockSubscribe();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.target = A2.string();
                break;
              case 2:
                o.sequence = A2.uint64();
                break;
              case 3:
                o.flags = A2.uint64();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/StateLockSubscribe";
        }, A;
      })(), StateLockSubscribeResult = $root$1.StateLockSubscribeResult = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.target = "", A.prototype.sequence = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.code = 0, A.prototype.flags = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.target && Object.hasOwnProperty.call(A2, "target") && e.uint32(10).string(A2.target), null != A2.sequence && Object.hasOwnProperty.call(A2, "sequence") && e.uint32(16).uint64(A2.sequence), null != A2.code && Object.hasOwnProperty.call(A2, "code") && e.uint32(24).uint32(A2.code), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(32).uint64(A2.flags), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.StateLockSubscribeResult();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.target = A2.string();
                break;
              case 2:
                o.sequence = A2.uint64();
                break;
              case 3:
                o.code = A2.uint32();
                break;
              case 4:
                o.flags = A2.uint64();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/StateLockSubscribeResult";
        }, A;
      })(), LockState = $root$1.LockState = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.lockName = "", A.prototype.lockState = "", A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.lockName && Object.hasOwnProperty.call(A2, "lockName") && e.uint32(10).string(A2.lockName), null != A2.lockState && Object.hasOwnProperty.call(A2, "lockState") && e.uint32(18).string(A2.lockState), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.LockState();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.lockName = A2.string();
                break;
              case 2:
                o.lockState = A2.string();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/LockState";
        }, A;
      })(), StateLockSubscribeEvent = $root$1.StateLockSubscribeEvent = (() => {
        function A(A2) {
          if (this.lockStates = [], A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.target = "", A.prototype.lockStates = $util$1.emptyArray, A.prototype.eventType = 0, A.prototype.flags = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.encode = function(A2, e) {
          if (e || (e = $Writer$1.create()), null != A2.target && Object.hasOwnProperty.call(A2, "target") && e.uint32(10).string(A2.target), null != A2.lockStates && A2.lockStates.length)
            for (let t = 0; t < A2.lockStates.length; ++t)
              $root$1.LockState.encode(A2.lockStates[t], e.uint32(18).fork()).ldelim();
          return null != A2.eventType && Object.hasOwnProperty.call(A2, "eventType") && e.uint32(24).int32(A2.eventType), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(32).uint64(A2.flags), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.StateLockSubscribeEvent();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.target = A2.string();
                break;
              case 2:
                o.lockStates && o.lockStates.length || (o.lockStates = []), o.lockStates.push($root$1.LockState.decode(A2, A2.uint32()));
                break;
              case 3:
                o.eventType = A2.int32();
                break;
              case 4:
                o.flags = A2.uint64();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/StateLockSubscribeEvent";
        }, A;
      })(), StateLockUnsubscribe = $root$1.StateLockUnsubscribe = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.target = "", A.prototype.sequence = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.flags = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.target && Object.hasOwnProperty.call(A2, "target") && e.uint32(10).string(A2.target), null != A2.sequence && Object.hasOwnProperty.call(A2, "sequence") && e.uint32(16).uint64(A2.sequence), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(24).uint64(A2.flags), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.StateLockUnsubscribe();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.target = A2.string();
                break;
              case 2:
                o.sequence = A2.uint64();
                break;
              case 3:
                o.flags = A2.uint64();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/StateLockUnsubscribe";
        }, A;
      })(), StateLockCreate = $root$1.StateLockCreate = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.target = "", A.prototype.lock = "", A.prototype.ttl = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.requestUuid = "", A.prototype.flags = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.target && Object.hasOwnProperty.call(A2, "target") && e.uint32(10).string(A2.target), null != A2.lock && Object.hasOwnProperty.call(A2, "lock") && e.uint32(18).string(A2.lock), null != A2.ttl && Object.hasOwnProperty.call(A2, "ttl") && e.uint32(24).uint64(A2.ttl), null != A2.requestUuid && Object.hasOwnProperty.call(A2, "requestUuid") && e.uint32(34).string(A2.requestUuid), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(40).uint64(A2.flags), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.StateLockCreate();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.target = A2.string();
                break;
              case 2:
                o.lock = A2.string();
                break;
              case 3:
                o.ttl = A2.uint64();
                break;
              case 4:
                o.requestUuid = A2.string();
                break;
              case 5:
                o.flags = A2.uint64();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/StateLockCreate";
        }, A;
      })(), StateLockCreateResult = $root$1.StateLockCreateResult = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.target = "", A.prototype.lock = "", A.prototype.code = 0, A.prototype.requestUuid = "", A.prototype.flags = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.target && Object.hasOwnProperty.call(A2, "target") && e.uint32(10).string(A2.target), null != A2.lock && Object.hasOwnProperty.call(A2, "lock") && e.uint32(18).string(A2.lock), null != A2.code && Object.hasOwnProperty.call(A2, "code") && e.uint32(24).uint32(A2.code), null != A2.requestUuid && Object.hasOwnProperty.call(A2, "requestUuid") && e.uint32(34).string(A2.requestUuid), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(40).uint64(A2.flags), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.StateLockCreateResult();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.target = A2.string();
                break;
              case 2:
                o.lock = A2.string();
                break;
              case 3:
                o.code = A2.uint32();
                break;
              case 4:
                o.requestUuid = A2.string();
                break;
              case 5:
                o.flags = A2.uint64();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/StateLockCreateResult";
        }, A;
      })(), StateLockDelete = $root$1.StateLockDelete = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.target = "", A.prototype.lock = "", A.prototype.requestUuid = "", A.prototype.flags = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.target && Object.hasOwnProperty.call(A2, "target") && e.uint32(10).string(A2.target), null != A2.lock && Object.hasOwnProperty.call(A2, "lock") && e.uint32(18).string(A2.lock), null != A2.requestUuid && Object.hasOwnProperty.call(A2, "requestUuid") && e.uint32(26).string(A2.requestUuid), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(32).uint64(A2.flags), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.StateLockDelete();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.target = A2.string();
                break;
              case 2:
                o.lock = A2.string();
                break;
              case 3:
                o.requestUuid = A2.string();
                break;
              case 4:
                o.flags = A2.uint64();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/StateLockDelete";
        }, A;
      })(), StateLockDeleteResult = $root$1.StateLockDeleteResult = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.target = "", A.prototype.lock = "", A.prototype.code = 0, A.prototype.requestUuid = "", A.prototype.flags = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.target && Object.hasOwnProperty.call(A2, "target") && e.uint32(10).string(A2.target), null != A2.lock && Object.hasOwnProperty.call(A2, "lock") && e.uint32(18).string(A2.lock), null != A2.code && Object.hasOwnProperty.call(A2, "code") && e.uint32(24).uint32(A2.code), null != A2.requestUuid && Object.hasOwnProperty.call(A2, "requestUuid") && e.uint32(34).string(A2.requestUuid), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(40).uint64(A2.flags), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.StateLockDeleteResult();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.target = A2.string();
                break;
              case 2:
                o.lock = A2.string();
                break;
              case 3:
                o.code = A2.uint32();
                break;
              case 4:
                o.requestUuid = A2.string();
                break;
              case 5:
                o.flags = A2.uint64();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/StateLockDeleteResult";
        }, A;
      })(), StateLockList = $root$1.StateLockList = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.target = "", A.prototype.sequence = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.flags = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.target && Object.hasOwnProperty.call(A2, "target") && e.uint32(10).string(A2.target), null != A2.sequence && Object.hasOwnProperty.call(A2, "sequence") && e.uint32(16).uint64(A2.sequence), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(24).uint64(A2.flags), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.StateLockList();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.target = A2.string();
                break;
              case 2:
                o.sequence = A2.uint64();
                break;
              case 3:
                o.flags = A2.uint64();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/StateLockList";
        }, A;
      })(), StateLockListResult = $root$1.StateLockListResult = (() => {
        function A(A2) {
          if (this.lockStates = [], A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.target = "", A.prototype.sequence = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.code = 0, A.prototype.lockStates = $util$1.emptyArray, A.prototype.flags = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.encode = function(A2, e) {
          if (e || (e = $Writer$1.create()), null != A2.target && Object.hasOwnProperty.call(A2, "target") && e.uint32(10).string(A2.target), null != A2.sequence && Object.hasOwnProperty.call(A2, "sequence") && e.uint32(16).uint64(A2.sequence), null != A2.code && Object.hasOwnProperty.call(A2, "code") && e.uint32(24).uint32(A2.code), null != A2.lockStates && A2.lockStates.length)
            for (let t = 0; t < A2.lockStates.length; ++t)
              $root$1.LockState.encode(A2.lockStates[t], e.uint32(34).fork()).ldelim();
          return null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(40).uint64(A2.flags), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.StateLockListResult();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.target = A2.string();
                break;
              case 2:
                o.sequence = A2.uint64();
                break;
              case 3:
                o.code = A2.uint32();
                break;
              case 4:
                o.lockStates && o.lockStates.length || (o.lockStates = []), o.lockStates.push($root$1.LockState.decode(A2, A2.uint32()));
                break;
              case 5:
                o.flags = A2.uint64();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/StateLockListResult";
        }, A;
      })(), SyncInit = $root$1.SyncInit = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.seq = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.seq && Object.hasOwnProperty.call(A2, "seq") && e.uint32(8).uint64(A2.seq), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.SyncInit();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            if (e2 >>> 3 == 1)
              o.seq = A2.uint64();
            else
              A2.skipType(7 & e2);
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/SyncInit";
        }, A;
      })(), SyncInit2 = $root$1.SyncInit2 = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.seq = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.seq && Object.hasOwnProperty.call(A2, "seq") && e.uint32(8).uint64(A2.seq), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.SyncInit2();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            if (e2 >>> 3 == 1)
              o.seq = A2.uint64();
            else
              A2.skipType(7 & e2);
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/SyncInit2";
        }, A;
      })(), SyncInitAck = $root$1.SyncInitAck = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.seq = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.code = 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.seq && Object.hasOwnProperty.call(A2, "seq") && e.uint32(8).uint64(A2.seq), null != A2.code && Object.hasOwnProperty.call(A2, "code") && e.uint32(16).uint32(A2.code), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.SyncInitAck();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.seq = A2.uint64();
                break;
              case 2:
                o.code = A2.uint32();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/SyncInitAck";
        }, A;
      })(), SyncFin = $root$1.SyncFin = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.code = 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.code && Object.hasOwnProperty.call(A2, "code") && e.uint32(8).uint32(A2.code), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.SyncFin();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            if (e2 >>> 3 == 1)
              o.code = A2.uint32();
            else
              A2.skipType(7 & e2);
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/SyncFin";
        }, A;
      })(), StateHistoryGet2 = $root$1.StateHistoryGet2 = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.uuid = "", A.prototype.startTime = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.endTime = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.dst = "", A.prototype.count = 0, A.prototype.flags = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer$1.create()), null != A2.uuid && Object.hasOwnProperty.call(A2, "uuid") && e.uint32(10).string(A2.uuid), null != A2.startTime && Object.hasOwnProperty.call(A2, "startTime") && e.uint32(16).uint64(A2.startTime), null != A2.endTime && Object.hasOwnProperty.call(A2, "endTime") && e.uint32(24).uint64(A2.endTime), null != A2.dst && Object.hasOwnProperty.call(A2, "dst") && e.uint32(34).string(A2.dst), null != A2.count && Object.hasOwnProperty.call(A2, "count") && e.uint32(40).uint32(A2.count), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(48).uint64(A2.flags), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.StateHistoryGet2();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.uuid = A2.string();
                break;
              case 2:
                o.startTime = A2.uint64();
                break;
              case 3:
                o.endTime = A2.uint64();
                break;
              case 4:
                o.dst = A2.string();
                break;
              case 5:
                o.count = A2.uint32();
                break;
              case 6:
                o.flags = A2.uint64();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/StateHistoryGet2";
        }, A;
      })(), HistoryRecord2 = $root$1.HistoryRecord2 = (() => {
        function A(A2) {
          if (this.details = {}, A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.src = "", A.prototype.payload = $util$1.newBuffer([]), A.prototype.options = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.ms = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.details = $util$1.emptyObject, A.encode = function(A2, e) {
          if (e || (e = $Writer$1.create()), null != A2.src && Object.hasOwnProperty.call(A2, "src") && e.uint32(10).string(A2.src), null != A2.payload && Object.hasOwnProperty.call(A2, "payload") && e.uint32(18).bytes(A2.payload), null != A2.options && Object.hasOwnProperty.call(A2, "options") && e.uint32(24).uint64(A2.options), null != A2.ms && Object.hasOwnProperty.call(A2, "ms") && e.uint32(32).uint64(A2.ms), null != A2.details && Object.hasOwnProperty.call(A2, "details"))
            for (let t = Object.keys(A2.details), g = 0; g < t.length; ++g)
              e.uint32(42).fork().uint32(10).string(t[g]).uint32(18).bytes(A2.details[t[g]]).ldelim();
          return e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g, o, I = void 0 === e ? A2.len : A2.pos + e, i2 = new $root$1.HistoryRecord2();
          for (; A2.pos < I; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                i2.src = A2.string();
                break;
              case 2:
                i2.payload = A2.bytes();
                break;
              case 3:
                i2.options = A2.uint64();
                break;
              case 4:
                i2.ms = A2.uint64();
                break;
              case 5: {
                i2.details === $util$1.emptyObject && (i2.details = {});
                let e3 = A2.uint32() + A2.pos;
                for (g = "", o = []; A2.pos < e3; ) {
                  let e4 = A2.uint32();
                  switch (e4 >>> 3) {
                    case 1:
                      g = A2.string();
                      break;
                    case 2:
                      o = A2.bytes();
                      break;
                    default:
                      A2.skipType(7 & e4);
                  }
                }
                i2.details[g] = o;
                break;
              }
              default:
                A2.skipType(7 & e2);
            }
          }
          return i2;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/HistoryRecord2";
        }, A;
      })(), StateHistoryGetResult2 = $root$1.StateHistoryGetResult2 = (() => {
        function A(A2) {
          if (this.messages = [], A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.uuid = "", A.prototype.startTime = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.endTime = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.dst = "", A.prototype.messages = $util$1.emptyArray, A.prototype.flags = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.code = 0, A.prototype.more = false, A.prototype.latestTime = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.prototype.oldestTime = $util$1.Long ? $util$1.Long.fromBits(0, 0, true) : 0, A.encode = function(A2, e) {
          if (e || (e = $Writer$1.create()), null != A2.uuid && Object.hasOwnProperty.call(A2, "uuid") && e.uint32(10).string(A2.uuid), null != A2.startTime && Object.hasOwnProperty.call(A2, "startTime") && e.uint32(16).uint64(A2.startTime), null != A2.endTime && Object.hasOwnProperty.call(A2, "endTime") && e.uint32(24).uint64(A2.endTime), null != A2.dst && Object.hasOwnProperty.call(A2, "dst") && e.uint32(34).string(A2.dst), null != A2.messages && A2.messages.length)
            for (let t = 0; t < A2.messages.length; ++t)
              $root$1.HistoryRecord2.encode(A2.messages[t], e.uint32(42).fork()).ldelim();
          return null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(48).uint64(A2.flags), null != A2.code && Object.hasOwnProperty.call(A2, "code") && e.uint32(56).uint32(A2.code), null != A2.more && Object.hasOwnProperty.call(A2, "more") && e.uint32(64).bool(A2.more), null != A2.latestTime && Object.hasOwnProperty.call(A2, "latestTime") && e.uint32(72).uint64(A2.latestTime), null != A2.oldestTime && Object.hasOwnProperty.call(A2, "oldestTime") && e.uint32(80).uint64(A2.oldestTime), e;
        }, A.decode = function(A2, e, t) {
          A2 instanceof $Reader || (A2 = $Reader.create(A2));
          let g = void 0 === e ? A2.len : A2.pos + e, o = new $root$1.StateHistoryGetResult2();
          for (; A2.pos < g; ) {
            let e2 = A2.uint32();
            if (e2 === t)
              break;
            switch (e2 >>> 3) {
              case 1:
                o.uuid = A2.string();
                break;
              case 2:
                o.startTime = A2.uint64();
                break;
              case 3:
                o.endTime = A2.uint64();
                break;
              case 4:
                o.dst = A2.string();
                break;
              case 5:
                o.messages && o.messages.length || (o.messages = []), o.messages.push($root$1.HistoryRecord2.decode(A2, A2.uint32()));
                break;
              case 6:
                o.flags = A2.uint64();
                break;
              case 7:
                o.code = A2.uint32();
                break;
              case 8:
                o.more = A2.bool();
                break;
              case 9:
                o.latestTime = A2.uint64();
                break;
              case 10:
                o.oldestTime = A2.uint64();
                break;
              default:
                A2.skipType(7 & e2);
            }
          }
          return o;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/StateHistoryGetResult2";
        }, A;
      })(), URI$1 = $root$1.URI = (() => {
        const A = {}, e = Object.create(A);
        return e[A[0] = "Unknown"] = 0, e[A[1] = "PingUri"] = 1, e[A[2] = "PongUri"] = 2, e[A[3] = "Ping2Uri"] = 3, e[A[4] = "Ping3Uri"] = 4, e[A[5] = "Pong3Uri"] = 5, e[A[11] = "UserJoinUri"] = 11, e[A[12] = "UserRespUri"] = 12, e[A[15] = "UserTicketNearlyExpireUri"] = 15, e[A[16] = "UserRenewTokenReqUri"] = 16, e[A[17] = "UserRenewTokenRespUri"] = 17, e[A[18] = "UserJoin2Uri"] = 18, e[A[19] = "UserResp2Uri"] = 19, e[A[21] = "UserQuitUri"] = 21, e[A[22] = "UserDropUri"] = 22, e[A[24] = "UserQuit2Uri"] = 24, e[A[25] = "UserTicketNearlyExpire2Uri"] = 25, e[A[26] = "UserRenewToken2ReqUri"] = 26, e[A[27] = "UserRenewToken2RespUri"] = 27, e[A[31] = "GroupEnterUri"] = 31, e[A[32] = "GroupLeaveUri"] = 32, e[A[33] = "GroupReplyUri"] = 33, e[A[35] = "GroupDropUri"] = 35, e[A[230] = "GroupLeave2Uri"] = 230, e[A[36] = "GroupEnterNoticeUri"] = 36, e[A[37] = "GroupLeaveNoticeUri"] = 37, e[A[38] = "GroupEventNoticeUri"] = 38, e[A[39] = "GroupCountNoticeUri"] = 39, e[A[41] = "UserStatusListUri"] = 41, e[A[42] = "UserStatusResultUri"] = 42, e[A[51] = "GroupStatusListUri"] = 51, e[A[52] = "GroupStatusResultUri"] = 52, e[A[55] = "GroupAllUsersListUri"] = 55, e[A[56] = "GroupAllUsersResultUri"] = 56, e[A[100] = "MessageUri"] = 100, e[A[101] = "AckUri"] = 101, e[A[201] = "UserJoinNoticeUri"] = 201, e[A[202] = "UserQuitNoticeUri"] = 202, e[A[203] = "UserWaitNoticeUri"] = 203, e[A[301] = "UserAttributeGetUri"] = 301, e[A[302] = "UserAttributeRetUri"] = 302, e[A[303] = "UserAttributeSetUri"] = 303, e[A[304] = "UserAttributeModUri"] = 304, e[A[305] = "UserAttributeDelUri"] = 305, e[A[307] = "UserAttributeRspUri"] = 307, e[A[308] = "UserAttributeErrUri"] = 308, e[A[311] = "UserAttributeKeysGetUri"] = 311, e[A[312] = "UserAttributeKeysRetUri"] = 312, e[A[351] = "GroupAttributeGetUri"] = 351, e[A[352] = "GroupAttributeRetUri"] = 352, e[A[353] = "GroupAttributeSetUri"] = 353, e[A[354] = "GroupAttributeModUri"] = 354, e[A[355] = "GroupAttributeDelUri"] = 355, e[A[356] = "GroupAttributeAltUri"] = 356, e[A[357] = "GroupAttributeRspUri"] = 357, e[A[358] = "GroupAttributeErrUri"] = 358, e[A[361] = "GroupAttributeKeysGetUri"] = 361, e[A[362] = "GroupAttributeKeysRetUri"] = 362, e[A[401] = "SubscribeUserStatusUri"] = 401, e[A[402] = "UnsubscribeUserStatusUri"] = 402, e[A[499] = "SubscribeResponseUri"] = 499, e[A[601] = "StateSubscribeUri"] = 601, e[A[602] = "StateUpdateUri"] = 602, e[A[603] = "StateSubscribeResultUri"] = 603, e[A[604] = "StateUnsubscribeUri"] = 604, e[A[605] = "StateSetUri"] = 605, e[A[606] = "StateModifyUri"] = 606, e[A[607] = "StateRequestResultUri"] = 607, e[A[608] = "StateGetUri"] = 608, e[A[609] = "StateGetResultUri"] = 609, e[A[610] = "StateLockAcquireUri"] = 610, e[A[611] = "StateLockReleaseUri"] = 611, e[A[612] = "StateLockAcquireResultUri"] = 612, e[A[613] = "StateLockUpdateUri"] = 613, e[A[614] = "StateLockReleaseResultUri"] = 614, e[A[615] = "StateLockDisableUri"] = 615, e[A[616] = "StateLockDisableResultUri"] = 616, e[A[617] = "StateLockSubscribeUri"] = 617, e[A[618] = "StateLockSubscribeResultUri"] = 618, e[A[619] = "StateLockSubscribeEventUri"] = 619, e[A[620] = "StateLockUnsubscribeUri"] = 620, e[A[621] = "StateLockCreateUri"] = 621, e[A[622] = "StateLockCreateResultUri"] = 622, e[A[623] = "StateLockDeleteUri"] = 623, e[A[624] = "StateLockDeleteResultUri"] = 624, e[A[625] = "StateLockListUri"] = 625, e[A[626] = "StateLockListResultUri"] = 626, e[A[750] = "SyncPacketUri"] = 750, e[A[751] = "SyncInitUri"] = 751, e[A[752] = "SyncInitAckUri"] = 752, e[A[753] = "SyncFinUri"] = 753, e[A[633] = "StateHistoryGet2Uri"] = 633, e[A[634] = "StateHistoryGetResult2Uri"] = 634, e[A[754] = "SyncInit2Uri"] = 754, e;
      })(), UserJoinDetailKey = $root$1.UserJoinDetailKey = (() => {
        const A = {}, e = Object.create(A);
        return e[A[0] = "kDetailKeyUnused"] = 0, e[A[1] = "kDetailKeyConsoleConfig"] = 1, e[A[2] = "kDetailKeyKeepAliveInterval"] = 2, e[A[3] = "kDetailKeyKeepAliveBuffer"] = 3, e;
      })(), LockEventType = $root$1.LockEventType = (() => {
        const A = {}, e = Object.create(A);
        return e[A[0] = "LockUnknown"] = 0, e[A[1] = "LockAdded"] = 1, e[A[2] = "LockModified"] = 2, e[A[3] = "LockRemoved"] = 3, e[A[4] = "LockSnapshot"] = 4, e;
      })();
      var ProtoPackets$1 = Object.freeze({ __proto__: null, Ack, GroupAllUsersList, GroupAllUsersResult, GroupCountNotice, GroupDrop, GroupEnter, GroupEnterNotice, GroupLeave, GroupLeave2, GroupLeaveNotice, GroupReply, HistoryRecord2, LockEventType, LockState, Message, Ping3, Pong3, StateGet, StateGetResult, StateHistoryGet2, StateHistoryGetResult2, StateLockAcquire, StateLockAcquireResult, StateLockCreate, StateLockCreateResult, StateLockDelete, StateLockDeleteResult, StateLockDisable, StateLockDisableResult, StateLockList, StateLockListResult, StateLockRelease, StateLockReleaseResult, StateLockSubscribe, StateLockSubscribeEvent, StateLockSubscribeResult, StateLockUnsubscribe, StateLockUpdate, StateModify, StateRequestResult, StateSet, StateSubscribe, StateSubscribeResult, StateUnsubscribe, StateUpdate, SyncFin, SyncInit, SyncInit2, SyncInitAck, URI: URI$1, UserDrop, UserJoin2, UserJoinDetailKey, UserQuit2, UserRenewToken2Req, UserRenewToken2Resp, UserRenewTokenReq, UserRenewTokenResp, UserResp2, UserTicketNearlyExpire, UserTicketNearlyExpire2, Wrapper: Wrapper$1, default: $root$1 });
      const { URI } = $root$1, { Wrapper } = ProtoPackets$1, PacketsAndURI = _objectWithoutProperties(ProtoPackets$1, ["Wrapper"]), Packets = omit$1(PacketsAndURI, "URI", "LockEventType", "UserJoinDetailKey"), nameToUri = (A) => {
        const e = "".concat(A, "Uri"), t = URI[e];
        if ("number" != typeof t || 0 === t)
          throw new TypeError("Got Unknown URI Name");
        return t;
      };
      function uriToPacketName(A) {
        return URI[A].slice(0, -3);
      }
      function getWrappedByName(A, e) {
        const t = nameToUri(A), g = Packets[A], o = new g(e), I = g.encode(o).finish();
        return new Wrapper({ uri: t, data: I });
      }
      function getSyncWrapped(A) {
        return new Wrapper({ uri: URI.SyncPacketUri, data: A });
      }
      const getApUrl = (A) => {
        const e = getPrivateSettingsPortAndDomains([A]), t = e.port, g = e.hostname[0];
        return "https://".concat(g).concat(t ? ":".concat(t) : "", "/api/v1");
      };
      function getEdgeDomain(A, e, t, g) {
        if (true === getParameter("EDGE_USE_IP"))
          return A;
        const o = t && t[0], I = t && t[1];
        if (!(!e || !I) && validateIpPort(I))
          return I;
        return !!o && validateIpPort(o) ? o : "".concat(A.split(".").join("-"), ".edge.").concat(e ? I || o || g || "sd-rtn.com" : o || g || "agora.io");
      }
      const $Writer = minimal_1.Writer, $util = minimal_1.util, $root = minimal_1.roots.default || (minimal_1.roots.default = {}), Session = $root.Session = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.sid = "", A.prototype.userId = "", A.prototype.lts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.elapse = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.appId = "", A.prototype.ver = "", A.prototype.buildno = 0, A.prototype.installId = "", A.prototype.os = 0, A.prototype.did = "", A.prototype.index = null, A.prototype.token = "", A.prototype.version = 0, A.prototype.subVersion = 0, A.encode = function(A2, e) {
          return e || (e = $Writer.create()), null != A2.sid && Object.hasOwnProperty.call(A2, "sid") && e.uint32(10).string(A2.sid), null != A2.userId && Object.hasOwnProperty.call(A2, "userId") && e.uint32(18).string(A2.userId), null != A2.lts && Object.hasOwnProperty.call(A2, "lts") && e.uint32(24).int64(A2.lts), null != A2.elapse && Object.hasOwnProperty.call(A2, "elapse") && e.uint32(32).int64(A2.elapse), null != A2.appId && Object.hasOwnProperty.call(A2, "appId") && e.uint32(42).string(A2.appId), null != A2.ver && Object.hasOwnProperty.call(A2, "ver") && e.uint32(50).string(A2.ver), null != A2.buildno && Object.hasOwnProperty.call(A2, "buildno") && e.uint32(56).int32(A2.buildno), null != A2.installId && Object.hasOwnProperty.call(A2, "installId") && e.uint32(66).string(A2.installId), null != A2.os && Object.hasOwnProperty.call(A2, "os") && e.uint32(128).int32(A2.os), null != A2.did && Object.hasOwnProperty.call(A2, "did") && e.uint32(138).string(A2.did), null != A2.index && Object.hasOwnProperty.call(A2, "index") && $root.CommonIndex.encode(A2.index, e.uint32(162).fork()).ldelim(), null != A2.token && Object.hasOwnProperty.call(A2, "token") && e.uint32(170).string(A2.token), null != A2.version && Object.hasOwnProperty.call(A2, "version") && e.uint32(176).int32(A2.version), null != A2.subVersion && Object.hasOwnProperty.call(A2, "subVersion") && e.uint32(184).int32(A2.subVersion), e;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/Session";
        }, A.CommonIndex = function() {
          function A2(A3) {
            if (A3)
              for (let e = Object.keys(A3), t = 0; t < e.length; ++t)
                null != A3[e[t]] && (this[e[t]] = A3[e[t]]);
          }
          return A2.prototype.index1 = "", A2.prototype.index2 = "", A2.prototype.index3 = "", A2.encode = function(A3, e) {
            return e || (e = $Writer.create()), null != A3.index1 && Object.hasOwnProperty.call(A3, "index1") && e.uint32(10).string(A3.index1), null != A3.index2 && Object.hasOwnProperty.call(A3, "index2") && e.uint32(18).string(A3.index2), null != A3.index3 && Object.hasOwnProperty.call(A3, "index3") && e.uint32(26).string(A3.index3), e;
          }, A2.getTypeUrl = function(A3) {
            return void 0 === A3 && (A3 = "type.googleapis.com"), A3 + "/Session.CommonIndex";
          }, A2;
        }(), A;
      })(), ApEvent = $root.ApEvent = (() => {
        function A(A2) {
          if (this.linkServerList = [], A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.sid = "", A.prototype.userId = "", A.prototype.lts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.elapse = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.apAddr = "", A.prototype.linkServerList = $util.emptyArray, A.prototype.localWanIp = "", A.prototype.errCode = 0, A.prototype.serverErrCode = 0, A.prototype.isp = "", A.prototype.opId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.envId = 0, A.prototype.flag = 0, A.prototype.area = "", A.prototype.responseTime = 0, A.prototype.apLinkType = "", A.prototype.version = 0, A.prototype.subVersion = 0, A.prototype.connectionsequence = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.resultcount = 0, A.prototype.validresultcount = 0, A.prototype.newvalidresultcount = 0, A.encode = function(A2, e) {
          if (e || (e = $Writer.create()), null != A2.sid && Object.hasOwnProperty.call(A2, "sid") && e.uint32(10).string(A2.sid), null != A2.userId && Object.hasOwnProperty.call(A2, "userId") && e.uint32(18).string(A2.userId), null != A2.lts && Object.hasOwnProperty.call(A2, "lts") && e.uint32(24).int64(A2.lts), null != A2.elapse && Object.hasOwnProperty.call(A2, "elapse") && e.uint32(32).int64(A2.elapse), null != A2.apAddr && Object.hasOwnProperty.call(A2, "apAddr") && e.uint32(50).string(A2.apAddr), null != A2.linkServerList && A2.linkServerList.length)
            for (let t = 0; t < A2.linkServerList.length; ++t)
              e.uint32(58).string(A2.linkServerList[t]);
          return null != A2.localWanIp && Object.hasOwnProperty.call(A2, "localWanIp") && e.uint32(66).string(A2.localWanIp), null != A2.errCode && Object.hasOwnProperty.call(A2, "errCode") && e.uint32(72).int32(A2.errCode), null != A2.serverErrCode && Object.hasOwnProperty.call(A2, "serverErrCode") && e.uint32(80).int32(A2.serverErrCode), null != A2.isp && Object.hasOwnProperty.call(A2, "isp") && e.uint32(90).string(A2.isp), null != A2.opId && Object.hasOwnProperty.call(A2, "opId") && e.uint32(96).int64(A2.opId), null != A2.envId && Object.hasOwnProperty.call(A2, "envId") && e.uint32(104).int32(A2.envId), null != A2.flag && Object.hasOwnProperty.call(A2, "flag") && e.uint32(112).int32(A2.flag), null != A2.area && Object.hasOwnProperty.call(A2, "area") && e.uint32(122).string(A2.area), null != A2.responseTime && Object.hasOwnProperty.call(A2, "responseTime") && e.uint32(128).int32(A2.responseTime), null != A2.apLinkType && Object.hasOwnProperty.call(A2, "apLinkType") && e.uint32(138).string(A2.apLinkType), null != A2.version && Object.hasOwnProperty.call(A2, "version") && e.uint32(144).int32(A2.version), null != A2.subVersion && Object.hasOwnProperty.call(A2, "subVersion") && e.uint32(152).int32(A2.subVersion), null != A2.connectionsequence && Object.hasOwnProperty.call(A2, "connectionsequence") && e.uint32(160).int64(A2.connectionsequence), null != A2.resultcount && Object.hasOwnProperty.call(A2, "resultcount") && e.uint32(168).int32(A2.resultcount), null != A2.validresultcount && Object.hasOwnProperty.call(A2, "validresultcount") && e.uint32(176).int32(A2.validresultcount), null != A2.newvalidresultcount && Object.hasOwnProperty.call(A2, "newvalidresultcount") && e.uint32(184).int32(A2.newvalidresultcount), e;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/ApEvent";
        }, A;
      })(), ApRequest = $root.ApRequest = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.sid = "", A.prototype.userId = "", A.prototype.lts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.elapse = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.apAddr = "", A.prototype.opId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.envId = 0, A.prototype.flag = 0, A.prototype.version = 0, A.prototype.subVersion = 0, A.prototype.connectionsequence = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.rtmapflag = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer.create()), null != A2.sid && Object.hasOwnProperty.call(A2, "sid") && e.uint32(10).string(A2.sid), null != A2.userId && Object.hasOwnProperty.call(A2, "userId") && e.uint32(18).string(A2.userId), null != A2.lts && Object.hasOwnProperty.call(A2, "lts") && e.uint32(24).int64(A2.lts), null != A2.elapse && Object.hasOwnProperty.call(A2, "elapse") && e.uint32(32).int64(A2.elapse), null != A2.apAddr && Object.hasOwnProperty.call(A2, "apAddr") && e.uint32(42).string(A2.apAddr), null != A2.opId && Object.hasOwnProperty.call(A2, "opId") && e.uint32(48).int64(A2.opId), null != A2.envId && Object.hasOwnProperty.call(A2, "envId") && e.uint32(56).int32(A2.envId), null != A2.flag && Object.hasOwnProperty.call(A2, "flag") && e.uint32(64).int32(A2.flag), null != A2.version && Object.hasOwnProperty.call(A2, "version") && e.uint32(72).int32(A2.version), null != A2.subVersion && Object.hasOwnProperty.call(A2, "subVersion") && e.uint32(80).int32(A2.subVersion), null != A2.connectionsequence && Object.hasOwnProperty.call(A2, "connectionsequence") && e.uint32(88).int64(A2.connectionsequence), null != A2.rtmapflag && Object.hasOwnProperty.call(A2, "rtmapflag") && e.uint32(96).int64(A2.rtmapflag), e;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/ApRequest";
        }, A;
      })(), LinkLoginRequest = $root.LinkLoginRequest = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.sid = "", A.prototype.userId = "", A.prototype.lts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.elapse = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.destServerIp = "", A.prototype.linkId = 0, A.encode = function(A2, e) {
          return e || (e = $Writer.create()), null != A2.sid && Object.hasOwnProperty.call(A2, "sid") && e.uint32(10).string(A2.sid), null != A2.userId && Object.hasOwnProperty.call(A2, "userId") && e.uint32(18).string(A2.userId), null != A2.lts && Object.hasOwnProperty.call(A2, "lts") && e.uint32(24).int64(A2.lts), null != A2.elapse && Object.hasOwnProperty.call(A2, "elapse") && e.uint32(32).int64(A2.elapse), null != A2.destServerIp && Object.hasOwnProperty.call(A2, "destServerIp") && e.uint32(42).string(A2.destServerIp), null != A2.linkId && Object.hasOwnProperty.call(A2, "linkId") && e.uint32(48).int32(A2.linkId), e;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/LinkLoginRequest";
        }, A;
      })(), Link = $root.Link = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.sid = "", A.prototype.userId = "", A.prototype.lts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.elapse = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.ec = 0, A.prototype.sc = 0, A.prototype.destServerIp = "", A.prototype.ackedServerIp = "", A.prototype.responseTime = 0, A.prototype.version = 0, A.prototype.subVersion = 0, A.prototype.connectionsequence = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.linktype = 0, A.prototype.linkflag = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.linkenv = 0, A.encode = function(A2, e) {
          return e || (e = $Writer.create()), null != A2.sid && Object.hasOwnProperty.call(A2, "sid") && e.uint32(10).string(A2.sid), null != A2.userId && Object.hasOwnProperty.call(A2, "userId") && e.uint32(18).string(A2.userId), null != A2.lts && Object.hasOwnProperty.call(A2, "lts") && e.uint32(24).int64(A2.lts), null != A2.elapse && Object.hasOwnProperty.call(A2, "elapse") && e.uint32(32).int64(A2.elapse), null != A2.ec && Object.hasOwnProperty.call(A2, "ec") && e.uint32(40).int32(A2.ec), null != A2.sc && Object.hasOwnProperty.call(A2, "sc") && e.uint32(48).int32(A2.sc), null != A2.destServerIp && Object.hasOwnProperty.call(A2, "destServerIp") && e.uint32(58).string(A2.destServerIp), null != A2.ackedServerIp && Object.hasOwnProperty.call(A2, "ackedServerIp") && e.uint32(66).string(A2.ackedServerIp), null != A2.responseTime && Object.hasOwnProperty.call(A2, "responseTime") && e.uint32(72).int32(A2.responseTime), null != A2.version && Object.hasOwnProperty.call(A2, "version") && e.uint32(80).int32(A2.version), null != A2.subVersion && Object.hasOwnProperty.call(A2, "subVersion") && e.uint32(88).int32(A2.subVersion), null != A2.connectionsequence && Object.hasOwnProperty.call(A2, "connectionsequence") && e.uint32(96).int64(A2.connectionsequence), null != A2.linktype && Object.hasOwnProperty.call(A2, "linktype") && e.uint32(104).int32(A2.linktype), null != A2.linkflag && Object.hasOwnProperty.call(A2, "linkflag") && e.uint32(112).int64(A2.linkflag), null != A2.linkenv && Object.hasOwnProperty.call(A2, "linkenv") && e.uint32(120).int32(A2.linkenv), e;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/Link";
        }, A;
      })(), Logout = $root.Logout = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.sid = "", A.prototype.userId = "", A.prototype.lts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.elapse = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.version = 0, A.prototype.subVersion = 0, A.prototype.connectionsequence = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.linktype = 0, A.prototype.linkflag = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.linkenv = 0, A.encode = function(A2, e) {
          return e || (e = $Writer.create()), null != A2.sid && Object.hasOwnProperty.call(A2, "sid") && e.uint32(10).string(A2.sid), null != A2.userId && Object.hasOwnProperty.call(A2, "userId") && e.uint32(18).string(A2.userId), null != A2.lts && Object.hasOwnProperty.call(A2, "lts") && e.uint32(24).int64(A2.lts), null != A2.elapse && Object.hasOwnProperty.call(A2, "elapse") && e.uint32(32).int64(A2.elapse), null != A2.version && Object.hasOwnProperty.call(A2, "version") && e.uint32(40).int32(A2.version), null != A2.subVersion && Object.hasOwnProperty.call(A2, "subVersion") && e.uint32(48).int32(A2.subVersion), null != A2.connectionsequence && Object.hasOwnProperty.call(A2, "connectionsequence") && e.uint32(56).int64(A2.connectionsequence), null != A2.linktype && Object.hasOwnProperty.call(A2, "linktype") && e.uint32(64).int32(A2.linktype), null != A2.linkflag && Object.hasOwnProperty.call(A2, "linkflag") && e.uint32(72).int64(A2.linkflag), null != A2.linkenv && Object.hasOwnProperty.call(A2, "linkenv") && e.uint32(80).int32(A2.linkenv), e;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/Logout";
        }, A;
      })(), KickedOff = $root.KickedOff = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.sid = "", A.prototype.userId = "", A.prototype.lts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.elapse = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.linkId = 0, A.prototype.code = 0, A.prototype.server = "", A.prototype.serverCode = 0, A.encode = function(A2, e) {
          return e || (e = $Writer.create()), null != A2.sid && Object.hasOwnProperty.call(A2, "sid") && e.uint32(10).string(A2.sid), null != A2.userId && Object.hasOwnProperty.call(A2, "userId") && e.uint32(18).string(A2.userId), null != A2.lts && Object.hasOwnProperty.call(A2, "lts") && e.uint32(24).int64(A2.lts), null != A2.elapse && Object.hasOwnProperty.call(A2, "elapse") && e.uint32(32).int64(A2.elapse), null != A2.linkId && Object.hasOwnProperty.call(A2, "linkId") && e.uint32(48).int32(A2.linkId), null != A2.code && Object.hasOwnProperty.call(A2, "code") && e.uint32(56).int32(A2.code), null != A2.server && Object.hasOwnProperty.call(A2, "server") && e.uint32(66).string(A2.server), null != A2.serverCode && Object.hasOwnProperty.call(A2, "serverCode") && e.uint32(72).int32(A2.serverCode), e;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/KickedOff";
        }, A;
      })(), ChnJoin = $root.ChnJoin = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.sid = "", A.prototype.userId = "", A.prototype.lts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.elapse = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.cname = "", A.prototype.errCode = 0, A.prototype.seq = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.joinFlag = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer.create()), null != A2.sid && Object.hasOwnProperty.call(A2, "sid") && e.uint32(10).string(A2.sid), null != A2.userId && Object.hasOwnProperty.call(A2, "userId") && e.uint32(18).string(A2.userId), null != A2.lts && Object.hasOwnProperty.call(A2, "lts") && e.uint32(24).int64(A2.lts), null != A2.elapse && Object.hasOwnProperty.call(A2, "elapse") && e.uint32(32).int64(A2.elapse), null != A2.cname && Object.hasOwnProperty.call(A2, "cname") && e.uint32(50).string(A2.cname), null != A2.errCode && Object.hasOwnProperty.call(A2, "errCode") && e.uint32(56).int32(A2.errCode), null != A2.seq && Object.hasOwnProperty.call(A2, "seq") && e.uint32(64).int64(A2.seq), null != A2.joinFlag && Object.hasOwnProperty.call(A2, "joinFlag") && e.uint32(72).int64(A2.joinFlag), e;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/ChnJoin";
        }, A;
      })(), ChnJoinRes = $root.ChnJoinRes = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.sid = "", A.prototype.userId = "", A.prototype.lts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.elapse = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.cname = "", A.prototype.errCode = 0, A.prototype.serverErrCode = 0, A.prototype.seq = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer.create()), null != A2.sid && Object.hasOwnProperty.call(A2, "sid") && e.uint32(10).string(A2.sid), null != A2.userId && Object.hasOwnProperty.call(A2, "userId") && e.uint32(18).string(A2.userId), null != A2.lts && Object.hasOwnProperty.call(A2, "lts") && e.uint32(24).int64(A2.lts), null != A2.elapse && Object.hasOwnProperty.call(A2, "elapse") && e.uint32(32).int64(A2.elapse), null != A2.cname && Object.hasOwnProperty.call(A2, "cname") && e.uint32(50).string(A2.cname), null != A2.errCode && Object.hasOwnProperty.call(A2, "errCode") && e.uint32(56).int32(A2.errCode), null != A2.serverErrCode && Object.hasOwnProperty.call(A2, "serverErrCode") && e.uint32(64).int32(A2.serverErrCode), null != A2.seq && Object.hasOwnProperty.call(A2, "seq") && e.uint32(72).int64(A2.seq), e;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/ChnJoinRes";
        }, A;
      })(), ChnLeave = $root.ChnLeave = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.sid = "", A.prototype.userId = "", A.prototype.lts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.elapse = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.cname = "", A.prototype.errCode = 0, A.encode = function(A2, e) {
          return e || (e = $Writer.create()), null != A2.sid && Object.hasOwnProperty.call(A2, "sid") && e.uint32(10).string(A2.sid), null != A2.userId && Object.hasOwnProperty.call(A2, "userId") && e.uint32(18).string(A2.userId), null != A2.lts && Object.hasOwnProperty.call(A2, "lts") && e.uint32(24).int64(A2.lts), null != A2.elapse && Object.hasOwnProperty.call(A2, "elapse") && e.uint32(32).int64(A2.elapse), null != A2.cname && Object.hasOwnProperty.call(A2, "cname") && e.uint32(50).string(A2.cname), null != A2.errCode && Object.hasOwnProperty.call(A2, "errCode") && e.uint32(56).int32(A2.errCode), e;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/ChnLeave";
        }, A;
      })(), LinkTcpEvent = $root.LinkTcpEvent = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.sid = "", A.prototype.userId = "", A.prototype.lts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.elapse = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.destServerIp = "", A.prototype.action = "", A.prototype.code = 0, A.prototype.responseTime = 0, A.prototype.version = 0, A.prototype.subVersion = 0, A.prototype.connectionsequence = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.linktype = 0, A.prototype.linkflag = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.linkenv = 0, A.encode = function(A2, e) {
          return e || (e = $Writer.create()), null != A2.sid && Object.hasOwnProperty.call(A2, "sid") && e.uint32(10).string(A2.sid), null != A2.userId && Object.hasOwnProperty.call(A2, "userId") && e.uint32(18).string(A2.userId), null != A2.lts && Object.hasOwnProperty.call(A2, "lts") && e.uint32(24).int64(A2.lts), null != A2.elapse && Object.hasOwnProperty.call(A2, "elapse") && e.uint32(32).int64(A2.elapse), null != A2.destServerIp && Object.hasOwnProperty.call(A2, "destServerIp") && e.uint32(42).string(A2.destServerIp), null != A2.action && Object.hasOwnProperty.call(A2, "action") && e.uint32(50).string(A2.action), null != A2.code && Object.hasOwnProperty.call(A2, "code") && e.uint32(56).int32(A2.code), null != A2.responseTime && Object.hasOwnProperty.call(A2, "responseTime") && e.uint32(64).int32(A2.responseTime), null != A2.version && Object.hasOwnProperty.call(A2, "version") && e.uint32(72).int32(A2.version), null != A2.subVersion && Object.hasOwnProperty.call(A2, "subVersion") && e.uint32(80).int32(A2.subVersion), null != A2.connectionsequence && Object.hasOwnProperty.call(A2, "connectionsequence") && e.uint32(88).int64(A2.connectionsequence), null != A2.linktype && Object.hasOwnProperty.call(A2, "linktype") && e.uint32(96).int32(A2.linktype), null != A2.linkflag && Object.hasOwnProperty.call(A2, "linkflag") && e.uint32(104).int64(A2.linkflag), null != A2.linkenv && Object.hasOwnProperty.call(A2, "linkenv") && e.uint32(112).int32(A2.linkenv), e;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/LinkTcpEvent";
        }, A;
      })(), SyncOperateEvent = $root.SyncOperateEvent = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.lts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.ip = "", A.prototype.userid = "", A.prototype.vid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.sid = "", A.prototype.requestts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.replyts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.target = "", A.prototype.eventtype = "", A.prototype.revision = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.uuid = "", A.prototype.sdktype = 0, A.prototype.flags = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.code = 0, A.prototype.seq = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.index = null, A.prototype.lock = "", A.prototype.lockrev = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.subtarget = "", A.prototype.usersid = "", A.prototype.sdkip = "", A.encode = function(A2, e) {
          return e || (e = $Writer.create()), null != A2.lts && Object.hasOwnProperty.call(A2, "lts") && e.uint32(8).int64(A2.lts), null != A2.ip && Object.hasOwnProperty.call(A2, "ip") && e.uint32(18).string(A2.ip), null != A2.userid && Object.hasOwnProperty.call(A2, "userid") && e.uint32(26).string(A2.userid), null != A2.vid && Object.hasOwnProperty.call(A2, "vid") && e.uint32(32).int64(A2.vid), null != A2.sid && Object.hasOwnProperty.call(A2, "sid") && e.uint32(42).string(A2.sid), null != A2.requestts && Object.hasOwnProperty.call(A2, "requestts") && e.uint32(48).int64(A2.requestts), null != A2.replyts && Object.hasOwnProperty.call(A2, "replyts") && e.uint32(56).int64(A2.replyts), null != A2.target && Object.hasOwnProperty.call(A2, "target") && e.uint32(66).string(A2.target), null != A2.eventtype && Object.hasOwnProperty.call(A2, "eventtype") && e.uint32(74).string(A2.eventtype), null != A2.revision && Object.hasOwnProperty.call(A2, "revision") && e.uint32(80).int64(A2.revision), null != A2.uuid && Object.hasOwnProperty.call(A2, "uuid") && e.uint32(90).string(A2.uuid), null != A2.sdktype && Object.hasOwnProperty.call(A2, "sdktype") && e.uint32(96).int32(A2.sdktype), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(104).int64(A2.flags), null != A2.code && Object.hasOwnProperty.call(A2, "code") && e.uint32(112).int32(A2.code), null != A2.seq && Object.hasOwnProperty.call(A2, "seq") && e.uint32(120).int64(A2.seq), null != A2.index && Object.hasOwnProperty.call(A2, "index") && $root.CommonIndex.encode(A2.index, e.uint32(130).fork()).ldelim(), null != A2.lock && Object.hasOwnProperty.call(A2, "lock") && e.uint32(138).string(A2.lock), null != A2.lockrev && Object.hasOwnProperty.call(A2, "lockrev") && e.uint32(144).int64(A2.lockrev), null != A2.subtarget && Object.hasOwnProperty.call(A2, "subtarget") && e.uint32(154).string(A2.subtarget), null != A2.usersid && Object.hasOwnProperty.call(A2, "usersid") && e.uint32(162).string(A2.usersid), null != A2.sdkip && Object.hasOwnProperty.call(A2, "sdkip") && e.uint32(170).string(A2.sdkip), e;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/SyncOperateEvent";
        }, A;
      })(), SyncSubscribeEvent = $root.SyncSubscribeEvent = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.lts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.userid = "", A.prototype.vid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.sid = "", A.prototype.target = "", A.prototype.eventtype = "", A.prototype.sdktype = 0, A.prototype.flags = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.code = 0, A.prototype.seq = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.requestts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.replyts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.index = null, A.prototype.subtarget = "", A.prototype.usersid = "", A.encode = function(A2, e) {
          return e || (e = $Writer.create()), null != A2.lts && Object.hasOwnProperty.call(A2, "lts") && e.uint32(8).int64(A2.lts), null != A2.userid && Object.hasOwnProperty.call(A2, "userid") && e.uint32(26).string(A2.userid), null != A2.vid && Object.hasOwnProperty.call(A2, "vid") && e.uint32(32).int64(A2.vid), null != A2.sid && Object.hasOwnProperty.call(A2, "sid") && e.uint32(42).string(A2.sid), null != A2.target && Object.hasOwnProperty.call(A2, "target") && e.uint32(66).string(A2.target), null != A2.eventtype && Object.hasOwnProperty.call(A2, "eventtype") && e.uint32(74).string(A2.eventtype), null != A2.sdktype && Object.hasOwnProperty.call(A2, "sdktype") && e.uint32(96).int32(A2.sdktype), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(104).int64(A2.flags), null != A2.code && Object.hasOwnProperty.call(A2, "code") && e.uint32(112).int32(A2.code), null != A2.seq && Object.hasOwnProperty.call(A2, "seq") && e.uint32(120).int64(A2.seq), null != A2.requestts && Object.hasOwnProperty.call(A2, "requestts") && e.uint32(128).int64(A2.requestts), null != A2.replyts && Object.hasOwnProperty.call(A2, "replyts") && e.uint32(136).int64(A2.replyts), null != A2.index && Object.hasOwnProperty.call(A2, "index") && $root.CommonIndex.encode(A2.index, e.uint32(146).fork()).ldelim(), null != A2.subtarget && Object.hasOwnProperty.call(A2, "subtarget") && e.uint32(154).string(A2.subtarget), null != A2.usersid && Object.hasOwnProperty.call(A2, "usersid") && e.uint32(162).string(A2.usersid), e;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/SyncSubscribeEvent";
        }, A;
      })(), SyncUpdateEvent = $root.SyncUpdateEvent = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.lts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.userid = "", A.prototype.vid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.sid = "", A.prototype.replyts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.target = "", A.prototype.eventtype = "", A.prototype.revision = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.sdktype = 0, A.prototype.flags = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.count = 0, A.prototype.delta = 0, A.prototype.code = 0, A.prototype.index = null, A.prototype.subtarget = "", A.encode = function(A2, e) {
          return e || (e = $Writer.create()), null != A2.lts && Object.hasOwnProperty.call(A2, "lts") && e.uint32(8).int64(A2.lts), null != A2.userid && Object.hasOwnProperty.call(A2, "userid") && e.uint32(26).string(A2.userid), null != A2.vid && Object.hasOwnProperty.call(A2, "vid") && e.uint32(32).int64(A2.vid), null != A2.sid && Object.hasOwnProperty.call(A2, "sid") && e.uint32(42).string(A2.sid), null != A2.replyts && Object.hasOwnProperty.call(A2, "replyts") && e.uint32(56).int64(A2.replyts), null != A2.target && Object.hasOwnProperty.call(A2, "target") && e.uint32(66).string(A2.target), null != A2.eventtype && Object.hasOwnProperty.call(A2, "eventtype") && e.uint32(74).string(A2.eventtype), null != A2.revision && Object.hasOwnProperty.call(A2, "revision") && e.uint32(80).int64(A2.revision), null != A2.sdktype && Object.hasOwnProperty.call(A2, "sdktype") && e.uint32(96).int32(A2.sdktype), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(104).int64(A2.flags), null != A2.count && Object.hasOwnProperty.call(A2, "count") && e.uint32(112).int32(A2.count), null != A2.delta && Object.hasOwnProperty.call(A2, "delta") && e.uint32(120).int32(A2.delta), null != A2.code && Object.hasOwnProperty.call(A2, "code") && e.uint32(128).int32(A2.code), null != A2.index && Object.hasOwnProperty.call(A2, "index") && $root.CommonIndex.encode(A2.index, e.uint32(138).fork()).ldelim(), null != A2.subtarget && Object.hasOwnProperty.call(A2, "subtarget") && e.uint32(162).string(A2.subtarget), e;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/SyncUpdateEvent";
        }, A;
      })(), CommonIndex = $root.CommonIndex = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.index1 = "", A.prototype.index2 = "", A.prototype.index3 = "", A.encode = function(A2, e) {
          return e || (e = $Writer.create()), null != A2.index1 && Object.hasOwnProperty.call(A2, "index1") && e.uint32(10).string(A2.index1), null != A2.index2 && Object.hasOwnProperty.call(A2, "index2") && e.uint32(18).string(A2.index2), null != A2.index3 && Object.hasOwnProperty.call(A2, "index3") && e.uint32(26).string(A2.index3), e;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/CommonIndex";
        }, A;
      })(), ProtoRaws = $root.ProtoRaws = (() => {
        function A(A2) {
          if (this.payloads = [], A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.sendTs = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.payloads = $util.emptyArray, A.prototype.vid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.aid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.encode = function(A2, e) {
          if (e || (e = $Writer.create()), null != A2.sendTs && Object.hasOwnProperty.call(A2, "sendTs") && e.uint32(8).int64(A2.sendTs), null != A2.payloads && A2.payloads.length)
            for (let t = 0; t < A2.payloads.length; ++t)
              $root.ProtoRaws.MessageInfo.encode(A2.payloads[t], e.uint32(18).fork()).ldelim();
          return null != A2.vid && Object.hasOwnProperty.call(A2, "vid") && e.uint32(24).int64(A2.vid), null != A2.aid && Object.hasOwnProperty.call(A2, "aid") && e.uint32(32).int64(A2.aid), e;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/ProtoRaws";
        }, A.MessageInfo = function() {
          function A2(A3) {
            if (A3)
              for (let e = Object.keys(A3), t = 0; t < e.length; ++t)
                null != A3[e[t]] && (this[e[t]] = A3[e[t]]);
          }
          return A2.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A2.prototype.msg = $util.newBuffer([]), A2.encode = function(A3, e) {
            return e || (e = $Writer.create()), null != A3.id && Object.hasOwnProperty.call(A3, "id") && e.uint32(8).int64(A3.id), null != A3.msg && Object.hasOwnProperty.call(A3, "msg") && e.uint32(18).bytes(A3.msg), e;
          }, A2.getTypeUrl = function(A3) {
            return void 0 === A3 && (A3 = "type.googleapis.com"), A3 + "/ProtoRaws.MessageInfo";
          }, A2;
        }(), A;
      })(), LoginResult = $root.LoginResult = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.lts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.vid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.sid = "", A.prototype.code = 0, A.prototype.elapse = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.userId = "", A.encode = function(A2, e) {
          return e || (e = $Writer.create()), null != A2.lts && Object.hasOwnProperty.call(A2, "lts") && e.uint32(8).int64(A2.lts), null != A2.vid && Object.hasOwnProperty.call(A2, "vid") && e.uint32(16).int64(A2.vid), null != A2.sid && Object.hasOwnProperty.call(A2, "sid") && e.uint32(26).string(A2.sid), null != A2.code && Object.hasOwnProperty.call(A2, "code") && e.uint32(32).int32(A2.code), null != A2.elapse && Object.hasOwnProperty.call(A2, "elapse") && e.uint32(40).int64(A2.elapse), null != A2.userId && Object.hasOwnProperty.call(A2, "userId") && e.uint32(50).string(A2.userId), e;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/LoginResult";
        }, A;
      })(), ChannelPresenceSnapshotEvent = $root.ChannelPresenceSnapshotEvent = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.lts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.vid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.sid = "", A.prototype.userId = "", A.prototype.channelName = "", A.prototype.channelType = 0, A.prototype.elapse = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.reqId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer.create()), null != A2.lts && Object.hasOwnProperty.call(A2, "lts") && e.uint32(8).int64(A2.lts), null != A2.vid && Object.hasOwnProperty.call(A2, "vid") && e.uint32(16).int64(A2.vid), null != A2.sid && Object.hasOwnProperty.call(A2, "sid") && e.uint32(26).string(A2.sid), null != A2.userId && Object.hasOwnProperty.call(A2, "userId") && e.uint32(34).string(A2.userId), null != A2.channelName && Object.hasOwnProperty.call(A2, "channelName") && e.uint32(42).string(A2.channelName), null != A2.channelType && Object.hasOwnProperty.call(A2, "channelType") && e.uint32(48).int32(A2.channelType), null != A2.elapse && Object.hasOwnProperty.call(A2, "elapse") && e.uint32(56).int64(A2.elapse), null != A2.reqId && Object.hasOwnProperty.call(A2, "reqId") && e.uint32(64).int64(A2.reqId), e;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/ChannelPresenceSnapshotEvent";
        }, A;
      })(), LinkStateChange = $root.LinkStateChange = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.lts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.vid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.sid = "", A.prototype.userid = "", A.prototype.currentState = 0, A.prototype.previousState = 0, A.prototype.operation = 0, A.prototype.reason = 0, A.prototype.serviceType = 0, A.prototype.streamChannelName = "", A.prototype.elapse = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer.create()), null != A2.lts && Object.hasOwnProperty.call(A2, "lts") && e.uint32(8).int64(A2.lts), null != A2.vid && Object.hasOwnProperty.call(A2, "vid") && e.uint32(16).int64(A2.vid), null != A2.sid && Object.hasOwnProperty.call(A2, "sid") && e.uint32(26).string(A2.sid), null != A2.userid && Object.hasOwnProperty.call(A2, "userid") && e.uint32(34).string(A2.userid), null != A2.currentState && Object.hasOwnProperty.call(A2, "currentState") && e.uint32(40).int32(A2.currentState), null != A2.previousState && Object.hasOwnProperty.call(A2, "previousState") && e.uint32(48).int32(A2.previousState), null != A2.operation && Object.hasOwnProperty.call(A2, "operation") && e.uint32(56).int32(A2.operation), null != A2.reason && Object.hasOwnProperty.call(A2, "reason") && e.uint32(64).int32(A2.reason), null != A2.serviceType && Object.hasOwnProperty.call(A2, "serviceType") && e.uint32(72).int32(A2.serviceType), null != A2.streamChannelName && Object.hasOwnProperty.call(A2, "streamChannelName") && e.uint32(82).string(A2.streamChannelName), null != A2.elapse && Object.hasOwnProperty.call(A2, "elapse") && e.uint32(88).int64(A2.elapse), e;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/LinkStateChange";
        }, A;
      })(), RenewToken = $root.RenewToken = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.sid = "", A.prototype.userId = "", A.prototype.lts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.elapse = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.cname = "", A.prototype.token = "", A.encode = function(A2, e) {
          return e || (e = $Writer.create()), null != A2.sid && Object.hasOwnProperty.call(A2, "sid") && e.uint32(10).string(A2.sid), null != A2.userId && Object.hasOwnProperty.call(A2, "userId") && e.uint32(18).string(A2.userId), null != A2.lts && Object.hasOwnProperty.call(A2, "lts") && e.uint32(24).int64(A2.lts), null != A2.elapse && Object.hasOwnProperty.call(A2, "elapse") && e.uint32(32).int64(A2.elapse), null != A2.cname && Object.hasOwnProperty.call(A2, "cname") && e.uint32(50).string(A2.cname), null != A2.token && Object.hasOwnProperty.call(A2, "token") && e.uint32(58).string(A2.token), e;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/RenewToken";
        }, A;
      })(), RenewTokenRes = $root.RenewTokenRes = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.lts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.vid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.sid = "", A.prototype.userId = "", A.prototype.elapse = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.cname = "", A.prototype.token = "", A.prototype.apErrCode = 0, A.prototype.regErrCode = 0, A.encode = function(A2, e) {
          return e || (e = $Writer.create()), null != A2.lts && Object.hasOwnProperty.call(A2, "lts") && e.uint32(8).int64(A2.lts), null != A2.vid && Object.hasOwnProperty.call(A2, "vid") && e.uint32(16).int64(A2.vid), null != A2.sid && Object.hasOwnProperty.call(A2, "sid") && e.uint32(26).string(A2.sid), null != A2.userId && Object.hasOwnProperty.call(A2, "userId") && e.uint32(34).string(A2.userId), null != A2.elapse && Object.hasOwnProperty.call(A2, "elapse") && e.uint32(40).int64(A2.elapse), null != A2.cname && Object.hasOwnProperty.call(A2, "cname") && e.uint32(50).string(A2.cname), null != A2.token && Object.hasOwnProperty.call(A2, "token") && e.uint32(58).string(A2.token), null != A2.apErrCode && Object.hasOwnProperty.call(A2, "apErrCode") && e.uint32(64).int32(A2.apErrCode), null != A2.regErrCode && Object.hasOwnProperty.call(A2, "regErrCode") && e.uint32(72).int32(A2.regErrCode), e;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/RenewTokenRes";
        }, A;
      })(), SyncLockAcquireEvent = $root.SyncLockAcquireEvent = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.lts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.vid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.ip = "", A.prototype.userid = "", A.prototype.sid = "", A.prototype.index = null, A.prototype.target = "", A.prototype.lock = "", A.prototype.lockrev = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.uuid = "", A.prototype.flags = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.code = 0, A.prototype.leaseid = "", A.prototype.eventtype = "", A.prototype.sdktype = 0, A.prototype.requestts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.replyts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.ttl = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.usersid = "", A.prototype.sdkip = "", A.encode = function(A2, e) {
          return e || (e = $Writer.create()), null != A2.lts && Object.hasOwnProperty.call(A2, "lts") && e.uint32(8).int64(A2.lts), null != A2.vid && Object.hasOwnProperty.call(A2, "vid") && e.uint32(16).int64(A2.vid), null != A2.ip && Object.hasOwnProperty.call(A2, "ip") && e.uint32(26).string(A2.ip), null != A2.userid && Object.hasOwnProperty.call(A2, "userid") && e.uint32(34).string(A2.userid), null != A2.sid && Object.hasOwnProperty.call(A2, "sid") && e.uint32(42).string(A2.sid), null != A2.index && Object.hasOwnProperty.call(A2, "index") && $root.CommonIndex.encode(A2.index, e.uint32(50).fork()).ldelim(), null != A2.target && Object.hasOwnProperty.call(A2, "target") && e.uint32(58).string(A2.target), null != A2.lock && Object.hasOwnProperty.call(A2, "lock") && e.uint32(66).string(A2.lock), null != A2.lockrev && Object.hasOwnProperty.call(A2, "lockrev") && e.uint32(72).int64(A2.lockrev), null != A2.uuid && Object.hasOwnProperty.call(A2, "uuid") && e.uint32(82).string(A2.uuid), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(88).int64(A2.flags), null != A2.code && Object.hasOwnProperty.call(A2, "code") && e.uint32(96).int32(A2.code), null != A2.leaseid && Object.hasOwnProperty.call(A2, "leaseid") && e.uint32(106).string(A2.leaseid), null != A2.eventtype && Object.hasOwnProperty.call(A2, "eventtype") && e.uint32(114).string(A2.eventtype), null != A2.sdktype && Object.hasOwnProperty.call(A2, "sdktype") && e.uint32(120).int32(A2.sdktype), null != A2.requestts && Object.hasOwnProperty.call(A2, "requestts") && e.uint32(128).int64(A2.requestts), null != A2.replyts && Object.hasOwnProperty.call(A2, "replyts") && e.uint32(136).int64(A2.replyts), null != A2.ttl && Object.hasOwnProperty.call(A2, "ttl") && e.uint32(144).int64(A2.ttl), null != A2.usersid && Object.hasOwnProperty.call(A2, "usersid") && e.uint32(154).string(A2.usersid), null != A2.sdkip && Object.hasOwnProperty.call(A2, "sdkip") && e.uint32(162).string(A2.sdkip), e;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/SyncLockAcquireEvent";
        }, A;
      })(), SyncLockReleaseEvent = $root.SyncLockReleaseEvent = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.lts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.vid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.ip = "", A.prototype.userid = "", A.prototype.sid = "", A.prototype.index = null, A.prototype.target = "", A.prototype.lock = "", A.prototype.uuid = "", A.prototype.flags = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.code = 0, A.prototype.leaseid = "", A.prototype.eventtype = "", A.prototype.sdktype = 0, A.prototype.requestts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.replyts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.usersid = "", A.prototype.sdkip = "", A.encode = function(A2, e) {
          return e || (e = $Writer.create()), null != A2.lts && Object.hasOwnProperty.call(A2, "lts") && e.uint32(8).int64(A2.lts), null != A2.vid && Object.hasOwnProperty.call(A2, "vid") && e.uint32(16).int64(A2.vid), null != A2.ip && Object.hasOwnProperty.call(A2, "ip") && e.uint32(26).string(A2.ip), null != A2.userid && Object.hasOwnProperty.call(A2, "userid") && e.uint32(34).string(A2.userid), null != A2.sid && Object.hasOwnProperty.call(A2, "sid") && e.uint32(42).string(A2.sid), null != A2.index && Object.hasOwnProperty.call(A2, "index") && $root.CommonIndex.encode(A2.index, e.uint32(50).fork()).ldelim(), null != A2.target && Object.hasOwnProperty.call(A2, "target") && e.uint32(58).string(A2.target), null != A2.lock && Object.hasOwnProperty.call(A2, "lock") && e.uint32(66).string(A2.lock), null != A2.uuid && Object.hasOwnProperty.call(A2, "uuid") && e.uint32(74).string(A2.uuid), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(80).int64(A2.flags), null != A2.code && Object.hasOwnProperty.call(A2, "code") && e.uint32(88).int32(A2.code), null != A2.leaseid && Object.hasOwnProperty.call(A2, "leaseid") && e.uint32(98).string(A2.leaseid), null != A2.eventtype && Object.hasOwnProperty.call(A2, "eventtype") && e.uint32(106).string(A2.eventtype), null != A2.sdktype && Object.hasOwnProperty.call(A2, "sdktype") && e.uint32(112).int32(A2.sdktype), null != A2.requestts && Object.hasOwnProperty.call(A2, "requestts") && e.uint32(120).int64(A2.requestts), null != A2.replyts && Object.hasOwnProperty.call(A2, "replyts") && e.uint32(128).int64(A2.replyts), null != A2.usersid && Object.hasOwnProperty.call(A2, "usersid") && e.uint32(138).string(A2.usersid), null != A2.sdkip && Object.hasOwnProperty.call(A2, "sdkip") && e.uint32(146).string(A2.sdkip), e;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/SyncLockReleaseEvent";
        }, A;
      })(), SyncLockUpdateEvent = $root.SyncLockUpdateEvent = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.lts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.vid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.ip = "", A.prototype.userid = "", A.prototype.sid = "", A.prototype.index = null, A.prototype.target = "", A.prototype.lock = "", A.prototype.flags = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.code = 0, A.prototype.eventtype = "", A.prototype.sdktype = 0, A.prototype.replyts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.usersid = "", A.prototype.sdkip = "", A.encode = function(A2, e) {
          return e || (e = $Writer.create()), null != A2.lts && Object.hasOwnProperty.call(A2, "lts") && e.uint32(8).int64(A2.lts), null != A2.vid && Object.hasOwnProperty.call(A2, "vid") && e.uint32(16).int64(A2.vid), null != A2.ip && Object.hasOwnProperty.call(A2, "ip") && e.uint32(26).string(A2.ip), null != A2.userid && Object.hasOwnProperty.call(A2, "userid") && e.uint32(34).string(A2.userid), null != A2.sid && Object.hasOwnProperty.call(A2, "sid") && e.uint32(42).string(A2.sid), null != A2.index && Object.hasOwnProperty.call(A2, "index") && $root.CommonIndex.encode(A2.index, e.uint32(50).fork()).ldelim(), null != A2.target && Object.hasOwnProperty.call(A2, "target") && e.uint32(58).string(A2.target), null != A2.lock && Object.hasOwnProperty.call(A2, "lock") && e.uint32(66).string(A2.lock), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(72).int64(A2.flags), null != A2.code && Object.hasOwnProperty.call(A2, "code") && e.uint32(80).int32(A2.code), null != A2.eventtype && Object.hasOwnProperty.call(A2, "eventtype") && e.uint32(90).string(A2.eventtype), null != A2.sdktype && Object.hasOwnProperty.call(A2, "sdktype") && e.uint32(96).int32(A2.sdktype), null != A2.replyts && Object.hasOwnProperty.call(A2, "replyts") && e.uint32(104).int64(A2.replyts), null != A2.usersid && Object.hasOwnProperty.call(A2, "usersid") && e.uint32(114).string(A2.usersid), null != A2.sdkip && Object.hasOwnProperty.call(A2, "sdkip") && e.uint32(122).string(A2.sdkip), e;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/SyncLockUpdateEvent";
        }, A;
      })(), SyncLockDisableEvent = $root.SyncLockDisableEvent = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.lts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.vid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.ip = "", A.prototype.userid = "", A.prototype.sid = "", A.prototype.index = null, A.prototype.target = "", A.prototype.lock = "", A.prototype.leaseid = "", A.prototype.uuid = "", A.prototype.flags = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.code = 0, A.prototype.eventtype = "", A.prototype.sdktype = 0, A.prototype.requestts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.replyts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.usersid = "", A.prototype.sdkip = "", A.encode = function(A2, e) {
          return e || (e = $Writer.create()), null != A2.lts && Object.hasOwnProperty.call(A2, "lts") && e.uint32(8).int64(A2.lts), null != A2.vid && Object.hasOwnProperty.call(A2, "vid") && e.uint32(16).int64(A2.vid), null != A2.ip && Object.hasOwnProperty.call(A2, "ip") && e.uint32(26).string(A2.ip), null != A2.userid && Object.hasOwnProperty.call(A2, "userid") && e.uint32(34).string(A2.userid), null != A2.sid && Object.hasOwnProperty.call(A2, "sid") && e.uint32(42).string(A2.sid), null != A2.index && Object.hasOwnProperty.call(A2, "index") && $root.CommonIndex.encode(A2.index, e.uint32(50).fork()).ldelim(), null != A2.target && Object.hasOwnProperty.call(A2, "target") && e.uint32(58).string(A2.target), null != A2.lock && Object.hasOwnProperty.call(A2, "lock") && e.uint32(66).string(A2.lock), null != A2.leaseid && Object.hasOwnProperty.call(A2, "leaseid") && e.uint32(74).string(A2.leaseid), null != A2.uuid && Object.hasOwnProperty.call(A2, "uuid") && e.uint32(82).string(A2.uuid), null != A2.flags && Object.hasOwnProperty.call(A2, "flags") && e.uint32(88).int64(A2.flags), null != A2.code && Object.hasOwnProperty.call(A2, "code") && e.uint32(96).int32(A2.code), null != A2.eventtype && Object.hasOwnProperty.call(A2, "eventtype") && e.uint32(106).string(A2.eventtype), null != A2.sdktype && Object.hasOwnProperty.call(A2, "sdktype") && e.uint32(112).int32(A2.sdktype), null != A2.requestts && Object.hasOwnProperty.call(A2, "requestts") && e.uint32(120).int64(A2.requestts), null != A2.replyts && Object.hasOwnProperty.call(A2, "replyts") && e.uint32(128).int64(A2.replyts), null != A2.usersid && Object.hasOwnProperty.call(A2, "usersid") && e.uint32(138).string(A2.usersid), null != A2.sdkip && Object.hasOwnProperty.call(A2, "sdkip") && e.uint32(146).string(A2.sdkip), e;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/SyncLockDisableEvent";
        }, A;
      })(), StreamChnJoin = $root.StreamChnJoin = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.lts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.vid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.sid = "", A.prototype.userId = "", A.prototype.elapse = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.channelName = "", A.prototype.joinOptionsFlag = 0, A.prototype.rtcSid = "", A.prototype.preState = 0, A.prototype.seq = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer.create()), null != A2.lts && Object.hasOwnProperty.call(A2, "lts") && e.uint32(8).int64(A2.lts), null != A2.vid && Object.hasOwnProperty.call(A2, "vid") && e.uint32(16).int64(A2.vid), null != A2.sid && Object.hasOwnProperty.call(A2, "sid") && e.uint32(26).string(A2.sid), null != A2.userId && Object.hasOwnProperty.call(A2, "userId") && e.uint32(34).string(A2.userId), null != A2.elapse && Object.hasOwnProperty.call(A2, "elapse") && e.uint32(40).int64(A2.elapse), null != A2.channelName && Object.hasOwnProperty.call(A2, "channelName") && e.uint32(50).string(A2.channelName), null != A2.joinOptionsFlag && Object.hasOwnProperty.call(A2, "joinOptionsFlag") && e.uint32(56).int32(A2.joinOptionsFlag), null != A2.rtcSid && Object.hasOwnProperty.call(A2, "rtcSid") && e.uint32(66).string(A2.rtcSid), null != A2.preState && Object.hasOwnProperty.call(A2, "preState") && e.uint32(72).int32(A2.preState), null != A2.seq && Object.hasOwnProperty.call(A2, "seq") && e.uint32(80).int64(A2.seq), e;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/StreamChnJoin";
        }, A;
      })(), StreamChnLeave = $root.StreamChnLeave = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.lts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.vid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.sid = "", A.prototype.userId = "", A.prototype.elapse = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.channelName = "", A.prototype.preState = 0, A.prototype.seq = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer.create()), null != A2.lts && Object.hasOwnProperty.call(A2, "lts") && e.uint32(8).int64(A2.lts), null != A2.vid && Object.hasOwnProperty.call(A2, "vid") && e.uint32(16).int64(A2.vid), null != A2.sid && Object.hasOwnProperty.call(A2, "sid") && e.uint32(26).string(A2.sid), null != A2.userId && Object.hasOwnProperty.call(A2, "userId") && e.uint32(34).string(A2.userId), null != A2.elapse && Object.hasOwnProperty.call(A2, "elapse") && e.uint32(40).int64(A2.elapse), null != A2.channelName && Object.hasOwnProperty.call(A2, "channelName") && e.uint32(50).string(A2.channelName), null != A2.preState && Object.hasOwnProperty.call(A2, "preState") && e.uint32(56).int32(A2.preState), null != A2.seq && Object.hasOwnProperty.call(A2, "seq") && e.uint32(64).int64(A2.seq), e;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/StreamChnLeave";
        }, A;
      })(), TopicJoin = $root.TopicJoin = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.lts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.vid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.sid = "", A.prototype.userId = "", A.prototype.elapse = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.channelName = "", A.prototype.topicName = "", A.prototype.qos = 0, A.prototype.priority = 0, A.prototype.syncWithMedia = 0, A.prototype.streamId = 0, A.prototype.errorCode = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.seq = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer.create()), null != A2.lts && Object.hasOwnProperty.call(A2, "lts") && e.uint32(8).int64(A2.lts), null != A2.vid && Object.hasOwnProperty.call(A2, "vid") && e.uint32(16).int64(A2.vid), null != A2.sid && Object.hasOwnProperty.call(A2, "sid") && e.uint32(26).string(A2.sid), null != A2.userId && Object.hasOwnProperty.call(A2, "userId") && e.uint32(34).string(A2.userId), null != A2.elapse && Object.hasOwnProperty.call(A2, "elapse") && e.uint32(40).int64(A2.elapse), null != A2.channelName && Object.hasOwnProperty.call(A2, "channelName") && e.uint32(50).string(A2.channelName), null != A2.topicName && Object.hasOwnProperty.call(A2, "topicName") && e.uint32(58).string(A2.topicName), null != A2.qos && Object.hasOwnProperty.call(A2, "qos") && e.uint32(64).int32(A2.qos), null != A2.priority && Object.hasOwnProperty.call(A2, "priority") && e.uint32(72).int32(A2.priority), null != A2.syncWithMedia && Object.hasOwnProperty.call(A2, "syncWithMedia") && e.uint32(80).int32(A2.syncWithMedia), null != A2.streamId && Object.hasOwnProperty.call(A2, "streamId") && e.uint32(88).int32(A2.streamId), null != A2.errorCode && Object.hasOwnProperty.call(A2, "errorCode") && e.uint32(96).int64(A2.errorCode), null != A2.seq && Object.hasOwnProperty.call(A2, "seq") && e.uint32(104).int64(A2.seq), e;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/TopicJoin";
        }, A;
      })(), TopicLeave = $root.TopicLeave = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.lts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.vid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.sid = "", A.prototype.userId = "", A.prototype.elapse = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.channelName = "", A.prototype.topicName = "", A.prototype.streamId = 0, A.prototype.seq = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer.create()), null != A2.lts && Object.hasOwnProperty.call(A2, "lts") && e.uint32(8).int64(A2.lts), null != A2.vid && Object.hasOwnProperty.call(A2, "vid") && e.uint32(16).int64(A2.vid), null != A2.sid && Object.hasOwnProperty.call(A2, "sid") && e.uint32(26).string(A2.sid), null != A2.userId && Object.hasOwnProperty.call(A2, "userId") && e.uint32(34).string(A2.userId), null != A2.elapse && Object.hasOwnProperty.call(A2, "elapse") && e.uint32(40).int64(A2.elapse), null != A2.channelName && Object.hasOwnProperty.call(A2, "channelName") && e.uint32(50).string(A2.channelName), null != A2.topicName && Object.hasOwnProperty.call(A2, "topicName") && e.uint32(58).string(A2.topicName), null != A2.streamId && Object.hasOwnProperty.call(A2, "streamId") && e.uint32(64).int32(A2.streamId), null != A2.seq && Object.hasOwnProperty.call(A2, "seq") && e.uint32(72).int64(A2.seq), e;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/TopicLeave";
        }, A;
      })(), TopicSubscribe = $root.TopicSubscribe = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.lts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.vid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.sid = "", A.prototype.userId = "", A.prototype.elapse = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.channelName = "", A.prototype.topicName = "", A.prototype.randomSubscribe = 0, A.prototype.preSubscribe = 0, A.prototype.userCount = 0, A.prototype.seq = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer.create()), null != A2.lts && Object.hasOwnProperty.call(A2, "lts") && e.uint32(8).int64(A2.lts), null != A2.vid && Object.hasOwnProperty.call(A2, "vid") && e.uint32(16).int64(A2.vid), null != A2.sid && Object.hasOwnProperty.call(A2, "sid") && e.uint32(42).string(A2.sid), null != A2.userId && Object.hasOwnProperty.call(A2, "userId") && e.uint32(50).string(A2.userId), null != A2.elapse && Object.hasOwnProperty.call(A2, "elapse") && e.uint32(56).int64(A2.elapse), null != A2.channelName && Object.hasOwnProperty.call(A2, "channelName") && e.uint32(66).string(A2.channelName), null != A2.topicName && Object.hasOwnProperty.call(A2, "topicName") && e.uint32(74).string(A2.topicName), null != A2.randomSubscribe && Object.hasOwnProperty.call(A2, "randomSubscribe") && e.uint32(80).int32(A2.randomSubscribe), null != A2.preSubscribe && Object.hasOwnProperty.call(A2, "preSubscribe") && e.uint32(88).int32(A2.preSubscribe), null != A2.userCount && Object.hasOwnProperty.call(A2, "userCount") && e.uint32(96).int32(A2.userCount), null != A2.seq && Object.hasOwnProperty.call(A2, "seq") && e.uint32(104).int64(A2.seq), e;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/TopicSubscribe";
        }, A;
      })(), TopicUnsubscribe = $root.TopicUnsubscribe = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.lts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.vid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.sid = "", A.prototype.userId = "", A.prototype.elapse = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.channelName = "", A.prototype.topicName = "", A.prototype.seq = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.encode = function(A2, e) {
          return e || (e = $Writer.create()), null != A2.lts && Object.hasOwnProperty.call(A2, "lts") && e.uint32(8).int64(A2.lts), null != A2.vid && Object.hasOwnProperty.call(A2, "vid") && e.uint32(16).int64(A2.vid), null != A2.sid && Object.hasOwnProperty.call(A2, "sid") && e.uint32(26).string(A2.sid), null != A2.userId && Object.hasOwnProperty.call(A2, "userId") && e.uint32(34).string(A2.userId), null != A2.elapse && Object.hasOwnProperty.call(A2, "elapse") && e.uint32(40).int64(A2.elapse), null != A2.channelName && Object.hasOwnProperty.call(A2, "channelName") && e.uint32(50).string(A2.channelName), null != A2.topicName && Object.hasOwnProperty.call(A2, "topicName") && e.uint32(58).string(A2.topicName), null != A2.seq && Object.hasOwnProperty.call(A2, "seq") && e.uint32(72).int64(A2.seq), e;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/TopicUnsubscribe";
        }, A;
      })(), TopicUpdateEvent = $root.TopicUpdateEvent = (() => {
        function A(A2) {
          if (A2)
            for (let e = Object.keys(A2), t = 0; t < e.length; ++t)
              null != A2[e[t]] && (this[e[t]] = A2[e[t]]);
        }
        return A.prototype.lts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.vid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.sid = "", A.prototype.userId = "", A.prototype.elapse = $util.Long ? $util.Long.fromBits(0, 0, false) : 0, A.prototype.channelName = "", A.prototype.topicEventType = 0, A.prototype.topicInfo = "", A.encode = function(A2, e) {
          return e || (e = $Writer.create()), null != A2.lts && Object.hasOwnProperty.call(A2, "lts") && e.uint32(8).int64(A2.lts), null != A2.vid && Object.hasOwnProperty.call(A2, "vid") && e.uint32(16).int64(A2.vid), null != A2.sid && Object.hasOwnProperty.call(A2, "sid") && e.uint32(26).string(A2.sid), null != A2.userId && Object.hasOwnProperty.call(A2, "userId") && e.uint32(34).string(A2.userId), null != A2.elapse && Object.hasOwnProperty.call(A2, "elapse") && e.uint32(40).int64(A2.elapse), null != A2.channelName && Object.hasOwnProperty.call(A2, "channelName") && e.uint32(50).string(A2.channelName), null != A2.topicEventType && Object.hasOwnProperty.call(A2, "topicEventType") && e.uint32(56).int32(A2.topicEventType), null != A2.topicInfo && Object.hasOwnProperty.call(A2, "topicInfo") && e.uint32(66).string(A2.topicInfo), e;
        }, A.getTypeUrl = function(A2) {
          return void 0 === A2 && (A2 = "type.googleapis.com"), A2 + "/TopicUpdateEvent";
        }, A;
      })();
      var ProtoPackets = Object.freeze({ __proto__: null, ApEvent, ApRequest, ChannelPresenceSnapshotEvent, ChnJoin, ChnJoinRes, ChnLeave, CommonIndex, KickedOff, Link, LinkLoginRequest, LinkStateChange, LinkTcpEvent, LoginResult, Logout, ProtoRaws, RenewToken, RenewTokenRes, Session, StreamChnJoin, StreamChnLeave, SyncLockAcquireEvent, SyncLockDisableEvent, SyncLockReleaseEvent, SyncLockUpdateEvent, SyncOperateEvent, SyncSubscribeEvent, SyncUpdateEvent, TopicJoin, TopicLeave, TopicSubscribe, TopicUnsubscribe, TopicUpdateEvent, default: $root });
      const EVENT_REPORT_DOMAIN = "webcollector-rtm.agora.io", EVENT_REPORT_BACKUP_DOMAIN = "rtm.statscollector.sd-rtn.com", maxReportCount = 20, reportInterval = 1e4, forceReportInterval = 6e4, eventsCacheKeyPrefix = "events-";
      let lastReportTime = 0;
      const storageEvents = /* @__PURE__ */ new Map();
      let reportDomainIdx = 0;
      function getReportDomain() {
        try {
          var A;
          const e = null !== (A = getParameter("EVENT_REPORT_DOMAIN_LIST")) && void 0 !== A ? A : [];
          reportDomainIdx >= e.length && (reportDomainIdx = 0);
          return e[reportDomainIdx];
        } catch (A2) {
          return console.error(A2), "";
        }
      }
      function initStorageCache(A) {
        storageEvents.has(A) || storageEvents.set(A, []);
      }
      const decodeHexAsBytes = (A) => {
        var e;
        const t = null === (e = A.match(/.{1,2}/g)) || void 0 === e ? void 0 : e.map((A2) => parseInt(A2, 16));
        return null != t ? t : [];
      }, genAid = (A) => {
        const e = decodeHexAsBytes(A), t = [e[0], e[4], e[8], e[12]], g = t.reduce((A2, e2, g2) => A2 | e2 << 8 * (t.length - 1 - g2), 0) >>> 0;
        return g;
      };
      async function batchSendReport(A, e, t) {
        var g;
        lastReportTime = Date.now();
        const o = t && getPrivateSettingsPortAndDomains(t), I = null == o ? void 0 : o.port, i2 = null == o ? void 0 : o.hostname, r = null !== (g = null == i2 ? void 0 : i2.length) && void 0 !== g ? g : 0, n = i2 && i2[0], C = i2 && i2[r - 1], E = async function(g2) {
          var o2;
          let i3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
          if (i3 > 3)
            return;
          const r2 = e && !t ? "https://".concat(null !== (o2 = null == areaConfig ? void 0 : areaConfig.PROXY_NGINX[0]) && void 0 !== o2 ? o2 : "webrtc-cloud-proxy.sd-rtn.com", "/rs/?h=").concat(g2, "&p=").concat(null != I ? I : 443, "&d=events/proto-raws") : "https://".concat(getReportDomain() || g2).concat(I ? ":".concat(I) : "", "/events/proto-raws");
          await postWithAbortSignal(r2, { body: A, timeout: 2e4, headers: { "Content-Type": "application/octet-stream" } }).catch((A2) => (reportDomainIdx++, E(g2, i3 + 1)));
        };
        try {
          await E((null == areaConfig ? void 0 : areaConfig.EVENT_REPORT_DOMAIN[0]) || isValidEnvString(null) && null || (null != n ? n : EVENT_REPORT_DOMAIN));
        } catch (A2) {
          await E(areaConfig && sample$1((null == areaConfig ? void 0 : areaConfig.EVENT_REPORT_DOMAIN.length) > 1 ? null == areaConfig ? void 0 : areaConfig.EVENT_REPORT_DOMAIN.slice(1) : null == areaConfig ? void 0 : areaConfig.EVENT_REPORT_DOMAIN) || (null != C ? C : EVENT_REPORT_BACKUP_DOMAIN));
        }
      }
      function triggerReport(A, e, t, g) {
        let o = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
        if (false === navigator.onLine)
          return;
        const I = "".concat(eventsCacheKeyPrefix).concat(A);
        initStorageCache(I);
        const i2 = storageEvents.get(I);
        if (0 !== i2.length && (!(i2.length < maxReportCount) || o))
          for (; i2.length > 0; ) {
            const o2 = i2.length > maxReportCount ? maxReportCount : i2.length, r = i2.splice(0, o2);
            storageEvents.set(I, i2);
            const n = Math.ceil(Date.now() / 1e3);
            batchSendReport(ProtoRaws.encode(Object.assign({ vid: Long$1.fromNumber(Number(A)), sendTs: Long$1.fromNumber(n), payloads: r }, 0 === Number(A) ? { aid: Long$1.fromNumber(genAid(e)) } : {})).finish(), t, g);
          }
      }
      function initEventReportTimer(A, e, t, g) {
        return setInterval(() => {
          const o = Date.now() - lastReportTime > forceReportInterval;
          triggerReport(A, e, t, g, o);
        }, reportInterval);
      }
      function clearEventReportTimer(A) {
        clearInterval(A);
      }
      async function addReportEvents(A, e, t, g, o, I) {
        const i2 = ProtoPackets[e].encode(t).finish(), r = ReportId[e], n = { id: Long$1.fromNumber(r), msg: i2 }, C = "".concat(eventsCacheKeyPrefix).concat(I);
        initStorageCache(C);
        const E = storageEvents.get(C);
        E.push(n), storageEvents.set(C, E), E.length >= maxReportCount && triggerReport(I, A, g, o, true);
      }
      async function sendReport(A, e, t, g, o) {
        arguments.length > 5 && void 0 !== arguments[5] && arguments[5] && await mockPromiseDelay(1e4);
        const I = o && getPrivateSettingsPortAndDomains(o), i2 = null == I ? void 0 : I.hostname;
        addReportEvents(A, e, t, g, o, "0"), triggerReport("0", A, g, i2, true);
      }
      function getElapse(A) {
        return void 0 === A ? Long$1.fromNumber(0) : Long$1.fromNumber(Date.now() - A);
      }
      function rateLimit(A) {
        let e = 1, t = asapScheduler;
        1 == (arguments.length <= 1 ? 0 : arguments.length - 1) ? "number" == typeof (arguments.length <= 1 ? void 0 : arguments[1]) ? e = arguments.length <= 1 ? void 0 : arguments[1] : t = arguments.length <= 1 ? void 0 : arguments[1] : 2 == (arguments.length <= 1 ? 0 : arguments.length - 1) && (e = arguments.length <= 1 ? void 0 : arguments[1], t = arguments.length <= 2 ? void 0 : arguments[2]);
        const g = e || 1;
        return (e2) => e2.pipe(scan((e3, o) => {
          const I = t.now(), i2 = I - A;
          if ((e3 = e3.filter((A2) => A2.until > i2)).length >= g) {
            const t2 = e3[0], i3 = e3[e3.length - 1], r = t2.until + A * Math.floor(e3.length / g);
            e3.push({ delay: i3.until < I ? r - I : r - i3.until, until: r, value: o });
          } else
            e3.push({ delay: 0, until: I, value: o });
          return e3;
        }, []), map$1((A2) => A2[A2.length - 1]), concatMap((A2) => {
          const e3 = of(A2.value);
          return A2.delay ? e3.pipe(delay(A2.delay, t)) : e3;
        }));
      }
      const SocketError = genError(), deprecatedURI = [URI$1.PingUri, URI$1.PongUri, URI$1.Ping2Uri, URI$1.UserJoinUri, URI$1.UserRespUri, URI$1.UserQuitUri, URI$1.GroupEventNoticeUri, URI$1.UserStatusListUri, URI$1.UserStatusResultUri, URI$1.GroupStatusListUri, URI$1.GroupStatusResultUri, URI$1.UserJoinNoticeUri, URI$1.UserQuitNoticeUri, URI$1.UserWaitNoticeUri, URI$1.UserAttributeGetUri, URI$1.UserAttributeRetUri, URI$1.UserAttributeSetUri, URI$1.UserAttributeModUri, URI$1.UserAttributeDelUri, URI$1.UserAttributeRspUri, URI$1.UserAttributeErrUri, URI$1.UserAttributeKeysGetUri, URI$1.UserAttributeKeysRetUri, URI$1.GroupAttributeGetUri, URI$1.GroupAttributeRetUri, URI$1.GroupAttributeSetUri, URI$1.GroupAttributeModUri, URI$1.GroupAttributeDelUri, URI$1.GroupAttributeAltUri, URI$1.GroupAttributeRspUri, URI$1.GroupAttributeErrUri, URI$1.GroupAttributeKeysGetUri, URI$1.GroupAttributeKeysRetUri, URI$1.SubscribeUserStatusUri, URI$1.UnsubscribeUserStatusUri, URI$1.SubscribeResponseUri];
      class Socket extends EventBase {
        get address() {
          return "".concat(this.ip, ":").concat(this.EDGE_ENV_PORT[this.env]);
        }
        get reOpened() {
          return this._reOpened;
        }
        constructor(A, e, t, g, o, I, i2) {
          var r;
          if (super(o, uniquePrefixedId("Socket-", o.loggerId)), _defineProperty$1(this, "isActiveClose", false), _defineProperty$1(this, "loggedIn", false), _defineProperty$1(this, "useNewDomain", void 0), _defineProperty$1(this, "receivedPacket", new Subject()), _defineProperty$1(this, "receivedSyncPacket", new Subject()), _defineProperty$1(this, "open$", void 0), _defineProperty$1(this, "input$", new Subject()), _defineProperty$1(this, "userJoin$", new Subject()), _defineProperty$1(this, "EDGE_ENV_PORT", null !== (r = getParameter("EDGE_ENV_PORT")) && void 0 !== r ? r : EDGE_ENV_PORT), _defineProperty$1(this, "attemptsSinceLastError", 0), _defineProperty$1(this, "message$", new Subject()), _defineProperty$1(this, "socket$", void 0), _defineProperty$1(this, "toClose", new Subject()), _defineProperty$1(this, "toReconnect", new Subject()), _defineProperty$1(this, "sendLogger", void 0), _defineProperty$1(this, "receiveLogger", void 0), _defineProperty$1(this, "ip", void 0), _defineProperty$1(this, "env", void 0), _defineProperty$1(this, "ticket", void 0), _defineProperty$1(this, "context", void 0), _defineProperty$1(this, "opened", false), _defineProperty$1(this, "reConnect", false), _defineProperty$1(this, "proxyIdx", 0), _defineProperty$1(this, "edgeDomain", void 0), _defineProperty$1(this, "_reOpened", false), _defineProperty$1(this, "getDomain", () => {
            var A2;
            return getEdgeDomain(this.ip, this.useNewDomain, null === (A2 = this.context.rtmConfig.privateConfig) || void 0 === A2 ? void 0 : A2.originDomains, this.edgeDomain);
          }), _defineProperty$1(this, "socketReconnector", (A2) => {
            const e2 = (A3) => (this.warn("The %s of Env %d reconnecting %s", this.name, this.env, A3.message), this.reConnect = true, timer(SOCKET_RETRY_INTERVAL));
            return A2.pipe(catchError((A3) => this.isActiveClose ? EMPTY : (this.attemptsSinceLastError += 1, this.logError("Env_".concat(this.env, "(").concat(this.name, "): socket connection closed, errorInfo: %o"), A3), this.loggedIn = false, this.attemptsSinceLastError >= 2 ? (this.log("ENV_".concat(this.env, "(").concat(this.name, "): will emit socketFailure")), this.close(), this.emit("socketFailure"), throwError(A3)) : this.isActiveClose ? EMPTY : (this.log("ENV_".concat(this.env, "(").concat(this.name, "): will emit reconnect")), this.emit("reconnect"), this.useNewDomain = !this.useNewDomain, throwError(A3)))), retryWhen((A3) => A3.pipe(switchMap(e2))), tap(() => {
              this.reConnect && this.env === this.context.connSyncEnv && (this.reConnect = false);
            }));
          }), this.ip = A, this.env = e, this.ticket = t, this.context = g, this.useNewDomain = null != I ? I : Math.random() >= 0.5, this.edgeDomain = null != i2 ? i2 : "", this.sendLogger = this.genLogger("RTM:MSG:SEND"), this.receiveLogger = this.genLogger("RTM:MSG:RECV"), 0 !== e && 1 !== e)
            throw new SocketError({ ILLEGAL_RTM_ENV: "The env number is out of rtm env count" });
          const n = this.EDGE_ENV_PORT[e];
          this.log("Opening websocket address %s for the Env %d, %s", maskIp(this.ip), this.env, this.name), this.context.addReportEvents("LinkLoginRequest", { sid: this.context.sid, userId: this.context.uid, lts: Long$1.fromNumber(Date.now()), elapse: getElapse(this.context.startTime), destServerIp: this.ip, linkId: this.env });
          const C = merge(this.input$, this.userJoin$.pipe(rateLimit(LOGIN_QPS_LIMIT)), this.message$).pipe(map$1((A2) => Wrapper$1.encode(A2).finish())), E = merge(makeWebSocketObservable("", { protocols: [], makeWebSocket: () => {
            let e2;
            const t2 = getParameter("REGISTRAR_USE_WS") ? "ws" : "wss";
            if (this.log("registrar websocket use ".concat(t2)), this.context.addReportEvents("LinkTcpEvent", { sid: this.context.sid, userId: this.context.uid, lts: Long$1.fromNumber(Date.now()), elapse: getElapse(this.context.startTime), destServerIp: A, action: "create", code: 0, responseTime: 0, version: VERSION_NO, subVersion: SUBVERSION, connectionsequence: Long$1.fromNumber(0, true), linktype: 4, linkflag: Long$1.fromNumber(0, true), linkenv: this.env }), !this.context.config.cloudProxy && !this.context.socketUseProxy || this.context.enablePrivate) {
              const A2 = parseHost(this.getDomain(), n);
              e2 = new WebSocket("".concat(t2, "://").concat(A2.domain, ":").concat(A2.port)), e2 instanceof WebSocket && (e2.addEventListener("close", (A3) => {
                this.log("ws onclose, code: %d, reason: '%s', env: %d, name: %s", A3.code, A3.reason, this.env, this.name);
              }), e2.addEventListener("error", (A3) => {
                this.log("ws onerror, env: %d, name: %s, error: %o", this.env, this.name, A3);
              }), e2.addEventListener("open", (A3) => {
                this.log("ws open, env: %d, name: %s", this.env, this.name);
              }));
            } else {
              var g2;
              if (0 === this.context.cloudProxyServers.length)
                throw this.logError("No cloud proxy server to connect, env: %d, name: %s", this.env, this.name), new RtmUnavailableError("");
              const A2 = null, o2 = (isValidEnvString() ? JSON.parse(A2.replace(/-/g, ".")) : this.context.cloudProxyServers)[this.genProxyIdx()];
              this.log("Using cloud proxy server %s, env: %d, name: %s", o2, this.env, this.name);
              const I2 = parseHost(getEdgeDomain(o2, false, null === (g2 = this.context.rtmConfig.privateConfig) || void 0 === g2 ? void 0 : g2.originDomains));
              let i3 = "".concat(t2, "://").concat(I2.domain, "/");
              i3 = appendQueryParameter(i3, "sid", this.context.sid), i3 = appendQueryParameter(i3, "remote_port", n.toString()), i3 = appendQueryParameter(i3, "remote_ip", this.ip), i3 = appendQueryParameter(i3, "token", this.context.key), e2 = new WebSocket("".concat(i3, ":").concat(I2.port));
            }
            return e2.binaryType = "arraybuffer", e2;
          } }), this.toReconnect);
          this.socket$ = race(E, NEVER.pipe(timeout(7e3), catchError((A2) => (isTimeout(A2) ? this.warn("ENV_".concat(this.env, "(").concat(this.name, "): socket open timed out")) : this.logError("ENV_".concat(this.env, "(").concat(this.name, "): error occurs of opening socket: %o"), A2), throwError(A2))))).pipe(map$1((A2) => {
            if (A2 instanceof Error)
              throw this.warn("Env_%d: Force reconnect the socket", this.env), A2;
            return A2(C).pipe(map$1((A3) => Wrapper$1.decode(new Uint8Array(A3))));
          }), this.socketReconnector), this.open$ = this.socket$.pipe(tap((e2) => {
            this.log("ENV_".concat(this.env, ": Websocket opened, addr: ").concat(maskIp(this.address)), this.name), this.context.addReportEvents("LinkTcpEvent", { sid: this.context.sid, userId: this.context.uid, lts: Long$1.fromNumber(Date.now()), elapse: getElapse(this.context.startTime), destServerIp: A, action: "on_connect", code: 0, responseTime: 0, version: VERSION_NO, subVersion: SUBVERSION, connectionsequence: Long$1.fromNumber(0, true), linktype: 4, linkflag: Long$1.fromNumber(0, true), linkenv: this.env }), e2.subscribe((A2) => {
              let { data: e3, uri: t2 } = A2;
              if (t2 === URI$1.SyncPacketUri)
                return getSyncPacketUri(e3), void this.receivedSyncPacket.next(e3);
              const g2 = uriToPacketName(t2), o2 = Packets[g2].decode(e3);
              if (deprecatedURI.includes(t2))
                return void this.receiveLogger("Env_%d: %s, deprecated.", this.env, g2);
              const I2 = mergeWith$1({}, omit$1(o2, "toJSON"), (A3, e4) => e4 instanceof Long$1 ? longToStringIfNeeded(e4) : e4);
              let i3 = false;
              if (o2 instanceof GroupEnterNotice || o2 instanceof GroupLeaveNotice) {
                const { instance: A3 } = o2;
                A3.lessThanOrEqual(UINT32_MAX) && (i3 = true);
              }
              if (o2 instanceof Message || o2 instanceof Ack) {
                const { instance: A3, dialogue: e4, sequence: t3 } = o2;
                (e4.lessThanOrEqual(UINT32_MAX) || A3.lessThanOrEqual(UINT32_MAX) || t3.lessThan(1)) && (i3 = true);
              }
              i3 ? this.warn("Env_%d: Illegal %s, abandoned %o", this.env, g2, I2) : ((getParameter("LOG_PING_PONG") || LOG_PING_PONG || "Pong3" !== g2) && this.receiveLogger("Env_%d: %s %o", this.env, g2, I2), this.receivedPacket.next([g2, o2]));
            }, () => {
            });
          }), mapTo(void 0), takeUntil(this.toClose), share());
        }
        sendPacket(A, e) {
          if (getParameter("LOG_PING_PONG") || LOG_PING_PONG || "Ping3" !== A) {
            const t2 = mapValues$1(e, (A2) => A2 instanceof Long$1 ? longToStringIfNeeded(A2) : A2);
            this.sendLogger("Env_%d: %s %o", this.env, A, t2);
          }
          const t = getWrappedByName(A, e);
          "UserJoin2" === A ? this.userJoin$.next(t) : "Message" === A ? this.message$.next(t) : this.input$.next(t);
        }
        close() {
          this.log("Closing websocket by client, name: %s, env: %d", this.name, this.env), this.isActiveClose = true, this.loggedIn = false, this.toClose.next();
        }
        fromReceived(A) {
          return this.receivedPacket.pipe(filter((e) => {
            let [t] = e;
            return t === A;
          }), map$1((A2) => {
            let [, e] = A2;
            return e;
          }));
        }
        sendSyncPacket(A) {
          const e = getSyncWrapped(A), t = getSyncPacketUri(A);
          (102 !== t && 104 !== t || LOG_SYNC_PING_PONG) && this.sendLogger("Env_%d: %s send  sync packet uri: %d", this.env, "SyncPacket", t), this.input$.next(e);
        }
        forceReconnect() {
          this.toReconnect.next(new SocketError({ FORCE_RECONNECTING: "Connection seems broken, try force reconnecting" }));
        }
        changeToReOpened() {
          this._reOpened = true;
        }
        genProxyIdx() {
          const A = this.proxyIdx;
          return this.proxyIdx = (A + 1) % this.context.cloudProxyServers.length, A;
        }
      }
      class AccessPoint extends EventBase {
        constructor(A, e) {
          var t;
          let g = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          super(e, "AccessPoint"), _defineProperty$1(this, "queryApEdgeInfo$", void 0), _defineProperty$1(this, "genApEdgeInfo$", void 0), _defineProperty$1(this, "apFinish$", new Subject()), _defineProperty$1(this, "retryCount", 0), _defineProperty$1(this, "failedAreas", /* @__PURE__ */ new Set()), _defineProperty$1(this, "replayedEdges", /* @__PURE__ */ new Map()), _defineProperty$1(this, "lastEdges", /* @__PURE__ */ new Map()), _defineProperty$1(this, "apDomainList", []), _defineProperty$1(this, "privateAccessPoints", void 0), _defineProperty$1(this, "handleUniLbsError", (A2, e2) => {
            const t2 = OperationName.login;
            let g2 = A2;
            if (A2.toString().length > 4) {
              const e3 = A2.toString().padStart(8, "0"), t3 = parseInt(e3.slice(0, 4), 10), o2 = parseInt(e3.slice(4, 8), 10);
              if (t3 === UNI_LBS_CODE)
                g2 = o2;
              else {
                if (t3 === ACCESS_POINT_CODE && (UniLbsNonRetryableErrorCodes.includes(o2) || o2 > 0 && o2 < 200)) {
                  const { code: A3, reason: e4 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_LOGIN_REJECTED);
                  return throwError(new RtmUnavailableError(OperationName.login, [e4], { code: A3, serverCode: g2 }));
                }
                if (t3 === ACCESS_POINT_CODE && o2 >= 200)
                  return this.warn("AP lowFour code is %s, NO_SERVICE_AVAILABLE.", o2), EMPTY;
              }
            }
            const o = g2.toString();
            if (!Object.keys(ApResErrorCode).includes(o)) {
              const { code: A3, reason: e3 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_LOGIN_REJECTED), o2 = new RtmUnavailableError(t2, [e3 + "apCode is ".concat(g2, ", unexpected code.")], { code: A3, serverCode: g2 });
              return o2.serverCode = g2, throwError(o2);
            }
            const I = ApResErrorCode[o];
            switch (this.warn("%s: %s's error type is %s", this.name, e2, I), I) {
              case "INVALID_APP_ID":
              case "APP_ID_NO_ACTIVATED":
              case "DYNAMIC_KEY_NOT_ENABLED": {
                const { code: A3, reason: e3 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_INVALID_APP_ID), o2 = new RtmUnauthenticatedError(t2, [e3 + " detail: ".concat(I, ", ").concat(ApResErrorMessage[I])], A3);
                return o2.serverCode = g2, throwError(o2);
              }
              case "NO_AUTHORIZED":
              case "DYNAMIC_ENABLED_BUT_STATIC_KEY":
              case "INVALID_USER_ID":
              case "INVALID_TOKEN_UID": {
                const { code: A3, reason: e3 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_INVALID_TOKEN), o2 = new RtmUnauthenticatedError(t2, [e3 + " detail: ".concat(I, ", ").concat(ApResErrorMessage[I])], A3);
                return o2.serverCode = g2, throwError(o2);
              }
              case "TOKEN_TIMEOUT":
              case "TOKEN_EXPIRED": {
                const { code: A3, reason: e3 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_TOKEN_EXPIRED), o2 = new RtmUnauthenticatedError(t2, [e3 + " detail: ".concat(I, ", ").concat(ApResErrorMessage[I])], A3);
                return o2.serverCode = g2, throwError(o2);
              }
              case "CANNOT_MEET_AREA_DEMAND": {
                const A3 = getAreaCodeByApUrl(e2);
                A3.forEach((A4) => this.failedAreas.add(A4));
                const o2 = void 0 === areaConfig ? 2 : areaConfig.CODES.size, { code: i2, reason: r } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_LOGIN_NO_SERVER_RESOURCES);
                if (this.failedAreas.size === o2) {
                  const A4 = new RtmInvalidArgumentError(t2, [r + " detail: ".concat(I, ", ").concat(ApResErrorMessage[I])], i2);
                  return A4.serverCode = g2, throwError(A4);
                }
                const n = new RtmUnavailableError(t2, [r + "".concat(this.name, " ").concat(A3.join(", "), " cannot meet requirement")], i2);
                return n.serverCode = g2, throwError(n);
              }
              case "INIT_APPID_MISMATCH": {
                const { code: A3, reason: e3 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_INCONSISTENT_APPID), o2 = new RtmUnavailableError(t2, [e3], A3);
                return o2.serverCode = g2, throwError(o2);
              }
              case "NO_ACTIVE_PRODUCT_STATUS": {
                const { code: A3, reason: e3 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_LOGIN_NOT_AUTHORIZED), o2 = new RtmUnauthenticatedError(t2, [e3 + " detail: ".concat(I, ", ").concat(ApResErrorMessage[I])], A3);
                return o2.serverCode = g2, throwError(o2);
              }
              default: {
                const { code: A3, reason: e3 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_LOGIN_REJECTED), o2 = new RtmUnavailableError(t2, [e3 + " detail: ".concat(I, ", ").concat(ApResErrorMessage[I])], A3);
                return o2.serverCode = g2, throwError(o2);
              }
            }
          }), _defineProperty$1(this, "generateShuffledUrls", (A2, e2) => {
            const t2 = [...A2], g2 = [...e2], o = [], I = t2.length + g2.length;
            for (; o.length < I; ) {
              const A3 = shuffle$1(t2)[0];
              t2.splice(t2.indexOf(A3), 1), A3 && o.push(A3);
              const e3 = shuffle$1(g2)[0];
              g2.splice(g2.indexOf(e3), 1), e3 && o.push(e3);
            }
            return o;
          }), _defineProperty$1(this, "generateUrlStream", () => {
            var A2;
            let e2 = this.apDomainList;
            return null !== (A2 = this.privateAccessPoints) && void 0 !== A2 && A2.length && (e2 = shuffle$1(this.privateAccessPoints)), (this.context.config.cloudProxy || this.context.socketUseProxy) && (e2 = (null == areaConfig ? void 0 : areaConfig.PROXY_AP) || ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"]), zip(of(...e2)).pipe(concatMap((A3) => of(...A3)));
          }), _defineProperty$1(this, "getApUrl$", (A2) => {
            var e2, t2;
            return this.generateUrlStream().pipe(take((null !== (e2 = null == areaConfig || null === (t2 = areaConfig.CODES) || void 0 === t2 ? void 0 : t2.size) && void 0 !== e2 ? e2 : 0) || Number(getParameter("CONCURRENT_AP_NUM")) || AP_CONCURRENT_REQ_NUM), throwIfEmpty(() => AccessPoint.runOutOfUrlSymbol), catchError((A3, e3) => A3 === AccessPoint.runOutOfUrlSymbol ? e3 : throwError(A3)));
          }), _defineProperty$1(this, "context", void 0), _defineProperty$1(this, "fetchCloudProxy", (A2, e2) => {
            const t2 = uniquePrefixedId("AP-", this.loggerId);
            this.log("The AccessPoint requests %s(%s)", A2, t2);
            const g2 = new AbortController();
            return this.apFinish$.subscribe(() => g2.abort()), defer(async () => {
              const o = getRandomInt(0, Number.MAX_SAFE_INTEGER);
              return this.log("%s request opid: %d", t2, o), postWithAbortSignal(A2, { headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "90", "Content-Type": "application/json" }, body: { sid: this.context.sid, opid: o, appid: this.context.appId, client_ts: Math.ceil(Date.now() / 1e3), request_bodies: [{ uri: 22, buffer: { service_ids: [7, 16], key: null != e2 ? e2 : this.context.key, cname: this.context.uid, uid: 0, detail: _objectSpread2(_objectSpread2({}, void 0 === areaConfig ? { 11: [AreaCodeMap.CHINA, AreaCodeMap.GLOBAL].join(",") } : { 11: Array.from(areaConfig.CODES).map((A3) => A3 === AreaCodeMap.OVERSEA ? "".concat(AreaCodeMap.ASIA, ",").concat(AreaCodeMap.EUROPE, ",").concat(AreaCodeMap.AFRICA, ",").concat(AreaCodeMap.NORTH_AMERICA, ",").concat(AreaCodeMap.SOUTH_AMERICA, ",").concat(AreaCodeMap.OCEANIA) : A3).join(",") }), { 12: "1", [AP_DETAIL_KEY_BUSINESS_TYPE]: "RTM2", [AP_DETAIL_KEY_APP_ID]: this.context.appId }) } }] }, signal: g2.signal });
            }).pipe(catchError((A3) => ("AbortError" !== A3.name && this.logError("The ProxyAP request reg server failure, %s", A3), EMPTY)), mergeMap(async (e3) => {
              var g3;
              let { responseText: o } = e3;
              const I = JSON.parse(o);
              this.log("The %s response is %o", t2, I);
              const { response_body: i2 } = I;
              if (void 0 === i2 || 0 === i2.length || i2.some((A3) => {
                var e4;
                return void 0 === (null === (e4 = A3.buffer) || void 0 === e4 ? void 0 : e4.code) || 23 !== A3.uri;
              })) {
                const { code: A3, reason: e4 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_LOGIN_REJECTED);
                return throwError(new RtmUnavailableError(OperationName.login, [e4 + "cloud proxy response_body not valid"], A3));
              }
              const r = i2.filter((A3) => 0 !== A3.buffer.code);
              if (0 !== r.length) {
                const e4 = r.find((A3) => 128 === A3.buffer.flag);
                return void 0 !== e4 ? this.handleUniLbsError(e4.buffer.code, A2) : (this.logError("cloud proxy error response"), this.handleUniLbsError(r[0].buffer.code, A2));
              }
              let n = [];
              for (let A3 = 0; A3 < i2.length; A3++) {
                var C, E;
                const e4 = i2[A3];
                var s, B;
                if (262144 === (null == e4 || null === (C = e4.buffer) || void 0 === C ? void 0 : C.flag))
                  null === (s = e4.buffer) || void 0 === s || null === (s = s.edges_services) || void 0 === s || null === (B = s.forEach) || void 0 === B || B.call(s, (A4) => {
                    let { ip: e5 } = A4;
                    isValidIp(e5) && -1 === this.context.cloudProxyServers.indexOf(e5) && (this.log("got cloud proxy server: %s", e5), this.context.cloudProxyServers.push(e5));
                  });
                else if (128 === (null == e4 || null === (E = e4.buffer) || void 0 === E ? void 0 : E.flag)) {
                  var a, Q, c, l;
                  for (let A4 = 0, t3 = e4.buffer.edges_services; A4 < t3.length; A4++) {
                    const g4 = t3[A4];
                    n.some((A5) => A5.ip === g4.ip) || n.push({ ip: g4.ip, ticket: e4.buffer.cert });
                  }
                  this.context.rtmArea = null !== (a = null === (Q = e4.buffer) || void 0 === Q || null === (Q = Q.detail) || void 0 === Q ? void 0 : Q[9]) && void 0 !== a ? a : "", this.context.vid = null !== (c = null === (l = e4.buffer) || void 0 === l || null === (l = l.detail) || void 0 === l ? void 0 : l[8]) && void 0 !== c ? c : "", setVidParameter(this.context.appId, this.context.vid);
                }
              }
              this.resetApDomainList();
              const h = null !== (g3 = getParameter("EDGE_IP_LIST")) && void 0 !== g3 ? g3 : [];
              return this.log("registrar EDGE_IP_LIST: ".concat(h, " ")), null != h && h.length && (n = h.map((A3) => ({ ip: A3, ticket: n[0].ticket }))), n.forEach((A3) => {
                this.replayedEdges.set(A3.ip, A3);
              }), of(...n, queueScheduler);
            }), catchError((A3) => isRtmError(A3) ? throwError(A3) : EMPTY), mergeAll(), filter((A3) => void 0 !== A3 && "string" == typeof A3.ip && "string" == typeof A3.ticket && isValidIp(A3.ip)));
          }), _defineProperty$1(this, "fetchAp", (A2, e2) => {
            const t2 = uniquePrefixedId("AP-", this.loggerId);
            this.log("The AccessPoint requests %s(%s)", A2, t2);
            const g2 = new AbortController();
            this.apFinish$.subscribe(() => g2.abort());
            const o = getRandomInt(0, Number.MAX_SAFE_INTEGER);
            return defer(async () => (this.log("%s request opid: %d", t2, o), postWithAbortSignal(A2, { headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "69", "Content-Type": "application/json" }, body: { flag: 128, opid: o, key: e2 || this.context.key, cname: this.context.uid, detail: _objectSpread2(_objectSpread2({}, void 0 === areaConfig ? { 11: [AreaCodeMap.CHINA, AreaCodeMap.GLOBAL].join(",") } : { 11: Array.from(areaConfig.CODES).map((A3) => A3 === AreaCodeMap.OVERSEA ? "".concat(AreaCodeMap.ASIA, ",").concat(AreaCodeMap.EUROPE, ",").concat(AreaCodeMap.AFRICA, ",").concat(AreaCodeMap.NORTH_AMERICA, ",").concat(AreaCodeMap.SOUTH_AMERICA, ",").concat(AreaCodeMap.OCEANIA) : A3).join(",") }), { 12: "1", [AP_DETAIL_KEY_BUSINESS_TYPE]: "RTM2", [AP_DETAIL_KEY_APP_ID]: this.context.appId }), uid: 0, sid: this.context.sid }, signal: g2.signal }))).pipe(catchError((e3) => (this.context.addReportEvents("ApEvent", { sid: this.context.sid, userId: this.context.uid, lts: Long$1.fromNumber(Date.now()), elapse: getElapse(this.context.startTime), apAddr: A2, linkServerList: [], serverErrCode: 10, flag: 128, envId: 0, opId: Long$1.fromNumber(o), errCode: 0, area: "", isp: "", version: VERSION_NO, subVersion: SUBVERSION, connectionsequence: Long$1.fromNumber(0), localWanIp: "", responseTime: 0, apLinkType: "tcp", resultcount: 0, validresultcount: 0, newvalidresultcount: 0 }), "AbortError" !== e3.name && this.logError("The AP request reg server failure, %s", e3), EMPTY)), mergeMap(async (e3) => {
              var g3, I;
              let { responseText: i2 } = e3;
              const r = JSON.parse(i2);
              this.log("The %s response is %o", t2, r);
              const { code: n, addresses: C, detail: E } = r;
              if (this.context.vid = null !== (g3 = E[8]) && void 0 !== g3 ? g3 : "", setVidParameter(this.context.appId, this.context.vid), this.context.initReportEvent(), this.context.addReportEvents("ApEvent", { sid: this.context.sid, userId: this.context.uid, lts: Long$1.fromNumber(Date.now()), elapse: getElapse(this.context.startTime), apAddr: A2, linkServerList: C.map((A3) => A3.ip), serverErrCode: n, flag: 128, envId: 0, opId: Long$1.fromNumber(o), errCode: 0, area: E[9], isp: E[2], version: VERSION_NO, subVersion: SUBVERSION, connectionsequence: Long$1.fromNumber(0), localWanIp: "", responseTime: 0, apLinkType: "tcp", resultcount: C.length, validresultcount: C.length, newvalidresultcount: C.length }), 0 !== n)
                return this.handleUniLbsError(n, A2);
              this.resetApDomainList();
              let s = C;
              const B = null !== (I = getParameter("EDGE_IP_LIST")) && void 0 !== I ? I : [];
              return this.log("registrar EDGE_IP_LIST: ".concat(B.map(maskIp))), null != B && B.length && (s = B.map((A3) => ({ ip: A3, ticket: s[0].ticket }))), 0 === s.length ? throwError(new Error("No available edge address to connect")) : (this.context.rtmArea = null == E ? void 0 : E[9], s.forEach((A3) => {
                this.replayedEdges.set(A3.ip, A3);
              }), of(...s, queueScheduler));
            }), mergeAll(), catchError((A3) => isRtmError(A3) ? throwError(A3) : EMPTY), filter((A3) => void 0 !== A3 && "string" == typeof A3.ip && "string" == typeof A3.ticket));
          }), this.context = A, this.privateAccessPoints = null === (t = this.context.rtmConfig.privateConfig) || void 0 === t ? void 0 : t.accessPointHosts, this.resetApDomainList(), this.queryApEdgeInfo$ = (A2) => timer(0, A2 || g ? getParameter("RECONNECTING_AP_INTERVAL") : 2e3).pipe(take(1), tap(() => {
            this.retryCount += 1;
          }), mergeMap(() => this.getApUrl$(A2 || g)), mergeMap((A3) => this.context.config.cloudProxy || this.context.socketUseProxy ? this.fetchCloudProxy(getApUrl(A3)) : (this.updateApDomainList(A3), 0 === this.apDomainList.length && this.resetApDomainList(), this.fetchAp(getApUrl(A3)))), catchError((A3) => (A3 instanceof TimeoutError && this.warn("AP request timeout"), throwError(A3))), distinct((A3) => {
            let { ip: e2 } = A3;
            return e2;
          }), takeUntil(this.apFinish$)), this.genApEdgeInfo$ = (A2, e2) => 0 === this.replayedEdges.size ? (this.log("The AccessPoint starts to query edge info, isRetrying: %s", A2), e2 || this.context.sendReport("ApRequest", { sid: this.context.sid, userId: this.context.uid, lts: Long$1.fromNumber(Date.now()), elapse: getElapse(this.context.startTime), apAddr: "", opId: Long$1.fromNumber(0), envId: 0, flag: 128, version: VERSION_NO, subVersion: SUBVERSION, connectionsequence: Long$1.fromNumber(0), rtmapflag: Long$1.fromNumber(0) }), this.queryApEdgeInfo$(false)) : of(...this.replayedEdges.values());
        }
        updateApDomainList(A) {
          for (let e = this.apDomainList.length - 1; e >= 0; e--)
            if (this.apDomainList[e] === A) {
              this.apDomainList.splice(e, 1);
              break;
            }
        }
        resetApDomainList() {
          this.apDomainList = [];
          const A = getParameter("AP_DOMAIN_LIST");
          null != A && A.length && this.apDomainList.push(...A), areaConfig ? (this.apDomainList.push(...shuffle$1(areaConfig.AP_DOMAINS)), this.apDomainList.push(...shuffle$1(areaConfig.AP_BACKUP_DOMAINS))) : (this.apDomainList.push(...this.generateShuffledUrls(AP_DOMAINS_IO, AP_DOMAINS_NEW)), this.apDomainList.push(...this.generateShuffledUrls(AP_BACKUP_DOMAINS_IO, AP_BACKUP_DOMAINS_NEW)));
        }
        isEdgeRunOut() {
          return 0 === this.replayedEdges.size;
        }
        banIp(A) {
          this.warn("edge %s lost", A), this.replayedEdges.delete(A), this.isEdgeRunOut() && this.warn("run out of edge");
        }
        clearEdges4RenewToken() {
          this.lastEdges.clear(), this.replayedEdges.forEach((A, e) => {
            this.lastEdges.set(e, _objectSpread2({}, A));
          }), this.replayedEdges.clear();
        }
        recoverEdges4RenewToken() {
          this.replayedEdges.clear(), this.lastEdges.forEach((A, e) => {
            this.replayedEdges.set(e, _objectSpread2({}, A));
          }), this.lastEdges.clear();
        }
        clearUp() {
          this.failedAreas.clear(), this.retryCount = 0;
        }
      }
      _defineProperty$1(AccessPoint, "runOutOfUrlSymbol", Symbol("AP urls are used up"));
      const ConnectionError = genError();
      class Connection extends EventBase {
        constructor(A, e, t) {
          var g;
          let o;
          super(e, "Connection"), _defineProperty$1(this, "apClient", void 0), _defineProperty$1(this, "startApRequest$", new Subject()), _defineProperty$1(this, "endLogin$", new Subject()), _defineProperty$1(this, "lastOpenSockets", [new ReplaySubject(1), new ReplaySubject(1)]), _defineProperty$1(this, "EDGE_ENV_PORT", null !== (g = getParameter("EDGE_ENV_PORT")) && void 0 !== g ? g : EDGE_ENV_PORT), _defineProperty$1(this, "curOpenSockets", [void 0, void 0]), _defineProperty$1(this, "ipIterator", 0), _defineProperty$1(this, "loginSocketOpenFailureCount", 0), _defineProperty$1(this, "firstEnv", Math.random() >= 0.5 ? 1 : 0), _defineProperty$1(this, "firstSocketOpener", void 0), _defineProperty$1(this, "secondSocketOpener", void 0), _defineProperty$1(this, "firstOpenKeeperSubject", new Subject()), _defineProperty$1(this, "secondOpenKeeperSubject", new Subject()), _defineProperty$1(this, "blacklistedIP", {}), _defineProperty$1(this, "edgeInfoReplayed", void 0), _defineProperty$1(this, "firstEnvOpenSocket", void 0), _defineProperty$1(this, "firstOpenKeeperSub", void 0), _defineProperty$1(this, "secondOpenKeeperSub", void 0), _defineProperty$1(this, "context", void 0), _defineProperty$1(this, "logger", void 0), _defineProperty$1(this, "cancelLogin", false), _defineProperty$1(this, "edgeIdx", 0), this.context = A, this.logger = e, this.apClient = new AccessPoint(this.context, e), this.apClient.apFinish$.subscribe(() => {
            this.log("Ap client fetch finished");
          }), this.edgeInfoReplayed = this.startApRequest$.pipe(tap(() => {
            if (this.log("start request ap by genApEdgeInfo$"), this.cancelLogin)
              throw this.handleCancelLogin();
          }), switchMap(() => this.apClient.genApEdgeInfo$(t).pipe(retryWhen((A2) => A2.pipe(tap((A3) => {
            if (isRtmError(A3))
              throw A3;
          }), delay(t ? getParameter("RECONNECTING_AP_INTERVAL") : 900), takeUntil(this.apClient.apFinish$))), filter((A2) => {
            var e2;
            return (null !== (e2 = this.blacklistedIP[A2.ip]) && void 0 !== e2 ? e2 : 0) <= 1;
          }), tap((A2) => {
            this.log("An edge info got %o", A2);
          }), tap({ error: (A2) => {
            this.logError("get edge info error %o", A2), this.emit("connectionInitFailure", A2);
          } }), finalize(() => {
            this.apClient.clearUp();
          }))), takeUntil(this.endLogin$), share()), this.firstEnvOpenSocket = this.edgeInfoReplayed.pipe(mergeMap((A2) => {
            if (void 0 === A2)
              return throwError(new Error("create first socket occurs Invalid edge info"));
            const { ip: g2, ticket: I } = A2;
            this.emit("syncTicketUpdated", { ticket: atob(I) }), this.log("create first socket ip: %s, env: %s", maskIp(g2), this.firstEnv);
            const i2 = this.getEdgeDomain(), r = new Socket(g2, this.firstEnv, I, this.context, e, o, i2);
            if (this.firstEnv = 1 === this.firstEnv ? 0 : 1, r.once("socketFailure", () => this.onSocketFailure(r)), !t && getParameter("ENABLE_EDGE_AUTO_FALLBACK") && !this.context.config.cloudProxy) {
              const A3 = Date.now();
              let e2;
              r.on("reconnect", () => {
                this.loginSocketOpenFailureCount += 1, null != e2 || (e2 = Date.now() - A3), e2 < 500 && this.loginSocketOpenFailureCount > 1 && void 0 === this.context.rtmConfig.privateConfig && true === this.context.socketUseProxy ? this.context.socketUseProxy = false : e2 < 500 && this.loginSocketOpenFailureCount > 1 && void 0 === this.context.rtmConfig.privateConfig && (this.context.socketUseProxy = true);
              });
            }
            return o = !r.useNewDomain, r.open$.pipe(mapTo(r));
          }), takeUntil(this.apClient.apFinish$), take(1), tap((A2) => {
            this.log("The websocket of first ENV_%d opened to %s:%d", A2.env, maskIp(A2.ip), this.EDGE_ENV_PORT[A2.env]), this.curOpenSockets[A2.env] = A2, this.lastOpenSockets[A2.env].next(A2), this.firstEnv = A2.env, this.openSecondSocket(A2.env, A2.ip, A2.useNewDomain);
          }), share()), this.firstSocketOpener = this.firstEnvOpenSocket.pipe(mergeMap((A2) => A2.open$.pipe(tap(() => {
            this.log("The websocket of first ENV_%d re-opened to %s:%d", A2.env, maskIp(A2.ip), this.EDGE_ENV_PORT[A2.env]), A2.changeToReOpened(), this.curOpenSockets[A2.env] = A2, this.lastOpenSockets[A2.env].next(A2);
          }))), tap(() => {
            this.log("first socket re opened");
          })), this.subKeeperSubject();
        }
        getEdgeDomain() {
          try {
            var A;
            const e = null !== (A = getParameter("EDGE_DOMAIN_TLD_LIST")) && void 0 !== A ? A : [];
            this.edgeIdx >= e.length && (this.edgeIdx = 0);
            const t = e[this.edgeIdx];
            return this.edgeIdx++, t;
          } catch (A2) {
            return console.error(A2), "";
          }
        }
        onSocketFailure(A) {
          this.apClient.banIp(A.ip);
          const e = [0, 1].filter((e2) => e2 !== A.env)[0], t = this.curOpenSockets[e];
          A.env === this.context.connSyncEnv && (this.context.connSyncEnv = void 0, this.warn("change connSyncEnv: %d to undefined in onSocketFailure", A.env)), this.log("ENV_".concat(A.env, "(").concat(A.name, "): socketFailure received, otherSocketState: ").concat(null == t ? void 0 : t.loggedIn)), t && t.loggedIn ? this.reopenSocketWithApRequest(A.env) : (this.log("ENV_".concat(A.env, "(").concat(A.name, "): will emit connectionFailure")), t && this.closeSocket(t.env, 0), this.emit("connectionFailure"));
        }
        openSecondSocket(A, e, t) {
          const g = 1 === A ? 0 : 1;
          this.secondSocketOpener = this.apClient.genApEdgeInfo$(false).pipe(reduce((A2, e2) => [...A2, e2], []), map$1((A2) => sortBy$1(A2, (A3) => {
            let { ip: t2 } = A3;
            return calIpDistance(e, t2);
          }).slice(-1)[0]), mergeMap((A2) => {
            if (void 0 === A2)
              return throwError(new Error("create second socket occurs Invalid edge info"));
            const { ip: e2, ticket: o2 } = A2;
            this.log("create second socket. ip: %s, env: %s", maskIp(e2), g);
            const I = this.getEdgeDomain(), i2 = new Socket(e2, g, o2, this.context, this.logger, t, I);
            return i2.on("socketFailure", () => this.onSocketFailure(i2)), i2.open$.pipe(tap(() => {
              this.lastOpenSockets[g].next(i2), this.curOpenSockets[g] = i2;
            }), mergeMap((A3, e3) => (this.log("The websocket of second ENV_%d %s to %s:%d", i2.env, e3 > 0 ? "re-opened" : "opened", maskIp(i2.ip), this.EDGE_ENV_PORT[i2.env]), EMPTY)));
          }), share());
          const o = this.secondOpenKeeperSubject.pipe(switchAll());
          this.secondOpenKeeperSub = o.subscribe({ error: this.logError }), this.secondOpenKeeperSubject.next(this.secondSocketOpener);
        }
        reopenSocketWithApRequest(A) {
          const e = [0, 1].filter((e2) => e2 !== A)[0], t = this.curOpenSockets[e];
          if (void 0 === t)
            return;
          const g = t.ip;
          let o;
          const I = ((A2) => A2.pipe(throwIfEmpty(() => new ConnectionError({ AP_NO_AVAILABLE_EDGE: "No available edge address to connect" })), retryWhen((A3) => A3.pipe(tap((A4) => {
            if (A4.code !== RTMErrorCode.RTM_ERROR_TOKEN_EXPIRED)
              if (A4.code !== RTMErrorCode.RTM_ERROR_LOGIN_NOT_AUTHORIZED) {
                if (isRtmError(A4))
                  throw A4;
              } else
                this.apClient.apFinish$.next(void 0);
            else
              this.apClient.apFinish$.next(void 0);
          }), delay(getParameter("RECONNECTING_AP_INTERVAL")), takeUntil(timer(15e3)))), tap((A3) => {
            this.log("An edge info got %o", A3);
          }), finalize(() => {
            this.apClient.clearUp();
          })))(this.apClient.genApEdgeInfo$(false)).pipe(reduce((A2, e2) => [...A2, e2], []), map$1((A2) => {
            const e2 = sortBy$1(A2, (A3) => {
              let { ip: e3 } = A3;
              return calIpDistance(g, e3);
            });
            return e2.length - 1 >= this.ipIterator ? e2.slice(-this.ipIterator++ - 1)[0] : (this.ipIterator = 0, e2.slice(-1)[0]);
          }), throwIfEmpty(), mergeMap((e2) => {
            if (void 0 === e2)
              return throwError(new Error("reopen socket with ap request occurs Invalid edge info"));
            const { ip: t2, ticket: g2 } = e2;
            this.emit("syncTicketUpdated", { ticket: atob(g2) }), this.log("open socket ip: %s, env: %s using ap", maskIp(t2), A);
            const I2 = this.getEdgeDomain(), i2 = new Socket(t2, A, g2, this.context, this.logger, o, I2);
            return i2.on("socketFailure", () => this.onSocketFailure(i2)), o = !i2.useNewDomain, i2.open$.pipe(mapTo(i2));
          }), take(1), tap((A2) => {
            this.log("The websocket of ENV_%d opened to %s:%d using ap", A2.env, maskIp(A2.ip), this.EDGE_ENV_PORT[A2.env]), this.curOpenSockets[A2.env] = A2, this.lastOpenSockets[A2.env].next(A2);
          }), mergeMap((e2) => e2.open$.pipe(tap(() => {
            this.log("The websocket of ENV_%d re-opened to %s:%d using ap", e2.env, maskIp(e2.ip), this.EDGE_ENV_PORT[e2.env]), e2.changeToReOpened(), this.curOpenSockets[A] = e2, this.lastOpenSockets[A].next(e2);
          }))), share());
          A === this.firstEnv ? (this.firstOpenKeeperSubject.next(I), this.log("reopenSocketWithAp, and start openSocket$, firstOpenKeeperSubject emit next")) : this.secondOpenKeeperSubject.next(I);
        }
        initConnection() {
          var A;
          null === (A = this.secondOpenKeeperSub) || void 0 === A || A.unsubscribe(), this.log("initConnection, and start firstSocketOpener, firstOpenKeeperSubject emit next"), this.firstOpenKeeperSubject.next(this.firstSocketOpener), this.startApRequest$.next(void 0);
        }
        subKeeperSubject() {
          const A = this.firstOpenKeeperSubject.pipe(switchAll()).pipe(tap(() => {
            this.log("firstOpenKeeperSubject switch æå¼ååºæ¥");
          }));
          this.firstOpenKeeperSub && this.firstOpenKeeperSub.unsubscribe(), this.firstOpenKeeperSub = A.subscribe({ error: this.logError });
        }
        closeSocket(A, e) {
          if (![0, 1].includes(A))
            throw new CommonError({ INVALID_ENV: "The env argument is not 0 or 1" });
          let t;
          A === this.firstEnv ? (t = this.firstOpenKeeperSub, this.firstOpenKeeperSub = void 0) : (t = this.secondOpenKeeperSub, this.secondOpenKeeperSub = void 0);
          const g = this.curOpenSockets[A];
          this.curOpenSockets[A] = void 0, g && (g.isActiveClose = true, setTimeout(() => {
            g.close();
          }, e)), void 0 !== t && setTimeout(() => {
            var A2;
            null === (A2 = t) || void 0 === A2 || A2.unsubscribe();
          }, e);
        }
        waitClosing(A) {
          return A.isActiveClose = true, A.open$.pipe(ignoreElements(), catchError((A2) => A2.message === normalClosureMessage ? EMPTY : throwError(A2)), timeout(LOGOUT_SOCKET_CLOSE_TIMEOUT), catchError((e) => e instanceof TimeoutError ? (this.warn("Force closing the ENV_%d connection", A.env), EMPTY) : throwError(e)));
        }
        handleCancelLogin() {
          const A = OperationName.login, { code: e, reason: t } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_LOGIN_CANCELED);
          return new RtmUnavailableError(A, [t], e);
        }
        stopLogin() {
          this.endLogin$.next();
        }
        banIP(A) {
          var e;
          this.log("ip banned", A);
          const t = null !== (e = this.blacklistedIP[A]) && void 0 !== e ? e : 0;
          this.blacklistedIP[A] = t + 1, t > 0 && this.apClient.banIp(A);
        }
      }
      let AckCodeType = function(A) {
        return A[A.kAckMiss = 1] = "kAckMiss", A[A.kAckPeerOffline = 8] = "kAckPeerOffline", A[A.kAckNoPrivilege = 9] = "kAckNoPrivilege", A;
      }({}), RegServerErrorCode = function(A) {
        return A[A.kOk = 0] = "kOk", A[A.kFail = 1] = "kFail", A[A.kTimestampExpired = 2] = "kTimestampExpired", A[A.kChannelPermissionInvalid = 3] = "kChannelPermissionInvalid", A[A.kCertificateInvalid = 4] = "kCertificateInvalid", A[A.kChannelNameEmpty = 5] = "kChannelNameEmpty", A[A.kChannelNotFound = 6] = "kChannelNotFound", A[A.kTicketInvalid = 7] = "kTicketInvalid", A[A.kChannelConflicted = 8] = "kChannelConflicted", A[A.kServiceNotReady = 9] = "kServiceNotReady", A[A.kServiceTooHeavy = 10] = "kServiceTooHeavy", A[A.kRejoined = 11] = "kRejoined", A[A.kNoNeedToChange = 13] = "kNoNeedToChange", A[A.kUidBanned = 14] = "kUidBanned", A[A.kIpBanned = 15] = "kIpBanned", A[A.kChannelBanned = 16] = "kChannelBanned", A[A.kTicketParseError = 17] = "kTicketParseError", A[A.kTicketIllegalLength = 18] = "kTicketIllegalLength", A[A.kTicketNotAuth = 19] = "kTicketNotAuth", A[A.kTicketUnknownVersion = 20] = "kTicketUnknownVersion", A[A.kLoginedFromRemote = 21] = "kLoginedFromRemote", A[A.kGwychFailed = 23] = "kGwychFailed", A[A.kTooManyBroadcasters = 24] = "kTooManyBroadcasters", A[A.kServerDown = 25] = "kServerDown", A[A.kResourceHeldByOther = 26] = "kResourceHeldByOther", A[A.kRtm2GwychFailed = 27] = "kRtm2GwychFailed", A[A.kAutoRebalance = 28] = "kAutoRebalance", A[A.kBannedForExceedingQuota = 101] = "kBannedForExceedingQuota", A[A.kRequestPending = 65535] = "kRequestPending", A[A.kVoid = 1e4] = "kVoid", A[A.kConnectionTimeout = 10001] = "kConnectionTimeout", A[A.kInvalidPacket = 10002] = "kInvalidPacket", A[A.kAlreadyJoined = 10003] = "kAlreadyJoined", A[A.kJoinTimeout = 10004] = "kJoinTimeout", A[A.kRejoinFailed = 10005] = "kRejoinFailed", A[A.kJoinTooFrequently = 10006] = "kJoinTooFrequently", A[A.kCompressionMethodUnrecognized = 10007] = "kCompressionMethodUnrecognized", A[A.kUserNotFound = 10008] = "kUserNotFound", A[A.kUserInstanceConflict = 10009] = "kUserInstanceConflict", A[A.kContentOversized = 10010] = "kContentOversized", A[A.kRequestTooFrequently = 10011] = "kRequestTooFrequently", A[A.kDamagedPacket = 10012] = "kDamagedPacket", A[A.kInvalidRequestParameters = 10013] = "kInvalidRequestParameters", A[A.kServerInternalError = 10014] = "kServerInternalError", A[A.kContentNotFound = 10015] = "kContentNotFound", A[A.kIncompatible = 10016] = "kIncompatible", A[A.kEdgeInDegradation = 10017] = "kEdgeInDegradation", A[A.kUserBannedByRule = 10018] = "kUserBannedByRule", A[A.kUserBannedByAuth = 10019] = "kUserBannedByAuth", A[A.kGroupUserBannedByAuth = 10020] = "kGroupUserBannedByAuth", A[A.kConsoleConfigNotFound = 10021] = "kConsoleConfigNotFound", A[A.kUserRejectedByConsoleConfig = 10022] = "kUserRejectedByConsoleConfig", A[A.kGroupUserNoPrivilege = 10025] = "kGroupUserNoPrivilege", A[A.kTest1 = 11001] = "kTest1", A[A.kTest2 = 11002] = "kTest2", A[A.kTest3 = 11003] = "kTest3", A;
      }({}), SyncServerErrorCode = function(A) {
        return A[A.kMetadataOk = 0] = "kMetadataOk", A[A.kDuplicatedOperation = 1] = "kDuplicatedOperation", A[A.kSyncServerError = 2] = "kSyncServerError", A[A.kArgumentError = 3] = "kArgumentError", A[A.kAutheticationError = 4] = "kAutheticationError", A[A.kExceedLimitationError = 5] = "kExceedLimitationError", A[A.kOutdateRevision = 6] = "kOutdateRevision", A[A.kLockAcquireFailed = 7] = "kLockAcquireFailed", A[A.kLockExpired = 8] = "kLockExpired", A[A.kLockWatching = 9] = "kLockWatching", A[A.kInvalidLock = 10] = "kInvalidLock", A[A.kLockReleased = 11] = "kLockReleased", A[A.kWriteNotAllowed = 12] = "kWriteNotAllowed", A[A.kNoLock = 13] = "kNoLock", A[A.kNoPrivilege = 14] = "kNoPrivilege", A[A.kTimeOutError = 100] = "kTimeOutError", A[A.kUnknownError = 255] = "kUnknownError", A;
      }({});
      function convertMetadataServerCodeToSdkCode(A) {
        switch (A) {
          case SyncServerErrorCode.kMetadataOk:
            return getErrorInfoByCode(RTMErrorCode.RTM_ERROR_OK);
          case SyncServerErrorCode.kArgumentError:
            return getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_INVALID_ARGUMENT);
          case SyncServerErrorCode.kOutdateRevision:
            return getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_OUTDATED_REVISION);
          case SyncServerErrorCode.kTimeOutError:
            return getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_OPERATION_TIMEOUT);
          case SyncServerErrorCode.kNoPrivilege:
            return getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_PERMISSION_DENIED);
          default:
            return getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_OPERATION_FAILED);
        }
      }
      function convertServerCodeToSdkCodeForSub(A) {
        switch (A) {
          case SyncServerErrorCode.kMetadataOk:
          case SyncServerErrorCode.kDuplicatedOperation:
            return getErrorInfoByCode(RTMErrorCode.RTM_ERROR_OK);
          case SyncServerErrorCode.kArgumentError:
            return getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_INVALID_ARGUMENT);
          case SyncServerErrorCode.kTimeOutError:
            return getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_OPERATION_TIMEOUT);
          case SyncServerErrorCode.kNoPrivilege:
            return getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_SUBSCRIBE_PERMISSION_DENIED);
          default:
            return getErrorInfoByCode(A);
        }
      }
      function convertLockServerCodeToSdkCode(A) {
        switch (A) {
          case SyncServerErrorCode.kMetadataOk:
          case SyncServerErrorCode.kDuplicatedOperation:
            return getErrorInfoByCode(RTMErrorCode.RTM_ERROR_OK);
          case SyncServerErrorCode.kOutdateRevision:
            return getErrorInfoByCode(RTMErrorCode.RTM_ERROR_LOCK_ALREADY_EXIST);
          case SyncServerErrorCode.kLockAcquireFailed:
            return getErrorInfoByCode(RTMErrorCode.RTM_ERROR_LOCK_ACQUIRE_FAILED);
          case SyncServerErrorCode.kNoLock:
            return getErrorInfoByCode(RTMErrorCode.RTM_ERROR_LOCK_NOT_EXIST);
          case SyncServerErrorCode.kNoPrivilege:
            return getErrorInfoByCode(RTMErrorCode.RTM_ERROR_LOCK_PERMISSION_DENIED);
          default:
            return getErrorInfoByCode(RTMErrorCode.RTM_ERROR_LOCK_OPERATION_FAILED);
        }
      }
      function convertDataChannelJoinCodeToSdkCode(A, e) {
        switch (A) {
          case AgoraRTCErrorCode.NOT_SUPPORTED:
          case AgoraRTCErrorCode.UNEXPECTED_RESPONSE:
            return getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_NOT_AVAILABLE);
          case AgoraRTCErrorCode.INIT_DATACHANNEL_TIMEOUT:
          case AgoraRTCErrorCode.CREATE_DATACHANNEL_ERROR:
          case AgoraRTCErrorCode.DATACHANNEL_FAILED:
          case AgoraRTCErrorCode.DATACHANNEL_CONNECTION_TIMEOUT:
            return getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_JOIN_TOPIC_FAILED);
          case AgoraRTCErrorCode.CAN_NOT_GET_GATEWAY_SERVER:
          case AgoraRTCErrorCode.VOID_GATEWAY_ADDRESS:
          case AgoraRTCErrorCode.MULTI_UNILBS_RESPONSE_ERROR:
          case AgoraRTCErrorCode.UID_CONFLICT:
            return getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_JOIN_FAILED);
          case AgoraRTCErrorCode.TOKEN_EXPIRE:
            return getErrorInfoByCode(RTMErrorCode.RTM_ERROR_TOKEN_EXPIRED);
          case AgoraRTCErrorCode.TIMEOUT:
          case AgoraRTCErrorCode.UNEXPECTED_ERROR:
          case AgoraRTCErrorCode.INVALID_PARAMS:
          case AgoraRTCErrorCode.NOT_READABLE:
          case AgoraRTCErrorCode.INVALID_OPERATION:
          case AgoraRTCErrorCode.OPERATION_ABORTED:
          case AgoraRTCErrorCode.WEB_SECURITY_RESTRICT:
          case AgoraRTCErrorCode.EXCHANGE_SDP_FAILED:
          case AgoraRTCErrorCode.NETWORK_ERROR:
          case AgoraRTCErrorCode.NETWORK_TIMEOUT:
          case AgoraRTCErrorCode.NETWORK_RESPONSE_ERROR:
          case AgoraRTCErrorCode.API_INVOKE_TIMEOUT:
          case AgoraRTCErrorCode.ENUMERATE_DEVICES_FAILED:
          case AgoraRTCErrorCode.DEVICE_NOT_FOUND:
          case AgoraRTCErrorCode.ELECTRON_IS_NULL:
          case AgoraRTCErrorCode.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR:
          case AgoraRTCErrorCode.CHROME_PLUGIN_NO_RESPONSE:
          case AgoraRTCErrorCode.CHROME_PLUGIN_NOT_INSTALL:
          case AgoraRTCErrorCode.MEDIA_OPTION_INVALID:
          case AgoraRTCErrorCode.PERMISSION_DENIED:
          case AgoraRTCErrorCode.CONSTRAINT_NOT_SATISFIED:
          case AgoraRTCErrorCode.TRACK_IS_DISABLED:
          case AgoraRTCErrorCode.GET_VIDEO_ELEMENT_VISIBLE_ERROR:
          case AgoraRTCErrorCode.SHARE_AUDIO_NOT_ALLOWED:
          case AgoraRTCErrorCode.LOW_STREAM_ENCODING_ERROR:
          case AgoraRTCErrorCode.SET_ENCODING_PARAMETER_ERROR:
          case AgoraRTCErrorCode.TRACK_STATE_UNREACHABLE:
          case AgoraRTCErrorCode.INVALID_UINT_UID_FROM_STRING_UID:
          case AgoraRTCErrorCode.CAN_NOT_GET_PROXY_SERVER:
          case AgoraRTCErrorCode.UPDATE_TICKET_FAILED:
          case AgoraRTCErrorCode.INVALID_LOCAL_TRACK:
          case AgoraRTCErrorCode.INVALID_TRACK:
          case AgoraRTCErrorCode.SENDER_NOT_FOUND:
          case AgoraRTCErrorCode.CREATE_OFFER_FAILED:
          case AgoraRTCErrorCode.SET_ANSWER_FAILED:
          case AgoraRTCErrorCode.ICE_FAILED:
          case AgoraRTCErrorCode.PC_CLOSED:
          case AgoraRTCErrorCode.SENDER_REPLACE_FAILED:
          case AgoraRTCErrorCode.GET_LOCAL_CAPABILITIES_FAILED:
          case AgoraRTCErrorCode.GET_LOCAL_CONNECTION_PARAMS_FAILED:
          case AgoraRTCErrorCode.SUBSCRIBE_FAILED:
          case AgoraRTCErrorCode.UNSUBSCRIBE_FAILED:
          case AgoraRTCErrorCode.GATEWAY_P2P_LOST:
          case AgoraRTCErrorCode.NO_ICE_CANDIDATE:
          case AgoraRTCErrorCode.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS:
          case AgoraRTCErrorCode.EXIST_DISABLED_VIDEO_TRACK:
          case AgoraRTCErrorCode.INVALID_REMOTE_USER:
          case AgoraRTCErrorCode.REMOTE_USER_IS_NOT_PUBLISHED:
          case AgoraRTCErrorCode.CUSTOM_REPORT_SEND_FAILED:
          case AgoraRTCErrorCode.CUSTOM_REPORT_FREQUENCY_TOO_HIGH:
          case AgoraRTCErrorCode.FETCH_AUDIO_FILE_FAILED:
          case AgoraRTCErrorCode.READ_LOCAL_AUDIO_FILE_ERROR:
          case AgoraRTCErrorCode.DECODE_AUDIO_FILE_FAILED:
          case AgoraRTCErrorCode.WS_ABORT:
          case AgoraRTCErrorCode.WS_DISCONNECT:
          case AgoraRTCErrorCode.WS_ERR:
          case AgoraRTCErrorCode.LIVE_STREAMING_TASK_CONFLICT:
          case AgoraRTCErrorCode.LIVE_STREAMING_INVALID_ARGUMENT:
          case AgoraRTCErrorCode.LIVE_STREAMING_INTERNAL_SERVER_ERROR:
          case AgoraRTCErrorCode.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED:
          case AgoraRTCErrorCode.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED:
          case AgoraRTCErrorCode.LIVE_STREAMING_CDN_ERROR:
          case AgoraRTCErrorCode.LIVE_STREAMING_INVALID_RAW_STREAM:
          case AgoraRTCErrorCode.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT:
          case AgoraRTCErrorCode.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE:
          case AgoraRTCErrorCode.LIVE_STREAMING_WARN_FREQUENT_REQUEST:
          case AgoraRTCErrorCode.WEBGL_INTERNAL_ERROR:
          case AgoraRTCErrorCode.BEAUTY_PROCESSOR_INTERNAL_ERROR:
          case AgoraRTCErrorCode.CROSS_CHANNEL_WAIT_STATUS_ERROR:
          case AgoraRTCErrorCode.CROSS_CHANNEL_FAILED_JOIN_SRC:
          case AgoraRTCErrorCode.CROSS_CHANNEL_FAILED_JOIN_DEST:
          case AgoraRTCErrorCode.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST:
          case AgoraRTCErrorCode.CROSS_CHANNEL_SERVER_ERROR_RESPONSE:
          case AgoraRTCErrorCode.METADATA_OUT_OF_RANGE:
          case AgoraRTCErrorCode.LOCAL_AEC_ERROR:
          case AgoraRTCErrorCode.INVALID_PLUGIN:
          case AgoraRTCErrorCode.DISCONNECT_P2P:
          case AgoraRTCErrorCode.CONVERTING_IMAGEDATA_TO_BLOB_FAILED:
          case AgoraRTCErrorCode.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED:
          case AgoraRTCErrorCode.ADD_CANDIDATE_FAILED:
          case AgoraRTCErrorCode.EXTERNAL_SIGNAL_ABORT:
          case AgoraRTCErrorCode.IMAGE_MODERATION_UPLOAD_FAILED:
          case AgoraRTCErrorCode.P2P_MESSAGE_FAILED:
          case AgoraRTCErrorCode.PROHIBITED_OPERATION:
          default: {
            var t;
            const A2 = getErrorInfoByCode(e);
            return { code: A2.code, reason: null !== (t = A2.reason) && void 0 !== t ? t : "" };
          }
        }
      }
      function comparator(A, e) {
        return Long$1.fromValue(A).eq(e);
      }
      function validateField(A, e) {
        const t = void 0 === e ? A.val : e, { isBoolean: g, isNumber: o, oneof: I, len: i2 } = A;
        if (2 !== [g, o, I].filter((A2) => !A2).length)
          throw new TypeError("invalid field type");
        if (void 0 === t)
          return;
        let r = false;
        if (void 0 !== I) {
          const A2 = values$3(I);
          uniqWith$1(A2, comparator).length === A2.length && void 0 !== find$1(A2, (A3) => comparator(t, A3)) && (r = true);
        }
        const n = void 0 !== g && (0 === t || 1 === t) && 1 === i2, C = void 0 !== o && t.toString(2).length <= i2;
        if (!(r || n || C))
          throw new Error("invalid field value");
      }
      class Struct {
        constructor() {
          _defineProperty$1(this, "size", 0), _defineProperty$1(this, "fields", /* @__PURE__ */ new Map());
        }
        define(A, e, t) {
          if (this.size += t, this.size > 64)
            throw new RangeError("the struct over 64 bits is not supported");
          const g = { val: 0, isNumber: "number" === e, isBoolean: "boolean" === e, oneof: "number" === e || "boolean" === e ? void 0 : e, len: t };
          validateField(g), this.fields.set(A, g);
        }
        set(A, e) {
          const t = this.fields.get(A);
          if (!t)
            throw new Error("field not found");
          const { oneof: g } = t;
          let o;
          if (Long$1.isLong(e) || "number" == typeof e)
            o = e;
          else if ("boolean" == typeof e)
            o = e ? 1 : 0;
          else {
            if (void 0 === g)
              throw new Error("invalid field type");
            const A2 = g[e];
            if (void 0 === A2)
              throw new Error("field type not found");
            o = A2;
          }
          validateField(t, o), t.val = o;
        }
        toNumber() {
          let A = 0, e = 0;
          for (let t = 0, g = Array.from(this.fields); t < g.length; t++) {
            const [, o] = g[t], { len: I, val: i2 } = o;
            void 0 !== i2 && (A += Long$1.fromValue(i2).shiftLeft(e).toNumber(), e += I);
          }
          return A;
        }
        toLong() {
          let A = Long$1.fromNumber(0, true), e = 0;
          for (let t = 0, g = Array.from(this.fields); t < g.length; t++) {
            const [, o] = g[t], { len: I, val: i2 } = o;
            void 0 !== i2 && (A = Long$1.fromValue(i2).shiftLeft(e).add(A), e += I);
          }
          return A;
        }
        assert(A, e) {
          const t = this.fields.get(A);
          if (!t)
            throw new Error("field not found");
          const { oneof: g } = t;
          function o(A2) {
            let e2;
            if (Long$1.isLong(A2) || "number" == typeof A2)
              e2 = A2;
            else if ("boolean" == typeof A2)
              e2 = A2 ? 1 : 0;
            else {
              if (void 0 === g)
                throw new Error("invalid field type");
              const t2 = g[A2];
              if (void 0 === t2)
                throw new Error("field type not found");
              e2 = t2;
            }
            return validateField(t, e2), comparator(e2, t.val);
          }
          if (!Array.isArray(e))
            return o(e);
          if (1 === e.length)
            return o(e[0]);
          if (e.every((A2) => "string" == typeof A2) && void 0 !== g)
            return e.some((A2) => o(A2));
          throw new Error("invalid valueTypes");
        }
        from(A) {
          const e = Long$1.fromValue(A);
          let t = 0;
          for (let A2 = 0, g = Array.from(this.fields); A2 < g.length; A2++) {
            const [, o] = g[A2], { len: I } = o, i2 = Long$1.fromNumber(2 ** I - 1, true).shiftLeft(t), r = e.and(i2).shiftRightUnsigned(t);
            validateField(o, r), o.val = r, t += I;
          }
        }
        typeOf(A) {
          const e = this.fields.get(A);
          if (void 0 !== e) {
            const { oneof: A2, val: t } = e;
            if (void 0 !== A2)
              for (let e2 = 0, g = Object.entries(A2); e2 < g.length; e2++) {
                const [A3, o] = g[e2];
                if (comparator(t, o))
                  return A3;
              }
          }
          throw new TypeError("can only get type of oneof type");
        }
      }
      class UserJoinOptions extends Struct {
        constructor(A) {
          super(), this.define("Rejoin", "boolean", 1), this.define("Unused", "number", 31), this.define("Platform", "number", 8), this.define("Version", "number", 12), this.define("Subversion", "number", 12), this.set("Platform", WEB_PLATFORM_TYPE), this.set("Version", VERSION_NO), this.set("Subversion", SUBVERSION), this.set("Rejoin", A);
        }
      }
      var AsyncAction$1 = {}, Action$1 = {}, Subscription$1 = {}, isArray = {};
      Object.defineProperty(isArray, "__esModule", { value: true }), isArray.isArray = Array.isArray || function(A) {
        return A && "number" == typeof A.length;
      };
      var isObject$1 = {};
      function isObject(A) {
        return null !== A && "object" == typeof A;
      }
      Object.defineProperty(isObject$1, "__esModule", { value: true }), isObject$1.isObject = isObject;
      var isFunction$1 = {};
      function isFunction(A) {
        return "function" == typeof A;
      }
      Object.defineProperty(isFunction$1, "__esModule", { value: true }), isFunction$1.isFunction = isFunction;
      var UnsubscriptionError = {};
      Object.defineProperty(UnsubscriptionError, "__esModule", { value: true });
      var UnsubscriptionErrorImpl = function() {
        function A(A2) {
          return Error.call(this), this.message = A2 ? A2.length + " errors occurred during unsubscription:\n" + A2.map(function(A3, e) {
            return e + 1 + ") " + A3.toString();
          }).join("\n  ") : "", this.name = "UnsubscriptionError", this.errors = A2, this;
        }
        return A.prototype = Object.create(Error.prototype), A;
      }();
      UnsubscriptionError.UnsubscriptionError = UnsubscriptionErrorImpl, Object.defineProperty(Subscription$1, "__esModule", { value: true });
      var isArray_1 = isArray, isObject_1 = isObject$1, isFunction_1 = isFunction$1, UnsubscriptionError_1 = UnsubscriptionError, Subscription = function() {
        function A(A2) {
          this.closed = false, this._parentOrParents = null, this._subscriptions = null, A2 && (this._ctorUnsubscribe = true, this._unsubscribe = A2);
        }
        return A.prototype.unsubscribe = function() {
          var e;
          if (!this.closed) {
            var t = this, g = t._parentOrParents, o = t._ctorUnsubscribe, I = t._unsubscribe, i2 = t._subscriptions;
            if (this.closed = true, this._parentOrParents = null, this._subscriptions = null, g instanceof A)
              g.remove(this);
            else if (null !== g)
              for (var r = 0; r < g.length; ++r) {
                g[r].remove(this);
              }
            if (isFunction_1.isFunction(I)) {
              o && (this._unsubscribe = void 0);
              try {
                I.call(this);
              } catch (A2) {
                e = A2 instanceof UnsubscriptionError_1.UnsubscriptionError ? flattenUnsubscriptionErrors(A2.errors) : [A2];
              }
            }
            if (isArray_1.isArray(i2)) {
              r = -1;
              for (var n = i2.length; ++r < n; ) {
                var C = i2[r];
                if (isObject_1.isObject(C))
                  try {
                    C.unsubscribe();
                  } catch (A2) {
                    e = e || [], A2 instanceof UnsubscriptionError_1.UnsubscriptionError ? e = e.concat(flattenUnsubscriptionErrors(A2.errors)) : e.push(A2);
                  }
              }
            }
            if (e)
              throw new UnsubscriptionError_1.UnsubscriptionError(e);
          }
        }, A.prototype.add = function(e) {
          var t = e;
          if (!e)
            return A.EMPTY;
          switch (typeof e) {
            case "function":
              t = new A(e);
            case "object":
              if (t === this || t.closed || "function" != typeof t.unsubscribe)
                return t;
              if (this.closed)
                return t.unsubscribe(), t;
              if (!(t instanceof A)) {
                var g = t;
                (t = new A())._subscriptions = [g];
              }
              break;
            default:
              throw new Error("unrecognized teardown " + e + " added to Subscription.");
          }
          var o = t._parentOrParents;
          if (null === o)
            t._parentOrParents = this;
          else if (o instanceof A) {
            if (o === this)
              return t;
            t._parentOrParents = [o, this];
          } else {
            if (-1 !== o.indexOf(this))
              return t;
            o.push(this);
          }
          var I = this._subscriptions;
          return null === I ? this._subscriptions = [t] : I.push(t), t;
        }, A.prototype.remove = function(A2) {
          var e = this._subscriptions;
          if (e) {
            var t = e.indexOf(A2);
            -1 !== t && e.splice(t, 1);
          }
        }, A.EMPTY = function(A2) {
          return A2.closed = true, A2;
        }(new A()), A;
      }();
      function flattenUnsubscriptionErrors(A) {
        return A.reduce(function(A2, e) {
          return A2.concat(e instanceof UnsubscriptionError_1.UnsubscriptionError ? e.errors : e);
        }, []);
      }
      Subscription$1.Subscription = Subscription;
      var __extends$2 = commonjsGlobal && commonjsGlobal.__extends || function() {
        var A = function(e, t) {
          return A = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(A2, e2) {
            A2.__proto__ = e2;
          } || function(A2, e2) {
            for (var t2 in e2)
              e2.hasOwnProperty(t2) && (A2[t2] = e2[t2]);
          }, A(e, t);
        };
        return function(e, t) {
          function g() {
            this.constructor = e;
          }
          A(e, t), e.prototype = null === t ? Object.create(t) : (g.prototype = t.prototype, new g());
        };
      }();
      Object.defineProperty(Action$1, "__esModule", { value: true });
      var Subscription_1 = Subscription$1, Action = function(A) {
        function e(e2, t) {
          return A.call(this) || this;
        }
        return __extends$2(e, A), e.prototype.schedule = function(A2, e2) {
          return this;
        }, e;
      }(Subscription_1.Subscription);
      Action$1.Action = Action;
      var __extends$1 = commonjsGlobal && commonjsGlobal.__extends || function() {
        var A = function(e, t) {
          return A = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(A2, e2) {
            A2.__proto__ = e2;
          } || function(A2, e2) {
            for (var t2 in e2)
              e2.hasOwnProperty(t2) && (A2[t2] = e2[t2]);
          }, A(e, t);
        };
        return function(e, t) {
          function g() {
            this.constructor = e;
          }
          A(e, t), e.prototype = null === t ? Object.create(t) : (g.prototype = t.prototype, new g());
        };
      }();
      Object.defineProperty(AsyncAction$1, "__esModule", { value: true });
      var Action_1 = Action$1, AsyncAction = function(A) {
        function e(e2, t) {
          var g = A.call(this, e2, t) || this;
          return g.scheduler = e2, g.work = t, g.pending = false, g;
        }
        return __extends$1(e, A), e.prototype.schedule = function(A2, e2) {
          if (void 0 === e2 && (e2 = 0), this.closed)
            return this;
          this.state = A2;
          var t = this.id, g = this.scheduler;
          return null != t && (this.id = this.recycleAsyncId(g, t, e2)), this.pending = true, this.delay = e2, this.id = this.id || this.requestAsyncId(g, this.id, e2), this;
        }, e.prototype.requestAsyncId = function(A2, e2, t) {
          return void 0 === t && (t = 0), setInterval(A2.flush.bind(A2, this), t);
        }, e.prototype.recycleAsyncId = function(A2, e2, t) {
          if (void 0 === t && (t = 0), null !== t && this.delay === t && false === this.pending)
            return e2;
          clearInterval(e2);
        }, e.prototype.execute = function(A2, e2) {
          if (this.closed)
            return new Error("executing a cancelled action");
          this.pending = false;
          var t = this._execute(A2, e2);
          if (t)
            return t;
          false === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
        }, e.prototype._execute = function(A2, e2) {
          var t = false, g = void 0;
          try {
            this.work(A2);
          } catch (A3) {
            t = true, g = !!A3 && A3 || new Error(A3);
          }
          if (t)
            return this.unsubscribe(), g;
        }, e.prototype._unsubscribe = function() {
          var A2 = this.id, e2 = this.scheduler, t = e2.actions, g = t.indexOf(this);
          this.work = null, this.state = null, this.pending = false, this.scheduler = null, -1 !== g && t.splice(g, 1), null != A2 && (this.id = this.recycleAsyncId(e2, A2, null)), this.delay = null;
        }, e;
      }(Action_1.Action), AsyncAction_2 = AsyncAction$1.AsyncAction = AsyncAction, AsyncScheduler$1 = {}, Scheduler$1 = {};
      Object.defineProperty(Scheduler$1, "__esModule", { value: true });
      var Scheduler = function() {
        function A(e, t) {
          void 0 === t && (t = A.now), this.SchedulerAction = e, this.now = t;
        }
        return A.prototype.schedule = function(A2, e, t) {
          return void 0 === e && (e = 0), new this.SchedulerAction(this, A2).schedule(t, e);
        }, A.now = function() {
          return Date.now();
        }, A;
      }();
      Scheduler$1.Scheduler = Scheduler;
      var __extends = commonjsGlobal && commonjsGlobal.__extends || function() {
        var A = function(e, t) {
          return A = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(A2, e2) {
            A2.__proto__ = e2;
          } || function(A2, e2) {
            for (var t2 in e2)
              e2.hasOwnProperty(t2) && (A2[t2] = e2[t2]);
          }, A(e, t);
        };
        return function(e, t) {
          function g() {
            this.constructor = e;
          }
          A(e, t), e.prototype = null === t ? Object.create(t) : (g.prototype = t.prototype, new g());
        };
      }();
      Object.defineProperty(AsyncScheduler$1, "__esModule", { value: true });
      var Scheduler_1 = Scheduler$1, AsyncScheduler = function(A) {
        function e(t, g) {
          void 0 === g && (g = Scheduler_1.Scheduler.now);
          var o = A.call(this, t, function() {
            return e.delegate && e.delegate !== o ? e.delegate.now() : g();
          }) || this;
          return o.actions = [], o.active = false, o.scheduled = void 0, o;
        }
        return __extends(e, A), e.prototype.schedule = function(t, g, o) {
          return void 0 === g && (g = 0), e.delegate && e.delegate !== this ? e.delegate.schedule(t, g, o) : A.prototype.schedule.call(this, t, g, o);
        }, e.prototype.flush = function(A2) {
          var e2 = this.actions;
          if (this.active)
            e2.push(A2);
          else {
            var t;
            this.active = true;
            do {
              if (t = A2.execute(A2.state, A2.delay))
                break;
            } while (A2 = e2.shift());
            if (this.active = false, t) {
              for (; A2 = e2.shift(); )
                A2.unsubscribe();
              throw t;
            }
          }
        }, e;
      }(Scheduler_1.Scheduler), AsyncScheduler_2 = AsyncScheduler$1.AsyncScheduler = AsyncScheduler;
      const blob = new Blob(["var fakeIdToId = {};onmessage = function (event) {	var data = event.data,		name = data.name,		fakeId = data.fakeId,		time;	if(data.hasOwnProperty('time')) {		time = data.time;	}	switch (name) {		case 'setInterval':			fakeIdToId[fakeId] = setInterval(function () {				postMessage({fakeId: fakeId});			}, time);			break;		case 'clearInterval':			if (fakeIdToId.hasOwnProperty (fakeId)) {				clearInterval(fakeIdToId[fakeId]);				delete fakeIdToId[fakeId];			}			break;	}}"]), workerScript = window.URL.createObjectURL(blob), fakeIdToCallback = {};
      let lastFakeId = 0;
      const maxFakeId = 2147483647;
      function getFakeId() {
        do {
          lastFakeId == maxFakeId ? lastFakeId = 0 : lastFakeId++;
        } while (fakeIdToCallback.hasOwnProperty(lastFakeId));
        return lastFakeId;
      }
      const worker = new Worker(workerScript);
      function hackSetInterval(A, e) {
        const t = getFakeId();
        return fakeIdToCallback[t] = { callback: A, parameters: Array.prototype.slice.call(arguments, 2) }, worker.postMessage({ name: "setInterval", fakeId: t, time: e }), t;
      }
      function hackClearInterval(A) {
        fakeIdToCallback.hasOwnProperty(A) && (delete fakeIdToCallback[A], worker.postMessage({ name: "clearInterval", fakeId: A }));
      }
      worker.onmessage = function(A) {
        const e = A.data.fakeId;
        let t, g, o;
        fakeIdToCallback.hasOwnProperty(e) && (t = fakeIdToCallback[e], o = t.callback, g = t.parameters, o.apply(window, g));
      };
      class HackAsyncAction extends AsyncAction_2 {
        requestAsyncId(A, e) {
          let t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
          return hackSetInterval(A.flush.bind(A, this), t);
        }
        recycleAsyncId(A, e) {
          let t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
          if (null !== t && this.delay === t && false === this.pending)
            return e;
          hackClearInterval(e);
        }
      }
      const getHackAsyncScheduler = () => new AsyncScheduler_2(HackAsyncAction);
      class ConnectionController extends EventBase {
        get syncEstablishState() {
          return this._syncEstablishState;
        }
        set syncEstablishState(A) {
          this._syncEstablishState = A;
        }
        constructor(A, e, t, g, o) {
          super(t, "ConnControl"), _defineProperty$1(this, "userJoinOptions", new UserJoinOptions(false)), _defineProperty$1(this, "seqSentStatuses", [false, false]), _defineProperty$1(this, "loggedOut", false), _defineProperty$1(this, "curLoginSockets", [void 0, void 0]), _defineProperty$1(this, "loginSocketSubs", [{ receivers: [] }, { receivers: [] }]), _defineProperty$1(this, "lastLoginSockets", [new ReplaySubject(1), new ReplaySubject(1)]), _defineProperty$1(this, "context", void 0), _defineProperty$1(this, "connection", void 0), _defineProperty$1(this, "instanceId", void 0), _defineProperty$1(this, "lastPingTime", void 0), _defineProperty$1(this, "manualShakeHand", void 0), _defineProperty$1(this, "connectDatabase", void 0), _defineProperty$1(this, "loginSubject$", new Subject()), _defineProperty$1(this, "canEmitUserJoined", false), _defineProperty$1(this, "firstInitSyncSeq", void 0), _defineProperty$1(this, "syncInitSeq", void 0), _defineProperty$1(this, "networkOnlineSubject", new Subject()), _defineProperty$1(this, "syncInitTimer", null), _defineProperty$1(this, "shakeHandTimer", null), _defineProperty$1(this, "tokenPrivilegeSubscription", null), _defineProperty$1(this, "_syncEstablishState", SyncEstablishState.DISCONNECTED), _defineProperty$1(this, "_lastPingSequences", [Long$1.ZERO, Long$1.ZERO]), _defineProperty$1(this, "registerConnectionFailureListener", () => {
            this.connection.once("connectionFailure", () => {
              this.log("registrar: connectionFailure, start reLogin..."), defer(() => {
                this.connection.subKeeperSubject(), this.context.internalEmitter.emit("login-request");
                return this.loginHandler(true);
              }).pipe(retryWhen((A2) => A2.pipe(tap((A3) => {
                let e2 = false;
                if (isTimeout(A3) && !this.connection.cancelLogin && (e2 = true), this.logError(A3), this.log("reLogin need retry: %s, cancel login: %s", e2, this.connection.cancelLogin), e2)
                  return delay(getParameter("RECONNECTING_AP_INTERVAL"));
                throw A3;
              }))), takeUntil(this.loginSubject$)).subscribe(() => {
                this.log("new connection connected");
              });
            });
          }), this.context = A, this.context.startTime = Date.now(), this.connection = new Connection(A, t, false), this.instanceId = e, this.lastPingTime = [0, 0], this.setMaxListeners(512), this.log("The instanceId is %s", this.instanceId.toString()), this.connection.on("syncTicketUpdated", (A2) => {
            let { ticket: e2 } = A2;
            this.emit("syncTicketUpdated", { ticket: e2 });
          }), this.manualShakeHand = g, this.connectDatabase = o;
        }
        async initSync() {
          if (!this.context.disablePresence) {
            this._syncEstablishState = SyncEstablishState.CONNECTING;
            try {
              await this.connectDatabase(), this._syncEstablishState = SyncEstablishState.CONNECTED;
            } catch (A) {
              if (this._syncEstablishState = SyncEstablishState.DISCONNECTED, A instanceof RTMBaseError)
                throw A;
              {
                const { code: A2, reason: e } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_LOGIN_TIMEOUT);
                throw new RtmUnavailableError(OperationName.login, [e], A2);
              }
            }
          }
        }
        getVirtualSyncSocket() {
          return this.getLoginSockets().filter((A) => A.env === this.context.connSyncEnv);
        }
        loginHandler() {
          let A = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
          if (this.context.socketUseProxy = false, this.context.connSyncEnv = void 0, this.loggedOut && A) {
            const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_LOGIN_ABORTED);
            throw new RtmInvalidStatusError(OperationName.login, [e2 + "logout when login retrying"], A2);
          }
          A && this.registerConnectionFailureListener(), this.connection.initConnection();
          const { seq: e } = this.context, t = this.getSocketLoginObservables(this.connection.lastOpenSockets, e);
          let g;
          return this.initLoginsSocketsReceivers(t, A, false), this.initKeepAliveSender(), this.initLoginReceiver(), this.context.linkIntervals = [...LINK_INTERVALS], this.log("start login..."), merge(...t, fromEvent(this.connection, "connectionInitFailure").pipe(tap((A2) => {
            if (isRtmError(A2) || isTimeout(A2))
              throw A2;
            const { code: e2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_LOGIN_ABORTED);
            throw new RtmUnavailableError(OperationName.login, [t2], e2);
          })), fromEvent(this, "login-cancel").pipe(tap(() => {
            throw this.connection.handleCancelLogin();
          })), this.networkOnlineSubject.pipe(tap(() => {
            this.log("network change, will retry connect in 2s");
            const A2 = new TimeoutError();
            throw A2.name = "network-change", this.context.linkIntervals = [...LINK_INTERVALS], A2;
          }))).pipe(timeout(LOGIN_RESP_TIMEOUT), take(1), concatMap(async (e2) => {
            try {
              await timeoutPromise(this.connSyncInLogin(e2, A), DEFAULT_RPC_TIMEOUT_TIME, "init sync timeout", RTMErrorCode.RTM_ERROR_LOGIN_TIMEOUT, true);
            } catch (A2) {
              if (this.connection.cancelLogin)
                throw A2;
              if (!getParameter("DECOUPLE_SYNC")) {
                if (e2.forceReconnect(), isTimeout(A2))
                  throw new TimeoutError();
                throw A2;
              }
            }
            return e2;
          }), catchError((e2) => (e2 instanceof TimeoutError && (e2 && "network-change" === e2.name ? this.context.internalEmitter.emit("net-change-abort-reconn") : (this.warn("client ".concat(A ? "re-" : "", "login timeout")), this.context.internalEmitter.emit("login-timeout", A))), e2 && e2.code === RTMErrorCode.RTM_ERROR_TOKEN_EXPIRED && (this.warn("token expired when login, isRetrying: %s", A), A && this.context.internalEmitter.emit("tokenExpired"), this.connection.apClient.apFinish$.next(void 0), this.connection.stopLogin()), this.clearSockets(0, A), throwError(e2))), retryWhen((e2) => e2.pipe(switchMap((e3) => {
            if (this.connection.apClient.apFinish$.next(void 0), g = this.getFallBackTimer(), this.connection.cancelLogin && !A)
              throw this.connection.handleCancelLogin();
            if (e3 instanceof TimeoutError)
              return merge(fromEvent(this, "login-cancel").pipe(tap(() => {
                throw this.connection.handleCancelLogin();
              })), race(interval(g), this.networkOnlineSubject.pipe(tap(() => {
                this.log("network is online, will retry connect now");
              }))).pipe(take(1), takeUntil(this.connection.apClient.apFinish$), tap(() => {
                if (this.connection.cancelLogin)
                  throw this.connection.handleCancelLogin();
                this.context.internalEmitter.emit("login-request"), this.initLoginsSocketsReceivers(t, A, true), this.loginSocketSubs.find((A2) => !A2.keepAlive) && this.initKeepAliveSender(), this.initLoginReceiver(), this.connection.subKeeperSubject(), this.connection.initConnection(), this.log("retryWhen---interval");
              })));
            throw e3;
          }), catchError((A2) => throwError(A2)))), takeUntil(this.loginSubject$), tap(() => {
            A || this.registerConnectionFailureListener();
          }), tap(() => {
            this.manualShakeHand();
          }), finalize(() => {
            A || this.connection.apClient.apFinish$.next(void 0), this.loginSubject$.next(void 0), this.connection.endLogin$.next(void 0);
          }));
        }
        getFallBackTimer() {
          return 1e3 * (this.context.linkIntervals.length >= 1 ? this.context.linkIntervals.splice(0, 1)[0] : SUSPENDED_TIME_INTERVAL);
        }
        async connSyncInLogin(A, e) {
          if (this.context.disablePresence)
            return;
          const t = this.syncEstablishState === SyncEstablishState.DISCONNECTED;
          this.info("ENV_%d(%s): First reg logged response received, need connect sync: %s, connSyncEnv: %d, isRetrying: %s, syncConnecting: %s", A.env, A.name, t, this.context.connSyncEnv, e);
          const g = getParameter("DECOUPLE_SYNC");
          if (t) {
            try {
              await timeoutPromise(this.requestFirstSyncInit(A), 2e3, "syncInitAck timeout", RTMErrorCode.RTM_ERROR_LOGIN_TIMEOUT, true);
            } catch (e2) {
              const t2 = SyncDisconnectedReason.REQUEST_FIRST_SYNC_PHYSICAL_CONNECTION_ERROR;
              throw this.warn("ENV_%d(%s): %s, %o", A.env, A.name, t2, e2), g && !this.connection.cancelLogin && this.handleSyncDisconnected(A, t2), e2;
            }
            try {
              this.log("ENV_".concat(A.env, " - ").concat(A.name, ": reg connect sync done by concatMap when ").concat(e ? "reLogging" : "logging", ", start logging sync..., syncEnv: ").concat(this.context.connSyncEnv)), await this.initSync(), this.log("ENV_".concat(A.env, " - ").concat(A.name, ": logged sync when ").concat(e ? "reLogging" : "logging", "."));
            } catch (e2) {
              this.logError("change connSyncEnv: %d to undefined because first connect sync database error, %o", A.env, e2), this.context.connSyncEnv = void 0;
              const t2 = SyncDisconnectedReason.CONNECT_SYNC_DATABASE_ERROR;
              throw this.emit("syncDisconnected", t2), g && !this.connection.cancelLogin && this.handleSyncDisconnected(A, t2), e2;
            }
          }
        }
        async logoutHandler(A) {
          this.loggedOut = true, this.connection.apClient.apFinish$.next(void 0), this.connection.stopLogin();
          const e = this.getLoginSockets(), t = e.map((e2) => (e2.sendPacket("UserQuit2", { flags: A ? new Long$1(1, 0, true) : Long$1.fromNumber(0) }), this.connection.waitClosing(e2)));
          this.clearSockets(LOGOUT_SOCKET_CLOSE_TIMEOUT);
          const g = e.map((A2) => A2.env);
          return [0, 1].filter((A2) => !g.includes(A2)).forEach((A2) => {
            this.connection.closeSocket(A2, 0);
          }), this.context.internalEmitter.emit("logout-clear-backoff-events-timer"), merge(...t).toPromise();
        }
        cancelSyncTimer() {
          this.syncInitTimer && (clearTimeout(this.syncInitTimer), this.syncInitTimer = null);
        }
        cleanLoginSubs(A) {
          Object.entries(this.loginSocketSubs[A]).forEach((A2) => {
            let [e, t] = A2;
            Array.isArray(t) || t instanceof Map ? t.forEach((A3) => A3.unsubscribe()) : t && t.unsubscribe();
          }), this.loginSocketSubs[A] = { receivers: [] };
        }
        initLoginsSocketsReceivers(A, e, t) {
          const g = Date.now();
          A.forEach((A2, o) => {
            const { login: I } = this.loginSocketSubs[o];
            void 0 === I || t || I.unsubscribe(), this.loginSocketSubs[o].login = A2.pipe(tap((A3) => {
              this.log("Env_%s: acquired socket %s", o, A3.name);
              const t2 = Date.now();
              this.context.addReportEvents("Link", { ackedServerIp: A3.address, destServerIp: A3.ip, ec: 0, sc: 0, elapse: getElapse(this.context.startTime), lts: Long$1.fromNumber(t2), responseTime: t2 - g, sid: getSid(this.instanceId), userId: this.context.uid, version: VERSION_NO, subVersion: SUBVERSION, connectionsequence: Long$1.fromNumber(0), linktype: 4, linkflag: Long$1.fromNumber(0), linkenv: A3.env }), e && this.connection.apClient.apFinish$.next(void 0), this.context.internalEmitter.emit("link-success", A3.env);
            })).subscribe(this.lastLoginSockets[o]);
          });
        }
        initKeepAliveSender() {
          this.lastLoginSockets.map((A) => A.pipe(switchMap((A2) => {
            var e;
            this.loginSocketSubs[A2.env].pingTimer && Date.now() - this.lastPingTime[A2.env] >= this.context.heartbeatInterval ? (null === (e = this.loginSocketSubs[A2.env].pingTimer) || void 0 === e || e.unsubscribe(), this.lastPingTime[A2.env] = 0, A2.loggedIn && (this.log("Env_%s(%s): start a new keep alive sender, unsubscribe last timer", A2.env, A2.name), this.startPingTimer(A2, true))) : this.loginSocketSubs[A2.env].pingTimer || A2.loggedIn && (this.log("Env_%s(%s): start keep alive sender", A2.env, A2.name), this.startPingTimer(A2, true));
            return EMPTY;
          }))).forEach((A, e) => {
            const { keepAlive: t } = this.loginSocketSubs[e];
            void 0 !== t && t.unsubscribe(), this.loginSocketSubs[e].keepAlive = A.subscribe({ error: () => {
            } });
          });
        }
        startPingTimer(A) {
          let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          const t = of(A).pipe(delay(e ? 0 : this.context.heartbeatInterval, isMobile$1() ? void 0 : getHackAsyncScheduler()), tap(() => {
            !A.isActiveClose && this.sendPing(A), t.unsubscribe();
          })).subscribe();
          this.loginSocketSubs[A.env].pingTimer = t;
        }
        initLoginReceiver() {
          var A;
          null === (A = this.tokenPrivilegeSubscription) || void 0 === A || A.unsubscribe();
          const e = race(...this.lastLoginSockets.map((A2) => A2.pipe(switchMap((A3) => A3.fromReceived("UserTicketNearlyExpire2").pipe(throttleTime(3e4), tap((e2) => {
            if (e2.ticket === A3.ticket)
              try {
                const A4 = JSON.parse(e2.resources);
                this.context.internalEmitter.emit("UserTicketNearlyExpire", { messageChannels: A4.messageChannels.map((A5) => {
                  var e3;
                  return null !== (e3 = Object.keys(A5)[0]) && void 0 !== e3 ? e3 : "";
                }).filter((A5) => "" !== A5) });
              } catch (A4) {
                this.logError("parse permission revoked resources failed, error: %o", A4);
              }
          }))))));
          this.tokenPrivilegeSubscription = e.subscribe({ error: (A2) => {
            this.logError("TokenPrivilegeWillExpireReceivers error: %o", A2);
          } });
          this.lastLoginSockets.map((A2) => A2.pipe(switchMap((A3) => merge(A3.fromReceived("StateLockUpdate").pipe(tap((A4) => {
            this.context.internalEmitter.emit("StateLockUpdate", A4);
          })), A3.fromReceived("StateLockSubscribeEvent").pipe(tap((A4) => {
            this.context.internalEmitter.emit("StateLockSubscribeEvent", A4);
          })), A3.fromReceived("StateUpdate").pipe(tap((A4) => {
            this.context.internalEmitter.emit("StateUpdate", A4);
          })), A3.fromReceived("Message").pipe(tap((e2) => {
            this.context.internalEmitter.emit("Message", _objectSpread2(_objectSpread2({}, e2), {}, { eventReportInfo: { env: A3.env } }));
          })), A3.fromReceived("GroupDrop").pipe(tap((A4) => {
            this.context.internalEmitter.emit("GroupDrop", A4);
          })), fromEvent(A3, "reconnect").pipe(tap(this.onSocketReconnect(A3))), A3.fromReceived("UserDrop").pipe(tap(this.onUserDrop(A3))), A3.fromReceived("SyncFin").pipe(tap(this.onSyncFin(A3))), A3.fromReceived("SyncInitAck").pipe(tap(this.onSyncInitAck(A3))), A3.fromReceived("GroupEnterNotice").pipe(tap((A4) => {
            this.context.internalEmitter.emit("GroupEnterNotice", A4);
          })), A3.fromReceived("GroupLeaveNotice").pipe(tap((A4) => {
            this.context.internalEmitter.emit("GroupLeaveNotice", A4);
          })), A3.fromReceived("GroupCountNotice").pipe(tap(this.onGroupCountNotice())), A3.receivedSyncPacket.pipe(tap(this.onSyncPacket()))).pipe(mapTo(void 0))))).forEach((A2, e2) => {
            this.loginSocketSubs[e2].receivers.forEach((A3) => A3.unsubscribe()), this.loginSocketSubs[e2].receivers.push(A2.subscribe({ error: (A3) => {
              this.logError("socketReceiver error: %o", A3);
            }, complete: () => {
              this.log("socketReceiver complete: %o");
            } }));
          });
        }
        clearShakehandTimer() {
          this.shakeHandTimer && (clearTimeout(this.shakeHandTimer), this.shakeHandTimer = null);
        }
        handleConfig(A) {
          if (void 0 !== typeof A["presence.interval"] && isUintString(A["presence.interval"])) {
            const e = Number(A["presence.interval"]);
            e > K_PRESENCE_INTERVAL_MAX ? A["presence.interval"] = String(K_PRESENCE_INTERVAL_MAX) : e < K_PRESENCE_INTERVAL_MIN && (A["presence.interval"] = String(K_PRESENCE_INTERVAL_MIN));
          } else
            A["presence.interval"] = String(K_PRESENCE_INTERVAL_DEFAULT);
          if (void 0 !== typeof A["presence.occupancy"] && isUintString(A["presence.occupancy"])) {
            const e = Number(A["presence.occupancy"]);
            e > K_INTERVAL_THRESHOLD_MAX ? A["presence.occupancy"] = String(K_INTERVAL_THRESHOLD_MAX) : e < K_INTERVAL_THRESHOLD_MIN && (A["presence.occupancy"] = String(K_INTERVAL_THRESHOLD_MIN));
          } else
            A["presence.occupancy"] = String(K_DEFAULT_INTERVAL_THRESHOLD);
          if (void 0 !== typeof A["presence.debounce"] && isUintString(A["presence.debounce"])) {
            const e = Number(A["presence.debounce"]);
            e > K_INTERVAL_THRESHOLD_MAX ? A["presence.debounce"] = String(K_INTERVAL_THRESHOLD_MAX) : e < K_INTERVAL_THRESHOLD_MIN && (A["presence.debounce"] = String(K_INTERVAL_THRESHOLD_MIN));
          } else
            A["presence.debounce"] = String(K_DEBOUNCE_DEFAULT);
        }
        requestSocketLogin(A, e, t, g) {
          const o = defer(() => {
            this.context.internalEmitter.emit("login-request"), this.userJoinOptions = new UserJoinOptions(e), this.log("ENV_%d(%s): socket.isActiveClose: %s, isRejoin: %s", A.env, A.name, A.isActiveClose, e);
            const g2 = !A.isActiveClose;
            if (this.loggedOut)
              return this.log("close other socket, ignore this login request"), void A.close();
            if (g2) {
              var o2;
              const g3 = null !== (o2 = getParameter("RTM_LINK_KEEP_ALIVE_TIMEOUT")) && void 0 !== o2 ? o2 : CONFIGURABLE_KEY_RTM_LINK_KEEP_ALIVE_TIMEOUT;
              e && !this.canEmitUserJoined && (this.canEmitUserJoined = true), A.sendPacket("UserJoin2", { account: this.context.uid, instance: this.instanceId, opt: this.userJoinOptions.toLong(), seq: t, ticket: A.ticket, detail: { [UserJoinDetailKey.kDetailKeyConsoleConfig]: new Uint8Array(), [UserJoinDetailKey.kDetailKeyKeepAliveInterval]: new TextEncoder().encode(String(this.context.heartbeatInterval / 1e3)), [UserJoinDetailKey.kDetailKeyKeepAliveBuffer]: new TextEncoder().encode(String(g3 / 1e3)) } });
            }
          }), I = A.fromReceived("UserResp2").pipe(first((A2) => t.eq(A2.seq)), tap((t2) => {
            if (this.loggedOut)
              return this.log("ENV_%d(%s): other socket is closing, will close this socket, ignore this resp", A.env, A.name), EMPTY;
            const { code: g2 } = t2;
            if (0 !== g2) {
              let A2 = String(g2);
              this.clearSockets();
              let t3 = RTMErrorCode.RTM_ERROR_LOGIN_REJECTED;
              switch (g2) {
                case RegServerErrorCode.kCertificateInvalid:
                case RegServerErrorCode.kTicketParseError:
                case RegServerErrorCode.kTicketIllegalLength:
                case RegServerErrorCode.kTicketNotAuth:
                case RegServerErrorCode.kTicketUnknownVersion:
                case RegServerErrorCode.kTicketInvalid:
                  t3 = RTMErrorCode.RTM_ERROR_INVALID_TOKEN;
                  break;
                case RegServerErrorCode.kTimestampExpired:
                  this.warn("token expired when received userResp, isReJoin: %s", e), e && this.context.internalEmitter.emit("tokenExpired"), this.connection.apClient.apFinish$.next(void 0), this.connection.stopLogin(), t3 = RTMErrorCode.RTM_ERROR_TOKEN_EXPIRED;
                  break;
                case RegServerErrorCode.kUserRejectedByConsoleConfig:
                  t3 = RTMErrorCode.RTM_ERROR_LOGIN_NOT_AUTHORIZED, A2 = "NOT_ENABLE_RTM";
                case RegServerErrorCode.kFail:
                case RegServerErrorCode.kServiceTooHeavy:
              }
              this.logError("Connected to gateway success but the Rtm server rejected login, server code is %s", A2);
              const { code: o3, reason: I2 } = getErrorInfoByCode(t3);
              throw new RtmUnavailableError(OperationName.login, [I2 + " userResp error, detail: ".concat(A2)], o3);
            }
            try {
              let A2;
              const { detail: { 1: e2 } } = t2;
              A2 = JSON.parse(new TextDecoder().decode(e2)), this.handleConfig(A2);
              const g3 = {};
              for (const e3 in A2)
                "_" !== e3[0] && (g3[e3] = A2[e3]);
              this.log("user console config: %o", g3), this.context.consoleConfig = A2;
            } catch (A2) {
              this.warn("parse user console config failed, will use default, error: %o", A2);
            }
            var o2;
            (A.attemptsSinceLastError = 0, A.loggedIn = true, e) && (null === (o2 = this.loginSocketSubs[A.env].pingTimer) || void 0 === o2 || o2.unsubscribe(), this.lastPingTime[A.env] = 0, this.startPingTimer(A, true));
            return this.log("ENV_%d logged in", A.env), A;
          }), mapTo(A), timeout(6e3));
          return concat(o, I).pipe(filter((A2) => void 0 !== A2), tap(() => {
            this.log("ENV_%d(%s): Login response received", g, A.name), this.curLoginSockets[g] = A;
          }), concatMap(async (A2) => {
            const t2 = !A2.isActiveClose;
            return e && this.canEmitUserJoined && t2 && (this.emit("userJoined", A2.env), this.canEmitUserJoined = false), A2;
          }), catchError((t2) => {
            var g2;
            return t2 instanceof TimeoutError && null !== (g2 = this.curLoginSockets[0 === A.env ? 1 : 0]) && void 0 !== g2 && g2.isActiveClose ? (this.log("ENV_%d(%s): other socket is closing, will close this socket", A.env, A.name), EMPTY) : t2 instanceof TimeoutError ? (!e && this.warn("ENV_%d(%s): sdk connect sync or reg response timeout, rejoin: %s", A.env, A.name, e), t2.name = "loginRespTimeout", setTimeout(() => {
              A.emit("socketFailure"), A.close();
            }, SOCKET_RETRY_INTERVAL), of(A).pipe(delay(6e3))) : (this.connection.banIP(A.ip), throwError(t2));
          }));
        }
        getSocketLoginObservables(A, e) {
          return A.map((A2, t) => A2.pipe(switchMap((A3, g) => (this.context.incSeqIfNeeded(A3.env), A3.isActiveClose || this.loggedOut ? EMPTY : (this.log("ENV_%d(%s): start reg login request, isRejoin: %s", A3.env, A3.name, 0 !== g), this.requestSocketLogin(A3, 0 !== g, 0 === g ? e : this.context.seq, t)))), share()));
        }
        getLoginSockets() {
          return compact$1(this.curLoginSockets);
        }
        sendOperationPacket(A, e, t) {
          const g = this.getLoginSockets();
          if (0 === g.length) {
            const { code: e2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_NOT_CONNECTED);
            throw new RtmInvalidStatusError(A, [t2], e2);
          }
          g.forEach((A2) => {
            A2.sendPacket(e, t);
          });
        }
        sendOperationPacketUseOneEnv(A, e, t, g) {
          const o = this.getLoginSockets();
          if (0 === o.length) {
            const { code: e2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_NOT_CONNECTED);
            throw new RtmInvalidStatusError(A, [t2], e2);
          }
          o.forEach((A2) => {
            A2.env === e && A2.sendPacket(t, g);
          });
        }
        onOperationPacket(A) {
          return merge(...this.getLoginSockets().map((e) => e.fromReceived(A).pipe(tap((A2) => _objectSpread2(_objectSpread2({}, A2), {}, { eventReportInfo: { ip: e.ip } })))));
        }
        onSocketReconnect(A) {
          return () => {
            const e = [0, 1].filter((e2) => e2 !== A.env)[0], t = this.connection.curOpenSockets[e], g = this.context.connSyncEnv === A.env;
            this.log("ENV_".concat(A.env, "(").concat(A.name, "): received a reconnect event from ").concat(maskIp(A.address), ", otherSocketState: ").concat(null == t ? void 0 : t.loggedIn, ", syncEnv: ").concat(g)), g && this.syncEstablishState === SyncEstablishState.CONNECTED && this.handleSyncDisconnected(A, SyncDisconnectedReason.REG_SOCKET_RECONNECT), t && !t.loggedIn && (this.log("ENV_".concat(A.env, "(").concat(A.name, "): will emit connectionLost")), g || this.syncEstablishState !== SyncEstablishState.CONNECTED || this.handleSyncDisconnected(t, SyncDisconnectedReason.REG_SOCKET_RECONNECT)), null != t && t.loggedIn || this.context.internalEmitter.emit("connectionLost");
          };
        }
        onGroupCountNotice() {
          return (A) => {
            let { group: e, size: t } = A;
            this.log("group count notice: %s, %s", e, t);
          };
        }
        async requestFirstSyncInit(A) {
          let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          if (this.context.disablePresence)
            return;
          this.cancelSyncTimer(), this.syncEstablishState = SyncEstablishState["SYNCINIT_".concat(A.env)];
          const t = this.context.incGetSeq();
          return e && (this.firstInitSyncSeq = t), this.log("ENV_".concat(A.env, " - ").concat(A.name, ": request ").concat(e ? "first" : "", " sync physical connection, seq: ").concat(t.toNumber())), this.syncInitSeq = t, A.sendPacket(getParameter("DECOUPLE_SYNC") ? "SyncInit2" : "SyncInit", { seq: t }), A.fromReceived("SyncInitAck").pipe(first((A2) => A2.seq.eq(t)), map$1(async (e2) => {
            if (0 !== e2.code)
              throw this.context.connSyncEnv = void 0, this.warn("change connSyncEnv %d to undefined in requestFirstSyncInit", A.env), new Error("reg connect sync error, code is ".concat(e2.code));
            this.log("reg connect sync succeed, change sync connected"), this.emit("syncConnected"), this.context.connSyncEnv = A.env;
          })).toPromise();
        }
        onSyncFin(A) {
          return (e) => {
            let { code: t } = e;
            this.warn("ENV_%d: reg and sync conn is fin, connSyncEnv is %d, code is %d, %s, syncEstablishState is %s", A.env, this.context.connSyncEnv, t, A.name, this.syncEstablishState), this.syncEstablishState === SyncEstablishState.CONNECTED && (this.emit("syncDisconnected", "sync fin"), isNil$1(this.context.connSyncEnv) || this.context.connSyncEnv !== A.env || this.handleSyncDisconnected(A, SyncDisconnectedReason.SYNC_FIN));
          };
        }
        onSyncInitAck(A) {
          return async (e) => {
            let { code: t, seq: g } = e;
            if (this.context.disablePresence)
              return;
            if (this.firstInitSyncSeq && g.eq(this.firstInitSyncSeq))
              return void this.log("first sync init ack, ignore.");
            if (this.syncInitSeq && g < this.syncInitSeq)
              return void this.log("sync init ack is outdated, ignore.");
            const o = getParameter("DECOUPLE_SYNC");
            if (0 !== t)
              this.warn("reg connect sync error, code: ".concat(t)), o || (A.emit("socketFailure"), A.close()), this.context.connSyncEnv = void 0, this.warn("change connSyncEnv %d to undefined in onSyncInitAck error", A.env);
            else {
              this.context.connSyncEnv = A.env, this.log("sync physical connect success, will emit sync connected, connSyncEnv: %d", this.context.connSyncEnv), this.emit("syncConnected");
              try {
                await this.initSync();
              } catch (e2) {
                this.logError("received syncInitAck and connect sync database error: %o", e2), o ? this.handleSyncDisconnected(A, "connect sync database error") : A.forceReconnect();
              }
            }
          };
        }
        retrySyncInit(A) {
          this.cancelSyncTimer(), this.syncEstablishState === SyncEstablishState.DISCONNECTED && timeoutPromise(this.requestFirstSyncInit(A, false), 5e3, "syncInitAck timeout", RTMErrorCode.RTM_ERROR_LOGIN_TIMEOUT, true).catch((e) => {
            this.warn("Env_%s: request sync physical connection error: %o", A.env, e), this.handleSyncDisconnected(A, SyncDisconnectedReason.RETRY_SYNC_PHYSICAL_CONNECTION, isTimeout(e) ? 0 : 5e3);
          });
        }
        handleSyncDisconnected(A, e) {
          let t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
          if (!isNil$1(this.context.connSyncEnv) && this.context.connSyncEnv !== A.env)
            return void this.warn("Now connSyncEnv is not equal to socket env, can't handle disconnected");
          if (this.emit("syncDisconnected", "handle handleSyncDisconnected, reason: " + e), this.context.connSyncEnv = void 0, this.syncEstablishState = SyncEstablishState.DISCONNECTED, this.cancelSyncTimer(), this.clearShakehandTimer(), this.loggedOut)
            return;
          e !== SyncDisconnectedReason.REG_SOCKET_RECONNECT && e !== SyncDisconnectedReason.RETRY_SYNC_PHYSICAL_CONNECTION && this.context.internalEmitter.emit("presence-backoff");
          const g = [0, 1].filter((e2) => e2 !== A.env)[0], o = this.connection.curOpenSockets[g];
          o && o.loggedIn ? (this.info("use another env to connect sync, env: %d(%s)", o.env, o.name), this.syncInitTimer = setTimeout(() => {
            this.retrySyncInit(o);
          }, t)) : !getParameter("DECOUPLE_SYNC") || null != o && o.loggedIn || (this.info("use same env to connect sync, env: %d(%s), loggedIn: %s", A.env, A.name, A.loggedIn), this.syncInitTimer = setTimeout(() => {
            this.retrySyncInit(A);
          }, t));
        }
        onSyncPacket() {
          return (A) => {
            102 === getSyncPacketUri(A) && this.clearShakehandTimer(), this.emit("syncPacket", A);
          };
        }
        onUserDrop(A) {
          return (e) => {
            let { code: t } = e;
            if (t === RegServerErrorCode.kConnectionTimeout)
              return void this.warn("connection timeout");
            if (this.context.addReportEvents("KickedOff", { code: 0, elapse: getElapse(this.context.startTime), linkId: parseInt(A.name.split("-")[1], 10), lts: Long$1.fromNumber(Date.now()), server: A.address, serverCode: t, sid: getSid(this.instanceId), userId: this.context.uid }), t === RegServerErrorCode.kUserInstanceConflict)
              return this.warn("The instance ID conflicts, reconnecting"), this.instanceId = getRandomUInt64(), this.context.instanceId = this.instanceId, this.context.sid = getSid(this.instanceId), void this.context.internalEmitter.emit("instanceChanged", this.instanceId);
            [RegServerErrorCode.kTimestampExpired, RegServerErrorCode.kRejoined, RegServerErrorCode.kUidBanned, RegServerErrorCode.kIpBanned, RegServerErrorCode.kChannelBanned, RegServerErrorCode.kUserBannedByAuth, RegServerErrorCode.kJoinTooFrequently].includes(t) && (this.emit("syncDisconnected", "userDrop"), this.loggedOut = true, this.context.internalEmitter.emit("userDrop", t), this.connection.cancelLogin = true, this.emit("login-cancel"), this.clearSockets());
          };
        }
        clearSockets() {
          let A = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          this.info("clearSockets, delayTime: %d, isRetrying: %s", A, e), [0, 1].forEach((e2) => {
            this.cleanLoginSubs(e2), this.connection.closeSocket(e2, A);
          });
        }
        handleHeartbeatTimeout(A) {
          var e;
          const t = this.context.heartbeatInterval + (null !== (e = getParameter("RTM_LINK_KEEP_ALIVE_TIMEOUT")) && void 0 !== e ? e : CONFIGURABLE_KEY_RTM_LINK_KEEP_ALIVE_TIMEOUT) - 2 * SOCKET_RETRY_INTERVAL;
          this.warn("ENV_".concat(A.env, "(").concat(A.name, "): registrar forceReconnect, the last received packet is the same as it was ").concat(t / 1e3, "s ago ")), A.forceReconnect();
        }
        sendPing(A) {
          var e;
          if (Date.now() - this.lastPingTime[A.env] <= this.context.heartbeatInterval || !A.loggedIn)
            return;
          this.context.incSeqIfNeeded(A.env);
          const t = this.context.seq, g = this.context.heartbeatInterval + (null !== (e = getParameter("RTM_LINK_KEEP_ALIVE_TIMEOUT")) && void 0 !== e ? e : CONFIGURABLE_KEY_RTM_LINK_KEEP_ALIVE_TIMEOUT) - 2 * SOCKET_RETRY_INTERVAL;
          this._lastPingSequences[A.env] = t, A.sendPacket("Ping3", { ms: Long$1.fromNumber(Date.now(), true), seq: t, flags: new Long$1(3, 0, true) }), this.lastPingTime[A.env] = Date.now(), A.env === this.context.connSyncEnv && (this.manualShakeHand(), this.shakeHandTimer = setTimeout(() => {
            this.loggedOut || (this.warn("not received shakeHand response in heartbeat interval"), this.context.internalEmitter.emit("presence-backoff"));
          }, SHAKEHAND_TIMEOUT));
          const o = A.fromReceived("Pong3").pipe(filter((A2) => {
            let { seq: e2 } = A2;
            return e2.eq(t);
          }), take(1), tap((e2) => {
            let { serverMs: t2 } = e2;
            this.context.pongTime = t2.toNumber(), this.context.offsetTime = this.context.pongTime - (/* @__PURE__ */ new Date()).getTime(), this.startPingTimer(A);
          }), timeout(g), catchError((e2) => (false === A.loggedIn || this._lastPingSequences[A.env].greaterThan(t) || (this.warn("ENV: %d, loggedIn: %s, received pong error, seq: %s, e: %o", A.env, A.loggedIn, t.toNumber(), e2), e2 instanceof TimeoutError && (A.env === this.context.connSyncEnv && this.clearShakehandTimer(), this.handleHeartbeatTimeout(A))), EMPTY)), finalize(() => {
            o.unsubscribe();
          })).subscribe();
        }
        notifyNetworkChange(A) {
          this.networkOnlineSubject.next(A);
        }
        updateRegTicket(A) {
          this.curLoginSockets.filter((A2) => void 0 !== A2).forEach((e) => e.ticket = A);
        }
        updateLoggedOut(A) {
          this.loggedOut = A;
        }
      }
      class CollectionEvent {
        constructor(A, e, t, g) {
          this.document = A, this.path = e, this.type = t, this.value = g;
        }
      }
      var CollectionEventType;
      !function(A) {
        A.Put = "Put", A.Insert = "Insert", A.Delete = "Delete", A.DocSyncEnd = "DocSyncEnd";
      }(CollectionEventType || (CollectionEventType = {}));
      var CollectionEventType$1 = CollectionEventType;
      class SyncCounter {
        constructor(A, e, t, g, o) {
          this.docInstance = A, this.path = e, this.documentIn = t, this.collectionIn = g, this.client = o;
        }
        Set(A) {
          if (Math.round(A) != A)
            throw new TypeError("The value is expected to be an int, but a double was got.");
          if (!checkAll(this.documentIn, this.collectionIn.writable))
            throw new Error("The current collection is forbidden to write the Document : " + this.documentIn);
          const e = Module._rte_crdt_path_create();
          parsePath(this.path, e);
          const t = Module._rte_crdt_nested_value_create();
          if (0 !== Module._rte_crdt_document_get(this.docInstance, null, e, t))
            throw Module._rte_crdt_nested_value_destroy(t), Module._rte_crdt_path_destroy(e), new Error("The counter no longer exists.");
          counterCheckAndReplace(t, e, this.docInstance), Module._rte_crdt_document_batch_write_begin(this.docInstance), setValue(this.docInstance, null, A, e, true), Module._rte_crdt_document_batch_write_end(this.docInstance), Module._rte_crdt_nested_value_destroy(t), Module._rte_crdt_path_destroy(e), this.client.connected && tickLoop(this.client);
        }
        Inc() {
          let A = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
          if (Math.round(A) != A)
            throw new TypeError("The delta is expected to be an int, but a double was got.");
          if (!checkAll(this.documentIn, this.collectionIn.writable))
            throw new Error("The current collection is forbidden to write the Document : " + this.documentIn);
          const e = Module._rte_crdt_path_create();
          parsePath(this.path, e);
          const t = Module._rte_crdt_nested_value_create();
          if (0 !== Module._rte_crdt_document_get(this.docInstance, null, e, t))
            throw Module._rte_crdt_nested_value_destroy(t), Module._rte_crdt_path_destroy(e), new Error("The counter no longer exists.");
          counterCheckAndReplace(t, e, this.docInstance), Module._rte_crdt_document_batch_write_begin(this.docInstance), Module._rte_crdt_document_increment(this.docInstance, null, e, BigInt(A)), Module._rte_crdt_document_batch_write_end(this.docInstance), Module._rte_crdt_nested_value_destroy(t), Module._rte_crdt_path_destroy(e), this.client.connected && tickLoop(this.client);
        }
        Dec() {
          let A = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
          if (Math.round(A) != A)
            throw new TypeError("The delta is expected to be an int, but a double was got.");
          if (!checkAll(this.documentIn, this.collectionIn.writable))
            throw new Error("The current collection is forbidden to write the Document : " + this.documentIn);
          const e = Module._rte_crdt_path_create();
          parsePath(this.path, e);
          const t = Module._rte_crdt_nested_value_create();
          if (0 !== Module._rte_crdt_document_get(this.docInstance, null, e, t))
            throw Module._rte_crdt_nested_value_destroy(t), Module._rte_crdt_path_destroy(e), new Error("The counter no longer exists.");
          counterCheckAndReplace(t, e, this.docInstance), Module._rte_crdt_document_batch_write_begin(this.docInstance), Module._rte_crdt_document_increment(this.docInstance, null, e, -BigInt(A)), Module._rte_crdt_document_batch_write_end(this.docInstance), Module._rte_crdt_nested_value_destroy(t), Module._rte_crdt_path_destroy(e), this.client.connected && tickLoop(this.client);
        }
        Value() {
          if (!checkAll(this.documentIn, this.collectionIn.readable))
            throw new Error("The current collection is forbidden to read the Document : " + this.documentIn);
          let A;
          const e = Module._rte_crdt_path_create();
          parsePath(this.path, e);
          const t = Module._rte_crdt_nested_value_create();
          if (0 !== Module._rte_crdt_document_get(this.docInstance, null, e, t))
            throw Module._rte_crdt_nested_value_destroy(t), Module._rte_crdt_path_destroy(e), new Error("The counter no longer exists.");
          return counterCheckAndReplace(t, e, this.docInstance), A = getScalarValue(t), Module._rte_crdt_nested_value_destroy(t), Module._rte_crdt_path_destroy(e), A;
        }
      }
      class List {
        constructor(A, e, t, g, o) {
          this.docInstance = A, this.path = e, this.documentIn = t, this.collectionIn = g, this.client = o;
        }
        Insert(A, e) {
          if (Math.round(A) != A)
            throw new TypeError("The index is expected to be an int, but a double was got.");
          if (!checkAll(this.documentIn, this.collectionIn.writable))
            throw new Error("The current collection is forbidden to write the Document : " + this.documentIn);
          const t = Module._rte_crdt_path_create();
          parsePath(this.path, t);
          const g = Module._rte_crdt_nested_value_create();
          if (0 !== Module._rte_crdt_document_get(this.docInstance, null, t, g) || !Module._rte_crdt_nested_value_is_list(g))
            throw Module._rte_crdt_nested_value_destroy(g), Module._rte_crdt_path_destroy(t), new Error("The list no longer exists.");
          {
            const o = Module._rte_crdt_nested_value_iterator_create(g);
            let I = 0;
            for (; ; ) {
              if (305 === Module._rte_crdt_nested_value_iterator_next_value(o, null))
                break;
              I += 1;
            }
            if (Module._rte_crdt_nested_value_iterator_destroy(o), A < 0 || A > I)
              throw Module._rte_crdt_nested_value_destroy(g), Module._rte_crdt_path_destroy(t), new Error("The index is out of bound.");
            Module._rte_crdt_document_batch_write_begin(this.docInstance);
            for (let g2 = 0; g2 < e.length; g2++) {
              const o2 = e[g2];
              setValue(this.docInstance, A, o2, t), A += 1;
            }
            Module._rte_crdt_document_batch_write_end(this.docInstance);
          }
          Module._rte_crdt_nested_value_destroy(g), Module._rte_crdt_path_destroy(t), this.client.connected && tickLoop(this.client);
        }
        Append(A) {
          if (!checkAll(this.documentIn, this.collectionIn.writable))
            throw new Error("The current collection is forbidden to write the Document : " + this.documentIn);
          const e = Module._rte_crdt_path_create();
          parsePath(this.path, e);
          const t = Module._rte_crdt_nested_value_create();
          if (0 !== Module._rte_crdt_document_get(this.docInstance, null, e, t) || !Module._rte_crdt_nested_value_is_list(t))
            throw Module._rte_crdt_nested_value_destroy(t), Module._rte_crdt_path_destroy(e), new Error("The list no longer exists.");
          {
            const g = Module._rte_crdt_nested_value_iterator_create(t);
            let o = 0;
            for (; ; ) {
              if (305 === Module._rte_crdt_nested_value_iterator_next_value(g, null))
                break;
              o += 1;
            }
            Module._rte_crdt_nested_value_iterator_destroy(g), Module._rte_crdt_document_batch_write_begin(this.docInstance);
            for (let t2 = 0; t2 < A.length; t2++) {
              const g2 = A[t2];
              setValue(this.docInstance, o, g2, e), o += 1;
            }
            Module._rte_crdt_document_batch_write_end(this.docInstance);
          }
          Module._rte_crdt_nested_value_destroy(t), Module._rte_crdt_path_destroy(e), this.client.connected && tickLoop(this.client);
        }
        Remove(A) {
          for (let e2 = 0; e2 < A.length; e2++) {
            const t2 = A[e2];
            if (Math.round(t2) != t2)
              throw new TypeError("The indexes is expected to be an array of int, but a double was got in the array.");
          }
          if (!checkAll(this.documentIn, this.collectionIn.writable))
            throw new Error("The current collection is forbidden to write the Document : " + this.documentIn);
          let e = A.filter((A2, e2, t2) => t2.indexOf(A2) === e2), t = e.sort();
          const g = Module._rte_crdt_path_create();
          parsePath(this.path, g);
          const o = Module._rte_crdt_nested_value_create();
          if (0 !== Module._rte_crdt_document_get(this.docInstance, null, g, o) || !Module._rte_crdt_nested_value_is_list(o))
            throw Module._rte_crdt_nested_value_destroy(o), Module._rte_crdt_path_destroy(g), new Error("The list no longer exists.");
          {
            const e2 = Module._rte_crdt_nested_value_iterator_create(o);
            let I = 0;
            for (; ; ) {
              if (305 === Module._rte_crdt_nested_value_iterator_next_value(e2, null))
                break;
              I += 1;
            }
            Module._rte_crdt_nested_value_iterator_destroy(e2);
            for (let e3 = 0; e3 < A.length; e3++) {
              const t2 = A[e3];
              if (t2 < 0 || t2 > I)
                throw Module._rte_crdt_nested_value_destroy(o), Module._rte_crdt_path_destroy(g), new Error("The index is out of bound.");
            }
            let i2 = 0;
            Module._rte_crdt_document_batch_write_begin(this.docInstance);
            for (let A2 = 0; A2 < t.length; A2++) {
              let e3 = t[A2];
              const g2 = Module._rte_crdt_path_create();
              e3 -= i2, parsePath(this.path + "[" + e3.toString() + "]", g2), Module._rte_crdt_document_delete(this.docInstance, null, g2), i2 += 1, Module._rte_crdt_path_destroy(g2);
            }
            Module._rte_crdt_document_batch_write_end(this.docInstance);
          }
          Module._rte_crdt_nested_value_destroy(o), Module._rte_crdt_path_destroy(g), this.client.connected && tickLoop(this.client);
        }
        Value() {
          if (!checkAll(this.documentIn, this.collectionIn.readable))
            throw new Error("The current collection is forbidden to read the Document : " + this.documentIn);
          let A = [];
          const e = Module._rte_crdt_path_create();
          parsePath(this.path, e);
          const t = Module._rte_crdt_nested_value_create();
          if (0 !== Module._rte_crdt_document_get(this.docInstance, null, e, t) || !Module._rte_crdt_nested_value_is_list(t))
            throw Module._rte_crdt_nested_value_destroy(t), Module._rte_crdt_path_destroy(e), new Error("The list no longer exists.");
          return getAll(this.docInstance, t, A, true), Module._rte_crdt_path_destroy(e), Module._rte_crdt_nested_value_destroy(t), A;
        }
      }
      class Map$1 {
        constructor(A, e, t, g, o) {
          this.docInstance = A, this.path = e, this.documentIn = t, this.collectionIn = g, this.client = o;
        }
        Set(A) {
          if (!isDict(A))
            throw new TypeError("The value should be in JSON format");
          if (!checkAll(this.documentIn, this.collectionIn.writable))
            throw new Error("The current collection is forbidden to write the Document : " + this.documentIn);
          const e = Module._rte_crdt_path_create();
          parsePath(this.path, e);
          const t = Module._rte_crdt_nested_value_create();
          if (0 !== Module._rte_crdt_document_get(this.docInstance, null, e, t) || !Module._rte_crdt_nested_value_is_map(t))
            throw Module._rte_crdt_nested_value_destroy(t), Module._rte_crdt_path_destroy(e), new Error("The map no longer exists.");
          Module._rte_crdt_document_batch_write_begin(this.docInstance);
          for (let t2 = 0, g = Object.entries(A); t2 < g.length; t2++) {
            const [A2, o] = g[t2];
            setValue(this.docInstance, A2, o, e);
          }
          Module._rte_crdt_document_batch_write_end(this.docInstance), Module._rte_crdt_nested_value_destroy(t), Module._rte_crdt_path_destroy(e), this.client.connected && tickLoop(this.client);
        }
        Delete(A) {
          if (!checkAll(this.documentIn, this.collectionIn.writable))
            throw new Error("The current collection is forbidden to write the Document : " + this.documentIn);
          const e = Module._rte_crdt_path_create();
          parsePath(this.path, e);
          const t = Module._rte_crdt_nested_value_create();
          if (0 !== Module._rte_crdt_document_get(this.docInstance, null, e, t) || !Module._rte_crdt_nested_value_is_map(t))
            throw Module._rte_crdt_nested_value_destroy(t), Module._rte_crdt_path_destroy(e), new Error("The map no longer exists.");
          Module._rte_crdt_document_batch_write_begin(this.docInstance);
          for (let t2 = 0; t2 < A.length; t2++) {
            const g = A[t2], o = Module._rte_crdt_path_clone(e), I = getPtrWithStr(g);
            Module._rte_crdt_path_add_property(o, I, getRealLenWithStrBI(g)), releasePtr(I), Module._rte_crdt_document_delete(this.docInstance, null, o), Module._rte_crdt_path_destroy(o);
          }
          Module._rte_crdt_document_batch_write_end(this.docInstance), Module._rte_crdt_nested_value_destroy(t), Module._rte_crdt_path_destroy(e), this.client.connected && tickLoop(this.client);
        }
        Value() {
          if (!checkAll(this.documentIn, this.collectionIn.readable))
            throw new Error("The current collection is forbidden to read the Document : " + this.documentIn);
          let A = {};
          const e = Module._rte_crdt_path_create();
          parsePath(this.path, e);
          const t = Module._rte_crdt_nested_value_create();
          if (0 !== Module._rte_crdt_document_get(this.docInstance, null, e, t) || !Module._rte_crdt_nested_value_is_map(t))
            throw Module._rte_crdt_nested_value_destroy(t), Module._rte_crdt_path_destroy(e), new Error("The map no longer exists.");
          return getAll(this.docInstance, t, A, false), Module._rte_crdt_nested_value_destroy(t), Module._rte_crdt_path_destroy(e), A;
        }
      }
      class SyncDocument {
        constructor(A, e, t, g) {
          this.docInstance = A, this.name = e, this.collectionIn = t, this.client = g;
        }
        Set(A) {
          if (!isDict(A))
            throw new TypeError("The value should be in JSON format");
          if (!checkAll(this.name, this.collectionIn.writable))
            throw new Error("The current collection is forbidden to write the Document : " + this.name);
          Module._rte_crdt_document_batch_write_begin(this.docInstance);
          const e = Module._rte_crdt_path_create();
          for (let t = 0, g = Object.entries(A); t < g.length; t++) {
            const [A2, o] = g[t];
            setValue(this.docInstance, A2, o, e);
          }
          Module._rte_crdt_document_batch_write_end(this.docInstance), Module._rte_crdt_path_destroy(e), this.client.connected && tickLoop(this.client);
        }
        Update(A, e) {
          if (!checkAll(this.name, this.collectionIn.writable))
            throw new Error("The current collection is forbidden to write the Document : " + this.name);
          Module._rte_crdt_document_batch_write_begin(this.docInstance);
          const t = Module._rte_crdt_path_create();
          parsePath(A, t, true), setValue(this.docInstance, null, e, t), Module._rte_crdt_document_batch_write_end(this.docInstance), this.client.connected && tickLoop(this.client);
        }
        Del(A) {
          if (!checkAll(this.name, this.collectionIn.writable))
            throw new Error("The current collection is forbidden to write the Document : " + this.name);
          Module._rte_crdt_document_batch_write_begin(this.docInstance);
          for (let e = 0; e < A.length; e++) {
            const t = A[e], g = Module._rte_crdt_path_create();
            parsePath(t, g, true), Module._rte_crdt_document_delete(this.docInstance, null, g), Module._rte_crdt_path_destroy(g);
          }
          Module._rte_crdt_document_batch_write_end(this.docInstance), this.client.connected && tickLoop(this.client);
        }
        Get() {
          if (!checkAll(this.name, this.collectionIn.readable))
            throw new Error("The current collection is forbidden to read the Document : " + this.name);
          let A = {};
          const e = Module._rte_crdt_path_create(), t = Module._rte_crdt_nested_value_create();
          try {
            return Module._rte_crdt_document_get(this.docInstance, null, e, t), getAll(this.docInstance, t, A, false), Module._rte_crdt_path_destroy(e), Module._rte_crdt_nested_value_destroy(t), A;
          } catch (A2) {
            Module._rte_crdt_path_destroy(e), Module._rte_crdt_nested_value_destroy(t), logger("The Error Stack is : ".concat(A2.Stack), this.collectionIn.getLogger, "error");
          }
        }
        Counter(A, e) {
          const t = Module._rte_crdt_path_create();
          parsePath(A, t, true);
          const g = Module._rte_crdt_nested_value_create();
          let o;
          try {
            o = Module._rte_crdt_document_get(this.docInstance, null, t, g);
          } catch (A2) {
            throw Module._rte_crdt_nested_value_destroy(g), Module._rte_crdt_path_destroy(t), new Error("The path is invalid");
          }
          if (0 != o) {
            if (!e)
              throw new Error("The given path leads to an empty field and the 'create' is false.");
            Module._rte_crdt_document_batch_write_begin(this.docInstance), setValue(this.docInstance, null, 0, t, true), Module._rte_crdt_document_batch_write_end(this.docInstance);
          } else {
            if (!Module._rte_crdt_nested_value_is_scalar(g))
              throw Module._rte_crdt_nested_value_destroy(g), Module._rte_crdt_path_destroy(t), new TypeError("The given path does not lead to a counter.");
            {
              const A2 = Module._rte_crdt_nested_value_get_scalar(g);
              if (!Module._rte_crdt_scalar_value_is_counter(A2) && !Module._rte_crdt_scalar_value_is_i64(A2))
                throw new TypeError("The given path does not lead to a counter.");
              if (Module._rte_crdt_scalar_value_is_i64(A2)) {
                const A3 = getScalarValue(g);
                Module._rte_crdt_document_batch_write_begin(this.docInstance), setValue(this.docInstance, null, A3, t, true), Module._rte_crdt_document_batch_write_end(this.docInstance);
              }
            }
          }
          return Module._rte_crdt_nested_value_destroy(g), Module._rte_crdt_path_destroy(t), new SyncCounter(this.docInstance, A, this.name, this.collectionIn, this.client);
        }
        Map(A, e) {
          const t = Module._rte_crdt_path_create();
          parsePath(A, t, true);
          const g = Module._rte_crdt_nested_value_create();
          let o;
          try {
            o = Module._rte_crdt_document_get(this.docInstance, null, t, g);
          } catch (A2) {
            throw Module._rte_crdt_nested_value_destroy(g), Module._rte_crdt_path_destroy(t), new Error("The path is invalid!");
          }
          if (0 != o) {
            if (!e)
              throw new Error("The given path leads to an empty field and the 'create' is false.");
            Module._rte_crdt_document_batch_write_begin(this.docInstance), setValue(this.docInstance, null, {}, t), Module._rte_crdt_document_batch_write_end(this.docInstance);
          } else if (!Module._rte_crdt_nested_value_is_map(g))
            throw Module._rte_crdt_nested_value_destroy(g), Module._rte_crdt_path_destroy(t), new TypeError("The given path does not lead to a map.");
          return Module._rte_crdt_nested_value_destroy(g), Module._rte_crdt_path_destroy(t), new Map$1(this.docInstance, A, this.name, this.collectionIn, this.client);
        }
        List(A, e) {
          const t = Module._rte_crdt_path_create();
          parsePath(A, t, true);
          const g = Module._rte_crdt_nested_value_create();
          let o;
          try {
            o = Module._rte_crdt_document_get(this.docInstance, null, t, g);
          } catch (A2) {
            throw Module._rte_crdt_nested_value_destroy(g), Module._rte_crdt_path_destroy(t), new Error("The path is invalid!");
          }
          if (0 != o) {
            if (!e)
              throw new Error("The given path leads to an empty field and the 'create' is false.");
            Module._rte_crdt_document_batch_write_begin(this.docInstance), setValue(this.docInstance, null, [], t), Module._rte_crdt_document_batch_write_end(this.docInstance);
          } else if (!Module._rte_crdt_nested_value_is_list(g))
            throw Module._rte_crdt_nested_value_destroy(g), Module._rte_crdt_path_destroy(t), new TypeError("The given path does not lead to a list.");
          return Module._rte_crdt_nested_value_destroy(g), Module._rte_crdt_path_destroy(t), new List(this.docInstance, A, this.name, this.collectionIn, this.client);
        }
        Keepalive(A) {
          if (!isInteger(A))
            throw new TypeError("The ttl is expected to be an interger, but a double was got.");
          const e = getPtrWithStr(this.collectionIn.dbIn), t = getPtrWithStr(this.collectionIn.name), g = getPtrWithStr(this.name);
          Module._sync_client_keepalive(this.client.clientPtr, e, t, g, A), releasePtr(e), releasePtr(t), releasePtr(g);
        }
      }
      class SyncCollection {
        constructor(A, e, t, g, o, I, i2) {
          this.colPtr = A, this.name = e, this.client = t, this.readable = g, this.writable = o, this.dbIn = I, this.channel = new eventsExports.EventEmitter(), this.cb = null, this.getLogger = i2;
        }
        PutDoc(A) {
          if (!checkAll(A, this.writable))
            throw new Error("The current collection is forbidden to write the Document : " + A);
          const e = getPtrWithStr(A);
          Module._rte_crdt_collection_put_doc(this.colPtr, e, getRealLenWithStrBI(A));
          const t = getPtrWithStr(this.name);
          releasePtr(e), releasePtr(t), this.client.connected && tickLoop(this.client);
        }
        DelDoc(A) {
          if (!checkAll(A, this.writable))
            throw new Error("The current collection is forbidden to write the Document : " + A);
          const e = getPtrWithStr(A), t = getPtrWithStr(this.name);
          Module._rte_crdt_collection_delete_doc(this.colPtr, e, getRealLenWithStrBI(A)), releasePtr(e), releasePtr(t), this.client.connected && tickLoop(this.client);
        }
        Docs() {
          let A = /* @__PURE__ */ new Map(), e = Module._rte_crdt_collection_iterator_create(this.colPtr, null, BigInt(0)), t = 0;
          const g = Module._malloc(4), o = Module._malloc(4);
          for (; t = Module._rte_crdt_collection_iterator_next(e, o, g), 305 !== t; ) {
            const e2 = Module.getValue(o, "i32"), t2 = Module.UTF8ToString(e2).valueOf(), g2 = getPtrWithStr(t2), I = Module._rte_crdt_collection_ref_doc(this.colPtr, g2, getRealLenWithStrBI(t2));
            releasePtr(g2);
            const i2 = new SyncDocument(I, t2, this, this.client);
            A.set(t2, i2);
          }
          return releasePtr(g), releasePtr(o), A;
        }
        Doc(A) {
          const e = getPtrWithStr(A), t = Module._rte_crdt_collection_ref_doc(this.colPtr, e, getRealLenWithStrBI(A));
          return releasePtr(e), 0 != t ? new SyncDocument(t, A, this, this.client) : null;
        }
        Subscribe() {
          return null !== this.cb ? (logger("The Collection : ".concat(this.name, " has already been subscribed."), this.getLogger, "info"), null) : (this.cb = subscribe(this, this.channel), this.channel);
        }
        UnSubscribe() {
          this.channel.removeAllListeners(), null != this.cb && (Module.removeFunction(this.cb), this.cb = null), logger("The Collection : ".concat(this.name, " has been unsubscribed successfully."), this.getLogger, "info");
        }
        AddReadable(A) {
          let e = getPtrWithStr(this.dbIn), t = getPtrWithStr(this.name), g = getPtrWithStr(A);
          if (0 != Module._sync_client_add_readable(this.client.clientPtr, e, t, g))
            throw releasePtrs([e, t, g]), new Error("Attempt to add an existing readable: ".concat(A));
          this.client.connected && tickLoop(this.client), releasePtrs([e, t, g]);
        }
        RemoveReadable(A) {
          let e = getPtrWithStr(this.dbIn), t = getPtrWithStr(this.name), g = getPtrWithStr(A);
          Module._sync_client_remove_readable(this.client.clientPtr, e, t, g), this.client.connected && tickLoop(this.client), releasePtrs([e, t, g]);
        }
        SetSyncInterval(A) {
          if (!isInteger(A) || A < 0)
            throw new Error("Seconds should be a non-negative integer");
          let e = getPtrWithStr(this.dbIn), t = getPtrWithStr(this.name);
          Module._sync_client_set_sync_interval(this.client.clientPtr, e, t, A), this.client.connected && tickLoop(this.client), releasePtrs([e, t]);
        }
      }
      class SyncDatabase {
        constructor(A, e) {
          this.name = A, this.client = e, this.colls = /* @__PURE__ */ new Map(), this.keepAliveTimers = /* @__PURE__ */ new Map();
        }
        async CreateCollection(A, e, t) {
          if (this.colls.has(A))
            throw new Error("The collection : ".concat(A, " has alreay existed in this database."));
          try {
            await promisify(createCollection)({ client: this.client, db: this.name, coll: A, readable: e });
          } catch (A2) {
            logger("Collection init failed by the error : ".concat(A2), this.client.getLogger, "error");
          }
          const g = getPtrWithStr(A), o = getPtrWithStr(this.name), I = Module._sync_client_get_coll(this.client.clientPtr, o, g);
          releasePtr(g), releasePtr(o);
          const i2 = new SyncCollection(I, A, this.client, e, t, this.name, this.client.getLogger);
          this.colls.set(A, i2);
        }
        DestroyCollection(A) {
          let e = false;
          if (this.colls.has(A)) {
            const t = this.colls.get(A);
            if (null != t) {
              const g = getPtrWithStr(t.name), o = getPtrWithStr(this.name);
              Module._sync_client_delete_coll(this.client.clientPtr, o, g), releasePtr(g), releasePtr(o), this.colls.delete(A), e = true;
            }
          }
          logger(e ? "The Collection : ".concat(A, " has been destroyed successfully.") : "The operation to destroy the Collection : ".concat(A, " is failed."), this.client.getLogger, "info");
        }
        Coll(A) {
          return this.colls.has(A) ? this.colls.get(A) : null;
        }
        SetAutoKeepalive(A, e, t) {
          if (!isInteger(t) || t <= 0)
            throw new TypeError("The ttl is expected to be a positive integer.");
          const g = getPtrWithStr(this.name), o = getPtrWithStr(A), I = getPtrWithStr(e);
          Module._sync_client_set_doc_ttl(this.client.clientPtr, g, o, I, t), releasePtr(g), releasePtr(o), releasePtr(I), this.client.connected && tickLoop(this.client);
        }
        CancelAutoKeepalive(A, e) {
          const t = getPtrWithStr(this.name), g = getPtrWithStr(A), o = getPtrWithStr(e);
          Module._sync_client_set_doc_ttl(this.client.clientPtr, t, g, o, 0), releasePtr(t), releasePtr(g), releasePtr(o), this.client.connected && tickLoop(this.client);
        }
        SetAutoKeepaliveRPC(A, e, t) {
          if (!isInteger(t) || t <= 0)
            throw new TypeError("The ttl is expected to be a positive integer.");
          const g = A + " " + e, o = getPtrWithStr(this.name), I = getPtrWithStr(A), i2 = getPtrWithStr(e);
          if (Module._sync_client_keepalive(this.client.clientPtr, o, I, i2, t), releasePtr(o), releasePtr(I), releasePtr(i2), this.client.connected) {
            tickLoop(this.client);
            let o2 = setInterval(() => {
              const g2 = getPtrWithStr(this.name), o3 = getPtrWithStr(A), I2 = getPtrWithStr(e);
              Module._sync_client_keepalive(this.client.clientPtr, g2, o3, I2, t), releasePtr(g2), releasePtr(o3), releasePtr(I2), tickLoop(this.client);
            }, 1e3 * t / 2);
            this.keepAliveTimers.set(g, o2);
          }
        }
        RemoveAutoKeepaliveRPC(A, e) {
          let t = A + " " + e;
          if (this.keepAliveTimers.has(t)) {
            let A2 = this.keepAliveTimers.get(t);
            clearInterval(A2);
          }
        }
        GetAutoKeepaliveRPC() {
          return Array.from(this.keepAliveTimers.keys());
        }
      }
      function checkIfContainsStart(A) {
        for (let e = 0; e < A.length; e++) {
          if ("*" === A[e])
            return true;
        }
        return false;
      }
      function promisify(A) {
        return "function" != typeof A ? A : function() {
          let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          return new Promise((t, g) => {
            A(Object.assign(Object.assign(Object.assign({}, e), { success: t, fail: g })));
          });
        };
      }
      function isDict(A) {
        return !("object" != typeof A || null === A || A instanceof Array || A instanceof Date);
      }
      function toRegex(A) {
        let e = "";
        for (let t = 0; t < A.length; t++) {
          const g = A.charAt(t);
          "*" === g && (e += "."), e += g;
        }
        return new RegExp(e);
      }
      function checkRegex(A, e) {
        for (let t = 0; t < e.length; t++) {
          let g = e[t];
          if (g.includes("*")) {
            if (toRegex(g).test(A))
              return true;
          }
        }
        return false;
      }
      function isInteger(A) {
        return Math.round(A) === A;
      }
      function checkAll(A, e) {
        return !(!checkIfContainsStart(e) && e.length > 0 && !e.includes(A) && !checkRegex(A, e));
      }
      function logger(A, e, t) {
        if (null !== e)
          switch (t) {
            case "info":
              e().handleInfoLog(A);
              break;
            case "warn":
              e().handleWarnLog(A);
              break;
            case "error":
              e().handleErrorLog(A);
          }
        else {
          let e2 = /* @__PURE__ */ new Date();
          console.log(e2 + e2.getMilliseconds().toString() + " : " + A);
        }
      }
      function releasePtrs(A) {
        for (let e = 0; e < A.length; e++) {
          let t = A[e];
          0 !== t && releasePtr(t);
        }
      }
      function getMallocLenWithStr(A) {
        return new Blob([A]).size + 1;
      }
      function getPtrWithStr(A) {
        const e = Module._malloc(getMallocLenWithStr(A));
        return Module.stringToUTF8(A, e, getMallocLenWithStr(A)), e;
      }
      function releasePtr(A) {
        null != A && (Module._free(A), A = null);
      }
      function getRealLenWithStrBI(A) {
        const e = new Blob([A]).size;
        return BigInt(e);
      }
      function setValue(A, e, t, g) {
        let o = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
        const I = Module._rte_crdt_value_create(), i2 = Module._rte_crdt_path_clone(g);
        if ("object" == typeof t && null != t && null != t)
          if (Array.isArray(t)) {
            Module._rte_crdt_value_set_list(I), constructPathAndPut(e, A, i2, I);
            let g2 = 0;
            for (let e2 = 0; e2 < t.length; e2++) {
              setValue(A, g2, t[e2], i2), g2 += 1;
            }
          } else {
            Module._rte_crdt_value_set_map(I), constructPathAndPut(e, A, i2, I);
            for (let e2 = 0, g2 = Object.entries(t); e2 < g2.length; e2++) {
              const [t2, o2] = g2[e2];
              setValue(A, t2, o2, i2);
            }
          }
        else {
          const g2 = Module._rte_crdt_value_set_scalar(I);
          switch (typeof t) {
            case "number":
              o ? Module._rte_crdt_scalar_value_set_counter(g2, BigInt(t)) : isInteger(t) ? Module._rte_crdt_scalar_value_set_i64(g2, BigInt(t)) : Module._rte_crdt_scalar_value_set_double(g2, t);
              break;
            case "boolean":
              Module._rte_crdt_scalar_value_set_bool(g2, t);
              break;
            case "string":
              const A2 = getPtrWithStr(t);
              Module._rte_crdt_scalar_value_set_bytes(g2, A2, getRealLenWithStrBI(t)), releasePtr(A2);
              break;
            default:
              Module._rte_crdt_scalar_value_set_null(g2);
          }
          constructPathAndPut(e, A, i2, I);
        }
        Module._rte_crdt_path_destroy(i2), Module._rte_crdt_value_destroy(I);
      }
      function constructPathAndPut(A, e, t, g) {
        if ("string" == typeof A) {
          const e2 = getPtrWithStr(A);
          Module._rte_crdt_path_add_property(t, e2, getRealLenWithStrBI(A)), releasePtr(e2);
        } else
          null != A && (Module._rte_crdt_path_add_index(t, BigInt(A)), Module._rte_crdt_document_insert(e, null, t, g));
        if (0 != Module._rte_crdt_document_put(e, null, t, g))
          throw Error("The path is invalid!");
      }
      function getScalarValue(A) {
        var e;
        let t;
        if (t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1] ? Module._rte_crdt_nested_value_get_scalar(A) : Module._rte_crdt_value_get_scalar(A), Module._rte_crdt_scalar_value_is_i64(t)) {
          const A2 = Module._malloc(4);
          Module._rte_crdt_scalar_value_get_i64(t, A2), e = Module.getValue(A2, "i64"), e = Number(e), releasePtr(A2);
        } else if (Module._rte_crdt_scalar_value_is_double(t)) {
          const A2 = Module._malloc(8);
          Module._rte_crdt_scalar_value_get_double(t, A2), e = Module.getValue(A2, "double"), e = Number(e), releasePtr(A2);
        } else if (Module._rte_crdt_scalar_value_is_bytes(t)) {
          const A2 = Module._malloc(4), g = Module._malloc(4);
          Module._rte_crdt_scalar_value_get_bytes(t, g, A2);
          const o = Module.getValue(g, "i32");
          e = Module.UTF8ToString(o).valueOf(), releasePtr(A2), releasePtr(g);
        } else if (Module._rte_crdt_scalar_value_is_bool(t)) {
          const A2 = Module._malloc(1);
          Module._rte_crdt_scalar_value_get_bool(t, A2);
          e = 1 == Module.getValue(A2), releasePtr(A2);
        } else if (Module._rte_crdt_scalar_value_is_counter(t)) {
          const A2 = Module._malloc(4);
          Module._rte_crdt_scalar_value_get_counter(t, A2), e = Module.getValue(A2, "i64"), e = Number(e), releasePtr(A2);
        } else
          e = null;
        return e;
      }
      function parsePath(A, e) {
        if (arguments.length > 2 && void 0 !== arguments[2] && arguments[2]) {
          const t2 = getPtrWithStr(A);
          return Module._rte_crdt_path_add_property(e, t2, getRealLenWithStrBI(A)), void releasePtr(t2);
        }
        let t = "", g = false;
        for (let o = 0; o < A.length; o++) {
          const I = A[o];
          "[" !== I ? "]" !== I ? "." !== I ? t += I : (t.length > 0 && (addPropertyOrIndex(t, e, g), t = ""), g = false) : (addPropertyOrIndex(t, e, g), g = false, t = "") : (t.length > 0 && (addPropertyOrIndex(t, e, g), t = ""), g = true);
        }
        t.length > 0 && addPropertyOrIndex(t, e, g);
      }
      function addPropertyOrIndex(A, e, t) {
        if (!isNaN(A) && t) {
          const t2 = Number(A);
          Module._rte_crdt_path_add_index(e, BigInt(t2));
        } else {
          const t2 = getPtrWithStr(A);
          Module._rte_crdt_path_add_property(e, t2, getRealLenWithStrBI(A)), releasePtr(t2);
        }
      }
      function getAll(A, e, t, g) {
        const o = Module._rte_crdt_nested_value_iterator_create(e), I = Module._malloc(4), i2 = Module._malloc(4), r = Module._malloc(4);
        let n = 0;
        for (; ; )
          if (g) {
            if (n = Module._rte_crdt_nested_value_iterator_next_value(o, r), 305 === n)
              break;
            const e2 = Module.getValue(r, "i32");
            if (Module._rte_crdt_nested_value_is_scalar(e2))
              t.push(getScalarValue(e2));
            else if (Module._rte_crdt_nested_value_is_map(e2)) {
              let g2 = {};
              t.push(g2), getAll(A, e2, g2, false);
            } else if (Module._rte_crdt_nested_value_is_list(e2)) {
              let g2 = [];
              t.push(g2), getAll(A, e2, g2, true);
            }
          } else {
            if (n = Module._rte_crdt_nested_value_iterator_next_key_value(o, I, i2, r), 305 === n)
              break;
            const e2 = Module.UTF8ToString(Module.getValue(I, "i32")).valueOf(), g2 = Module.getValue(r, "i32");
            if (Module._rte_crdt_nested_value_is_scalar(g2))
              t[e2] = getScalarValue(g2);
            else if (Module._rte_crdt_nested_value_is_map(g2)) {
              let o2 = {};
              t[e2] = o2, getAll(A, g2, o2, false);
            } else if (Module._rte_crdt_nested_value_is_list(g2)) {
              let o2 = [];
              t[e2] = o2, getAll(A, g2, o2, true);
            }
          }
        releasePtr(I), releasePtr(i2), releasePtr(r), Module._rte_crdt_nested_value_iterator_destroy(o);
      }
      function getPtrStringList(A) {
        const e = A.length, t = 0 === e ? 0 : Module._malloc(4 * e);
        let g = t, o = [];
        for (let e2 = 0; e2 < A.length; e2++) {
          let t2 = getPtrWithStr(A[e2]);
          o.push(t2), Module.setValue(g, t2, "i32"), g += 4;
        }
        return [t, o];
      }
      function counterCheckAndReplace(A, e, t) {
        if (!Module._rte_crdt_nested_value_is_scalar(A))
          throw Module._rte_crdt_nested_value_destroy(A), Module._rte_crdt_path_destroy(e), new TypeError("The counter no longer exists.");
        const g = Module._rte_crdt_nested_value_get_scalar(A);
        if (!Module._rte_crdt_scalar_value_is_counter(g)) {
          if (!Module._rte_crdt_scalar_value_is_i64(g))
            throw Module._rte_crdt_nested_value_destroy(A), Module._rte_crdt_path_destroy(e), new Error("The counter no longer exists.");
          {
            const g2 = getScalarValue(A);
            Module._rte_crdt_document_batch_write_begin(t), setValue(t, null, g2, e, true), Module._rte_crdt_document_batch_write_end(t);
          }
        }
      }
      function getRangeEndStringPtr(A) {
        const e = Module.lengthBytesUTF8(A) + 2, t = Module._malloc(e);
        return Module.stringToUTF8(A, t, e), Module.HEAPU8[t + e - 2] = 1, Module.HEAPU8[t + e - 1] = 0, t;
      }
      function getTick(A, e) {
        const t = Module._sync_client_tick(e, A), g = Module._sync_buffer_data(A), o = Number(Module._sync_buffer_length(A));
        return { resDeepCopy: new Uint8Array(Module.HEAPU8.buffer, g, o).slice(), tikGetRes: t };
      }
      function tickLoop(A) {
        let e = 0;
        for (; 305 != e; ) {
          const { resDeepCopy: t, tikGetRes: g } = getTick(A.tickBufferPtr, A.clientPtr);
          if (e = g, 101 === e)
            Module._sync_client_reset_connection(A.clientPtr);
          else {
            if (0 == t.length)
              continue;
            null !== A.reuseConn ? A.reuseConn().sendPacket(t) : A.ws.send(t), logger("send tick", A.getLogger, "info");
          }
        }
      }
      function getShakehand(A, e) {
        const t = Module._sync_client_shakehand(e, A), g = Module._sync_buffer_data(A), o = Number(Module._sync_buffer_length(A));
        return { resDeepCopy: new Uint8Array(Module.HEAPU8.buffer, g, o).slice(), shakehandRes: t };
      }
      function shakehandOnce(A) {
        const { resDeepCopy: e } = getShakehand(A.shakehandBufferPtr, A.clientPtr);
        null !== A.reuseConn ? A.reuseConn().sendPacket(e) : A.ws.send(e);
      }
      async function recvMsg(A, e) {
        e ? A.ws.addEventListener("message", async function(e2) {
          try {
            const t = await e2.data.arrayBuffer(), g = new Uint8Array(t), o = g.length * g.BYTES_PER_ELEMENT, I = Module._malloc(o);
            Module.HEAPU8.set(g, I);
            const i2 = Module._sync_client_on_recv(A.clientPtr, I, BigInt(o), A.tickBufferPtr);
            if (Module._free(I), 101 === i2)
              Module._sync_client_reset_connection(A.clientPtr);
            else {
              const e3 = new Uint8Array(Module.HEAPU8.buffer, Module._sync_buffer_data(A.tickBufferPtr), Number(Module._sync_buffer_length(A.tickBufferPtr))).slice();
              0 != e3.length && A.ws.send(e3);
            }
          } catch (e3) {
            logger("recvError : ".concat(e3), A.getLogger, "error");
          }
        }) : A.ws.on("message", (e2) => {
          try {
            const t = new Uint8Array(e2), g = t.length * t.BYTES_PER_ELEMENT, o = Module._malloc(g);
            Module.HEAPU8.set(t, o);
            const I = Module._sync_client_on_recv(A.clientPtr, o, BigInt(g), A.tickBufferPtr);
            if (Module._free(o), 101 === I)
              Module._sync_client_reset_connection(A.clientPtr);
            else {
              const e3 = new Uint8Array(Module.HEAPU8.buffer, Module._sync_buffer_data(A.tickBufferPtr), Number(Module._sync_buffer_length(A.tickBufferPtr))).slice();
              0 != e3.length && A.ws.send(e3);
            }
          } catch (e3) {
            logger("recvError : ".concat(e3), A.getLogger, "error");
          }
        });
      }
      async function fetchHelper(A, e) {
        A.tickBufferPtr = Module._sync_buffer_create();
        try {
          let t = "ws://60.191.137.101:6390/ws";
          e && (A.ws = new WebSocket(t)), A.ws.onopen = () => {
            A.manualTick || (tickLoop(A), A.connected = true, A.timer = setInterval(() => {
              3 == A.ws.readyState ? (A.connected = false, logger("The connection is time out...", A.getLogger, "info")) : (A.connected = true, tickLoop(A));
            }, 2e3));
          }, recvMsg(A, e);
        } catch (e2) {
          logger("fetchError : ".concat(e2), A.getLogger, "error");
        }
      }
      const createCollCallBackMap = /* @__PURE__ */ new Map(), dbConnectCallBackMap = /* @__PURE__ */ new Map(), dbDisConnectCallBackMap = /* @__PURE__ */ new Map();
      function initFunc(A) {
        null !== A && (Module.rtejsLog = (e, t) => {
          switch (e) {
            case 0:
              A().handleDebugLog(t, " ----------rtejslog");
              break;
            case 1:
              A().handleInfoLog(t, " ----------rtejslog");
              break;
            case 2:
              A().handleWarnLog(t, " ----------rtejslog");
              break;
            case 3:
              A().handleErrorLog(t, " ----------rtejslog");
          }
        });
      }
      async function createCollection(A) {
        const { client: e, db: t, coll: g, readable: o, success: I, fail: i2 } = A;
        let r = Module.addFunction((A2, t2, g2, o2) => {
          const { resolvePromise: I2, rejectPromise: i3 } = createCollCallBackMap.get(o2);
          releasePtr(o2), 0 === A2 ? (logger("init success", e.getLogger, "info"), I2(A2)) : i3(A2), Module.removeFunction(r);
        }, "viiii");
        const n = getPtrWithStr(g), C = getPtrWithStr(t), E = getPtrWithStr(g), [s, B] = getPtrStringList(o), a = uuid_1.v4(), Q = getPtrWithStr(a);
        createCollCallBackMap.set(n, { resolvePromise: I, rejectPromise: i2 }), Module._sync_client_create_coll(e.clientPtr, C, E, s, o.length, Q, getRealLenWithStrBI(a), r, n), releasePtr(C), releasePtr(E), releasePtr(Q);
        for (let A2 = 0; A2 < B.length; A2++) {
          releasePtr(B[A2]);
        }
        e.connected && tickLoop(e);
      }
      async function connectDatabase(A) {
        const { client: e, databaseName: t, success: g, fail: o } = A;
        let I = Module.addFunction((A2, t2, g2, o2, i3) => {
          const { resolvePromise: r2, rejectPromise: n2 } = dbConnectCallBackMap.get(i3);
          releasePtr(i3), 0 === A2 ? (logger("db connect success", e.getLogger, "info"), r2(A2)) : n2(A2), Module.removeFunction(I);
        }, "viiiji");
        const i2 = getPtrWithStr(t), r = i2;
        dbConnectCallBackMap.set(r, { resolvePromise: g, rejectPromise: o });
        let n = getPtrWithStr("");
        Module._sync_client_connect_database(e.clientPtr, i2, n, getRealLenWithStrBI(""), I, r), releasePtr(n), e.connected && tickLoop(e);
      }
      async function disconnectDatabase(A) {
        const { client: e, databaseName: t, success: g, fail: o } = A;
        let I = Module.addFunction((A2, t2, g2) => {
          const { resolvePromise: o2, rejectPromise: i3 } = dbDisConnectCallBackMap.get(g2);
          releasePtr(g2), 0 === A2 ? (logger("db disconnect success", e.getLogger, "info"), o2(A2)) : i3(A2), Module.removeFunction(I);
        }, "viii");
        const i2 = getPtrWithStr(t), r = i2;
        dbDisConnectCallBackMap.set(r, { resolvePromise: g, rejectPromise: o }), Module._sync_client_disconnect_database(e.clientPtr, i2, I, r), e.connected && tickLoop(e);
      }
      async function queryDoc(A) {
        const { client: e, database: t, coll: g, option: o, buffer: I, success: i2, fail: r } = A, n = Module.addFunction((A2, e2, t2, g2, o2, C2) => {
          if (0 === A2) {
            I.SetCount(Number(g2)), 1 === o2 && I.SetMore(true);
            for (let A3 = 0; A3 < Number(g2); A3++) {
              const A4 = Module.getValue(e2, "i32"), g3 = Module.getValue(t2, "i32"), o3 = Module.UTF8ToString(A4).valueOf(), i3 = Module.UTF8ToString(g3).valueOf();
              I.SetDocs(o3, i3), e2 += 4, t2 += 4;
            }
            i2(A2);
          } else
            r(A2);
          Module.removeFunction(n);
        }, "viiijii"), C = getPtrWithStr(t), E = getPtrWithStr(g);
        let s = 0, B = 0;
        s = o.startIncluded || 0 == o.start.length ? getPtrWithStr(o.start) : getRangeEndStringPtr(o.start), B = o.endIncluded && 0 != o.end.length ? getRangeEndStringPtr(o.end) : getPtrWithStr(o.end);
        Module._sync_client_query_doc(e.clientPtr, C, E, s, B, BigInt(o.limit), o.keysOnly, o.countOnly, o.ignoreExpired, n, 0), e.connected && tickLoop(e);
      }
      function subscribe(A, e) {
        const t = Module.addFunction((t2, I2, i3, r2, n, C, E) => {
          const s = Module.UTF8ToString(i3), B = Module._rte_crdt_path_iterator_create(r2);
          let a, Q = 0, c = "";
          for (; ; ) {
            const A2 = Module._malloc(4), e2 = Module._malloc(4);
            Module.setValue(e2, 0, "i64");
            const t3 = Module._malloc(4), g2 = Module._malloc(4);
            if (Q = Module._rte_crdt_path_iterator_next(B, A2, e2, t3), 305 === Q) {
              releasePtr(A2), releasePtr(e2), releasePtr(t3), releasePtr(g2);
              break;
            }
            if (0 === c.length) {
              if (0 != A2) {
                const e3 = Module.getValue(A2, "i32");
                c += Module.UTF8ToString(e3).valueOf();
              }
            } else {
              const g3 = Module.getValue(e2, "i64");
              if (Number(g3) > 0) {
                const e3 = Module.getValue(A2, "i32");
                c += "." + Module.UTF8ToString(e3).valueOf();
              } else {
                const A3 = Module.getValue(t3, "i64");
                c += "[" + Number(A3).toString() + "]";
              }
            }
            releasePtr(A2), releasePtr(e2), releasePtr(t3), releasePtr(g2);
          }
          switch (a = Module._rte_crdt_value_is_list(C) ? [] : Module._rte_crdt_value_is_map(C) ? {} : getScalarValue(C, false), n) {
            case 0:
              g.push(new CollectionEvent(s, c, CollectionEventType$1.Insert, a));
              break;
            case 1:
              o ? g.push(new CollectionEvent(s, c, CollectionEventType$1.Put, a)) : 0 != e.listenerCount("document-events") && (g = [new CollectionEvent(s, "", CollectionEventType$1.Put, null)], e.emit("document-events", g));
              break;
            case 2:
              o ? g.push(new CollectionEvent(s, c, CollectionEventType$1.Delete, a)) : 0 != e.listenerCount("document-events") && checkAll(s, A.readable) && (g = [new CollectionEvent(s, "", CollectionEventType$1.Delete, null)], e.emit("document-events", g));
              break;
            case 6:
              g = [], o = true;
              break;
            case 7:
              0 != e.listenerCount("document-events") && e.emit("document-events", g), o = false;
              break;
            case 8:
              0 != e.listenerCount("document-events") && e.emit("document-events", [new CollectionEvent(s, "", CollectionEventType$1.DocSyncEnd, null)]);
          }
        }, "viiiiiii");
        let g = [], o = false;
        const I = getPtrWithStr(A.dbIn), i2 = getPtrWithStr(A.name), r = Module._sync_client_subscribe(A.client.clientPtr, I, i2, t, 0);
        if (releasePtr(I), releasePtr(i2), 0 === r)
          return logger("The Collection : ".concat(A.name, " has been subscribed successfully!"), A.getLogger, "info"), t;
        logger("The Collection : ".concat(A.name, " has not been subscribed successfully!"), A.getLogger, "info");
      }
      function exceptionCallback(A) {
        A.exceptionCb = Module.addFunction((e, t, g) => {
          let o = Module.UTF8ToString(e).valueOf(), I = Module.UTF8ToString(t).valueOf();
          0 != A.exceptionChan.listenerCount("exception") && A.exceptionChan.emit("exception", [o, I]);
        }, "viii");
        Module._sync_client_set_exception_callback(A.clientPtr, A.exceptionCb, 0);
      }
      var createModule = function() {
        let A = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        var e, t, g = A;
        g.ready = new Promise((A2, g2) => {
          e = A2, t = g2;
        });
        var o = Object.assign({}, g), I = "./this.program", i2 = "object" == typeof window, r = "function" == typeof importScripts;
        "object" == typeof process && "object" == typeof process.versions && process.versions.node;
        var n, C = "";
        (i2 || r) && (r ? C = self.location.href : "undefined" != typeof document && document.currentScript && (C = document.currentScript.src), C = 0 !== C.indexOf("blob:") ? C.substr(0, C.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", r && (n = (A2) => {
          var e2 = new XMLHttpRequest();
          return e2.open("GET", A2, false), e2.responseType = "arraybuffer", e2.send(null), new Uint8Array(e2.response);
        })), g.print || console.log.bind(console);
        var E, s, B = g.printErr || console.error.bind(console);
        Object.assign(g, o), o = null, g.arguments && g.arguments, g.thisProgram && (I = g.thisProgram), g.quit && g.quit, g.wasmBinary && (E = g.wasmBinary), g.noExitRuntime, "object" != typeof WebAssembly && L("no native wasm support detected");
        var a, Q, c, l, h, u, d, D, y, p2 = false;
        function R2() {
          var A2 = s.buffer;
          g.HEAP8 = a = new Int8Array(A2), g.HEAP16 = c = new Int16Array(A2), g.HEAPU8 = Q = new Uint8Array(A2), g.HEAPU16 = new Uint16Array(A2), g.HEAP32 = l = new Int32Array(A2), g.HEAPU32 = h = new Uint32Array(A2), g.HEAPF32 = u = new Float32Array(A2), g.HEAPF64 = D = new Float64Array(A2), g.HEAP64 = d = new BigInt64Array(A2), g.HEAPU64 = new BigUint64Array(A2);
        }
        var w = [], _ = [], S = [];
        function f(A2) {
          w.unshift(A2);
        }
        function N(A2) {
          S.unshift(A2);
        }
        var M = 0, k = null;
        function L(A2) {
          g.onAbort && g.onAbort(A2), B(A2 = "Aborted(" + A2 + ")"), p2 = true, A2 += ". Build with -sASSERTIONS for more info.";
          var e2 = new WebAssembly.RuntimeError(A2);
          throw t(e2), e2;
        }
        var G, b, U = "data:application/octet-stream;base64,";
        function m(A2) {
          return A2.startsWith(U);
        }
        function T(A2) {
          if (A2 == G && E)
            return new Uint8Array(E);
          var e2 = function(A3) {
            if (m(A3))
              return function(A4) {
                try {
                  for (var e3 = atob(A4), t2 = new Uint8Array(e3.length), g2 = 0; g2 < e3.length; ++g2)
                    t2[g2] = e3.charCodeAt(g2);
                  return t2;
                } catch (A5) {
                  throw new Error("Converting base64 string to bytes failed.");
                }
              }(A3.slice(37));
          }(A2);
          if (e2)
            return e2;
          if (n)
            return n(A2);
          throw "both async and sync fetching of the wasm failed";
        }
        function O(A2, e2, t2) {
          return function(A3) {
            return Promise.resolve().then(() => T(A3));
          }(A2).then((A3) => WebAssembly.instantiate(A3, e2)).then((A3) => A3).then(t2, (A3) => {
            B("failed to asynchronously prepare wasm: ".concat(A3)), L(A3);
          });
        }
        m(G = "data:application/octet-stream;base64,AGFzbQEAAAAB6wVUYAJ/fwBgAX8AYAF/AX9gAn9/AX9gA39/fwBgA39/fwF/YAR/f39/AGAEf39/fwF/YAZ/f39/f38Bf2AFf39/f38Bf2AFf39/f38AYAZ/f39/f38AYAJ/fgBgCH9/f39/f39/AX9gA39/fgBgB39/f39/f38Bf2AAAGAFf35+fn4AYAF/AX5gAAF/YAV/f39/fgF/YAV/f35/fwBgAn9/AX5gB39/f39/f38AYAR/f35/AGAEf39/fwF+YAR/fn5/AGAEf35+fwF/YAJ+fwF/YAJ/fgF+YAh/f39/f39/fwBgBX9/f398AX9gC39/f39/f39/f39/AX9gBn9/f35/fwBgAAF8YAJ+fwBgAn9+AX9gAn98AGAAAX5gCn9/f39/f39/f38Bf2AHf39+fn9/fwF/YAF+AX9gAX4BfmAMf39/f39/f39/f39/AX9gA39+fwBgBn9/f39+fwF/YA9/f39/f39/f39/f39/f38AYAp/f39/f39/f39/AGAFf39/fn8AYAd/f39/f35+AX9gBn9/f39+fgF/YAN/f34Bf2ALf39/f39/f39/f38AYAR+fn5+AX9gB39/f39+f38AYAd/f39+f39/AX5gDn9/f39/f39+f39/f39/AGACfn4BfGABfwF8YAV/f39/fgBgBn9/fn5/fwF/YAV/f35+fwF/YAJ8fwBgA39/fwF8YAN/f38BfWACfn4BfWADfn5+AX9gBn98f39/fwF/YAJ8fwF8YAR/f39+AX5gBn9/f39+fwBgCH9/f39/fn9/AX9gCX9/f39+fn9/fwF/YBF/f39/f39/f35+f39/f39/fwF/YBB/f39/f39/f35+f39/f39/AX9gCn9/f39/fn9/f38Bf2AJf39/f39+f39/AX9gC39/f39/fn9/f39/AX9gBn9/f35/fwF/YAl/f39/f39+f38AYAR/f35/AX9gCn9/f39/fn5/f38AYAZ/fn9/f38AYAR/f39+AX8CPQoBYQFhAAYBYQFiABABYQFjAAkBYQFkAAMBYQFlAAMBYQFmABMBYQFnACIBYQFoAAIBYQFpACIBYQFqAAAD3A/aDwIBAwMCAgMDAgIBAgECIwAQAwAFBQACAwMBAAEDAgIRAgAAAwMCBAEDAAMTAwEDAhEBAgISBAIEAQEBAQUCAAICAgEBAgIDAAAC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IAIsAA9BAEgbIQVBwMICKAIABEBByMICKAIAIQYjAEEQayIBJAAgASAFNgIIIAEgAzYCDCABIAY2AgRBwMICKAIAIgNFBEAQGgALIAMgAUEMaiABQQhqIAFBBGogAygCACgCGBEGACABQRBqJAALIAQQChogAEEEahDmARogAkEQaiQACwwAQbDBAigCACAATAsGACAAEAsLNgEBf0EBIAAgAEEBTRshAAJAA0AgABBHIgENAUHo2AIoAgAiAQRAIAEREAAMAQsLEAEACyABCysBAX8DQCABIACnQf8AcSAAQv8AViICQQd0csAQnQEgAEIHiCEAIAINAAsLhQECBH4DfyABKAIEIQYgAAJ/AkADQCAGRSACQj9Wcg0BIAEoAgAiBywAACIIrUL/AIMiBCAChiIFIAKIIARSDQEgASAGQQFrIgY2AgQgASAHQQFqNgIAIAJCB3whAiADIAV8IQMgCEEASA0ACyAAIAM3AwBBAQwBCyAAQQA6AABBAAs6AAgLBQAQAQALjwEBBH8jAEEQayIDJAAgASgCACEEIAMgASgCBCABLQALIgIgAsBBAEgiAhs2AgwgAyAEIAEgAhs2AgggACgCACAAIAAtAAsiBMBBAEgiAhsgAygCCCADKAIMIgEgACgCBCAEIAIbIgAgACABSyIEGxDpBSICQX8gBCAAIAFJGyACGyEFIANBEGokACAFQR92CzYAIAAsAAtBAEgEQCAAKAIAEAsLIAAgASkCADcCACAAIAEoAgg2AgggAUEAOgALIAFBADoAAAszAQF/IAIEQCAAIQMDQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQQFrIgINAAsLIAALKQEBfyACBEAgACEDA0AgAyABOgAAIANBAWohAyACQQFrIgINAAsLIAALKgEBfwJAIAAQDiICIAFJBEAgACABIAJrEOUJDAELIAAgABAgIAEQ9wkLCxIAIAAQlgEEQCAAKAIADwsgAAsJACAAECAgAWoLkAEBBX8CQCAAKAIEIgUgAC0ACyICIALAIgZBAEgbIAEoAgQgAS0ACyIEIATAIgRBAEgbRw0AIAEoAgAgASAEQQBIGyEBIAZBAE4EQANAIAJFIQMgAkUNAiAALQAAIAEtAABHDQIgAUEBaiEBIABBAWohACACQQFrIQIMAAsACyAAKAIAIAEgBRDpBUUh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Qf//AWtBgYB+Sw0BCyABUCACQv///////////wCDIgtCgICAgICAwP//AFQgC0KAgICAgIDA//8AURtFBEAgAkKAgICAgIAghCEKDAILIANQIARC////////////AIMiAkKAgICAgIDA//8AVCACQoCAgICAgMD//wBRG0UEQCAEQoCAgICAgCCEIQogAyEBDAILIAEgC0KAgICAgIDA//8AhYRQBEAgAiADhFAEQEKAgICAgIDg//8AIQpCACEBDAMLIApCgICAgICAwP//AIQhCkIAIQEMAgsgAyACQoCAgICAgMD//wCFhFAEQCABIAuEIRlCACEBIBlQBEBCgICAgICA4P//ACEKDAMLIApCgICAgICAwP//AIQhCgwCCyABIAuEUARAQgAhAQwCCyACIAOEUARAQgAhAQwCCyALQv///////z9YBEAgBUHQAGogASANIAEgDSANUCIGG3kgBkEGdK18pyIGQQ9rEGNBECAGayEGIAUpA1giDUIgiCEOIAUpA1AhAQsgAkL///////8/Vg0AIAVBQGsgAyAMIAMgDCAMUCIIG3kgCEEGdK18pyIIQQ9rEGMgBiAIa0EQaiEGIAUpA0ghDCAFKQNAIQMLIANCD4YiC0KAgP7/D4MiAiABQiCIIgR+IhAgC0IgiCITIAFC/////w+DIgF+fCIPQiCGIhEgASACfnwiCyARVK0gAiANQv////8PgyINfiIVIAQgE358IhEgDEIPhiISIANCMYiEQv////8PgyIDIAF+fCIUIA8gEFStQiCGIA9CIIiEfCIPIAIgDkKAgASEIgx+IhYgDSATfnwiDiASQiCIQoCAgIAIhCICIAF+fCIQIAMgBH58IhJCIIZ8Ihd8IQEgByAJaiAGakH//wBrIQYCQCACIAR+IhggDCATfnwiBCAYVK0gBCAEIAMgDX58IgRWrXwgAiAMfnwgBCAEIBEgFVStIBEgFFatfHwiBFatfCADIAx+IgMgAiANfnwiAiADVK1CIIYgAkIgiIR8IAQgAkIghnwiAiAEVK18IAIgAiAQIBJWrSAOIBZUrSAOIBBWrXx8QiCGIBJCIIiEfCICVq18IAIgAiAPIBRUrSAPIBdWrXx8IgJWrXwiBEKAgICAgIDAAINQRQRAIAZBAWohBgwBCyALQj+IIRogBEIBhiACQj+IhCEEIAJCAYYg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QbjEAiADNgIACyACQQhqIQALIApBEGokACAACyQBAX8gACgCBCAALQALIgIgAsBBAEgbrSABEBggASAAEKICGgsKACAAKAIAEN4KCwsAIAAoAgAQ5ArACwQAIAALIAEBfyAAKAIMIgEEQCABEAsgAEEANgIMCyAAQgA3AhALFwEBfyAAKAIMIgEEQCABEAsLIAAQDxoLWgECfyMAQRBrIgEkACAAQgA3AgAgAEE+OgAeIABBzZmz+gM2AhggAEIANwIQIABCADcCCCAAEDEgACgCDCICBEAgAkEAIAAoAhBBA3QQHhoLIAFBEGokACAACwQAQQALEQAgACABEBAiAEEBOgAQIAALJAEBfyAAKAIAIQIgACABNgIAIAIEQCACIAAQiwMoAgARAQALC7ABAgJ/AX4jAEEgayICJAAgAkEQaiABEBkCQCACLQAYRQRAIABBADoADCAAQQA6AAAMAQsgAikDECIEIAEoAgQiA61WBEAgAEEAOgAMIABBADoAAAwBCyABIAMgBKciA2s2AgQgASABKAIAIgEgA2o2AgAgAiABIAMQQSAAIAIoAgg2AgggACACKQMANwIAIAJBADYCCCACQgA3AwAgAEEBOgAMIAIQChoLIAJBIGokAAsNACAAKAIAEN0KGiAACw0AIAAoAgAQ4woaIAALSgEBfyAAIAFJBEAgACABIAIQHQ8LIAIEQCAAIAJqIQMgASACaiEBA0AgA0EBayIDIAFBAWsiAS0AADoAACACQQFrIgINAAsLIAALYgEDfyMAQRBrIgIkACAAQSBqIQMDQCAAIANHBEAgAC0AACEEIAAgAS0AADoAACABIAQ6AAAgAUEBaiEBIABBAWohAAwBCwsgAiABNgIMIAIgAzYCCCACKAIMGiACQRBqJAALMAEBfyAAKAIEIgIgACgCCEkEQCACIAEpAwA3AwAgACACQQhqNgIEDwsgACABEJsGCyYBAX4gACgCACIAKQMAIQIgACABKAIAIgApAwA3AwAgACACNwMAC58JAQ1/IAAoAgAiASgCAEH53avFAkYEQANAAkACQAJAIAEoAhggCE0EQCAAKAIEIQNBACEBA0AgASADRg0CIAAoAgggAUEEdGoiAigCABC+BiAHaiACKAIIaiEHIAFBAWohAQwACwALIAAgASgCHCAIQTBsaiIEKAIQaiEDIAAgBCgCFGohAgJAAkACQCAEKAIIIgEOBAEAAgACCyAELQAgQQRxBEBBACEBIAQoAgQgAygCAEcNBQJAIAQoAgxBDmsOAwACAAILIAIoAgAiA0UNBSADIAQoAhxHDQEMBQsCQAJAIAFBAWsOAwADAQMLAkACQCAEKAIMQQ5rDgMAAQABC0EAIQEgAigCACIDRQ0GIAMgBCgCHEcNAgwGCyADKAIADQEMBAtBACEBIAQgAhCWCw0ECwJ/IAQoAgQQvgYhAwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBCgCDA4RAA0EAwIFAQQDBQcIBgAJCgsMCyACKAIAELsGIANqDA0LIAIoAgAQqAEgA2oMDAsgAikDABC6BiADagwLCyACKQMAENkEIANqDAoLIANBBGoMCQsgA0EIcgwICyADQQFqDAcLIANBBGoMBgsgA0EIcgwFCyACKAIAIgEEfyABENYBBUEACyIBEKgBIAEgA2pqDAQLIAIoAgAiASADaiABEKgBagwDCyACKAIAIgEEfyABEFkFQQALIgEQqAEgASADamoMAgtB988AQfvHAEHNA0GmMhAAAAsgAigCABC9BiADagshAQwDCyADKAIAIgNFDQEgAigCACEFIAQoAgQQvgYhDUEBIAMgBCgCIEEBcSIJGyEMQQAhAUEAIQICQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBCgCDA4RAQAFBAMGAgUEBgUGBwEICQoLCwNAIAEgA0cEQCAFIAFBAnRqKAIAEL0GIAJqIQIgAUEBaiEBDAELCyACIQEMCgsDQCACIANGDQogBSACQQJ0aigCABC7BiABaiEBIAJBAWohAgwACwALA0AgASADRwRAIAUgAUECdGooAgAQqAEgAmohAiABQQFqIQEMAQsLIAIhAQwICwNAIAEgA0cEQCAFIAFBA3RqKQMAELoGIAJqIQIgAUEBaiEBDAELCyACIQEMBwsDQCACIANGDQcgBSACQQN0aikDABDZBCABaiEBIAJBAWohAgwACwALIANBAnQhAQwFCyADQQN0IQEMBAsgAyEBDAMLA0AgASADRwRAIAIgBSABQQJ0aigCABDWASIGaiAGEKgBaiECIAFBAWohAQwBCwsgAiEBDAILA0AgASADRwRAIAIgBSABQQN0aigCACIGaiAGEKgBaiECIAFBAWohAQwBCwsgAiEBDAELA0AgASADRwRAIAIgBSABQQJ0aigCABBZIgZqIAYQqAFqIQIgAUEBaiEBDAELCyAEKAIgQQFxIQkgAiEBCyANIAxsIQIgCQR/IAEQqAEgAmoFIAILIAFqIQEMAgsgBw8LQQAhAQsgCEEBaiEIIAEgB2ohByAAKAIAIQEMAAsAC0HtzQBB+8cAQcsFQYMyEAAACzMAIAAQ3AMgACABKAIANgIAIAAgASgCBDYCBCAAIAEoAgg2AgggAUEANgIIIAFCADcCAAt2AQJ/IABBGGoQTSMAQRBrIgEkACABIABBDGo2AgwgASgCDCICKAIABEAgAhDSBiABKAIMKAIAEAsLIAFBEGokACMAQRBrIgEkACABIAA2AgwgASgCDCICKAIABEAgAhCBDCABKAIMKAIAEAsLIAFBEGokACAACzcBAX8jAEEQayIBJAAgASAANgIMIAEoAgwiACgCAARAIAAQ6AggASgCDCgCABALCyABQRBqJAALuAIBCH8jAEEQayIDJAAgAyABNgIMIAFB7////wdNBEACQCAAECggAU8NACADIAAQDjYCCCADQQxqIANBCGoQtgIoAgAQtQIiASAAEChGDQAjAEEQayICJAAgABAoIQUgABAOIQYCQAJ/IAEQ1AMiCQRAQQEhBCABQQFqIQcgACEBIAAoAgAMAQsgAUEBaiEEAn8gASAFSwRAIAJBCGogACAEEIoCIAIoAgghASACKAIMDAELIAJBCGogACAEEIoCIAIoAggiAUUNAiACKAIMCyEHIAAQlgEhBCAAECALIQggASAIIAAQDkEBahCXASAEBEAgACAIIAVBAWoQywQLAkAgCUUEQCAAIAcQlAEgACAGEHAgACABEJUBDAELIAAgBhB7CwsgAkEQaiQACyADQRBqJAAPCxBoAAsRACAAIAEgACgCACgCHBEDAAu/AQEDfyAALQAAQSBxRQRAAkAgASEDAkAgAiAAIgEoAhAiAAR/IAAFIAEQhgsNASABKAIQCyABKAIUIgVrSwRAIAEgAyACIAEoAiQRBQAaDAILAkAgASgCUEEASA0AIAIhAANAIAAiBEUNASADIARBAWsiAGotAABBCkcNAAsgASADIAQgASgCJBEFACAESQ0BIAMgBGohAyACIARrIQIgASgCFCEFCyAFIAMgAhAdGiABIAEoAhQgAmo2AhQLCwsLpAMCB38DfiMAQRBrIgUkAAJAIAEoAgQiAyABKAIISQRAIAMgAikDADcDACADIAIpAwg3AwggASADQRBqIgI2AgQMAQsgASACEJsFIAEoAgQhAgsgAkEQayIDELwBIgqnQf8BcUGAAnIhAiADKQMIIQsgAykDACEMIAogATEAHoinIQMgASgCECEHIAEoAgAhBiABKAIMIQggAAJ/A0AgCCADQQN0aiIEKAIAIgkgAk8EQAJAIAIgCUcNACAMIAYgBCgCBEEEdGoiBCkDAFINACALIAQpAwhSDQAgASABKAIEQRBrNgIEQQAMAwsgA0EBaiIDQQAgAyAHRxshAyACQYACaiECDAELCyABKAIEIAZrQQR1IgZBAWshBAJAIAEoAhQgBkkEQCABKAIUQYCAgIB4RgRAIAEgASgCBEEQazYCBBAaAAsgASABLQAeQQFrOgAeIAEQTCABEDEgARCMDAwBCyAFIAQ2AgwgBSACNgIIIAUgBSkCCDcDACABIAUgAxAwCyABKAIAIARBBHRqIQRBAQs6AAQgACAENgIAIAVBEGokAAuhAQECfwJAIAAQDkUgAiABa0EFSHINACABIAIQvQQgAkEEayEEIAAQICICIAAQDmohBQJAA0ACQCACLAAAIQAgASAETw0AIABBAEwgAEH/AE5yRQRAIAEoAgAgAiwAAEcNAwsgAUEEaiEBIAIgBSACa0EBSmohAgwBCwsgAEEATCAAQf8ATnINASACLAAAIAQoAgBBAWtLDQELIANBBDYCAAsLCAAgACABEBwLUAEBfgJAIANBwABxBEAgASADQUBqrYYhAkIAIQEMAQsgA0UNACACIAOtIgSGIAFBwAAgA2utiIQhAiABIASGIQELIAAgATcDACAAIAI3AwgLbQEBfyMAQYACayIFJAAgBEGAwARxIAIgA0xyRQRAIAUgAUH/AXEgAiADayIDQYACIANBgAJJIgEbEB4aIAFFBEADQCAAIAVBgAIQXyADQYACayIDQf8BSw0ACwsgACAFIAMQXwsgBUGAAmokAAudCwELfyMAQTBrIggkACAAKAIAIgcoAgBB+d2rxQJGBEADQAJAAkACQAJAIAcoAhggC00EQEEAIQMDQCADIAAoAgRPDQIgACgCCCADQQR0aiIEKAIAIAgQuQYhBiAIIAgtAAAgBC0ABHI6AAAg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aiQACwwAIAAgAUHICBDRCQsTACAALQCYAUEBRwRAEBoACyAACzABAX8gACgCBCICIAAoAghJBEAgAiABKAIANgIAIAAgAkEEajYCBA8LIAAgARC1Bgs5AQJ/IABBIGohAgNAAkAgACACRiIDDQAgAC0AACABLQAARw0AIAFBAWohASAAQQFqIQAMAQsLIAMLWQECfyAAQf8BOgAYIABBADoAACMAQRBrIgIkACAAEEQgAS0AGCIDQf8BRwRAIAJBD2ogACABIANBAnRBtAhqKAIAEQQAIAAgAS0AGDoAGAsgAkEQaiQAIAALGwEBf0EMEBciAiABNgIAIAIgACkCBDcCBCACCxEAIAAgASAAKAIAKAIsEQMACyEAIAAgAC0AC0GAAXEgAXI6AAsgACAALQALQf8AcToACwvGCQIEfwZ+IwBB8ABrIgYkACAEQv///////////wCDIQkCQAJAIAFQIgUgAkL///////////8AgyIKQoCAgICAgMD//wB9QoCAgICAgMCAgH9UIApQG0UEQCADQgBSIAlCgICAgICAwP//AH0iC0KAgICAgIDAgIB/ViALQoCAgICAgMCAgH9RGw0BCyAFIApCgICAgICAwP//AFQgCkKAgICAgIDA//8AURtFBEAgAkKAgICAgIAghCEEIAEhAwwCCyADUCAJQoCAgICAgMD//wBUIAlCgICAgICAwP//AFEbRQRAIARCgICAgICAIIQhBAwCCyABIApCgICAgICAwP//AIWEUARAQoCAgICAgOD//wAgAiABIAOFIAIgBIVCgICAgICAgICAf4WEUCIFGyEEQgAgASAFGyEDDAILIAMgCUKAgICAgIDA//8AhYRQDQEgASAKhFAEQCADIAmEQgBSDQIgASADgyEDIAIgBIMhBAwCCyADIAmEUEUNACABIQMgAiEEDAELIAMgASABIANUIAkgClYgCSAKURsiCBshCiAEIAIgCBsiC0L///////8/gyEJIAIgBCAIGyICQjCIp0H//wFxIQcgC0IwiKdB//8BcSIFRQRAIAZB4ABqIAogCSAKIAkgCVAiBRt5IAVBBnStfKciBUEPaxBjIAYpA2ghCSAGKQNgIQpBECAFayEFCyABIAMgCBshAyACQv///////z+DIQQgB0UEQCAGQdAAaiADIAQgAyAEIARQIgcbeSAHQQZ0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ABApIAJBQGsgACkAGCAFhUIAIAApABBC442j5Inemt6Of4VCABApIAJBMGogACkAKCAGhUIAIAApACBCw5ndqce52czYAIVCABApIABBMGohACACKQM4IAIpAzCFIQYgAikDSCACKQNAhSEFIAIpA1ggAikDUIUhBCADQTBrIgNBMEsNAAsgBCAFhSAGhSEECwNAIANBEU8EQCACQSBqIAApAAggBIVCACAAKQAAQtvR0IWa2t+BZ4VCABApIABBEGohACADQRBrIQMgAikDKCACKQMghSEEDAELCyAAIANqIgBBCGspAAAhBSAAQRBrKQAACyEGIAJBEGogBCAFhUIAIAZC29HQhZra34FnhUIAECkgAiACKQMYIAIpAxCFQgAgAa1C29HQhZra34FnhUIAECkgAikDCCEIIAIpAwAhByACQeAAaiQAIAggB4ULQQIBfgF/IABCP4chAgNAIAEgAKdB/wBxQYB/QQAgACAChULAAINCBoinIABCB4ciACACUnIiAxtyEJ0BIAMNAAsLMwEBfyMAQRBrIgIkACACIAE3AwggAkIANwMAIAAgAhDhASAAIAJBCGoQ5wUgAkEQaiQACxwAIAAgAUHVqtUqQRhBqtWq1QBBq9Wq1QAQkwELOgEBfyAAQdTnASgCACIBNgIAIAAgAUEMaygCAGpB4OcBKAIANgIAIABBBGoQ9AUaIABBOGoQ7AogAAvFAwEEfyMAQRBrIggkACAIIAI2AgggCCABNgIMIAhBBGoiASADECQgARBxIQkgARAjIARBADYCAEEAIQECQANAIAYgB0YgAXINAQJAIAhBDGogCEEIahAtDQACQCAJIAYoAgAQ9wJBJUYEQCAGQQRqIAdGDQJBACECAn8CQCAJIAYoAgQQ9wIiAUHFAEYNAEEBIQogAUH/AXFBMEYNACABDAELIAZBCGogB0YNA0ECIQogASECIAkgBigCCBD3AgshASAIIAAgCCgCDCAIKAIIIAMgBCAFIAEgAiAAKAIAKAIkEQ0ANgIMIAYgCkECdGpBBGohBgwBCyAJQQEgBigCABClAQRAA0ACQCAHIAZBBGoiBkYEQCAHIQYMAQsgCUEBIAYoAgAQpQENAQsLA0AgCEEMaiIBIAhBCGoQLQ0CIAlBASABEEkQpQFFDQIgARBTGgwACwALIAkgCEEMaiIBEEkQXiAJ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ADYCDCAAIAM2AhAgAQRAIAEQ6gQhBAsgACAENgIAIAAgBCACQQN0aiICNgIIIAAgBCABQQN0ajYCDCAAIAI2AgQgAAsOACAAIAEoAgA2AgAgAAskACAAQQtPBH8gAEEQakFwcSIAIABBAWsiACAAQQtGGwVBCgsLJAECfyMAQRBrIgIkACAAIAEQqwYhAyACQRBqJAAgASAAIAMbCwgAIAAoAgBFC40BAQF/AkAgACgCBCIBIAEoAgBBDGsoAgBqKAIYRQ0AIAAoAgQiASABKAIAQQxrKAIAahDmCkUNACAAKAIEIgEgASgCAEEMaygCAGooAgRBgMAAcUUNACAAKAIEIgEgASgCAEEMaygCAGooAhgQ5QpBf0cNACAAKAIEIgAgACgCAEEMaygCAGpBARC6AgsLswEBAX8gACABNgIEIABBADoAACABIAEoAgBBDGsoAgBqEOYKBEAgASABKAIAQQxrKAIAaigCSCIBBEAjAEEQayICJAAgASABKAIAQQxrKAIAaigCGARAIAJBCGogARC5AhoCQCACLQAIRQ0AIAEgASgCAEEMaygCAGooAhgQ5QpBf0cNACABIAEoAgBBDGsoAgBqQQEQugILIAJBCGoQuAILIAJBEGokAAsgAEEBOgAACyAACwkAIAAgARCxCQsIACAAQf8BcQuUAgIHfwJ+IwBBQGoiACQAQQAgAEEoahDyCgRAQfDCAigCABCCBgALIABBGGogAEEoahCNAiEEIAAgACgCMEHoB202AgwgAEEQaiAAQQxqEPAKIQUjAEEgayIBJAAjAEEQayIDJAAjAEEQayIGJAAjAEEQayICJAAgAiAEKQMAQsCEPX43AwAgAkEIaiACEI0CKQMAIQcgAkEQaiQAIAZBEGokACADIAc3AwggASADKQMINwMIIANBEGokACABKQMIIQcgASAFKQMANwMAIAEgByABKQMAfDcDECABQRhqIAFBEGoQjQIpAwAhByABQSBqJAAgACAHNwMgIABBOGogAEEgahCNAikDACEIIABBQGskACAIC1ABAX4CQCADQcAAcQRAIAIgA0FAaq2IIQFCACECDAELIANFDQAgAkHAACADa62GIAEgA60iBIiEIQEgAiAEiCECCyAAIAE3AwAgACACNwMIC9sBAgF/An5BASEEAkAgAEIAUiABQv///////////wCDIgVCgICAgICAwP//AFYgBUKAgICAgIDA//8AURsNACACQgBSIANC////////////AIMiBkKAgICAgIDA//8AViAGQoCAgICAgMD//wBRGw0AIAAgAoQgBSAGhIRQBEBBAA8LIAEgA4NCAFkEQEF/IQQgACACVCABIANTIAEgA1EbDQEgACAChSABIAOFhEIAUg8LQX8hBCAAIAJWIAEgA1UgASADURsNACAAIAKFIAEgA4WEQgBSIQQLIAQLKAAgAEERTwRAQffPAEH7xwBB8AlBnAoQAAALIABBAnRB8NkBaigCAAuoAgECfyAGKAIEIQggBi0ACyEHIABBADYCCCAAQgA3AgAgAEETQRIgARsgCCAHIAfAQQBIG2oQXSAAQesxEN0DIAAgAhDdAwJAIAFFBEAgACADEOYLIAAgBBDlCyAAIAUQ3QMMAQsgACAEEOULIwBBEGsiASQAIAEgBTYCDCAAIAFBDGpBBBBtGiABQRBqJAALIAYoAgQgBi0ACyIBIAHAQQBIG60iBKchAQJAIARC//8BWARAIAAgAUH//wNxEN0DDAELIAAgAUGAgAJyQf//A3EQ3QMgBEIPiCEEA0AgBFANASAAIASnQf8AcSAEQv8AVkEHdHIQ5gsgBEIHiCEEDAALAAsgACAGKAIAIAYgBi0ACyIAwEEASCIBGyAGKAIEIAAgARsQbRoLqAQBCn8jAEHgAWsiAyQAIAAtAIQDRQRAIABBASAALQBkQQFqQf8BcSIBIAFBAU0bOgBkCyAAQQA7ATQgA0G0AWoQ4QQhCAJ/IANBqAFqIgEgAEHYAGoiAigCADYCACABIAIoAgQiBDYCBCABIAIoAggiBTYCCCABQQRqIQYgBUUEQCABIAY2AgAgAQwBCyAEIAY2AgggAkIANwIEIAIgAkEEajYCACABCyIGQQRqIQQgBigCACECIANBHGohBQNAAkAgAiAERgRAIANBDGoiAUEANgIIIAEgATYCBCABIAE2AgAgACgCVCIFBEAgACgCUCIEKAIAIgcgACgCTCICKAIENgIEIAIoAgQgBzYCACABKAIAIgcgBDYCBCAEIAc2AgAgASACNgIAIAIgATYCBCABIAEoAgggBWo2AgggAEEANgJUCyABKAIEIQIgA0EcaiEEA0AgASACRg0CIAIvAQghAEECEBUEQCAEEBMhCSADQQI2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CDYCCCACQQA2AgggAkIANwMAIAMgAikDEDcDECADIAIpAxg3AxggAyACKAIgNgIgIAJBADYCICACQgA3AxgMAQsLIAEgAzYCBCAAKAIAIQIgACADNgIAIAEgAjYCBCAAKAIEIQIgACABKAIINgIEIAEgAjYCCCAAKAIIIQIgACABKAIMNgIIIAEgAjYCDCABIAEoAgQ2AgALNwEDfyMAQRBrIgMkACAAEE4hACABKAJUIQUgAyAANgIMIAUgAiABIANBDGoQ2gIaIANBEGokAAtfAQN/IwBBEGsiASQAIAEgADYCDCABKAIMIgAoAgAEQCAAKAIAIQMgACgCBCECA0AgAiADRwRAIAJBgAFrEIUBIQIMAQsLIAAgAzYCBCABKAIMKAIAEAsLIAFBEGokAAuHAQAgACABECYiAEEMaiABQQxqECYaIABBGGogAUEYahAmGiAAQSRqIAFBJGoQJhogAEEAOgA8IABBADoAMCABLQA8BEAgACABKQMwNwMwIAAgASgCODYCOCABQgA3AzAgAUEANgI4IABBAToAPAsgAEFAayABQUBrECYaIAAgASkDUDcDUCAACw8AIAAgARCJCUEBOgDAAQtNACAAAn8gAS0AQEUEQCAAQQA6AABBAAwBCyABEJ4CIAAgASkABTcAACAAIAEpAB03ABggACABKQAVNwAQIAAgASkADTcACEEBCzoAIAsQACAALQDAAQRAIAAQoAILC40DAQR/IwBBEGsiAyQAIAEgABAbIQUgAiABEBshBAJ/AkAgBUUEQEEAIARFDQIaIAMgASgCCDYCCCADIAEpAgA3AwAgASACKAIINgIIIAEgAikCADcCACACIAMoAgg2AgggAiADKQMANwIAQQEgASAAEBtFDQIaIAMgACgCCDYCCCADIAApAgA3AwAgACABKAIINgIIIAAgASkCADcCACABIAMoAgg2AgggASADKQMANwIADAELIAQEQCADIAAoAgg2AgggAyAAKQIANwMAIAAgAigCCDYCCCAAIAIpAgA3AgAgAiADKAIINgIIIAIgAykDADcCAEEBDAILIAMgACgCCDYCCCADIAApAgA3AwAgACABKAIINgIIIAAgASkCADcCACABIAMoAgg2AgggASADKQMANwIAQQEgAiABEBtFDQEaIAMgASgCCDYCCCADIAEpAgA3AwAgASACKAIINgIIIAEgAikCADcCACACIAMoAgg2AgggAiADKQMANwIAC0ECCyEGIANBEGokACAGC24CAn8BfiACED4iBadB/wFxQYACciECIAUgATEAHoinIQMgASgCECEEIAEoAgwhAQNAIAIgASADQQN0aigCAE9FBEAgA0EBaiIDQQAgAyAERxshAyACQYACaiECDAELCyAAIAM2AgQgACACNgIACwsAIAEgAEEgEG0aC8QBAgN/AX4jAEEgayICJAACQCABLQAwQQRGBEAgAEEYaiEEA0AgBSABKAIcIAEtACMiAyADwEEASButWg0CIAIgASkDACAFfDcDECACIAEpAwg3AxggAkEIaiAEIAJBEGoQYCAAIAApA0BCAXw3A0AgBUIBfCEFDAALAAsgAkEQaiIDIAEQ+wEgAkEIaiAAQRhqIgQgAxBgIAEtAFBFBEAgAyAEIAEQYAsgACAAKQNAIAEtADBBAEetfDcDQAsgAkEgaiQAC8IBAQN/IAAoAgQiAiAAKAIISQRAIAIgASkCADcCACACIAEoAgg2AgggAUIANwIAIAFBADYCCCAAIAJBDGo2AgQPCyMAQSBrIgMkACADQQxqIAAgACgCBCAAKAIAa0EMbUEBahDsAiAAKAIEIAAoAgBrQQxtIABBCGoQqQIiAigCCCIEIAEpAgA3AgAgBCABKAIINgIIIAFCADcCACABQQA2AgggAiACKAIIQQxqNgIIIAAgAhCuBCACEMsDIANBIGokAAsLACAAQfDZABDHAwtiAQJ/IwBBIGsiAiQAAkAgASAAKAIIIAAoAgAiA2tBA3VLBEAgAUGAgICAAk8NASAAIAJBDGogASAAKAIEIANrQQN1IABBCGoQswIiABCYBiAAELICCyACQSBqJAAPCxABAAsnAQF/IAAgACgCADYCBCAAKAIMIgEEQCABQQAgACgCEEEDdBAeGgsLFgEBfyAAKAIMIgEEQCABEAsLIAAQOwsdACAAIAFBqtWq1QBBDEHVqtWqAUHWqtWqARCTAQsgAQF/IAAoAkwiAUF/RgRAIAAgABCwCSIBNgJMCyABwAsfACAAQQA6AAwgAEEAOgAAIAEtAAwEQCAAIAEQxAMLCzEBAX8gASAFTwRAEAEACyAEIAAoAgggACgCAGsiACADdSIGIAEgASAGSRsgACACTxsLEgAgAC0AECABRwRAEBoACyAACxkAIAEgAhD4CSEBIAAgAjYCBCAAIAE2AgALJAAgAEECTwR/IABBBGpBfHEiACAAQQFrIgAgAEECRhsFQQELC6oBAQR/IwBBEGsiBSQAIAEQ6QkhAiMAQRBrIgMkAAJAIAJB7////wNNBEACQCACELQEBEAgACACEHsgACEEDAELIANBCGogACACEPICQQFqEPECIAMoAgwaIAAgAygCCCIEEJUBIAAgAygCDBCUASAAIAIQcAsgBCABIAIQjAIgA0EANgIEIAQgAkECdGogA0EEahCGASADQRBqJAAMAQsQaAALIAVBEGokAAtKAQF/IABBADYCDCAAIAM2AhAgAQRAIAEQrwkhBAsgACAENgIAIAAgBCACQQV0aiICNgIIIAAgBCABQQV0ajYCDCAAIAI2AgQgAAsVACAAIAEgAiADQcgAQeTxuBwQsQELxwEBBn8jAEEQayIEJAAgABCLAygCACEFAn8gAigCACAAKAIAayIDQf////8HSQRAIANBAXQMAQtBfwsiA0EEIAMbIQMgASgCACEGIAAoAgAhByAFQZMERgR/QQAFIAAoAgALIAMQ0wQiCARAIAVBkwRHBEAgABC4BBoLIARBkgQ2AgQgACAEQQhqIAggBEEEahBGIgUQnwogBRBFIAEgACgCACAGIAdrajYCACACIAAoAgAgA0F8cWo2AgAgBEEQaiQADwsQGgALEwAgACABQQAgACgCACgCNBEFAAsTACAAIAFBACAAKAIAKAIkEQUAC/ICAQJ/IwBBEGsiCiQAIAogADYCDAJAAkACQCADKAIAIAJHDQBBKyELIAAgCSgCYEcEQEEtIQsgCSgCZCAARw0BCyADIAJBAWo2AgAgAiALOgAADAELIAYQDkUgACAFR3JFBEBBACEAIAgoAgAiASAHa0GfAUoNAiAEKAIAIQAgCCABQQRqNgIAIAEgADYCAAwBC0F/IQAgCSAJQegAaiAKQQxqEJQGIAlrIgZB3ABKDQEgBkECdSEFAkACQAJAIAFBCGsOAwACAAELIAEgBUoNAQwDCyABQRBHIAZB2ABIcg0AIAMoAgAiASACRiABIAJrQQJKcg0CIAFBAWstAABBMEcNAkEAIQAgBEEANgIAIAMgAUEBajYCACABIAVBwIYCai0AADoAAAwCCyADIAMoAgAiAEEBajYCACAAIAVB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IAIgATYCRCACIAAQ8gELCxUAIABBOGoQChogAEEYahBNIAAQZgu6AQIEfwR+IAEoAgQgASgCACIEa0EDdSICIAAoAgQgACgCACIFa0EDdSIDIAIgA0kbrSEHQQAhAQJAA0AgBiAHUgRAAkAgBSAGp0EDdCIAaikDACIIIAAgBGopAwAiCVENACAIIAlUBEBBAyEAIAFBAUYNBEECIQEgAiADTw0BDAQLQQMhACABQQJGDQNBASEBIAIgA0sNAwsgBkIBfCEGDAELC0ECQQEgASACIANJGyACIANLGyEACyAAC7UCAQV/IwBBIGsiBSQAAkAgACgCBCICIAAoAgBHBEAgAiEDDAELIAAoAggiAyAAKAIMIgRJBEAgACADIAQgA2tBAnVBAWpBAm1BAnQiBGogAyACayIGayIDIAIgBhBVNgIEIAAgACgCCCAEajYCCAwBCyAFQQxqQQEgBCACa0EBdSACIARGGyICIAJBA2pBAnYgAEEMahC3ASICIAAoAgQgACgCCBCkAyAAKAIAIQMgACACKAIANgIAIAIgAzYCACAAKAIEIQMgACACKAIENgIEIAIgAzYCBCAAKAIIIQMgACACKAIINgIIIAIgAzYCCCAAKAIMIQMgACACKAIMNgIMIAIgAzYCDCACEJgBIAAoAgQhAwsgA0EEayABKAIANgIAIAAgACgCBEEEazYCBCAFQSBqJAALlwsCBn8CfiMAQYABayIJJAACQAJAAkACfyAAKAIAIAAoAgRGBEAgAEEMaiEMAkACQAJAAkAgACgCDCIHIAKnIgpB8ABsIghqIgstADBBAWsOBAABAQIBCyABQfAAaiALEJABIAYgDCgCACIHIAhqIggpAwA3AwAgBiAIKQMINwMICyAELQAwQQNHDQECQCAHIApB8ABsIgVqEJcCRQ0AIARB2ABqENwBIgEpAwAgDCgCACAFaiIAKQMAUg0AIAEpAwggACkDCFINACAEQRBqEM0CKQMAIQIgBSAMKAIAakEQahCfARDzASIAIAIgACkDCHw3AwgLIAwoAgAgBWohCAwGCyADIAsQigFCAX1UBEBBACEIIAAoAhAgACgCDCIHa0HwAG1BHksNBiAJQRBqIgggByAKQfAAbCIGaiADQgF8EKABIAwgACgCDCAGakHwAGogCBC7ASAAIAApAzhCAXw3AzggCBAvGgsg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ADcCAAsLJwEBfyMAQRBrIgIkACACIAE7AQ4gACACQQ5qQQIQbRogAkEQaiQACz0AIABB4ABqEAoaIABB1ABqEAoaIABByABqEAoaIABBPGoQChogAEEwahAKGiAAQRBqEBIaIABBBGoQChoLDwAgAEEIaiABLwEAENYFC1MBAX8gASgCECICRQRAIABBADYCECAADwsgASACRgRAIAAgADYCECABKAIQIgEgACABKAIAKAIMEQAAIAAPCyAAIAIgAigCACgCCBECADYCECAACycAIAEEQCAAIAEoAgAQ4QMgACABKAIEEOEDIAFBEGoQzQYgARALCwsbAQF/IAAoAgAhASAAQQA2AgAgAQRAIAEQCwsLbwICfwF+IAIQvAEiBadB/wFxQYACciECIAUgATEAHoinIQMgASgCECEEIAEoAgwhAQNAIAIgASADQQN0aigCAE9FBEAgA0EBaiIDQQAgAyAERxshAyACQYACaiECDAELCyAAIAM2AgQgACACNgIACyEAIAAoAhAiAEUEQBAaAAsgACABIAIgACgCACgCGBEEAAu5BQIKfwJ9IwBBEGsiCCQAIAggATYCBCMAQRBrIgQkACABEJACIQMgCAJ/AkAgACgCBCICRQ0AIAAoAgACfyACQQFrIANxIAJpIgZBAU0NABogAyACIANLDQAaIAMgAnALIgdBAnRqKAIAIgVFDQAgAkEBayEJIAZBAUshCgNAIAUoAgAiBUUNASADIAUoAgQiBkcEQAJAIApFBEAgBiAJcSEGDAELIAIgBksNACAGIAJwIQYLIAYgB0cNAgsgBUEIaiABECJFDQALQQAMAQtBIBAXIQEgBCAAQQhqNgIIIAQgATYCBCABQQhqIAgoAgQQ4AUaIARBAToADCABQQA2AgAgASADNgIEAkBBACACIAAoAgxBAWqzIgwgACoCECINIAKzlF4bDQAgACACIAJBAWtxQQBHIAJBA0lyIAJBAXRyIgECfyAMIA2VjSIMQwAAgE9dIAxDAAAAAGBxBEAgDKkMAQtBAAsiByABIAdLGxCMAyAAKAIEIgIgAkEBayIBcUUEQCABIANxIQcMAQsgAiADSwRAIAMhBwwBCyADIAJwIQcLAkAgB0ECdCIDIAAoAgBqKAIAIgFFBEAgBCgCBCAAKAIINgIAIAAgBCgCBDYCCCAAKAIAIANqIABB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AGxqQcQAahD1AwsgBkGQAWokAAsJACAAQSIQyAMLkAEBA38gASgCBCECIAAoAgAhBCAAKAIEIQMDQCADIARGRQRAIAJBImsiAiADQSJrIgNBIhAdGgwBCwsgASACNgIEIAAoAgAhAyAAIAI2AgAgASADNgIEIAAoAgQhAiAAIAEoAgg2AgQgASACNgIIIAAoAgghAiAAIAEoAgw2AgggASACNgIMIAEgASgCBDYCAAsUACAAIAEgAiADQSJBiI+ePBCxAQsGACABEDcLCwAgACABECJBAXMLuAECBH8BfSMAQRBrIgQkACAAQQA2AgggAEIANwIAIAEoAgQiAiABKAIAIgNHBEAgACACIANrQQR1EJwKIAAoAgQhAiABKAIEIQUgASgCACEDA0AgAyAFRwRAIAIgAykDADcDACACIAMpAwg3AwggAkEQaiECIANBEGohAwwBCwsgACACNgIECyAAQQA2AhQgAEIANwIMIAEqAhghBiAAQT46AB4gACAGOAIYIAAgARC8BiAEQRBqJAALqAIBBH8jAEEgayIFJAACQCAAKAIIIgIgACgCDEcNACAAKAIEIgMgACgCACIESwRAIAAgAyADIARrQQJ1QQFqQX5tQQJ0IgRqIAMgAiADayICEFUgAmoiAjYCCCAAIAAoAgQgBGo2AgQMAQsgBUEMakEBIAIgBGtBAXUgAiAERhsiAiACQQJ2IAAoAhAQtwEiAiAAKAIEIAAoAggQpAMgACgCACEDIAAgAigCADYCACACIAM2AgAgACgCBCEDIAAgAigCBDYCBCACIAM2AgQgACgCCCEDIAAgAigCCDYCCCACIAM2AgggACgCDCEDIAAgAigCDDYCDCACIAM2AgwgAhCYASAAKAIIIQILIAIgASgCADYCACAAIAAoAghBBGo2AgggBUEgaiQACw0AIAAgAUHg2gAQ0QkLDQAgACABQdjaABDUCQsJACABIAIQEBoL4wQCC38CfiMAQTBrIgQkACACLQAwQQFGBEAgBCABKQMINwMgIAQgASkDADcDGCAEQanZADYCKCAEIAA2AhQgAkEYaiEFIARBGGohCCAEQRRqIQkjAEEQayIBJAAgAhC8ASIOp0H/AXFBgAJyIQcgDiAAQeQAaiIAMQAeiKchBiAAKAIQIQogAikDCCEOIAIpAwAhDyAAKAIAIQsgACgCDCEM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BCIERQ0AIAQtAAwNAAwCCyADIAIoAgBHBEAgAhCvAyACKAIIIgIoAgghAQsgAkEBOgAMIAFBADoADCABEK4DDAILAkAgBEUNACAELQAMDQAMAQsgAyACKAIARgRAIAIQrgMgAigCCCICKAIIIQELIAJBAToADCABQQA6AAwgARCvAwwBCyACQQE6AAwgASABIAVGOgAMIARBAToADCABIQMMAQsLIAAgACgCCEEBajYCCAuZAQICfwF+IwBBEGsiAyQAQSAQFyECIAMgAEEIajYCCCADQQE2AgwgAiABKAIINgIQIAIgASkDADcDCCABQQA2AgggAUIANwMAIAEpAxAhBCACIAA2AgAgAiAENwMYIAIgACgCBCIBNgIEIAEgAjYCACAAIAI2AgQgACAAKAIIQQFqNgIIIANBADYCBCADQQRqEH8gA0EQaiQAC3ECAn8BfiACQSAQ4gEiBadB/wFxQYACciECIAUgATEAHoinIQMgASgCECEEIAEoAgwhAQNAIAIgASADQQN0aigCAE9FBEAgA0EBaiIDQQAgAyAERxshAyACQYACaiECDAELCyAAIAM2AgQgACACNgIAC0IBAX8jAEEQayICJAAgAEIANwIAIABBPjoAHiAAQc2Zs/oDNgIYIABCADcCECAAQgA3AgggACABEIgDIAJBEGokAAsWACAALQBABEAgABCxAyAAQQA6AEALCy4BAX8gACAAKAIAIgIgASACa0HIAG1ByABsaiIBQcgAaiAAKAIEIAEQ9gUQqQQLJQAgACgCECIARQRAEBoACyAAIAEgAiADIAQgACgCACgCGBEKAAsuAQF/IAEoAgAiAiABKAIENgIEIAEoAgQgAjYCACAAIAAoAghBAWs2AgggARALCzcBAn4gACgCACEAA34gASACUQR+IAMFIAMgACACp0HIAGxqKQM4fEIBfCEDIAJCAXwhAgwBCwsLgQEBAn8gACgCBCAAKAIISQRAIAAgARDpCg8LIwBBIGsiAyQAIANBDGogACAAKAIEIAAoAgBrQfAAbUEBahDbBSAAKAIEIAAoAgBrQfAAbSAAQQhqEIkDIgIoAgggARA4GiACIAIoAghB8ABqNgIIIAAgAhCzCyACEIUDIANBIGokAAsWACAALQAMBEAgABAPGiAAQQA6AAwLCzcBAX8jAEEQayIBJAAgASAANgIMIAEoAgwiACgCAARAIAAQ0AUgASgCDCgCABALCyABQRBqJAALQgEBfyMAQRBrIgIkACAAQgA3AgAgAEE+OgAeIABBzZmz+gM2AhggAEIANwIQIABCADcCCCAAIAEQ0QUgAkEQaiQACy8BA38gAC0AICICQQBHIAEtACAiA0EAR3MhBCACRSADRXIEfyAEBSAAIAEQzgULCxgAIAAtAMABBEAgABCgAiAAQQA6AMABCwuIAQEDfyACIAFrIgNB8P///wdJBEACQCADQQpNBEAgACADOgALDAELIANBD3JBAWoiBRAXIQQgACAFQYCAgIB4cjYCCCAAIAQ2AgAgACADNgIEIAQhAAsDQCABIAJGRQRAIAAgAS0AADoAACAAQQFqIQAgAUEBaiEBDAELCyAAQQA6AAAPCxABAAsSACAAIAEQHCAAIAEpAxA3AxALCwAgACABQQQQwwkLcgEBfyMAQRBrIgIkAAJAIAAtABhBBEYEQCAAIAEQHAwBCyACIAE2AgwgAiAANgIIIAIoAgwhACACKAIIIgEQ6AIgASAAKAIINgIIIAEgACkCADcCACAAQgA3AgAgAEEANgIIIAFBBDoAGAsgAkEQaiQACwsAIAAgAUEEEMIJC6oDAgR/AX4jAEFAaiIBJAAgAEEIaiECAkACQAJAAkACQAJAAkAgAC0AIA4GAAECBQMEBgsgAUIBNwMwIAFBMGohAyMAQRBrIgAkAAJAIAItABhBAUYEQCACIAEpAzA3AwAMAQsgACADNgIMIAAgAjYCCCAAKAIMIQQgACgCCCICELABIAQpAwAhBSACQQE6ABggAiAFNwMACyAAQRBqJAAMBQsgAiACKQMAQgF8NwMADAQLIAIgAikDAEIBfDcDAAwDCyABQQA2AjggAUIANwIwIAFBMGoiAyACEFcgASABKAIwNgIkIAEpAjQhBSABQQA2AjggASAFNwIoIAFCADcCMCAAIAFBJGoiABDBAyAAEA8aIAFCATcDGCACIAFBGGoQ8AUgAxAPGgwCCyAAIAIgACkDEBDvBSABQgE3AzAgAiABQTBqEPAFDAELIABBEGogAhBXIAEgACgCEDYCDCABIAAoAhQ2AhAgASAAKAIYNgIUIABBADYCGCAAQgA3AxAgACABQQxqIgAQwQMgABAPGiABQgE3AzAgAiABQTBqEPAFCyABQUBrJAALKgEBfyAAKAIEIQIDQCABIAJGRQRAIAJByABrEFshAgwBCwsgACABNgIECykBAX8gACgCBCEDA0AgASADRkUEQCADIAJrEAohAwwBCwsgACABNgIECz0BAn8gACgCBCECA0AgAiAAKAIIIgFHBEAgACABQcgAayIBNgIIIAEQWxoMAQsLIAAoAgAiAARAIAAQCwsLFQAgAC0AICABRwRAEBoACyAAQQhqC5QBAQN/IwBBIGsiAiQAIAAoAgwiAwRAIANBACAAKAIQQQN0EB4aCyAAKAIEIAAoAgBrIAFtIQRBACEDA0AgAyAERgRAIAJBIGokAAUgAkEYaiAAIAAoAgAgAyABbGoQ5AIgAiADNgIUIAIgAigCGDYCECACIAIpAhA3AwggACACQQhqIAIoAhwQMCADQQFqIQMMAQsLC6wBAQN/IAEoAgQhAyAAKAIAIQQgACgCBCECA0AgAiAERkUEQCADQQxrIgMgAkEMayICKQIANwIAIAMgAkEIaigCADYCCCACQgA3AgAgAkEANgIIDAELCyABIAM2AgQgACgCACECIAAgAzYCACABIAI2AgQgACgCBCECIAAgASgCCDYCBCABIAI2AgggACgCCCECIAAgASgCDDYCCCABIAI2AgwgASABKAIENgIAC0kBAn8gACgCBCIGQQh1IQUgBkEBcQRAIAIoAgAgBRCABiEFCyAAKAIAIgAgASACIAVqIANBAiAGQQJxGyAEIAAoAgAoAhgRCgALjAEBAn8jAEEQayIDJAAgAUHv////B00EQAJAIAEQ1AMEQCAAIAEQeyAAIQQMAQsgA0EIaiAAIAEQtQJBAWoQigIgAygCDBogACADKAIIIgQQlQEgACADKAIMEJQBIAAgARBwCyAEIAEgAhDmCSADQQA6AAcgASAEaiADQQdqEIkBIANBEGokAA8LEGgAC5QCAQN/IwBBEGsiCCQAIAIgAUF/c0Hv////B2pNBEAgABAgIQkgCEEEaiIKIAAgAUHn////A0kEfyAIIAFBAXQ2AgwgCCABIAJqNgIEIAogCEEMahC2AigCABC1AkEBagVB7////wcLEIoCIAgoAgQhAiAIKAIIGiAEBEAgAiAJIAQQlwELIAYEQCACIARqIAcgBhCXAQsgAyAEIAVqIgprIQcgAyAKRwRAIAIgBGogBmogBCAJaiAFaiAHEJcB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AyIAQQF2QQAgAEEBcWtzNgIADAoLIARBBUcNByABIAUoAAA2AgAMCQsgBA0GIAEgBiAFENYENwMADAgLIAQNBSABIAYgBRDWBCIKQgGIQgAgCkIBg32FNwMADAcLIARBAUcNBCABIAUpAAA3AwAMBgsgASAGIAUQkQs2AgAMBQsgBEECRw0CIAAtAAUhAAJAIANFDQAgASgCACIDRQ0AIAMgCCgCHEYNACACKAIIIAMgAigCBBEAAAsgASACKAIIIAYgAGsiA0EBaiACKAIAEQMAIgI2AgAgAkUNAiACIAAgBWogAxAdGiABKAIAIANqQQA6AAAMBAsgBEECRw0BIAAtAAUhAAJAIANFDQAgASgCBCIDRQ0AIAgoAhwiBARAIAMgBCgCBEYNAQsgAigCCCADIAIoAgQRAAALAkAgACAGSQRAIAEgAigCCCAGIABrIgQgAigCABEDACICNgIEIAJFDQMgAiAAIAVqIAQQHRoMAQsgAUEANgIEIAYgAGshBAsgASAENgIADAMLIARBAkcNACAIKAIcIQlBASEEIAgoAhggAiAGIAAtAAUiAGsgACAFahCnASEAAkAgA0UNACABKAIAIgdFIAcgCUZyDQACQCAARQRADAELIAcgACACEJALQQBHIQQgASgCACEHCyAHIAIQ7AELIAEgADYCACAAQQBHIARxIQcLIAcPCyABIAYgBRCGAzYCAAtBAQvBAQECfyAApyECIABCIIinIgNFBEAgAiABENcBDwsgASACQYABcjoAACABIAJBFXZBgAFyOgADIAEgAkEOdkGAAXI6AAIgASACQQd2QYABcjoAASADQQR0IAJBHHZyIQIgA0EHTQRAIAEgAjoABEEFDwsgASACQYABcjoABCADQQN2IQJBBSEDA0AgAkGAAUlFBEAgASADaiACQYABcjoAACACQQd2IQIgA0EBaiEDDAELCyABIANqIAI6AAAgA0EBagtSAQF/IABCIIinIgFFBEAgAKcQqAEPCwJ/QQUgAUEISQ0AGkEGIAFBgAhJDQAaQQcgAUGAgAhJDQAaQQggAUGAgIAISQ0AGkEJQQogAEIAWRsLCw0AIABBuJcBQSgQHRoLIwAgACABKAIANgIAIABBBGogAUEEahAQGiAAIAEoAhA2AhALHwAgACABEBAiAEEMaiABQQxqEBAaIAAgASkCGDcCGAsMACAAIAFBjAkQxAkLIQAgASgCECIBRQRAEBoACyAAIAEgAiABKAIAKAIYEQQACycBAX8jAEEQayIDJAAgAyABOwEOIAAgA0EOaiACEOQDIANBEGokAAsfACABKAIQIgFFBEAQGgALIAAgASABKAIAKAIYEQAACxUAIABBvOEANgIAIABBBGoQqgsgAAtdAQN/IwBBEGsiASQAIAEgADYCDCABKAIMIgAoAgAEQCAAKAIAIQMgACgCBCECA0AgAiADRwRAIAJBGGsQZiECDAELCyAAIAM2AgQgASgCDCgCABALCyABQRBqJAALJwEBfyMAQRBrIgMkACADIAE2AgwgACADQQxqIAIQ5AMgA0EQaiQACzEBA38gACgCCCEBA0AgAQRAIAEoAgAhAyABQQhqENMGIAEQCyADIQEMAQsLIAAQ4gMLJwAgAQRAIAAgASgCABDlBCAAIAEoAgQQ5QQgAUEQahC0BSABEAsLCyUAIAAgAUcEQCAAIAEoAkQQ5gQgACABKAJIEOYEIAEQnQMQCwsLkQUBC38gACgCACECIwBBEGsiCiQAIAogADYCDCAKQQxqIQEjAEEQayIGJAACQCACQegCaiIDKAIAIAMoAgRGDQAgBkEIaiADIAEQ6gggAygCECEFIAEoAgAhBCADKAIAIQcgAygCDCEIIAYoAgwhAiAGKAIIIQEDQCABIAggAkEDdGoiCSgCAEcNASAHIAkoAgRBAnRqKAIAIARHBEAgBiABQYACaiIBNgIIIAYgAkEBaiICQQAgAiAFRxsiAjYCDAwBCwsjAEEQayIHJAAgAkEBaiIBQQAgASADKAIQRxshBSADKAIMIgQgAkEDdGooAgQhCANAIAQgBSIBQQN0aiIFKAIAIglBgARPBEAgBCACQQN0aiICIAUoAgQ2AgQgAiAJQYACazYCACABQQFqIgJBACACIAMoAhBHGyEFIAMoAgwhBCABIQIMAQsLIAQgAkEDdGpCADcCACADKAIEIgIgAygCACIBa0ECdUEBayAIRwRAIAEgCEECdGogAkEEaygCACIBNgIAIAcgAa1CAEKV+Kn6l7fem55/QgAQKSADKAIEIgIgAygCAGtBAnVBAWshASAHKQMIIAcpAwCFIAMxAB6IpyEEIAMoAhAhBSADKAIMIQkDQCAJIARBA3RqIgsoAgQgAUcEQCAEQQFqIgRBACAEIAVHGyEEDAELCyALIAg2AgQLIAMgAkEEazYCBCAHQRBqJAALIAZBEGokACAKQRBqJAAgAEGkA2oiAigCDCIBBEAgARALCyMAQRBrIgEkACABIAI2AgwgASgCDCICKAIABEAgAhDYBiABKAIMKAIAEAsLIAFBEGokACAAQYADaiIBLQAgBEAgARDrAgsgAEG4AWoQ4gIgAEEEahAKGguSBQEDfyAAIAEpAgA3AgAgACABKAIINgIIIAFCADcCACABQQA2AgggAEEQaiIBQQA6AEQgAUEAOgBAIAFBADoAACABQQA6AIQBIAFBiAFqEE4aIwBBEGsiAyQAIAFBqAFqIgJCADcCACACQT46AB4gAkHNmbP6AzYCGCACQgA3AhAgAkIANwIIIAIQMSACKAIMIgQEQCAEQQAgAigCEEEDdBAeGgsgA0EQaiQAIAFCATcD4AEgAUEANgLcASABIAFB1AFqIgI2AtgBIAEgAjYC1AEgASABQcwBajYCyAEgAUIANwLMASABQegBakEAQS0QHhogAEEANgLgAiAAQQA2AsgCIABBADoAtAIgACAAQawCajYCqAIgAEIANwKsAiAAQegCahBOGiAAQQA2ApADIAAgAEGIA2oiATYCjAMgACABNgKIAyMAQRBrIgIkACAAQZQDaiIBQgA3AgAgAUE+OgAeIAFBzZmz+gM2AhggAUIANwIQIAFCADcCCCABEDEgASgCDCIDBEAgA0EAIAEoAhBBA3QQHhoLIAJBEGokACAAQgA3AcYDIABCADcDwAMgAEIANwO4AyAAQdADaiIBQgA3AgAgAUIANwIQIAFCADcCCCMAQRBrIgIkACABQRhqENMHGiACQRBqJAAgAUEANgJQIAFCADcCSCABQUBrQgA3AgAgAUIANwI4IAFBADYCWCABIAE2AlQgAEGsBGoiAUIANwIAIAFCADcCECABQgA3AgggAUEYahBOGiABQQA2AlAgAUIANwJIIAFBQGtCADcCACABQgA3AjggAUEANgJYIAEgATYCVCAAQQA2AtgFIABBADYCwAUgAEEAOgCoBSAAQQA2AqAFIABBADYCiAUgAAswAQF/IAAoAgAhASAAQQA2AgAgAQRAIAAtAAgEQCABQQhqENMGCyABBEAgARALCwsLGAAgAEGAgICAAk8EQBAaAAsgAEEDdBAXCx0A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KAIAIAIoAgRGDQAgAEG4AWogARDzCCEHIAIoAgQhCCACKAIAIQMDQCADIAhGDQEgAygCACEFIwBBMGsiBiQAIAZBJGogARAQIQQgBkEIaiAHEPkBIQIjAEEwayIAJAAgACAEKAIINgIoIAAgBCkCADcDICAEQgA3AgAgBEEANgIIIAAgAikDADcDCCAAIAIoAhA2AhggACACKQMINwMQIAJBADYCECACQgA3AwggBUEoaiAAQSBqIgkgAEEIahDGCCAAQRBqEAoaIAkQChogAEEwaiQAIAJBCGoQChogBBAKGiAFKAIIIQIgBSgCBCEAA0AgACACRwRAIAAoAgBB+AJqIAEQigggAEEEaiEADAELCyAGQTBqJAAgA0EEaiEDDAALAAsFIAMoAgBBpANqIAEQigggA0EEaiEDDAELCwstAQJ/IAAoAggiASAAKAIEIgJrQQN0QQFrQQAgASACRxsgACgCFCAAKAIQamsLpwIBAX8CQCABRQRAIAAgAzYCACMAQRBrIgMkACAAQQRqIgFCADcCACABQT46AB4gAUHNmbP6AzYCGCABQgA3AhAgAUIANwIIIAEQMSABKAIMIgQEQCAEQQAgASgCEEEDdBAeGgsgA0EQaiQAIwBBEGsiAyQAIABBJGoiAUIANwIAIAFBPjoAHiABQc2Zs/oDNgIYIAFCADcCECABQgA3AgggARAxIAEoAgwiBARAIARBACABKAIQQQN0EB4aCyADQRBqJAAgAEHEAGoQyAEgAEEAOgCYAQwBCyAAQgA3A1ggAEEAOgAIIAAgAzYCACAAQQA6AFAgAEIANwNgIABCADcDaCAAQfAAahDIASAAQgA3A5ABIABBAToAmAELIABBoAFqIAIQpQgLGwAgACABQaXo3gRB2AFBy9C9CUHM0L0JEJMBCzMAIAAoAhRBgICAgHhGBEAgABCdCBAaAAsgACAALQAeQQFrOgAeIAAQTCAAEDEgABCgDAsMACAAIAAoAgAQnggLDAAgACAAKAIAEKEICz8BAn8gACgCBCECA0AgAiAAKAIIIgFHBEAgACABQdgBazYCCCABQcgBaxCqCAwBCwsgACgCACIABEAgABALCwubAgEHfyAAKAIEIQMgACgCACEHIAEoAgQhAgNAIAMgB0cEQCACQdgBayICIANB2AFrIgMpAwA3AwAgAiADKQMINwMI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ahAcCx0AIAAgARDFBSAAIAEoAhg2AhggACABLQAcOgAcCxQAIABBxABqIgAQ5AggACABELMDC5EBAQN/IAEoAgQhAiAAKAIAIQQgACgCBCEDA0AgAyAERkUEQCACQQhrIgIgA0EIayIDKQIANwIADAELCyABIAI2AgQgACgCACEDIAAgAjYCACABIAM2AgQgACgCBCECIAAgASgCCDYCBCABIAI2AgggACgCCCECIAAgASgCDDYCCCABIAI2AgwgASABKAIENgIACxsBAX8gACgCACECIAAgATYCACACBEAgAhALCwszACAAKAIUQYCAgIB4RgRAIAAQywUQGgALIAAgAC0AHkEBazoAHiAAEEwgABAxIAAQzAULDwAgACAAKAIEQShrEIEJCwkAIABBKBCtBAthAQJ/IwBBIGsiAiQAAkAgASAAKAIIIAAoAgAiA2tBKG1LBEAgAUHnzJkzTw0BIAAgAkEMaiABIAAoAgQgA2tBKG0gAEEIahDBASIAENwCIAAQ2wILIAJBIGokAA8LEAEACwsAIAAgARB3QQFzCyMAIAAgASkCADcCACAAIAEoAgg2AgggAEEMaiABQQxqECYaCwwAIAAgACgCABCBCQvxAQIBfwF9AkAgACABRg0AIAAQTCAAKAIABEAgABDQBSAAKAIAEAsgAEEANgIIIABCADcCAAsgACABKAIANgIAIAAgASgCBDYCBCAAIAEoAgg2AgggAUEANgIIIAFCADcCACABENAFIAEoAgwhAiABQQA2AgwgACACNgIMIAEoAhAhAiABQQA2AhAgACACNgIQIAEoAhQhAiABQQA2AhQgACACNgIUIAEtAB4hAiABQT46AB4gACACOgAeIAEqAhghAyABQc2Zs/oDNgIYIAAgAzgCGCABEDEgASgCDCIARQ0AIABBACABKAIQQQN0EB4aCwuQAwIGfwJ+IAEQPiEJIAEgACgCAGtBMG0hByAJIAAxAB6IpyEBIAAoAhAhAiAAKAIMIQMDQCAHIAMgAUEDdGooAgRHBEAgAUEBaiIBQQAgASACRxshAQwBCwsgAUEBaiIDQQAgAyAAIgIoAhBHGyEDIAIoAgwiBCABQQN0aigCBCEFA0AgBCADIgBBA3RqIgMoAgAiBkGABE8EQCAEIAFBA3RqIgEgAygCBDYCBCABIAZBgAJrNgIAIABBAWoi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BjoAICABQQA2AjwgAUIANwI0IAkgACABQTRqIgJBASABQQhqEK0BIAFBEGoQQyACEFwgABAKGgsgAUHwAGoQTSABQdABaiQACyAHQcABaiQAIAoLFgAgAC0AIARAIAAQ6wIgAEEAOgAgCwslAQF/IwBBEGsiAiQAIAIgATYCDCAAIAJBDGoQugMgAkEQaiQAC8cDAgV/AX4jAEEQayIHJAAgAhA+IginQf8BcUGAAnIhBiAIIAExAB6IpyEEA0ACQAJAIAEoAgwgBEEDdGoiAygCACIFIAZGBEAgAiABKAIAIAMoAgRBCHRqECJFDQIgASgCACEBIAMoAgQhAiAAQQA6AAQgACABIAJBCHRqNgIADAELIAUgBk8NASAHIAI2AgwjAEEQayICJAACQCABKAIEIAEoAghJBEAgASABKAIEIAcoAgwQ1ghBgAJqNgIEDAELIwBBIGsiBSQAIAVBDGogASABKAIEIAEoAgBrQQh1QQFqENUIIAEoAgQgASgCAGtBCHUgAUEIahDUCCIDKAIIIAcoAgwQ1ggaIAMgAygCCEGAAmo2AgggASADENMIIAMQ0gggBUEgaiQACyABKAIEGiABKAIEIAEoAgBrQQh1IgVBAWshAwJAIAEoAhQgBUkEQCABENgIDAELIAIgAzYCDCACIAY2AgggAiACKQIINwMAIAEgAiAEEDALIAEoAgAhASAAQQE6AAQgACABIANBCHRqNgIAIAJBEGokAAsgB0EQaiQADwsgBEEBaiIEQQAgBCABKAIQRxshBCAGQYACaiEGDAALAAsbACAAIAEQayIBIAAoAgRGBEAQGgALIAFBEGoLlAEBAn8jAEEwayICJAAgAC0AMEUEQCAAQSRqEJEJIABBNGoQkQkgAEHEAGoiASIAEP0IIABBAToADCAAQQA2AgggAEIANwIAIAJBDGoiAEEAQSQQHhogAkEYakIAEJAJAkAgASgCBCABKAIISQRAIAEgABD8CAwBCyABIAAQ+wgLIAEoAgQaIAAQxQEaCyACQTBqJAAL5AEBA38gACgCBCECIAAoAgAhBCABKAIEIQMDQCACIARHBEAgA0GAAWsiAyACQYABayICKQMANwMAIAMgAigCCDYCCCACQQA2AgggAkIANwMAIAMgAikDEDcDECADIAIoAiA2AiAgAyACKQMYNwMYIAJBADYCICACQgA3AxggA0EoaiACQShqEN8CGgwBCwsgASADNgIEIAAoAgAhBCAAIAM2AgAgASAENgIEIAAoAgQhBCAAIAEoAgg2AgQgASAENgIIIAAoAgghBCAAIAEoAgw2AgggASAENgIMIAEgASgCBDYCAAsbACAAIAFByaSSCUHwAEGSyaQSQZPJpBIQkwELIwAgAEEAOgDAASAAQQA6AAAgAS0AwAEEQCAAIAEQ4AILIAALUAAgACgCAARAIAAQswkgACgCABALIABBADYCCCAAQgA3AgALIAAgASgCADYCACAAIAEoAgQ2AgQgACABKAIINgIIIAFBADYCCCABQgA3AgALCQAgAEEYEMkDC7IBAQN/IAAoAgQhAiAAKAIAIQQgASgCBCEDA0AgAiAERwRAIANBGGsiAyACQRhrIgIpAwA3AwAgAyACKAIINgIIIAJCADcDACACQQA2AgggAyACKQMQNwMQDAELCyABIAM2AgQgACgCACECIAAgAzYCACABIAI2AgQgACgCBCECIAAgASgCCDYCBCABIAI2AgggACgCCCECIAAgASgCDDYCCCABIAI2AgwgASABKAIENgIACxEAIAAgARAQIgBCADcDECAAC98CAQJ/IwBBEGsiBSQAIAAgASACIAMQ4gUhBgJAIAQgAxAbRQ0AIAUgAygCCDYCCCAFIAMpAgA3AwAgAyAEKAIINgIIIAMgBCkCADcCACAEIAUoAgg2AgggBCAFKQMANwIAIAMgAhAbRQRAIAZBAWohBgwBCyAFIAIoAgg2AgggBSACKQIANwMAIAIgAygCCDYCCCACIAMpAgA3AgAgAyAFKAIINgIIIAMgBSkDADcCACACIAEQG0UEQCAGQQJqIQYMAQsgBSABKAIINgIIIAUgASkCADcDACABIAIoAgg2AgggASACKQIANwIAIAIgBSgCCDYCCCACIAUpAwA3AgAgASAAEBtFBEAgBkEDaiEGDAELIAUgACgCCDYCCCAFIAApAgA3AwAgACABKAIINgIIIAAgASkCADcCACABIAUoAgg2AgggASAFKQMANwIAIAZBBGohBgsgBUEQaiQAIAYLjgIBAn8jAEEQayIEJAAgACABIAIQ4wIhBQJAIAMgAhAbRQ0AIAQgAigCCDYCCCAEIAIpAgA3AwAgAiADKAIINgIIIAIgAykCADcCACADIAQoAgg2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AhAMAAsACwsLCyAEQSBqJAALDQAgACgCACABKAIASQvSAwICfgJ/IwBBIGsiBCQAAkAgAUL///////////8AgyIDQoCAgICAgMCAPH0gA0KAgICAgIDA/8MAfVQEQCABQgSGIABCPIiEIQMgAEL//////////w+DIgBCgYCAgICAgIAIWgRAIANCgYCAgICAgIDAAHwhAgwCCyADQoCAgICAgICAQH0hAiAAQoCAgICAgICACFINASACIANCAYN8IQIMAQsgAFAgA0KAgICAgIDA//8AVCADQoCAgICAgMD//wBRG0UEQCABQgSGIABCPIiEQv////////8Dg0KAgICAgICA/P8AhCECDAELQoCAgICAgID4/wAhAiADQv///////7//wwBWDQBCACECIANCMIinIgVBkfcASQ0AIARBEGogACABQv///////z+DQoCAgICAgMAAhCICIAVBgfcAaxBjIAQgACACQYH4ACAFaxC9AiAEKQMIQgSGIAQpAwAiAEI8iIQhAiAEKQMQIAQpAxiEQgBSrSAAQv//////////D4OEIgBCgYCAgICAgIAIWgRAIAJCAXwhAgwBCyAAQoCAgICAgICACFINACACQgGDIAJ8IQILIARBIGokACACIAFCgICAgICAgICAf4OEvwtEAQF/IwBBEGsiBSQAIAUgASACIAMgBEKAgICAgICAgIB/hRB8IAUpAwAhASAAIAUpAwg3AwggACABNwMAIAVBEGokAAuJAgACQCAABH8gAUH/AE0NAQJAQYzEAigCACgCAEUEQCABQYB/cUGAvwNGDQMMAQsgAUH/D00EQCAAIAFBP3FBgAFyOgABIAAgAUEGdkHAAXI6AABBAg8LIAFBgEBxQYDAA0cgAUGAsANPcUUEQCAAIAFBP3FBgAFyOgACIAAgAUEMdkHgAXI6AAAgACABQQZ2QT9xQYABcjoAAUEDDwsgAUGAgARrQf//P00EQCAAIAFBP3FBgAFyOgADIAAgAUESdkHwAXI6AAAgACABQQZ2QT9xQYABcjoAAiAAIAFBDHZBP3FBgAFyOgABQQQPCwtB8MICQRk2AgBBfwVBAQsPCyAAIAE6AABBAQuRAQEDfyABKAIEIQIgACgCACEEIAAoAgQhAwNAIAMgBEZFBEAgAkEEayICIANBBGsiAygCADYCAAwBCwsgASAC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CyABIAI2AgQgACgCACEDIAAgAjYCACABIAM2AgQgACgCBCECIAAgASgCCDYCBCABIAI2AgggACgCCCECIAAgASgCDDYCCCABIAI2AgwgASABKAIENgIACw4AIAAoAgQgAiABEG0aCysBAX8gACgCBCICBH8gAgUgAEEoEBciAjYCBCACENoEIAAoAgQLIAE3AxALQAEBfyAAKAIERQRAIABBKBAXIgI2AgQgAhDaBAsgAEEIaiICIAEQHCAAKAIEIAAoAgggAiAALAATQQBIGzYCGAvFAQEEfyAAKAIAIQECQCAALQAcBEACQCABBEAgASgCAEGYkgFHDQEgAUEAEOwBCwwCC0GcIkHlyABB4QBBx8UAEAAACyABEAsLIABBEGoQDxoCQCAAQQRqIgIoAghFDQAgAigCBCIAKAIAIgEgAigCACIDKAIENgIEIAMoAgQgATYCACACQQA2AggDQCAAIAJGDQEgACgCBCEEIABBCGoiA0HQAGoQChogA0HEAGoQChogA0E4ahAKGiAAEAsgBCEADAALAAsLOQEBfyAAQcQAaiICIAEQHCAAIAAoAkQgAiAALQBPIgHAQQBIIgIbNgIcIAAgACgCSCABIAIbNgIYC/IBAQZ/IwBBEGsiAyQAIAAoAgBFBEAgAEEUEBciATYCACABEKULCyMAQRBrIgEkAEHoABAXIgJBADYCACABIABBBGoiBEEIajYCCCABQQE2AgwgAkEIaiIFQThqQQBBJBAeGiAFEKYLIAIgBDYCBCACIAAoAgQiBDYCACAEIAI2AgQgACACNgIEIAAgACgCDEEBajYCDCABQQA2AgQgAUEEahB/IAFBEGokACADIAAoAgRBCGo2AgwgAEEQaiADQQxqEHYgACgCACIBIAAoAhA2AhAgASABKAIMQQFqNgIMIAAoAgQhBiADQRBqJAAgBkEIagsVACAAIAEoAgAiACgCHCAAKAIYEEELlQIBCX8jAEGgAWsiAyQAAkAgAEGoAmoiByABEIIBIgYgAEGsAmpGBEBBAhAVRQ0BIANBGGoQEyEKIANBAjYCFCAKQfnSABANIAEQERogA0EUahAUDAELIANBFGoiBSAAQawEaiABEN0CIANBCGogARAQIgghAiMAQTBrIgQkACAEIAIoAgg2AiggBCACKQIANwMgIAJCADcCACACQQA2AgggAEEQ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C1gBAX8jAEEQayIDJAAgAyACNgIIIAMgATYCDCAAIAMoAgwiASkCADcCACAAIAEoAgg2AgggAUIANwIAIAFBADYCCCAAQRBqIAMoAggQOBogA0EQaiQAIAALLQEBfyAAKAIoIQEgACgCJCEAA0AgACABRwRAIABBAToAICAAQShqIQAMAQsLCz4BAn8gACgCBCECA0AgAiAAKAIIIgFHBEAgACABQYABayIBNgIIIAEQhQEaDAELCyAAKAIAIgAEQCAAEAsLC48BAQN/IAAoAgQhAyAAKAIAIQQgASgCBCECA0AgAyAERwRAIAJBgAFrIANBgAFrIgMQkgEhAgwBCwsgASACNgIEIAAoAgAhAyAAIAI2AgAgASADNgIEIAAoAgQhAiAAIAEoAgg2AgQgASACNgIIIAAoAgghAiAAIAEoAgw2AgggASACNgIMIAEgASgCBDYCAAsRACAALQCAAQRAIAAQhQEaCwuMAQECfyAAKAIEIAAoAghJBEAgACAAKAIEIAEQkgFBgAFqNgIEDwsjAEEgayIDJAAgA0EMaiAAIAAoAgQgACgCAGtBB3VBAWoQ2QIgACgCBCAAKAIAa0EHdSAAQQhqEOABIgIoAgggARCSARogAiACKAIIQYABajYCCCAAIAIQiQcgAhCIByADQSBqJAALEgAgACABKAIAIAEoAgQQQSAAC2EBAn8jAEEgayICJAACQCABIAAoAgggACgCACIDa0EHdUsEQCABQYCAgBBPDQEgACACQQxqIAEgACgCBCADa0EHdSAAQQhqEOABIgAQiQcgABCIBwsgAkEgaiQADwsQAQALmQMCB38CfiMAQcABayICJAACQCABKAIEIgRBCE0EQCAAQQA6ADggAEEAOgAADAELIAEoAgAiAygAAEGF36maeEcEQEEDEBUEQCACQThqEBMhByACQQM2AjQgB0GeMBANGiACQTRqEBQLIABBADoAOCAAQQA6AAAMAQsgAiADKAAEIgU2AjAgAy0ACCEGIAEgBEEJazYCBCABIANBCWo2AgAgAkEgaiABEBkgAi0AKEUEQCAAQQA6ADggAEEAOgAADAELIAIpAyAiCSABNQIEIgpWBEAgAEEAOgA4IABBADoAAAwBCyACIANBCGogCSAErSAKfSIKfEIIfRC/AyAAAn8gAigCMCACKAAARwRAQQMQFQRAIAJBOGoQEyEIIAJBAzYCNCAIQbowEA0aIAJBNGoQFAsgAEEAOgAAQQAMAQsgAikDICEJIAAgAikAADcAGCAAIAIpABg3ADAgACACKQAQNwAoIAAgAikACDcAICAAIAo3AxAgACAJNwMIIAAgBjoABCAAIAU2AgBBAQs6ADgLIAJBwAFqJAALWQEBfyMAQRBrIgMkACADIAI2AgggAyABNgIMIAAgAygCDCIBKQIANwIAIAAgASgCCDYCCCABQgA3AgAgAUEANgIIIABBEGogAygCCBCVAxogA0EQaiQAIAALWQEBfyMAQRBrIgMkACADIAI2AgggAyABNgIMIAAgAygCDCIBKQIANwIAIAAgASgCCDYCCCABQgA3AgAgAUEANgIIIABBEGogAygCCBCDBRogA0EQaiQAIAALOwAgACgCFEGAgICAeEYEQCAAIAAoAgRBMGsQkgcQGgALIAAgAC0AHkEBazoAHiAAEEwgABAxIAAQvAgLKgEBfyAAKAIEIQIDQCABIAJGRQRAIAJBMGsQkwchAgwBCwsgACABNgIECw4AIABBEGoQvQEgABAKCxcAIAIoAgAhACACQQA2AgAgASAANgIACz0BAn8gACgCBCECA0AgAiAAKAIIIgFHBEAgACABQTBrIgE2AgggARCTBxoMAQsLIAAoAgAiAARAIAAQCwsLtgEBA38gACgCBCECIAAoAgAhAyABKAIEIQQDQCACIANHBEAgBEEwayIEIAJBMGsiAikDADcDACAEIAIoAgg2AgggAkIANwMAIAJBADYCCCAEQRBqIAJBEGoQlQMaDAELCyABIAQ2AgQgACgCACEDIAAgBDYCACABIAM2AgQgACgCBCEDIAAgASgCCDYCBCABIAM2AgggACgCCCEDIAAgASgCDDYCCCABIAM2AgwgASABKAIENgIACxcAIAAgARAQIgBBGGogAkEIahCSAiAACw0AIABBGGoQfSAAEAoLWAEBfgJ/IAEtADAEQCAAIAApAwAgACkDCH03AxggARCKASECIAAgATYCICAAIAIgACkDCHwiAjcDCEECIAIgACkDAFYNARoLIAAgACkDEEIBfDcDEEEACwviAQIFfwJ+AkAgACgCACICIAAoAgQiA0cEQANAIAcgAyACa0HIAG2tIghUIQMgByAIWg0CAkACQCABIAIgB6ciBEHIAGwiBWoQ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BCADQRBqIgwQxwEgDBA3IAcQChoMAQsgA0EANgIYIANBADYCSCADQgA3AxAgA0EEOgAgIANCADcDQCAEIANBEGoiBRDHASAFEDcgA0FAaxAKGiAqpyEFCyADIAMoAlggBWo2AlggAyADKAJcIAVrNgJcDAQLIAMoAlwhBSADQUBrIANB2ABqELIBAkAgAy0ASARAICogBSADKAJca61RDQELIAlBADoADCAJQQA6AAAMGQsgA0EFOgAgIAMgAykDQCIqNwMYIAMgKjcDECAEIANBEGoiBRDHASAFEDcMAwsgKkIBUgRAIAlBADoADCAJQQA6AAAMGAsgAygCXCIFBEAgAygCWCIHLQAAIQwgAyAFQQFrNgJcIAMgB0EBajYCWCADQQc6ACAgAyAMOgAQIAQgA0EQaiIFEMcBIAUQNwwDCyAJQQA6AAwgCUEAOgAADBcLIAlBADoADCAJQQA6AAAMFgsgA0EGOgAgIAQgA0EQaiIFEMcBIAUQNwsgAkEIaiECDAELCyAGKAKEASAGKAKAAWtBA3UhAiMAQSBrIgUkACACIAZBsAFqIgQoAgggBCgCACIIa0EYbUsEQCACQavVqtUATw0XIAQgBUEMaiACIAQoAgQgCGtBGG0gBEEIahDGASICELsJIAIQugkLIAVBIGokACAGKAKEASEMIAYoAoABIQJCACEqAkADQCACIAxGDQEgAikDACErIANBADoAICADQQA6ABACQCArUEUEQCAqIAYoApwBIAYoApgBIgVrQQN1rVoNASAqIAYoApABIAYoAowBIghrQQN1rVoNASAFICqnQQN0IgdqKQMAISsgByAIaikDACEsIANBAToAICADICw3AxggAyArNwMQICpCAXwhKgsCQCAEKAIEIgUgBCgCCEcEQCAFIAMpAxA3AwAgBSADKQMgNwMQIAUgAykDGDcDCCAEIAVBGGo2AgQMAQsjAEEgayIHJAAgB0EMaiAEIAQoAgQgBCgCAGtBGG1BAWoQ5QEgBCgCBCAEKAIAa0EYbSAEQQhqEMYBIgUoAggiCCADKQMQNwMAIAggAykDIDcDECAIIAMpAxg3AwggBSAIQRhqNgIIIAQgBRC7CSAFELoJIAdBIGokAAsgAkEIaiECDAELCyAJQQA6AAwgCUEAOgAADBMLQgAhKiMAQZACayICJAACQAJAAkAgBigC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ADoAAAwOCyADIAMpA0g3AwAgIyADEFcgAykDKCEqIAMoAhQhAgwACwALIANBADoAMEIAISogA0IANwMoIANBADoAICADQQA6ABggAyAErSArQiCGhDcDECArpyECA0AgAkUgKlBxDQsgA0FAayADQRBqEKgCAkAgAy0AQARAIAMtAFANAQsgCUEAOgAMIAlBADoAAAwNCyAiIBMQgAIgAykDKCEqIAMoAhQhAgwACwALIANBADoAMEIAISogA0IANwMoIANBADoAICADQQA6ABggAyAErSArQiCGhDcDECArpyECA0AgAkUgKlBxDQogA0FAayADQRBqEKgCAkAgAy0AQARAIAMtAFANAQsgCUEAOgAMIAlBADoAAAwMCyAhIBMQgAIgAykDKCEqIAMoAhQhAgwACwALIAMgAjYCXCADIAQ2AlgMCAsgA0EAOgAwQgAhKiADQgA3AyggA0EAOgAgIANBADoAGCADIAStICtCIIaENwMQICunIQIDQCACRSAqUHENCCADQUBrIANBEGoQqAICQCADLQBABEAgAy0AUA0BCyAJQQA6AAwgCUEAOgAADAoLICAgExCAAiADKQMoISogAygCFCECDAALAAsgA0EAOgAwQgAhKiADQgA3AyggA0EAOgAgIANBADoAGCADIAStICtCIIaENwMQICunIQIDQCACRSAqUHENByADQUBrIANBEGoQqAICQCADLQBABEAgAy0AUA0BCyAJQQA6AAwgCUEAOgAADAkLIB8gExCAAiADKQMoISogAygCFCECDAALAAtCACEqIANCADcDICADQQE6ABggAyAErSArQiCGhDcDECArpyECA0AgAkUgKlBxDQYgA0FAayEFIwBBEGsiBCQAIANBEGoiAikDECEsAkADQCAsUARAIAQgAhAZIAQtAAgEQCACIAQpAwAiLDcDECACIAItAAhBAXM6AAgMAgUgBUEAOwAADAMLAAsLIAIgLEIBfTcDECAFQQE6AAAgBSACLQAIOgABCyAEQRBqJAAgAy0AQARAIAYoAlQiAiAGKAJYQQV0RgRAAn8gAkEBaiICQQBOBEAgBigCWCIEQQV0Qf7///8DTQR/IARBBnQiBCACQR9qQWBxIgIgAiAESRsFQf////8HCwwBCwwOCyECIwBBIGsiDiQAIAIgBigCWEEFdEsEQCACQQBIIgQN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dGoiBSEIA0AgBCAIRwRAIAEgCCkDADcDACABIAgpAwg3AwggAUEQaiEBIAhBEGohCAwBCwsgAyABNgIEIAxBAEwNAgsgAygCBCIEIQEgAiAEIAIgB0EEdGpraiIIIQcDQCAHIAlPBEAgAyABNgIEIwBBEGsiAyQAIAQhASAIIQQDQCACIARHBEAgAUEQayIBIARBEGsiBCkDADcDACABIAQpAwg3AwgMAQsLIAMgATYCDCADIAg2AgggAygCDBogA0EQaiQABSABIAcpAwA3AwAgASAHKQMINwMIIAFBEGohASAHQRBqIQcMAQsLIwBBEGsiASQAA0AgBSAGRwRAIAIgBikDADcDACACIAYpAwg3AwggAkEQaiECIAZBEGohBgwBCwsgASACNgIMIAEgBTYCCCABKAIMGiABQRBqJAAMAQsgC0EMaiADIAkgAygCAGtBBHUgB2oQkwMgAiADKAIAa0EEdSADQQhqEMYCIgEoAggiBSAEIAZraiEEA0AgBCAFRwRAIAUgBikDADcDACAFIAYpAwg3AwggBkEQaiEGIAVBEGohBQwBCwsgASAENgIIIAMiBCgCACEJIAEoAgQhBSACIQMDQCADIAlHBEAgBUEQayIFIANBEGsiAykDADcDACAFIAMpAwg3AwgMAQsLIAEgBTYCBCABKAIIIQMgBCgCBCEFA0AgAiAFRwRAIAMgAikDADcDACADIAIpAwg3AwggA0EQaiEDIAJBEGohAgwBCwsgASADNgIIIAQoAgAhAiAEIAEoAgQ2AgAgASACNgIEIAQoAgQhAiAEIAEoAgg2AgQgASACNgIIIAQoAgghAiAEIAEoAgw2AgggASACNgIMIAEgASgCBDYCACABEI0DCyALQSBqJAAgACgCWCECIABBADYCWCAKIAI2AgQgACgCXCECIABBADYCXCAKIAI2AgggACgCYCECIABBADYCYCAKIAI2AgwgCkEEahAPGiAKQRBqJAALMwEBfyABQavVqtUATwRAEAEACyAAIAEQrAkiAjYCBCAAIAI2AgAgACACIAFBGGxqNgIIC0YBAn8gAEEANgIIIABCADcCACABKAIEIgIgASgCACIDRwRAIAAgAiADa0EYbSICEOoHIAAgASgCACABKAIEIAIQnQULIAAL9AICBn8BfiAAKAIAIgQgACgCBEcEfwJAIAEQPiII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ACAAQaWSySRPBEAQGgALIABBOGwQFws9AQJ/IAAoAgQhAgNAIAIgACgCCCIBRwRAIAAgAUE4azYCCCABQRhrEAoaDAELCyAAKAIAIgAEQCAAEAsLCxAAIAAgACgCBEHwAGsQwAQL2gEBA38gACgCBCECIAAoAgAhBCABKAIEIQMDQCACIARHBEAgA0E4ayIDIAJBOGsiAikDADcDACADIAIpAxg3AxggAyACKQMQNwMQIAMgAikDCDcDCCADIAIoAig2AiggAyACKQMgNwMgIAJBADYCKCACQgA3AyAgAyACKQMwNwMwDAELCyABIAM2AgQgACgCACECIAAgAzYCACABIAI2AgQgACgCBCECIAAgASgCCDYCBCABIAI2AgggACgCCCECIAAgASgCDDYCCCABIAI2AgwgASABKAIENgIACwkAIABBKBDJAwvKAQEDfyABKAIEIQMgACgCACEEIAAoAgQhAgNAIAIgBEZFBEAgA0EoayIDIAJBKGsiAikDADcDACADIAJBCGooAgA2AgggAkIANwMAIAJBADYCCCADIAIpAyA3AyAgAyACKQMYNwMYIAMgAikDEDcDEAwBCwsgASADNgIEIAAoAgAhAiAAIAM2AgAgASACNgIEIAAoAgQhAiAAIAEoAgg2AgQgASACNgIIIAAoAgghAiAAIAEoAgw2AgggASACNgIMIAEgASgCBDYCAAs+AQJ/IAAoAgQhAgNAIAIgACgCCCIBRwRAIAAgAUGAAWsiATYCCCABEKAIGgwBCwsgACgCACIABEAgABALCwu3AQEDfyAAKAIEIQIgACgCACEDIAEoAgQhBANAIAIgA0cEQCAEQYABayIEIAJBgAFrIgIpAwA3AwAgBCACKAIINgIIIAJCADcDACACQQA2AgggBEEQaiACQRBqEDgaDAELCyABIAQ2AgQgACgCACEDIAAgBDYCACABIAM2AgQgACgCBCEDIAAgASgCCDYCBCABIAM2AgggACgCCCEDIAAgASgCDDYCCCABIAM2AgwgASABKAIENgIAC0EAIAAgASkDCBDSAiABLQBIQQFGBEAgACABQUBrKQMAENICCwJAIAEtAGhFDQAgASkDWFANACAAIAEpA2AQ0gILC5MBACMAQRBrIgAkACACKAIAIQIgACADKAIINgIIIAAgAykCADcDACAAIAI2AgwjAEEwayICJAAgASAAKAIMIgMpAwA3AwAgASADKQMINwMIIAAoAgAoAgAhAyACQQA6ACggAkEAOgAIIAFBEGogAyACQQhqIgEgACgCCCgCABCrBSABEJAEIAJBMGokACAAQRBqJAALEAAgACAAKAIEQdgBaxCrCAsLACAAIAFBKBCqBAvxAQIBfwF9AkAgACABRg0AIAAQTCAAKAIABEAgABCuBSAAKAIAEAsgAEEANgIIIABCADcCAAsgACABKAIANgIAIAAgASgCBDYCBCAAIAEoAgg2AgggAUEANgIIIAFCADcCACABEK4FIAEoAgwhAiABQQA2AgwgACACNgIMIAEoAhAhAiABQQA2AhAgACACNgIQIAEoAhQhAiABQQA2AhQgACACNgIUIAEtAB4hAiABQT46AB4gACACOgAeIAEqAhghAyABQc2Zs/oDNgIYIAAgAzgCGCABEDEgASgCDCIARQ0AIABBACABKAIQQQN0EB4aCwsOACAAQRBqEC8aIAAQCgsrAQF/IAAoAgQhAgNAIAEgAkZFBEAgAkGAAWsQoAghAgwBCwsgACABNgIEC/EBAgF/AX0CQCAAIAFGDQAgABBMIAAoAgAEQCAAEK8FIAAoAgAQCyAAQQA2AgggAEIANwIACyAAIAEoAgA2AgAgACABKAIENgIEIAAgASgCCDYCCCABQQA2AgggAUIANwIAIAEQrwUgASgCDCECIAFBADYCDCAAIAI2AgwgASgCECECIAFBADYCECAAIAI2AhAgASgCFCECIAFBADYCFCAAIAI2AhQgAS0AHiECIAFBPjoAHiAAIAI6AB4gASoCGCEDIAFBzZmz+gM2AhggACADOAIYIAEQMSABKAIMIgBFDQAgAEEAIAEoAhBBA3QQHhoLC3ABAn8gACABKAIANgIAIABBCGoiAkEAOgBIIAJBADoAACABQQhqIgMtAEgEQCACIAMQtwYLIABB2ABqIAFB2ABqECYaIABB5ABqIAFB5ABqECYaIABB8ABqIAFB8ABqEJcEIAAgASkDkAE3A5ABIAALqwEBAn8gACABKAIANgIAIwBBEGsiAyQAIABBBGoiAkIANwIAIAJBPjoAHiACQc2Zs/oDNgIYIAJCADcCECACQgA3AgggAiABQQRqEKIIIANBEGokACMAQRBrIgMkACAAQSRqIgJCADcCACACQT46AB4g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AkAgASgCFCAESQRAIAEoAhRBgICAgHhGBEAgARDmCBAaAAsgASABLQAeQQFrOgAeIAEQTCABEDEgARC8CAwBCyACIAM2AgwgAiAINgIIIAIgAikCCDcDACABIAIgBxAwCyABKAIAIQEgAEEBOgAEIAAgASADQTBsajYCACACQRBqJAALIAZBEGokAA8LIAdBAWoiB0EAIAcgASgCEEcbIQcgCEGAAmohCAwACwALFAAgACABEBAiACACKQMANwMQIAALrwIBBn8jAEGgAWsiAiQAIABBqAJqIgYgARCCASIEIABBrAJqRwRAIABB0AJqIQUgACgC4AIEQCACQZQBaiABEBAhAyACQQA6AIABIAJBBjoAeCACQQA2ApABIAJCADcCiAEgBSADIAJBiAFqIgdBBSACQeAAahCtASACQegAahBDIAcQXCADEAoaCyACQUBrIgMgAEGsBGogARDdAiAAIARBIGogAxCqAyAGIAQQqQMaIAAtALQCRQRAIAAgARC/CAsgACABIAJBQGsQqQUgACgC4AIEQCACQTRqIAEQECEAIAJBADoAICACQQY6ABggAkEANgIwIAJCADcCKCAFIAAgAkEoaiIBQQIgAhCtASACQQhqEEMgARBcIAAQChoLIAJBQGsQTQsgAkGgAWokAAtmAgJ+A38gARA+IQMgASAAKAIAa0EobSEEIAMgADEAHoinIQEgACgCECEFIAAoAgwhBgNAIAQgBiABQQN0aigCBEcEQCABQQFqIgFBACABIAVHGyEBDAELCyAAIAEQvQggACgCABoLIwAgACABIAIgAxC2BSAALQAERQRAIAAoAgBBEGogAxDFBQsL8AQCBn8BfiMAQYABayIFJAACQCAAQagBaiIHIAEQkQEiBiAAKAKsAUcEQCAGQRBqIgMgAhDYAgRAIARFDQIgAiADENcCRQ0CIAVB2ABqIARBkAFqIAEgAxCuAQwCCyAFIAMpAwAiCzcDeCAAKQOAAiALVARAIABByAFqIAVB+ABqEPgBIAEQqwMLIABB1AFqIgQgBigCKEEIahCVBCAAIAApA+ABQgF8Igs3A+ABIAAoAtgBIAs3AxggBCAGKAIoELgDIAAoAtgBIQQgBSACKQMANwNYIAUgAigCEDYCaCAFIAIpAwg3A2AgAkEANgIQIAJCADcDCCAFQQA6AHQgBSAENgJwIAMgBUHYAGoiAhDGBSAFQeAAahAKGiAGKQMQIAApA4ACWA0BIAAgAEHEAGogASADENYCIAIgAEHIAWogAxD4ASABEP4BDAELAkACQCAAQYgBaiIIIAEQayIGIAAoAowBRiIJRQRAIAZBEGoiCiACENgCRQ0BIARFDQMgAiAKENcCRQ0DIAVB2ABqIARB8ABqIAYQwwEMAwsgAikDACAAKQOAAlgNAgwBCyAAIAAgARCzAyAIIAYQygggAikDACAAKQOAAlYNACADIAEQyQgMAQsgACAAKQPgAUIBfDcD4AEgAEHUAWogBUHYAGoiBCABIABB4AFqEMgIIgYQlQQgBhAKGiAFIAAoAtgBNgJ4IAVBADoALyAEIAcgASACIAVB+ABqIgIgBUEvahDHCCAAIABBxABqIAUoAlgiASABQRBqIgQQ1gIgAiAAQcgBaiAEEPgBIAEQ/gEgCQ0AIAMgARDJCAsgBUGAAWokAAspACAAIAEQECIAIAIpAwA3AxAgAEEYaiADEBAaIABBKGogBBDfAhogAAumAQICfwF+AkAgACgCACICIAAoAgQiA0cEQANAIAQgAyACa0HIAG2tWg0CIAIgBKciA0HIAGxqIAEQzgggACgCECAAKAIMIgJrQfAAba0gBFYEQCABIAIgA0HwAGxqEL8BCyAEQgF8IQQgACgCACECIAAoAgQhAwwACwALIAAoAhAhAiAAKAIMIQADQCAAIAJGDQEgASAAEL8BIABB8ABqIQAMAAsACwsrAQF/IAAoAgQhAgNAIAEgAkZFBEAgAkGAAmsQ0AghAgwBCwsgACABNgIECw4AIABBEGoQrQMgABAKC8oCAQF/IAAgARAmIgBBDGogAUEMahAmGiAAQRhqIAFBGGoQJhogAEEkaiABQSRqEO4CIABBNGogAUE0ahDuAiAAQcQAaiABQcQAahDuAiAAQdQAaiABQdQAahDuAiAAIAEoAnQ2AnQgACABKQJsNwJsIAAgASkCZDcCZCAAQfgAaiABQfgAahAmGiAAQYQBaiABQYQBahAmGiAAQZABaiICIAEoApABNgIAIAIgASgClAE2AgQgAiABKAKYATYCCCACIAEoApwBNgIMIAFCADcCmAEgAUIANwKQASACIAEoAqABNgIQIAIgASgCpAE2AhQgAUIANwKgASAAQagBaiABQagBahCXBCAAQcgBaiABQcgBahAmGiAAIAEpA9gBNwPYASAAIAEoAugBNgLoASAAIAEpA+ABNwPgASABQQA2AugBIAFCADcD4AELPgECfyAAKAIEIQIDQCACIAAoAggiAUcEQCAAIAFBgAJrIgE2AgggARDQCBoMAQsLIAAoAgAiAARAIAAQCwsLtwEBA38gACgCBCECIAAoAgAhAyABKAIEIQQDQCACIANHBEAgBEGAAmsiBCACQYACayICKQMANwMAIAQgAigCCDYCCCACQgA3AwAgAkEANgIIIARBEGogAkEQahDRCAwBCwsgASAENgIEIAAoAgAhAyAAIAQ2AgAgASADNgIEIAAoAgQhAyAAIAEoAgg2AgQgASADNgIIIAAoAgghAyAAIAEoAgw2AgggASADNgIMIAEgASgCBDYCAAsUACAAIAEgAiADQQhBgICACBDWCQsbACAAIAFBgP7//wdBB0H///8HQYCAgAgQ7wILNgEBfyMAQRBrIgIkACACIAE2AgwgACACKAIMEBAiAEEQakEAQfABEB4QvgUaIAJBEGokACAACxAAIAAgACgCBEGAAmsQzwgLMwAgACgCFEGAgICAeEYEQCAAENcIEBoACyAAIAAtAB5BAWs6AB4gABBMIAAQMSAAEKYMC10AIAAgASkCADcCACAAIAEoAgg2AgggAUIANwIAIAFBADYCCCAAIAIpAwA3AxAgACADKAIINgIgIAAgAykCADcCGCADQgA3AgAgA0EANgIIIABBKGogBBDfAhogAAsWACAAQShqELwDIABBGGoQChogABAKCzEBAX8DQCABBEAgAiABIAFBEGogABAbIgMbIQIgAUEEaiABIAMbKAIAIQEMAQsLIAILUAAgACgCAARAIAAQ4AggACgCABALIABBADYCCCAAQgA3AgALIAAgASgCADYCACAAIAEoAgQ2AgQgACABKAIINgIIIAFBADYCCCABQgA3AgALUAAgACgCAARAIAAQ3wggACgCABALIABBADYCCCAAQgA3AgALIAAgASgCADYCACAAIAEoAgQ2AgQgACABKAIINgIIIAFBADYCCCABQgA3AgALDgAgACABELADQQE6AEALDAAgACAAKAIAEMEFCwwAIAAgACgCABDDBQs3AQF/IwBBEGsiASQAIAEgADYCDCABKAIMIgAoAgAEQCAAEN8IIAEoAgwo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KAIMEBAiAEEQaiADKAIIEPkBGiADQRBqJAAgAAsYACAAIAEQECIAQRBqIAFBEGoQ+QEaIAALaQECfyMAQSBrIgMkACADQQxqIAAgACgCBCAAKAIAa0EobUEBahD6ASAAKAIEIAAoAgBrQShtIABBCGoQwQEiAigCCCABEO8IGiACIAIoAghBKGo2AgggACACENwCIAIQ2wIgA0EgaiQACxQAIAAgACgCBCABEO8IQShqNgIEC2EBAX8gAEGAgICAeCABIAFBAEgbIgEQzQUgACABIAAoAgQgACgCAGtBKG0iAiABIAJLGxDMDSEBAkAgACgCEARAIAEgAC0AHk8NAQsgACABOgAeIAAQTCAAEDEgABDMBQsLHAAgACABEJEBIgEgACgCBEYEQBAaAAsgAUEQagsWACAAQShqEN8BIABBGGoQChogABAKCxcAIABByOPxOE8EQBAaAAsgAEEkbBAXCz0BAn8gACgCBCECA0AgAiAAKAIIIgFHBEAgACABQSRrIgE2AgggARDFARoMAQsLIAAoAgAiAARAIAAQCwsLjQEBA38gACgCBCEDIAAoAgAhBCABKAIEIQIDQCADIARHBEAgAkEkayADQSRrIgMQtQMhAgwBCwsgASACNgIEIAAoAgAhAyAAIAI2AgAgASADNgIEIAAoAgQhAiAAIAEoAgg2AgQgASACNgIIIAAoAgghAiAAIAEoAgw2AgggASACNgIMIAEgASgCBDYCAAtKAQF/IABBADYCDCAAIAM2AhAgAQRAIAEQ9QghBAsgACAENgIAIAAgBCACQSRsaiICNgIIIAAgBCABQSRsajYCDCAAIAI2AgQgAAs5AQF/IAFBAEgEQBABAAtB/////wcgACgCCCAAKAIAayIAQQF0IgIgASABIAJJGyAAQf////8DTxsLMAECfyAAKAIAIQIgACgCBCEBA0AgASACRwRAIAFBJGsQxQEhAQwBCwsgACACNgIEC50BAQR/IwBBIGsiAyQAIAAoAgQgACgCAGtBJG1BAWoiAkHI4/E4TwRAEAEACyADQQxqQcfj8TggACgCCCAAKAIAa0EkbSIEQQF0IgUgAiACIAVJGyAEQePxuBxPGyAAKAIEIAAoAgBrQSRtIABBCGoQ+AgiAigCCCABELUDGiACIAIoAghBJGo2AgggACACEPcIIAIQ9gggA0EgaiQA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ApABIAMoAsgCQThsaiEBA0AgAygClAEgAUYEQCADKAKQASEEIAMgAigCHDYCkAEgAiAENgIcIAMgAigCIDYClAEgAiABNgIgIAMoApgBIQEgAyACKAIkNgKYASACIAE2AiQgA0GcAWohBCAHKAIEIQUgBygCACEBA0AgASAFRgRAIANBgANqIQogAygChAMhBSADKAKAAyEBA0AgASAFRgRAIAsgAygCzAEgAygCyAFrQQxtrSAafSIZpyIBEKkHIAggARDCByADKAKgASELIAMoApwBIQEDQCABIAtGBEAgAxCECCACQRBqIgEgAyAJQQAQkwIgA0GgA2oiBSABEKgHKAIAEKcHIAogCRDoA0IAIRggA0IANwPIAiACQQA2AhggAkIANwIQIANBrANqIQEDQCACIBg3AwggAygClAEgAygCkAEiCWtBOG2tIBhYBEAgAygC9AIhASADIAIoAhAiBDYC9AIgAiABNgIQIAMoAvgCIQEgAyACKAIUIgk2AvgCIAIgATYCFCADKAL8AiEBIAMgAigCGDYC/AIgAiABNgIYIANB6AJqIANB3AJB0AIgBCAJRhtqEBwgAkEQahAPGiACQRxqEK8IDAwLIAQgCSAYp0E4bGpBDGoQywIgARCsByABIAUQngNBA0YEQCACQRBqIAJBCGoQgAILIAIpAwhCAXwhGAwACwALIBkhGCABQSBqIgUoAgAgBSAFLQALIgjAQQBIIg0bIgYgBSgCBCAIIA0bIg1qIQ9BACEIA0ACQAJAIAUgBiAPRwR/IAhBAWohCCAGLAAAQQBIDQEgGEIBfSIYUEUNASAIBSANCxAfDAELIAZBAWohBgwBCwsgASkDMCIYQn9SBEAgASAYIAMpA8gCfTcDMAsgAUE4aiEBDAALAAsgCSABEJQCIAMoAqwCRgRAIAQgARCmBwsgAUEgaiEBDAALAAUCQCAJIAEQlAIgAygCrAJGBEAgBCABEKYHDAELIAQgARDLAkJ/NwMQCyABQSBqIQEMAQsACwAFIAJBHGogARDDByABQThqIQEMAQsACwAFIAcgBigCACAYp0E4bGpBDGoQrgIgGEIBfCEYDAELAAsACyACQbABaiQAIAcQDxogABDCASEADAALAAsgDEGgAWokAAs3AQF/IwBBEGsiASQAIAEgADYCDCABKAIMIgAoAgAEQCAAEIIJ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hQgLIARBIGokAAwBCxABAAsgAkEIaiELA0AgKSACKQOAA1oNAyACQcABaiAIEBkgAi0AyAFFBEAgBkEAOgDAASAGQQA6AAAMBQsgAkHgAmogCBAZIAItAOgCRQRAIAZBADoAwAEgBkEAOgAADAULIAJB0AJqIAgQGSACLQDYAkUEQCAGQQA6AMABIAZBADoAAAwFCyACQQA2AswCQgAhJyACQgA3AsQCIAJBxAJqIAIoAtACEM0FAkADQAJAAkACQCACKQPQAiAnVgRAIAJB4AFqIAgQUiACLQDsAUUNASACQbACaiAIEBkgAi0AuAJFDQEgAkGgAmogCBBSAn8gAi0ArAJFBEAgBkEAOgDAASAGQQA6AABBAQwBCyACIAIpA7ACNwMAIAsgAikDoAI3AgAgCyACKAKoAjYCCCACQQA2AqgCIAJCADcDoAICQCACQcQCaiIPKAIEIgEgDygCCEkEQCABIAIpAuABNwIAIAEgAigC6AE2AgggAkIANwLgASACQQA2AugBIAEgAikDADcDECABIAIoAhA2AiAgASACKQMINwMYIAJBADYCECACQgA3AwggDyABQShqNgIEDAELIwBBIGsiASQAIAFBDGogDyAPKAIEIA8oAgBrQShtQQFqEPoBIA8oAgQgDygCAGtBKG0gD0EIahDBASINKAIIIgQgAikC4AE3AgAgBCACKALoATYCCCACQgA3AuABIAJBADYC6AEgBCACKQMANwMQIAQgAigCEDYCICAEIAIpAwg3AxggAkEANgIQIAJCADcDCCANIA0oAghBKGo2AgggDyANENwCIA0Q2wIgAUEgaiQAIA8oAgQaCyALEAoaQQALIQQgAkGgAmoQORoMAgsgAkGwAmogCBAZIAItALgCRQRAIAZBADoAwAEgBkEAOgAADAMLIAJBADYCnAJCACEnIAJCADcClAIgAkGUAmogAigCsAIQzgcCfwJAA0AgJyACKQOwAloNASACQaACaiAIEBkCQCACLQCoAkUNACACQQA6ACEgAkEAOgAAIAIpA6ACUEUEQCACQYACaiAIEBkgAi0AiAJFDQEgCCgCBCIEQSBJDQEgCCgCACINLQAAIQEgAiANKQAYNwD3ASACIA0pABE3A/ABIAIgDSkACTcD6AEgAiANKQABNwPgASAIIARBIGs2AgQgCCANQSBqNgIAIAIg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OgAADAELIANB0AJqIAUQGSADLQDYAkUEQCACQQA6AFggAkEAOgAADAELIANBADYCzAIgA0IANwLEAiADKALQAiEJIwBBIGsiBCQAAkACQCAJIANBxAJqIgcoAgggBygCACIBa0EkbUsEQCAJQcjj8ThPDQEgByAEQQxqIAkgBygCBCABa0EkbSAHQQhqEPgIIgEQ9wggARD2CAsgBEEgaiQADAELEAEACyADQZQBaiEKIANBjANqIQ4DQAJAAkACQCADKQPQAiAnVgRAIANB0AFqIAUQgQUgAy0A3AFFDQEgA0GwAmogBRAZIAMtALgCRQ0BIAMpA7ACIiggBTUCBFYNASADQgA3A5gBIANCADcDkAEgA0IANwOIASAFKAIAIQEgAyAoPgKEAyADIAE2AoADIAMgAykCgAM3AwgCfyADQYgBaiEJQQAhBCMAQTBrIgYkAAJAIANBCGoiASgCBARAIAZBIGogARAZIAYtAChFDQEgCSAGKQMgPgIAIAZBEGogARAZIAYtABhFDQEgCSAGKQMQPgIEIAYgARAZIAYtAAhFDQEgCSAGKQMAPgIIIAk1AgQgCTUCAH5CB3xCA4giKCABNQIEVg0BAkAgASgCACIEICinaiIPIARrIhEgCUEMaiIIKAIIIAgoAgAiAWtNBEAgASAEIAQgCCgCBCABayIBaiIHIA8gASARSSIJGyAEayIEEFUhASAJBEAgCCAHIA8gCCgCACARIAgoAgRrahCGBQwCCyAIIAEgBGo2AgQMAQsgCBDcAyAIIAggERD5CBCgByAIIAQgDyAREIYFCwtBASEECyAGQTBqJAAgBEUEQCACQQA6AFggAkEAOgAAQQEMAQsgBSADKAKwAiIBIAUoAgBqNgIAIAUgBSgCBCABazYCBCADKALQASEBIANBADYC0AEgAyABNgKAAyADKQLUASEoIANCADcC1AEgAyAoNwKEAyAOIANBiAFqEM8FIANBxAJqIANBgANqIgEQogMgARDFARpBAAshBCAKEA8aDAILIANBsAJqIAUQGSADLQC4AkUEQCACQQA6AFggAkEAOgAADAMLIANBADYCrAIgA0IANwKkAiADQaQCaiADKAKwAhCNByADQcABaiEJQgAhJwJAA0AgAykDsAIgJ1YEQCADQZACaiAFEBkCQCADLQCYAgRAIAMpA5ACIiggBTUCBFgNAQsgAkEAOgBYIAJBADoAAAwDCyAFKAIAIQEgAyAoPgJcIAMgATYCWCADIAMpA1giKDcDECADICg3A4ADIANB0AFqIANBEGoQjgcgAy0AiAJFBEAgAkEAOgBYIAJBADoAAAwDCyADQYADaiIEIANB0AFqQTgQHRogA0H4AGogA0HYAGoQjAchByADQYgBaiIBIARBOBAdGiAJIAcoAgg2AgggCSAHKQIANwIAIAdCADcCACAHQQA2AgggBCABEJcKIAkQChogBxAKGgJAIAMtAIAEIgRFBEAgAkEAOgBYIAJBADoAAAwBCyADQaQCaiADQYADahCLByAFIAMoApACIgEgBSgCAGo2AgAgBSAFKAIEIAFrNgIECyAnQgF8IScgA0GAA2oQigcgBA0BDAILCyADQZACaiAFEBkgA0EAOgCEASADQQA6AHggA0EANgJ0IANCADcCbAJAAn5CACADLQCYAkUNABogAykDkAJQRQRAIANB2ABqIAUQUgJAAkAgAy0AZEUEQCACQQA6AFggAkEAOgAADAELIANB+ABqIANB2ABqEL8JIAUoAgRFDQEgA0HIAGogBRAZIAMtAFBFBEAgAkEAOgBYIAJBADoAAAwBCyADQewAaiADKAJIEI0HIANBwAFqIQlCACEnA0AgJyADKQNIWg0CIANBOGogBRAZAkAgAy0AQARAIAMpAzgiKCAFNQIEWA0BCyACQQA6AFggAkEAOgAADAILIAUoAgAhASADICg+AjQgAyABNgIwIAMgAykDMCIoNwMYIAMgKDcDgAMgA0HQAWogA0EYahCOByADLQCIAkUEQCACQQA6AFggAkEAOgAADAILIANBgANqIgQgA0HQAWpBOBAdGiADQSRqIANBMGoQjAchByADQYgBaiIBIARBOBAdGiAJIAcoAgg2AgggCSAHKQIANwIAIAdCADcCACAHQQA2AgggBCABEJcKIAkQChogBxAKGgJAIAMtAIAEIgRFBEAgAkEAOgBYIAJBADoAAAwBCyADQewAaiADQYADahCLByAFIAMoAjgiASAFKAIAajYCACAFIAUoAgQgAWs2AgQLICdCAXwhJyADQYADahCKByAEDQALCyADQdgAahA5GgwDCyADQdgAahA5GkIAIAMtAJgCRQ0BGgsgA0GAA2ogBRCyASADKQOAA0IAIAMtAIgDGwsh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FCAFKAIQa0Eiba0gAhAYIAUoAhQhCiAFKAIQIQEDQCABIApGBEAgBUEcaiEFDAULIAExACEgAhAYIAEtACEEQCABMQAAIAIQGCABQQFqIAIQ5QILIAFBImohAQwACwAFIAEgAhBIIAEpAxAgAhAYIAFBGGogAhBIIAFBKGohAQwBCwALAAsLA0AgASAFRwRAIAEgAhBIIAEpAxAgAhAYIAFBGGogAhBIIAFBKGohAQwBCwsgAygClAEgAygCkAFrQShtrSACEBggAygClAEhBSADKAKQASEBA0AgASAFRgRAAkAgAygCtAEgAygCsAFrQRxtrSACEBggAygCtAEhBSADKAKwASEBA0AgASAFRg0BIAExAAAgAhAYIAFBBGogAhBIIAFBEGogAhBIIAFBHGohAQwACwALBSABIAIQSCABKQMQIAIQGCABQRhqIAIQSCABQShqIQEMAQsLIA5BEGokACACIAAQSCACEAoaDAELQgAgABAYCyADKALMASADKALIAWtBB3WtIAAQGCADKALMASEJIAMoAsgBIQ4DQCAJIA5GBEAgB0EQaiQABSAOIAAQSCAOKQMQIAAQGCAOQRhqIAAQSCMAQRBrIgUkACAFQcIAOgAPIAdBBGoiAyAFQQ9qIAVBEGoQowQgDkEoaiICIAMQggUgAkEMaiADEIIFIAIoAhwgAigCGGtBJG2tIAMQGCACKAIcIQogAigCGCEBA0AgASAKRgRAIAIoAiggAigCJGtBAnWtIAMQGCACKAIoIQogAigCJCEBA0AgASAKRgRAIAIxADwgAxAYAkAgAi0APEUNACACQTBqIAMQSCACKAJEIAIoAkBrQQJ1rSADEBggAigCRCEKIAIoAkAhAQNAIAEgCkYNASABKAIAIAMQSCABQQRqIQEMAAsACyACKQNQIAMQ4wEgBUEQaiQABSABKAIAIAMQSCABQQRqIQEMAQsLBSABIAMQggUgBUIANwIAIAVBADYCCCABKAIMIgQEQCAErSAFEBggATUCECAFEBggATUCFCAFEBggBSABKAIYIgQgASgCHCAEaxBtGgsgBSADEEggAUEkaiEBIAUQChoMAQsLIAMgABBIIA5BgAFqIQ4gAxAKGgwBCwsLIwBBEGsiACQAIAAgEUEIaiIFQcgBajYCDCAAKAIMIgEoAgAEQCABKAIAIQMgASgCBCEC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DGsQ4QUaDAELIAAgAEEMaiAAQRhqIgQQ4wIaIABBJGohAgNAIAIiBSABRg0BAkAgAiAEEBsEQCADIAIoAgg2AgggAyACKQIANwMAIAJCADcCACACQQA2AggDQAJAIAIgBCICEBwgACACRgRAIAAhAgwBCyADIAJBDGsiBBAbDQELCyACIAMQHCADEAoaIAdBAWoiB0EIRg0BCyAFQQxqIQIgBSEEDAELCyAFQQxqIAFGIQYLIANBEGokACAGC9oBAQN/IAAoAgQiBSEEIAEgBSADa0HwAG1B8ABsaiIGIQMDQCACIANNBEAgACAENgIEIwBBEGsiAiQAIwBBEGsiACQAIAUhAyAGIQQDQCABIARHBEAgA0HwAGsiAyAEQfAAayIEEK8BDAELCyAAIAM2AgwgACAGNgIIIAAoAgghAyACIAUgACgCDCAFa0HwAG1B8ABsajYCDCACIAEgAyABa0HwAG1B8ABsajYCCCAAQRBqJAAgAigCDBogAkEQaiQABSAEIAMQOEHwAGohBCADQfAAaiEDDAELCwsbACAAIAEpAwA3AwAgAEEIaiABQQhqECYaIAALGAAgACABKQMANwMAIABBCGogAUEIahBaC3IBAX8jAEEQayICJAACQCAALQAYQQVGBEAgACABKQMANwMAIAAgASkDCDcDCAwBCyACIAE2AgwgAiAANgIIIAIoAgwhASACKAIIIgAQowIgACABKQMINwMIIAAgASkDADcDACAAQQU6ABgLIAJBEGokAAsKACABQQhqEA8aCycBAX8jAEEQayICJAAgAiAAOQMIIAEgAkEIakEIEG0aIAJBEGokAAskAQN/A0AgAUEBaiEBIABC/wBWIQMgAEIHiCEAIAMNAAsgAa0LQQIBfgF/QgEhAQJAAkACQAJAIAAtACAiAg4DAgADAQsgACgCCEEAR61CAYYPC0IEQgUgAkEERhsPC0IDIQELIAELDgAgAEEMahA7IAAQChoLgwECAX8BfiMAQRBrIgIkAAJAIAAtABhBBUYEQCAAIAEQpAQMAQsgAiABNgIMIAIgADYCCCACKAIMIQAgAigCCCIBEOgCIAEgACgCCDYCCCABIAApAwA3AwAgAEEANgIIIABCADcDACAAKQMQIQMgAUEFOgAYIAEgAzcDEAsgAkEQaiQAC3IBAX8jAEEQayICJAACQCAALQAYQQVGBEAgACABKQMANwMAIAAgASkDCDcDCAwBCyACIAE2AgwgAiAANgIIIAIoAgwhASACKAIIIgAQsAEgACABKQMINwMIIAAgASkDADcDACAAQQU6ABgLIAJBEGokAAs1AQF/IAAhAyAAKAIEIQADQCABIAJHBEAgACABEBBBDGohACABQQxqIQEMAQsLIAMgADYCBAvrAwIIfwF+IwBBEGsiAyQAIwBBEGsiByQAIAEQPiIKp0H/AXFBgAJyIQYgCiAAMQAeiKchBANAAkACQAJAIAAoAgwgBEEDdGoiAigCACIFIAZGBEAgASAAKAIAIAIoAgRBGGxqECJFDQIgACgCACEAIAIoAgQhASADQQA6AAwgAyAAIAFBGGxqNgIIDAELIAUgBk8NASAHIAE2AgwgB0EMaiEFIwBBEGsiASQAAkAgACgCBCAAKAIISQRAIAAgACgCBCAFKAIAEOAFQRhqNgIEDAELIwBBIGsiCCQAIAhBDGogACAAKAIEIAAoAgBrQRhtQQFqEOUBIAAoAgQgACgCAGtBGG0gAEEIahDGASICKAIIIAUoAgAQ4AUaIAIgAigCCEEYajYCCCAAIAIQ3wUgAhDeBSAIQSBqJAALIAAoAgQaIAAoAgQgACgCAGtBGG0iBUEBayECAkAgACgCFCAFSQRAIAAQmwkMAQsgASACNgIMIAEgBjYCCCABIAEpAgg3AwAgACABIAQQMAsgACgCACEAIANBAToADCADIAAgAkEYbGo2AgggAUEQaiQACyAHQRBqJAAMAQsgBEEBaiIEQQAgBCAAKAIQRxshBCAGQYACaiEGDAELCyADKAIIIQkgA0EQaiQAIAlBEGoLYgEBfyMAQRBrIgMkAAJAIAAtABBFBEAgASACEIMBDAELIAMgAjYCDCADIAA2AggjAEEQayIAJAAgAygCCCAAQQRqIAMoAgwQECIBEKsLIAEQChogAEEQaiQACyADQRBqJAALGAAgAEGr1arVAE8EQBAaAAsgAEEYbBAXCywBAX8jAEEQayIBJAAgASAANgIMIAEoAgwoAgAiAARAIAAQCwsgAUEQaiQACxgAIABB1qrVqgFPBEAQGgALIABBDGwQFwsYACAAQYCAgMAATwRAEBoACyAAQQV0EBcLOgEDfyMAQRBrIgEkACABQQxqIgIgABAkIAIQbCIAQSAgACgCACgCHBEDACEDIAIQIyABQRBqJAAgAwsmACAAIAAoAhhFIAAoAhAgAXJyIgE2AhAgACgCFCABcQRAEBoACwsLACAAIAFBDBCqBAsMACAAIAAoAgAQsgkLPgECfyAAKAIEIQIDQCACIAAoAggiAUcEQCAAIAFB+ABrIgE2AgggARD1BRoMAQsLIAAoAgAiAARAIAAQCwsLjwEBA38gACgCBCEDIAAoAgAhBCABKAIEIQIDQCADIARHBEAgAkH4AGsgA0H4AGsiAxDyBSECDAELCyABIAI2AgQgACgCACEDIAAgAjYCACABIAM2AgQgACgCBCECIAAgASgCCDYCBCABIAI2AgggACgCCCECIAAgASgCDDYCCCABIAI2AgwgASABKAIENgIACxUAIAAgASACIANB+ABBo8SIERCxAQsRACAALQAoBEAgAEEIahBECwuzAwECfyMAQUBqIgMkAAJAIAFCBVgEQAJAAkACQAJAAkACQCABp0EBaw4FAQIDBAUACyADQQE6ADggA0EANgIgIAAgA0EYahCmAiADQSBqEEQMBgsgA0EgaiADIAIQdCICEHQiBEECOgAYIAAgA0EYahCmAiAEEEQgAhA3DAULIANBAToAOCADQQE2AiAgACADQRhqEKYCIANBIGoQRAwECyADQQA6ADggACADQRhqEKYCIANBIGoQRAwDCyADIAIQxQMiAigCCDYCCCADIAIpAgA3AwAgAkIANwIAIAJBADYCCCADQQQ6ADggAyADKAIINgIoIANBADYCCCADIAMpAwA3AyAgA0IANwMAIAAgA0EYahCmAiADQSBqEEQgAxAKGgwCCwJAIAJFDQACQAJAIAItABAOAgABAgsgAikDACEBIANBAzoAOCADIAE3AyAgACADQRhqEKYCIANBIGoQRAwDCyACKQMAIQEgA0EDOgA4IAMgATcDICAAIANBGGoQpgIgA0EgahBEDAILIABBADoAKCAAQQA6AAAMAQsgAEEAOgAoIABBADoAAAsgA0FAayQACwsAIAAgACABEKsJCwkAIABBGBDIAwulAQEDfyABKAIEIQIgACgCACEEIAAoAgQhAwNAIAMgBEZFBEAgAkEYayICIANBGGsiAykDADcDACACIAMpAxA3AxAgAiADKQMINwMIDAELCyABIAI2AgQgACgCACEDIAAgAjYCACABIAM2AgQg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IARB/wFGG0ECdGooAgARAAAgAkEQaiQACyAAQf8BOgAQIANBEGokAAtlAQJ/IABB/wE6ABAgAEEAOgAAIwBBEGsiAyQAIAAQJSABLQAQIgRB/wFHBEAgAyACKQMANwMIIANBB2ogACABIANBCGogBEECdGooAgARBAAgACABLQAQOgAQCyADQRBqJAAgAAtlAQJ/IABB/wE6ABggAEEAOgAAIwBBEGsiAyQAIAAQQyABLQAYIgRB/wFHBEAgAyACKQMANwMIIANBB2ogACABIANBCGogBEECdGooAgARBAAgACABLQAYOgAYCyADQRBqJAAgAAtXAQF/IABBADYCDCAAIAM2AhAgAQRAIAEgBU8EQBAaAAsgASAEdBAXIQYLIAAgBjYCACAAIAYgAiAEdGoiAjYCCCAAIAYgASAEdGo2AgwgACACNgIEIAALEwAgACAAKAIEIAEQEEEMajYCBAs9AQJ/IAAoAgQhAwNAIAMgACgCCCICRwRAIAAgAiABayICNgIIIAIQgAkaDAELCyAAKAIAIgAEQCAAEAsLCygBAX8jAEEQayICJAAgAiABNgIMIABBCGogAkEMahCnDyACQRBqJAALlAEBA38jAEEgayICJAAgACgCDCIDBEAgA0EAIAAoAhBBA3QQHhoLIAAoAgQgACgCAGsgAXUhBEEAIQMDQCADIARGBEAgAkEgaiQABSACQRhqIAAgACgCACADIAF0ahDNCiACIAM2AhQgAiACKAIYNgIQIAIgAikCEDcDCCAAIAJBCGogAigCHBAwIANBAWohAwwBCwsLlAEBA38jAEEgayICJAAgACgCDCIDBEAgA0EAIAAoAhBBA3QQHhoLIAAoAgQgACgCAGsgAXUhBEEAIQMDQCADIARGBEAgAkEgaiQABSACQRhqIAAgACgCACADIAF0ahDkAiACIAM2AhQgAiACKAIYNgIQIAIgAikCEDcDCCAAIAJBCGogAigCHBAwIANBAWohAwwBCwsLlAEBA38jAEEgayICJAAgACgCDCIDBEAgA0EAIAAoAhBBA3QQHhoLIAAoAgQgACgCAGsgAXUhBEEAIQMDQCADIARGBEAgAkEgaiQABSACQRhqIAAgACgCACADIAF0ahDqCCACIAM2AhQgAiACKAIYNgIQIAIgAikCEDcDCCAAIAJBCGogAigCHBAwIANBAWohAwwBCwsL/QEBBX8gACABKQMANwMAIAAgASkDCDcDCCMAQRBrIgQkAAJAIAFBGGoiBi0AGCIHQf8BRiIIIABBGGoiBS0AGEH/AUZxDQAgCARAIAUQRAwBCyAEIAU2AgwgBEEMaiAFIAYgB0ECdCADaigCABEEAAsgBEEQaiQAIwBBEGsiBCQAAkAgAUE4aiIGLQAQIgdB/wFGIgggAEE4aiIFLQAQQf8BRnENACAIBEAgBRDEAQwBCyAEIAU2AgQgBCACKQMANwMIIARBBGogBSAGIARBCGogB0ECdGooAgARBAALIARBEGokACAAIAEtAFA6AFAgAEHYAGogAUHYAGoQpwwLZwEDfyMAQUBqIgIkACAAKAIIIQQgAkE0aiAAKAIAEBAhACACQQA6ACAgAkEGOgAYIAJBADYCMCACQgA3AiggBCAAIAJBKGoiAyABIAIQrQEgAkEIahBDIAMQXCAAEAoaIAJBQGskAAtVAQJ/IAAoAgQhBAJ/QQAgAkUNABogBEEIdSIFIARBAXFFDQAaIAIoAgAgBRCABgshBSAAKAIAIgAgASACIAVqIANBAiAEQQJxGyAAKAIAKAIcEQYACw8AIAAtAAwEQCAAEPcFCwvJAwEHfyMAQSBrIgMkACADQRVqIgQgA0EgaiIFRiABQQBOcgR/IAQFIARBLToAAEEAIAFrIQEgBEEBagshAiADAn8gBSIGIAJrIgdBCUwEQEE9IAdBICABQQFyZ2tB0QlsQQx1IgggCEECdEHgvAJqKAIAIAFNakgNARoLAn8gAUG/hD1NBEAgAUGPzgBNBEAgAUHjAE0EQCABQQlNBEAgAiABEMwDDAQLIAIgARCqAgwDCyABQecHTQRAIAIgAUHkAG4iAhDMAyABIAJB5ABsaxCqAgwDCyACIAEQhQYMAgsgAUGfjQZNBEAgAiABQZDOAG4iAhDMAyABIAJBkM4AbGsQhQYMAgsgAiABEIQGDAELIAFB/8HXL00EQCABQf+s4gRNBEAgAiABQcCEPW4iAhDMAyABIAJBwIQ9bGsQhAYMAgsgAiABEIMGDAELIAFB/5Pr3ANNBEAgAiABQYDC1y9uIgIQzAMgASACQYDC1y9saxCDBgwBCyACIAFBgMLXL24iAhCqAiABIAJBgMLXL2xrEIMGCyEGQQALNgIQIAMgBjYCDCADKAIMIQEjAEEQayICJAAgACAEIAEQ2AogAkEQaiQAIAUkAAsOACAAQQxqEPcFIAAQOwvUAQEDfyMAQRBrIgUkACACQe////8DIAFrTQRAIAAQICEGIAVBBGoiByAAIAFB5////wFJBH8gBSABQQF0NgIMIAUgASACajYCBCAHIAVBDGoQtgIoAgAQ8gJBAWoFQe////8DCxDxAiAFKAIEIQIgBSgCCBogBARAIAIgBiAEEIwCCyADIARHBEAgBEECdCIHIAJqIAYgB2ogAyAEaxCMAgsgAUEBaiIBQQJHBEAgACAGIAEQswQLIAAgAhCVASAAIAUoAggQlAEgBUEQaiQADwsQaAALpQIBA38jAEEQayIIJAAgAiABQX9zQe////8Dak0EQCAAECAhCSAIQQRqIgogACABQef///8BSQR/IAggAUEBdDYCDCAIIAEgAmo2AgQgCiAIQQxqELYCKAIAEPICQQFqBUHv////AwsQ8QIgCCgCBCECIAgoAggaIAQEQCACIAkgBBCMAgsgBgRAIARBAnQgAmogByAGEIwCCyADIAQgBWoiCmshByADIApHBEAgBEECdCIDIAJqIAZBAnRqIAMgCWogBUECdGogBxCMAgsgAUEBaiIBQQJHBEAgACAJIAEQswQLIAAgAhCVASAAIAgoAggQlAEgACAEIAZqIAdqIgAQcCAIQQA2AgwgAiAAQQJ0aiAIQQxqEIYBIAhBEGokAA8LEGgAC28BA38jAEEQayIEJAAgAQRAIAEgABAoIgMgABAOIgJrSwRAIAAgAyABIANrIAJqIAIgAhCHBgsgAiAAECAiA2ogAUEAEOYJIAAgASACaiIAEK8CIARBADoADyAAIANqIARBD2oQiQELIARBEGokAAs9AQF/IwBBEGsiAyQAIAMgAjoADwNAIAEEQCAAIAMtAA86AAAgAUEBayEBIABBAWohAAwBCwsgA0EQaiQACxYAIAAgASACQoCAgICAgICAgH8QhwsLCQAgABA1NgIACyMBAn8gACEBA0AgASICQQRqIQEgAigCAA0ACyACIABrQQJ1Cw8AIAAgACgCAEEEazYCAAsKACAAKAIAQQRrCywAIAAoAgAaIAAoAgAaIAAQqwIaIAAoAgAaIAAQswEaIAAoAgAaIAAQqwIaCzAAIwBBEGsiAiQAAkAgACABRgRAIAFBADoAeAwBCyACQQ9qIAEQ9gkLIAJBEGokAAssAQF/IAAoAgQhAgNAIAEgAkcEQCAAEKwCGiACQQRrIQIMAQsLIAAgATYCBAsJACAAQQA2AgALJgAgACgCABogACgCABogABCrAhogACgCABogABCrAhogACgCABoLSwEBfyMAQRBrIgMkAAJAAkAgAkEeSw0AIAEtAHgNACABQQE6AHgMAQsgA0EPaiACEPgJIQELIANBEGokACAAIAI2AgQgACABNgIAC0QBAn8jAEEQayIBJAAgABCsAhogAUH/////AzYCDCABQf////8HNgIIIAFBDGogAUEIahDVAygCACECIAFBEGokACACCwsAIABBADYCACAACycBAn8jAEEQayIBJAAgASAANgIMIAFBDGoQigYhAiABQRBqJAAgAgs3AQF/IwBBEGsiAyQAIAMgARD0CTYCDCADIAIQ9Ak2AgggACADQQxqIANBCGoQzAQgA0EQaiQACwkAIAFBBBDTCgsvAQF/IwBBEGsiAyQAIAAgAhCvAiADQQA6AA8gASACaiADQQ9qEIkBIANBEGokAAsbACABQf////8DSwRAEBoACyABQQJ0QQQQzwoLbAECfyABIAAoAgQgACgCACABKAIEEOgKIgI2AgQgACgCACEDIAAgAjYCACABIAM2AgQgACgCBCECIAAgASgCCDYCBCABIAI2AgggACgCCCECIAAgASgCDDYCCCABIAI2AgwgASABKAIENgIACwkAIAAQiwYQCwuIAQEDfyMAQSBrIgQkACAEQQxqIAAgACgCBCAAKAIAa0EFdUEBahDDAyAAKAIEIAAoAgBrQQV1IABBCGoQ9AIiAygCCCICIAEpAAA3AAAgAiABKQAYNwAYIAIgASkAEDcAECACIAEpAAg3AAggAyACQSBqNgIIIAAgAxD8CSADEIwGIARBIGokAAuvAQEDfyABKAIEIQIgACgCACEEIAAoAgQhAwNAIAMgBEZFBEAgAkEgayICIANBIGsiAykAADcAACACIAMpABg3ABggAiADKQAQNwAQIAIgAykACDcACAwBCwsgASACNgIEIAAoAgAhAyAAIAI2AgAgASADNgIEIAAoAgQhAiAAIAEoAgg2AgQgASACNgIIIAAoAgghAiAAIAEoAgw2AgggASACNgIMIAEgASgCBDYCAAsVACAAQeCRAjYCACAAQRBqEAoa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AgAiEUEEajYCACARIAo2AgBBACERIAsQDiAQQQFqIhBNBEAgDyESDAELIAsgEBAhLQAAQf8ARgRAQX8hEgwBCyALIBAQISwAACESCyAHQQRrIgcoAgAhDyACIAIoAgAiGEEEajYCACAYIA82AgAgEUEBaiEPDAELCyACKAIAIQcLIBkgBxC9BAsgFEEBaiEUDAELCwvTAgEBfyMAQRBrIgokACAJAn8gAARAIAIQmwohAAJAIAEEQCAKQQRqIgEgABCFAiADIAooAgQ2AAAgASAAEIQCDAELIApBBGoiASAAELcEIAMgCigCBDYAACABIAAQowELIAggARDMASABEEAaIAQgABChATYCACAFIAAQbzYCACAKQQRqIgEgABBuIAYgARBiIAEQChogASAAEKQBIAcgARDMASABEEAaIAAQgwIMAQsgAhCaCiEAAkAgAQRAIApBBGoiASAAEIUCIAMgCigCBDYAACABIAAQhAIMAQsgCkEEaiIBIAAQtwQgAyAKKAIENgAAIAEgABCjAQsgCCABEMwBIAEQQBogBCAAEKEBNgIAIAUgABBvNgIAIApBBGoiASAAEG4gBiABEGIgARAKGiABIAAQpAEgByABEMwBIAEQQBogABCDAgs2AgAgCkEQaiQAC6sBAQV/IwBBEGsiBCQAIwBBIGsiAyQAIANBGGogACABEPUJIANBEGogA0EMaiIFIAMoAhggAygCHCACEJ8GIAMoAhAhBiMAQRBrIgEkACABIAA2AgwgAUEMaiIAIAYgABCKBmsQkQYhACABQRBqJAAgAyAANgIMIAMgAiADKAIUEM0ENgIIIARBCGogBSADQQhqENMBIANBIGokACAEKAIMIQcgBEEQaiQAIAcLjAYCBH8BfiMAQYACayICJAAgASgCOCEDIAIgASgCPCABLQBDIgQgBMBBAEgiBBsgASgCECIFazYC/AEgAiAFIAMgAUE4aiAEG2o2AvgBIAJB6AFqIAJB+AFqEBkCQCACLQDwAUUEQCAAQQA6AIABIABBADoAAAwBCyACQQA2AuQBIAJCADcC3AEgAkHcAWogAigC6AEQzgMCQAJAA0AgBiACKQPoAVoNASACKAL8ASIEQSBPBEAgAiACKAL4ASIDKQAINwMQIAIgAykAEDcDGCACIAMpABg3AyAgAiADKQAANwMIIAIgBEEgazYC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IAtB6ABqIAtB8ABqIAtByABqIgEQRiIPKAIAIgo2AmQgCyAKQZADajYCYCABECchESALQTxqECchDCALQTBqECchDiALQSRqECchDSALQRhqECchECMAQRBrIgokACALAn8gAgRAIApBBGoiASADEJsKIgIQhQIgCyAKKAIENgBcIAEgAhCEAiANIAEQzAEgARBAGiABIAIQowEgDiABEMwBIAEQQBogCyACEKEBNgJYIAsgAhBvNgJUIAEgAhBuIBEgARBiIAEQChogASACEKQBIAwgARDMASABEEAaIAIQgwIMAQsgCkEEaiIBIAMQmgoiAhCFAiALIAooAgQ2AFwgASACEIQCIA0gARDMASABEEAaIAEgAhCjASAOIAEQzAEgARBAGiALIAIQoQE2AlggCyACEG82AlQgASACEG4gESABEGIgARAKGiABIAIQpAEgDCABEMwBIAEQQBogAhCDAgs2AhQgCkEQaiQAIAkgCCgCADYCACAEQYAEcSEUQQAhA0EAIQEDQCABIQICQAJAAkACQCADQQRGDQAgACALQYwEahAtDQBBACEKAkACQAJAAkACQAJAIAtB3ABqIANqLAAADgUBAAQDBQkLIANBA0YNByAHQQEgABBJEKUBBEAgC0EMaiAAEJ0KIBAgCygCDBCGBgwCCyAFIAUoAgBBBHI2AgBBACEADAYLIANBA0YNBgsDQCAAIAtBjARqEC0NBiAHQQEgABBJEKUBRQ0GIAtBDGogABCdCiAQIAsoAgwQhgYMAAsACwJAIA4QDkUNACAAEEkgDhAgKAIARw0AIAAQUxogBkEAOgAAIA4gAiAOEA5BAUsbIQEMBgsCQCANEA5FDQAgABBJIA0QICgCAEcNACAAEFMaIAZBAToAACANIAIgDRAOQQFLGyEBDAYLAkAgDhAORQ0AIA0QDkUNACAFIAUoAgBBBHI2AgBBACEADAQLIA4QDkUEQCANEA5FDQULIAYgDRAORToAAAwECyAUIANBAkkgAnJyRQRAQQAhASADQQJGIAstAF9BAEdxRQ0FCyALIAwQiAE2AgggC0EMaiALQQhqELQCIQQCQCADRQ0AIAMgC2otAFtBAUsNAANAAkAgCyAMEIcCNgIIIAQgC0EIahDRAUUNACAHQQEgBCgCACgCABClAUUNACAEEM8DDAELCyALIAwQiAE2AgggBCgCACALQQhqIgEoAgBrQQJ1IgogEBAOTQRAIAsgEBCHAjYCCCABQQAgCmsQjwYhCiAQEIcCIRIgDBCIASETIwBBEGsiASQAIAEgEjYCCCABIAo2AgwgASATNgIEA0ACQCABQQxqIgogAUEIahDRASISRQ0AIAooAgAoAgAgAUEEaiITKAIAKAIARw0AIAoQzwMgExDPAwwBCwsgAUEQaiQAIBJBAXMNAQsgCyAMEIgBNgIEIAQgC0EIaiALQQRqELQCKAIANgIACyALIAQoAgA2AggDQAJAIAsgDBCHAjYCBCALQQhqIgEgC0EEahDRAUUNACAAIAtBjARqEC0NACAAEEkgASgCACgCAEcNACAAEFMaIAEQzwMMAQsLIBRFDQMgCyAMEIcCNgIEIAtBCGogC0EEahDRAUUNAyAFIAUoAgBBBHI2AgBBACEADAILA0ACQCAAIAtBjARqEC0NAAJ/IAdBwAAgABBJIgEQpQEEQCAJKAIAIgQgCygCiARGBEAgCCAJIAtBiARqEPYCIAkoAgAhBAsgCSAEQQRqNgIAIAQgATYCACAKQQFqDAELIBEQDkUgCkVyDQEgASALKAJURw0BIAsoAmQiASALKAJgRgRAIA8gC0HkAGogC0HgAGoQ9gIgCygCZCEBCyALIAFBBGo2AmQgASAKNgIAQQALIQogABBTGgwBCwsgCkUgCygCZCIBIA8oAgBGckUEQCALKAJgIAFGBEAgDyALQeQAaiALQeAAahD2AiALKAJkIQELIAsgAUEEajYCZCABIAo2AgALAkAgCygCFEEATA0AAkAgACALQYwEahAtRQRAIAAQSSALKAJYRg0BCyAFIAUoAgBBBHI2AgBBACEADAMLA0AgABBTGiALKAIUQQBMDQECQCAAIAtBjARqEC1FBEAgB0HAACAAEEkQpQENAQsgBSAFKAIAQQRyNgIAQQAhAAwECyAJKAIAIAsoAogERgRAIAggCSALQYgEahD2AgsgABBJIQEgCSAJKAIAIgRBBGo2AgAgBCABNgIAIAsgCygCFEEBazYCFAwACwALIAIhASAIKAIAIAkoAgBHDQMgBSAFKAIAQQRyNgIAQQAhAAwBCwJAIAJFDQBBASEKA0AgAhAOIApNDQECQCAAIAtBjARqEC1FBEAgABBJIAIgChDFBCgCAEYNAQsgBSAFKAIAQQRyNgIAQQAhAAwDCyAAEFMaIApBAWohCgwACwALQQEhACAPKAIAIAsoAmRGDQBBACEAIAtBADYCDCARIA8oAgAgCygCZCALQQxqEGEgCygCDARAIAUgBSgCAEEEcjYCAAwBC0EBIQALIBAQQBogDRBAGiAOEEAaIAwQQBogERAKGiAPEEUMAwsgAiEBCyADQQFqIQMMAAsACyALQZAEaiQAIAALHwAgACABELgEEFEgARCLAygCACEBIAAQiwMgATYCAAsLACAAQbzJAhDqAQsLACAAQcTJAhDqAQvHAQEGfyMAQRBrIgQkACAAEIsDKAIAIQVBAQJ/IAIoAgAgACgCAGsiA0H/////B0kEQCADQQF0DAELQX8LIgMgA0EBTRshAyABKAIAIQYgACgCACEHIAVBkwRGBH9BAAUgACgCAAsgAxDTBCIIBEAgBUGTBEcEQCAAELgEGgsgBEGSBDYCBCAAIARBCGogCCAEQQRqEEYiBRCfCiAFEEUgASAAKAIAIAYgB2tqNgIAIAIgAyAAKAIAajYCACAEQRBqJAAPCxAaAAsgAQF/IAEoAgAQ4wrAIQIgACABKAIANgIEIAAgAjoAAAuFEAEKfyMAQZAEayILJAAgCyAKNgKIBCALIAE2AowEAkAgACALQYwEahAuBEAgBSAFKAIAQQRyNgIAQQAhAAwBCyALQZMENgJMIAsgC0HoAGogC0HwAGogC0HMAGoiARBGIg8oAgAiCjYCZCALIApBkANqNgJgIAEQJyERIAtBQGsQJyEMIAtBNGoQJyEOIAtBKGoQJyENIAtBHGoQJyEQIwBBEGsiCiQAIAsCfyACBEAgCkEEaiIBIAMQoQoiAhCFAiALIAooAgQ2AFwgASACEIQCIA0gARBiIAEQChogASACEKMBIA4gARBiIAEQChogCyACEKEBOgBbIAsgAhBvOgBaIAEgAhBuIBEgARBiIAEQChogASACEKQBIAwgARBiIAEQChogAhCDAgwBCyAKQQRqIgEgAxCgCiICEIUCIAsgCigCBDYAXCABIAIQhAIgDSABEGIgARAKGiABIAIQowEgDiABEGIgARAKGiALIAIQoQE6AFsgCyACEG86AFogASACEG4gESABEGIgARAKGiABIAIQpAEgDCABEGIgARAKGiACEIMCCzYCGCAKQRBqJAAgCSAIKAIANgIAIARB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AigCACICBEADQCADIAJBCGoQ1QRFDQIgAigCICICDQALC0EkEEciAgRAIAJBhO0BKQIANwIAIAJBCGoiASADIAQQHRogASAEakEAOgAAIAJBsMgCKAIANgIgQbDIAiACNgIACyACQYTtASAAIAJyGyECCyACC98eAhB/BX4jAEGQAWsiCSQAIAlBAEGQARAeIglBfzYCTCAJIAA2AiwgCUGRBDYCICAJIAA2AlQgASEEIAIhD0EAIQAjAEGwAmsiByQAIAkiAygCTBoCQAJAAkACQCADKAIEDQAgAxCNCxogAygCBA0ADAELIAQtAAAiAUUNAgJAAkACQAJAA0ACQAJAIAFB/wFxEI4CBEADQCAEIgFBAWohBCABLQABEI4CDQALIANCABC5AQNAAn8gAygCBCICIAMoAmhHBEAgAyACQQFqNgIEIAItAAAMAQsgAxAqCxCOAg0ACyADKAIEIQQgAykDcEIAWQRAIAMgBEEBayIENgIECyAEIAMoAixrrCADKQN4IBZ8fCEWDAELAn8CQAJAIAQtAABBJUYEQCAELQABIgFBKkYNASABQSVHDQILIANCABC5AQJAIAQtAABBJUYEQANAAn8gAygCBCIBIAMoAmhHBEAgAyABQQFqNgIEIAEtAAAMAQsgAxAqCyIBEI4CDQALIARBAWohBAwBCyADKAIEIgEgAygCaEcEQCADIAFBAWo2AgQgAS0AACEBDAELIAMQKiEBCyAELQAAIAFHBEAgAykDcEIAWQRAIAMgAygCBEEBazYCBAsgAUEATg0NQQAhBiAODQ0MCwsgAygCBCADKAIsa6wgAykDeCAWfHwhFiAEIQEMAwtBACEIIARBAmoMAQsCQCABELgBRQ0AIAQtAAJBJEcNACAELQABQTBrIQIjAEEQayIBIA82AgwgASAPIAJBAnRBBGtBACACQQFLG2oiAUEEajYCCCABKAIAIQggBEEDagwBCyAPKAIAIQggD0EEaiEPIARBAWoLIQFBACEJQQAhBCABLQAAELgBBEADQCABLQAAIARBCmxqQTBrIQQgAS0AASESIAFBAWohASASELgBDQALCyABLQAAIg1B7QBHBH8gAQVBACEKIAhBAEchCSABLQABIQ1BACEAIAFBAWoLIgJBAWohAUEDIQUgCSEGAkACQAJAAkACQAJAIA1BwQBrDjoEDAQMBAQEDAwMDAMMDAwMDAwEDAwMDAQMDAQMDAwMDAQMBAQEBAQABAUMAQwEBAQMDAQCBAwMBAwCDAsgAkECaiABIAItAAFB6ABGIgIbIQFBfkF/IAIbIQUMBAsgAkECaiABIAItAAFB7ABGIgIbIQFBA0EBIAIbIQUMAwtBASEFDAILQQIhBQwBC0EAIQUgAiEBC0EBIAUgAS0AACIGQS9xQQNGIgIbIRACQCAGQSByIAYgAhsiC0HbAEYNAAJAIAtB7gBHBEAgC0HjAEcNAUEBIAQgBEEBTBshBAwCCyAIIBAgFhDLCgwCCyADQgAQuQEDQAJ/IAMoAgQiAiADKAJoRwRAIAMgAkEBajYCBCACLQAADAELIAMQKgsQjgINAAsgAygCBCECIAMpA3BCAFkEQCADIAJBAWsiAjYCBAsgAiADKAIsa6wgAykDeCAWfHwhFgsgAyAErCIVELkBAkAgAygCBCICIAMoAmhHBEAgAyACQQFqNgIEDAELIAMQKkEASA0GCyADKQNwQgBZBEAgAyADKAIEQQFrNgIEC0EQIQICQAJAAkACQAJAAkACQAJAAkACQCALQdgAaw4hBgkJAgkJCQkJAQkCBAEBAQkFCQkJCQkDBgkJAgkECQkGAAsgC0HBAGsiAkEGS0EBIAJ0QfEAcUVyDQgLIAdBCGogAyAQQQAQiQsgAykDeEIAIAMoAgQgAygCLGusfVINBQwMCyALQRByQfMARgRAIAdBIGpBf0GBAhAeGiAHQQA6ACAgC0HzAEcNBiAHQQA6AEEgB0EAOgAuIAdBADYBKgwGCyAHQSBqIAEtAAEiBUHeAEYiBkGBAhAeGiAHQQA6ACAgAUECaiABQQFqIAYbIQICfwJAAkAgAUECQQEgBhtqLQAAIgFBLUcEQCABQd0ARg0BIAVB3gBHIQUgAgwDCyAHIAVB3gBHIgU6AE4MAQsgByAFQd4ARyIFOgB+CyACQQFqCyEBA0ACQCABLQAAIgJBLUcEQCACRQ0PIAJB3QBGDQgMAQtBLSECIAEtAAEiDEUgDEHdAEZyDQAgAUEBaiEGAkAgDCABQQFrLQAAIgFNBEAgDCECDAELA0AgAUEBaiIBIAdBIGpqIAU6AAAgASAGLQAAIgJJDQALCyAGIQELIAIgB2ogBToAISABQQFqIQEMAAsAC0EIIQIMAgtBCiECDAELQQAhAgtCACETQQAhBUEAIQZBACENIwBBEGsiESQAAkAgAkEBRyACQSRNcUUEQEHwwgJBHDYCAAwBCwNAAn8gAygCBCIEIAMoAmhHBEAgAyAEQQFqNgIEIAQtAAAMAQsgAxAqCyIEEI4CDQALAkACQCAEQStrDgMAAQABC0F/QQAgBEEtRhshDSADKAIEIgQgAygCaEcEQCADIARBAWo2AgQgBC0AACEEDAELIAMQKiEECwJAAkACQAJAIAJBAEcgAkEQR3EgBEEwR3JFBEACfyADKAIEIgQgAygCaEcEQCADIARBAWo2AgQgBC0AAAwBCyADECoLIgRBX3FB2ABGBEBBECECAn8gAygCBCIEIAMoAmhHBEAgAyAEQQFqNgIEIAQtAAAMAQsgAxAqCyIEQZHpAWotAABBEEkNAyADKQNwQgBZBEAgAyADKAIEQQFrNgIECyADQgAQuQEMBgsgAg0BQQghAgwCCyACQQogAhsiAiAEQZHpAWotAABLDQAgAykDcEIAWQRAIAMgAygCBEEBazYCBAsgA0IAELkBQfDCAkEcNgIADAQLIAJBCkcNACAEQTBrIgVBCU0EQEEAIQQDQCAEQQpsIAVqIgRBmbPmzAFJAn8gAygCBCICIAMoAmhHBEAgAyACQQFqNgIEIAItAAAMAQsgAxAqC0EwayIFQQlNcQ0ACyAErSETCyAFQQlLDQIgE0IKfiEVIAWtIRQDQAJ/IAMoAgQiAiADKAJoRwRAIAMgAkEBajYCBCACLQAADAELIAMQKgsiBEEwayIGQQlNIBQgFXwiE0Kas+bMmbPmzBlUcUUEQEEKIQIgBkEJTQ0DDAQLIBNCCn4iFSAGrSIUQn+FWA0AC0EKIQIMAQsgAiACQQFrcQRAIARBkekBai0AACIGIAJJBEADQCAGIAIgBWxqIgVBx+PxOEkCfyADKAIEIgYgAygCaEcEQCADIAZBAWo2AgQgBi0AAAwBCyADECoLIgRBkekBai0AACIGIAJJcQ0ACyAFrSETCyACIAZNDQEgAq0hFwNAIBMgF34iFSAGrUL/AYMiFEJ/hVYNAiAUIBV8IRMgAgJ/IAMoAgQiBiADKAJoRwRAIAMgBkEBajYCBCAGLQAADAELIAMQKgsiBEGR6QFqLQAAIgZNDQIgESAXQgAgE0IAECkgESkDCFANAAsMAQsgAkEXbEEFdkEHcUGR6wFqLAAAIQwgBEGR6QFqLQAAIgUgAkkEQANAIAUgBiAMdHIiBkGAgIDAAEkCfyADKAIEIgUgAygCaEcEQCADIAVBAWo2AgQgBS0AAAwBCyADECoLIgRBkekBai0AACIFIAJJcQ0ACyAGrSETCyACIAVNDQBCfyAMrSIViCIUIBNUDQADQCAFrUL/AYMgEyAVhoQhEyACAn8gAygCBCIGIAMoAmhHBEAgAyAGQQFqNgIEIAYtAAAMAQsgAxAqCyIEQZHpAWotAAAiBU0NASATIBRYDQALCyACIARBkekBai0AAE0NAANAIAICfyADKAIEIgYgAygCaEcEQCADIAZBAWo2AgQgBi0AAAwBCyADECoLQZHpAWotAABLDQALQfDCAkHEADYCAEEAIQ1CfyETCyADKQNwQgBZBEAgAyADKAIEQQFrNgIECyANQQFyRSATQn9RcQRAQfDCAkHEADYCAEJ+IRMMAQsgEyANrCIUhSAUfSETCyARQRBqJAAgAykDeEIAIAMoAgQgAygCLGusfVENByAIRSALQfAAR3JFBEAgCCATPgIADAMLIAggECATEMsKDAILIAhFDQEgBykDECEVIAcpAwghFAJAAkACQCAQDgMAAQIECyAIIBQgFRD8CjgCAAwDCyAIIBQgFRCsBjkDAAwCCyAIIBQ3AwAgCCAVNwMIDAELQR8gBEEBaiALQeMARyIMGyEFAkAgEEEBRgRAIAghAiAJBEAgBUECdBBHIgJFDQcLIAdCADcCqAJBACEEA0AgAiEAAkADQAJ/IAMoAgQiAiADKAJoRwRAIAMgAkEBajYCBCACLQAADAELIAMQKgsiAiAHai0AIUUNASAHIAI6ABsgB0EcaiAHQRtqQQEgB0GoAmoQygQiAkF+Rg0AQQAhCiACQX9GDQsgAARAIAAgBEECdGogBygCHDYCACAEQQFqIQQLIAlFIAQgBUdyDQALQQEhBiAAIAVBAXRBAXIiBUECdBDTBCICDQEMCwsLQQAhCiAAIQUgB0GoAmoEfyAHKAKoAgVBAAsNCAwBCyAJBEBBACEEIAUQRyICRQ0GA0AgAiEAA0ACfyADKAIEIgIgAygCaEcEQCADIAJBAWo2AgQgAi0AAAwBCyADECoLIgIgB2otACFFBEBBACEFIAAhCgwECyAAIARqIAI6AAAgBEEBaiIEIAVHDQALQQEhBiAAIAVBAXRBAXIiBRDTBCICDQALIAAhCkEAIQAMCQtBACEEIAgEQANAAn8gAygCBCIAIAMoAmhHBEAgAyAAQQFqNgIEIAAtAAAMAQsgAxAqCyIAIAdqLQAhBEAgBCAIaiAAOgAAIARBAWohBAwBBUEAIQUgCCIAIQoMAwsACwALA0ACfyADKAIEIgAgAygCaEcEQCADIABBAWo2AgQgAC0AAAwBCyADECoLIAdqLQAhDQALQQAhAEEAIQpBACEFCyADKAIEIQIgAykDcEIAWQRAIAMgAkEBayICNgIECyADKQN4IAIgAygCLGusfCIUUCAMIBQgFVFyRXINAiAJBEAgCCAANgIACwJAIAtB4wBGDQAgBQRAIAUgBEECdGpBADYCAAsgCkUEQEEAIQoMAQsgBCAKakEAOgAACyAFIQALIAMoAgQgAygCLGusIAMpA3ggFnx8IRYgDiAIQQBHaiEOCyABQQFqIQQgAS0AASIBDQEMCAsLIAUhAAwBC0EBIQZBACEKQQAhAAwCCyAJIQYMAwsgCSEGCyAODQELQX8hDgsgBkUNACAKEAsgABALCyAHQbACaiQAIANBkAFqJAAgDgtDAAJAIABFDQACQAJAAkACQCABQQJqDgYAAQICBAMECyAAIAI8AAAPCyAAIAI9AQAPCyAAIAI+AgAPCyAAIAI3AwALCywBAX8gACgCACIBBEAgARDeCkF/EOsBRQRAIAAoAgBFDwsgAEEANgIAC0EBC50BAgN/AX4jAEEQayIEJAAgBCACKQMAQgBClfip+pe33puef0IAECkgBCkDCCAEKQMAhSIGp0H/AXFBgAJyIQIgBiABMQAeiKchAyABKAIQIQUgASgCDCEBA0AgAiABIANBA3RqKAIAT0UEQCADQQFqIgNBACADIAVHGyEDIAJBgAJqIQIMAQsLIAAgAzYCBCAAIAI2AgAgBEEQaiQACywBAX8gACgCACIBBEAgARDkCkF/EOsBRQRAIAAoAgBFDwsgAEEANgIAC0EBC5cFAQh/IAEQ0goEQEEEIAEgAUEETRshA0EBIAAgAEEBTRshBwNAAkAgAyAHakEBa0EAIANrcSIAIAcgACAHSxshBEEAIQEjAEEQayIIJAACQCADQQNxDQAgBCADcA0AAn8CQEEwAn8gA0EIRgRAIAQQRwwBC0EcIQEgA0EDcSADQQRJcg0BIANBAnYiACAAQQFrcQ0BQTAhAUFAIANrIARJDQECf0EQIQECQEEQQRAgAyADQRBNGyIAIABBEE0bIgIgAkEBa3FFBEAgAiEADAELA0AgASIAQQF0IQEgACACSQ0ACwsgBEFAIABrTwRAQfDCAkEwNgIAQQAMAQtBAEEQIARBC2pBeHEgBEELSRsiBSAAakEMahBHIgJFDQAaIAJBCGshAQJAIABBAWsgAnFFBEAgASEADAELIAJBBGsiCSgCACIEQXhxIAAgAmpBAWtBACAAa3FBCGsiAiAAQQAgAiABa0EPTRtqIgAgAWsiBmshAiAEQQNxRQRAIAEoAgAhASAAIAI2AgQgACABIAZqNgIADAELIAAgAiAAKAIEQQFxckECcjYCBCAAIAJqIgIgAigCBEEBcjYCBCAJIAYgCSgCAEEBcXJBAnI2AgAgASAGaiICIAIoAgRBAXI2AgQgASAGENIECwJAIAAoAgQiAkEDcUUNACACQXhxIgEgBUEQak0NACAAIAUgAkEBcXJBAnI2AgQgACAFaiIEIAEgBWsiAkEDcjYCBCAAIAFqIgEgASgCBEEBcjYCBCAEIAIQ0gQLIABBCGoLCyIARQ0BGiAIIAA2AgxBACEBCyABCyEAQQAgCCgCDCAAGyEBCyAIQRBqJAAgAQ0AQejYAigCACIARQ0AIAAREAAMAQsLIAEPCyAAEBcLBwAgASAAawsJACAAIAEQ0AoLBwAgAEEISwsTACABENIKBEAgABALDwsgABALC4EBAQN/IwBBEGsiBCQAIwBBIGsiAyQAIANBGGogACABEKAGIANBEGogA0EMaiIBIAMoAhggAygCHCACEJ8GIAMgACADKAIQEJ4GNgIMIAMgAiADKAIUEM0ENgIIIARBCGogASADQQhqENMBIANBIGokACAEKAIMIQUgBEEQaiQAIAULCQAgABDmARALCw4AQQAgACAAQX8Q6wEbC7cBAgR+AX8gACgCACIGKQMIIQIgASkDACIDIAYpAwAiBFIgAiABKQMIIgVSckUEQCAAQQE6ACBBAg8LAkACQCABLQAwIgZBBEYEfyACIAVSIAMgBFpyDQEgARCKASADfCAEVgRAIAEpAwAhAiAAKAIAKQMAIQMgAEEBOgAgIAAgAyACfTcDGEECDwsgAS0AMAUgBgtFDQELIAAgARCKASAAKQMIfDcDCAsgACAAKQMQQgF8NwMQQQALqQEBA38jAEEQayIDJAAgASACENEKIgVB7////wdNBEACQCAFENQDBEAgACAFEHsgACEEDAELIANBCGogACAFELUCQQFqEIoCIAMoAgwaIAAgAygCCCIEEJUBIAAgAygCDBCUASAAIAUQcAsDQCABIAJHBEAgBCABEIkBIARBAWohBCABQQFqIQEMAQsLIANBADoAByAEIANBB2oQiQEgA0EQaiQADwsQaAALEAAgAEIANwIAIABBADYCCAsPACAAIAAoAhggAWo2AhgLFwAgACACNgIcIAAgATYCFCAAIAE2AhgLVwECfwJAIAAoAgAiAkUNAAJ/IAIoAhgiAyACKAIcRgRAIAIgASACKAIAKAI0EQMADAELIAIgA0EEajYCGCADIAE2AgAgAQtBfxDrAUUNACAAQQA2AgALCzEBAX8gACgCDCIBIAAoAhBGBEAgACAAKAIAKAIoEQIADwsgACABQQRqNgIMIAEoAgALJwEBfyAAKAIMIgEgACgCEEYEQCAAIAAoAgAoAiQRAgAPCyABKAIAC0QBAX8gACgCCCIDIAIgAWtB8ABtQfAAbGohAgNAIAIgA0ZFBEAgAyABEDhB8ABqIQMgAUHwAGohAQwBCwsgACACNgIICycBAX8CQCAAKAIAIgJFDQAgAiABEOIKQX8Q6wFFDQAgAEEANgIACwsJACAAEKQGEAsLPQEBfyAAKAIYIgIgACgCHEYEQCAAIAEQuwIgACgCACgCNBEDAA8LIAAgAkEBajYCGCACIAE6AAAgARC7Ags0AQF/IAAoAgwiASAAKAIQRgRAIAAgACgCACgCKBECAA8LIAAgAUEBajYCDCABLAAAELsCCyoBAX8gACgCDCIBIAAoAhBGBEAgACAAKAIAKAIkEQIADwsgASwAABC7AgsPACAAIAAoAgAoAhgRAgALCAAgACgCEEULBABBfwsjAANAIAAgAUcEQCACQcgAayAAQcgAayIAEGchAgwBCwsgAgsUACAAIAAoAgQgARA4QfAAajYCBAsOACAAIAAgAWogAhDUCgsjAANAIAAgAUcEQCACQfAAayAAQfAAayIAEDghAgwBCwsgAgsIACAAEJ0GGgsKACABIABrQQJ1C4QBAQN/IwBBEGsiBSQAIAVBADoADiMAQRBrIgMkACAAIAEQ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IAMoAgQiAkYEQCAAIQIMAQsgAyACQQhrIgQ2AgQgA0EIaiAEEDYNAQsLIAIgAykDCDcDACAGQQFqIgZBCEcNACADKAIUQQhqIAFGIQUMAgsgAygCFCIEQQhqIQIMAAsACyADQSBqJAAgBQsMACAAIAAoAgQQ8QoLzQEBAX8jAEEgayIGJAAgBiABNgIYIAYgADYCHCAGIAI2AhQgBiADNgIQIAYgBDYCDCAAIAEgAiADIAUQ9gohBQJAIAQgAxA2RQ0AIAZBEGogBkEMahBYIAYoAhAgAhA2RQRAIAVBAWohBQwBCyAGQRRqIAZBEGoQWCAGKAIUIAEQNkUEQCAFQQJqIQUMAQsgBkEYaiAGQRRqEFggBigCGCAAEDZFBEAgBUEDaiEFDAELIAVBBGohBSAGQRxqIAZBGGoQWAsgBkEgaiQAIAULEgAgACABIAIgAyAEIAUQ+QoaCxAAIAAgASACIAMgBBD2ChoLtQMCA38BfiMAQSBrIgMkAAJAIAFC////////////AIMiBUKAgICAgIDAwD99IAVCgICAgICAwL/AAH1UBEAgAUIZiKchBCAAUCABQv///w+DIgVCgICACFQgBUKAgIAIURtFBEAgBEGBgICABGohAgwCCyAEQYCAgIAEaiECIAAgBUKAgIAIhYRCAFINASACIARBAXFqIQIMAQsgAFAgBUKAgICAgIDA//8AVCAFQoCAgICAgMD//wBRG0UEQCABQhmIp0H///8BcUGAgID+B3IhAgwBC0GAgID8ByECIAVC////////v7/AAFYNAEEAIQIgBUIwiKciBEGR/gBJDQAgA0EQaiAAIAFC////////P4NCgICAgICAwACEIgUgBEGB/gBrEGMgAyAAIAVBgf8AIARrEL0CIAMpAwgiAEIZiKchAiADKQMAIAMpAxAgAykDGIRCAFKthCIFUCAAQv///w+DIgBCgICACFQgAEKAgIAIURtFBEAgAkEBaiECDAELIAUgAEKAgIAIhYRCAFINACACQQFxIAJqIQILIANBIGokACACIAFCIIinQYCAgIB4cXK+C6oPAgV/D34jAEHQAmsiBSQAIARC////////P4MhCyACQv///////z+DIQogAiAEhUKAgICAgICAgIB/gyENIARCMIinQf//AXEhCAJAAkAgAkIwiKdB//8BcSIJQf//AWtBgoB+TwRAIAhB//8Ba0GBgH5LDQELIAFQIAJC////////////AIMiDEKAgICAgIDA//8AVCAMQoCAgICAgMD//wBRG0UEQCACQoCAgICAgCCEIQ0MAgsgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbRQRAIARCgICAgICAIIQhDSADIQEMAgsgASAMQoCAgICAgMD//wCFhFAEQCADIAJCgICAgICAwP//AIWEUARAQgAhAUKAgICAgIDg//8AIQ0MAwsgDUKAgICAgIDA//8AhCENQgAhAQwCCyADIAJCgICAgICAwP//AIWEUARAQgAhAQwCCyABIAyEUARAQoCAgICAgOD//wAgDSACIAOEUBshDUIAIQEMAgsgAiADhFAEQCANQoCAgICAgMD//wCEIQ1CACEBDAILIAxC////////P1gEQCAFQcACaiABIAogASAKIApQIgYbeSAGQQZ0rXynIgZBD2sQY0EQIAZrIQYgBSkDyAIhCiAFKQPAAiEBCyACQv///////z9WDQAgBUGwAmogAyALIAMgCyALUCIHG3kgB0EGdK18pyIHQQ9rEGMgBiAHakEQayEGIAUpA7gCIQsgBSkDsAIhAwsgBUGgAmogC0KAgICAgIDAAIQiEkIPhiADQjGIhCICQgBCgICAgLDmvIL1ACACfSIEQgAQKSAFQZACakIAIAUpA6gCfUIAIARCABApIAVBgAJqIAUpA5gCQgGGIAUpA5ACQj+IhCIEQgAgAkIAECkgBUHwAWogBEIAQgAgBSkDiAJ9QgAQKSAFQeABaiAFKQP4AUIBhiAFKQPwAUI/iIQiBEIAIAJCABApIAVB0AFqIARCAEIAIAUpA+gBfUIAECkgBUHAAWogBSkD2AFCAYYgBSkD0AFCP4iEIgRCACACQgAQKSAFQbABaiAEQgBCACAFKQPIAX1CABApIAVBoAFqIAJCACAFKQO4AUIBhiAFKQOwAUI/iIRCAX0iAkIAECkgBUGQAWogA0IPhkIAIAJCABApIAVB8ABqIAJCAEIAIAUpA6gBIAUpA6ABIgwgBSkDmAF8IgQgDFStfCAEQgFWrXx9QgAQKSAFQYABakIBIAR9QgAgAkIAECkgBiAJIAhraiEGAn8gBSkDcCITQgGGIg4gBSkDiAEiD0IBhiAFKQOA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NwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsgACACEIALCw8LIAIgAigCACIBQQRqNgIAIAAgATQCADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATUCADcDAA8LIAIgAigCAEEHakF4cSIBQQhqNgIAIAAgASkDADcDAAttAQR/IAAoAgAsAAAQuAFFBEBBAA8LA0AgACgCACEDQX8hASACQcyZs+YATQRAQX8gAywAAEEwayIEIAJBCmwiAWogBCABQf////8Hc0obIQELIAAgA0EBajYCACABIQIgAywAARC4AQ0ACyABC4sTAhZ/AX4jAEHQAGsiBiQAIAYgATYCTCAGQTdqIRYgBkE4aiEQAkACQAJAA0BBACEFA0AgASELIAUgD0H/////B3NKDQIgBSAPaiEPAkACQAJAIAEiBS0AACIHBEADQAJAAkAgB0H/AXEiAUUEQCAFIQEMAQsgAUElRw0BIAUhBwNAIActAAFBJUcEQCAHIQEMAgsgBUEBaiEFIActAAIhGCAHQQJqIgEhByAYQSVGDQALCyAFIAtrIgUgD0H/////B3MiF0oNCCAABEAgACALIAUQXwsgBQ0GIAYgATYCTCABQQFqIQVBfyEMAkAgASwAARC4AUUNACABLQACQSRHDQAgAUEDaiEFIAEsAAFBMGshDEEBIRELIAYgBTYCTEEAIQoCQCAFLAAAIgdBIGsiAUEfSwRAIAUhCQwBCyAFIQlBASABdCIBQYnRBHFFDQADQCAGIAVBAWoiCTYCTCABIApyIQogBSwAASIHQSBrIgFBIE8NASAJIQVBASABdCIBQYnRBHENAAsLAkAgB0EqRgRAIAlBAWohBwJ/AkAgCSwAARC4AUUNACAJLQACQSRHDQAgBywAAEEwayEBIAlBA2ohB0EBIRECfyAARQRAIAQgAUECdGpBCjYCAEEADAELIAMgAUEDdGooAgALDAELIBENBiAARQRAIAYgBzYCTEEAIRFBACENDAMLIAIgAigCACIBQQRqNgIAQQAhESABKAIACyENIAYgBzYCTCANQQBODQFBACANayENIApBgMAAciEKDAELIAZBzABqEIMLIg1BAEgNCSAGKAJMIQcLQQAhBUF/IQgCfyAHLQAAQS5HBEAgByEBQQAMAQsgBy0AAUEqRgRAIAdBAmohAQJA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//////8/g0KAgICAgIDAAIQhDCALQv///////z+DQoCAgICAgMAAhCELIAYgB0gEQANAAn4gCyAMfSADIARWrX0iCkIAWQRAIAogBCADfSIEhFAEQCAFQSBqIAEgAkIAQgAQOiAFKQMoIQIgBSkDICEEDAULIApCAYYgBEI/iIQMAQsgC0IBhiAEQj+IhAshCyAEQgGGIQQgB0EBayIHIAZKDQALIAYhBwsCQCALIAx9IAMgBFatfSIKQgBTBEAgCyEKDAELIAogBCADfSIEhEIAUg0AIAVBMGogASACQgBCABA6IAUpAzghAiAFKQMwIQQMAQsgCkL///////8/WARAA0AgBEI/iCENIAdBAWshByAEQgGGIQQgDSAKQgGGhCIKQoCAgICAgMAAVA0ACwsgCEGAgAJxIQYgB0EATARAIAVBQGsgBCAKQv///////z+DIAdB+ABqIAZyrUIwhoRCAEKAgICAgIDAwz8QOiAFKQNIIQIgBSkDQCEEDAELIApC////////P4MgBiAHcq1CMIaEIQILIAAgBDcDACAAIAI3AwggBUGAAWokAAu/AgEBfyMAQdAAayIEJAACQCADQYCAAU4EQCAEQSBqIAEgAkIAQoCAgICAgID//wAQOiAEKQMoIQIgBCkDICEBIANB//8BSQRAIANB//8AayEDDAILIARBEGogASACQgBCgICAgICAgP//ABA6Qf3/AiADIANB/f8CThtB/v8BayEDIAQpAxghAiAEKQMQIQEMAQsgA0GBgH9KDQAgBEFAayABIAJCAEKAgICAgICAORA6IAQpA0ghAiAEKQNAIQEgA0H0gH5LBEAgA0GN/wBqIQMMAQsgBEEwaiABIAJCAEKAgICAgICAORA6QeiBfSADIANB6IF9TBtBmv4BaiEDIAQpAzghAiAEKQMwIQELIAQgASACQgAgA0H//wBqrUIwhhA6IAAgBCkDCDcDCCAAIAQpAwA3AwAgBEHQAGokAAs1ACAAIAE3AwAgACACQv///////z+DIARCMIinQYCAAnEgAkIwiKdB//8BcXKtQjCGhDcDCAt8AQJ/IAAgACgCSCIBQQFrIAFyNgJIIAAoAhQgACgCHEcEQCAAQQBBACAAKAIkEQUAGgsgAEEANgIcIABCADcDECAAKAIAIgFBBHEEQCAAIAFBIHI2AgBBfw8LIAAgACgCLCAAKAIwaiICNgIIIAAgAjYCBCABQRt0QR91CywBAn8jAEEQayICJAAgAiABNgIMIABB5ABB+TEgARDUBCEDIAJBEGokACADCxMAIABBACABQcDBAigCABEFABoLhAUBC38gASgCACIEKAIcIQsDQAJAIAQoAhggCk0EQEEBDwsCQAJAAkACQCALIApBMGxqIgMoAghBAWsOAwEAAQILIAAgAygCECIGaiIEKAIAIghFDQEgASADKAIUIgVqIQcgACAFaiEFAkAgASAGaiIGKAIABEAgAygCDBC/AiEDIAIoAgggAyAGKAIAIAQoAgBqbCACKAIAEQMAIghFDQQgCCAFKAIAIAQoAgAgA2wQHSIIIAQoAgAgA2xqIAcoAgAgBigCACADbBAdGiAHKAIAIgMEQCACKAIIIAMgAigCBBEAAAsgBSgCACIDBEAgAigCCCADIAIoAgQRAAALIAcgCDYCACAGIAYoAgAgBCgCAGo2AgAMAQsgBiAINgIAIAcgBSgCADYCAAsgBEEANgIAIAVBADYCAAwBCyABIAMoAhAiBmohCCAAIAZqIQYgAy0AIEEEcQRAIAgoAgANASAEKAIkIAQoAiggBigCABC4BiIDQQBIDQMgBCgCHCADQTBsaiEDCyABIAMoAhQiBGohByAAIARqIQQgAygCHCEFAkACQAJAAkACQAJAIAMoAgwiDEEOaw4DAgEAAwsgBCgCACIFRQ0FIAcoAgAiCUUNBCAFIAkgAhCQC0UNBgwFCyAEKAIEIg1FDQQgBygCBCEJIAVFDQIgDSAFKAIEIgVGDQQgCUUgBSAJRnINAwwECyAEKAIAIAVGDQMgBygCACAFRg0CDAMLIAYoAgBFDQIgCCgCAA0CDAELIAkNAQsgByAEIAwQvwIiBxAdGiAEQQAgBxAeGiADKAIQRQ0AIAggBigCADYCACAGQQA2AgALIApBAWohCiABKAIAIQQMAgsLC0EACy4BA38DQCAAIAJGBEBBAA8LIAEgAmohBCACQQFqIQIgBC0AAEH/AHFFDQALQQELlwUBAn8jAEEgayIDJAAgACgCBCADELkGIQQCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIMDhEACwQDAgUBBAMFBAUGAAcICQoLIAIgASgCACADIARqEJULIARqIgAgAyACKAIAEQQADAsLIAIgASgCACADIARqENcBIARqIgAgAyACKAIAEQQADAoLIAIgASkDACADIARqEJMLIARqIgAgAyACKAIAEQQADAkLIAIgASkDACADIARqENgEIARqIgAgAyACKAIAEQQADAgLIAMgAy0AAEEFcjoAACADIARqIAEoAgA2AAAgAiAEQQRqIgAgAyACKAIAEQQADAcLIAMgAy0AAEEBcjoAACADIARqIAEpAwA3AAAgAiAEQQhqIgAgAyACKAIAEQQADAYLIAMgBGogASgCAEEARzoAACACIARBAWoiACADIAIoAgARBAAMBQsgASgCACIBBH8gARDWAQVBAAshACADIAMtAABBAnI6AAAgAiAAIAMgBGoQ1wEgBGoiBCADIAIoAgARBAAgAiAAIAEgAigCABEEACAAIARqIQAMBAsgASgCACEAIAMgAy0AAEECcjoAACACIAAgAyAEahDXASAEaiIEIAMgAigCABEEACACIAAgASgCBCACKAIAEQQAIAAgBGohAAwDCyABKAIAIQAgAyADLQAAQQJyOgAAIABFBEAgAyAEakEAOgAAIAIgBEEBaiIAIAMgAigCABEEAAwDCyACIAAQWSIBIAMgBGoQ1wEgBGoiBCADIAIoAgARBAAgACACEGUgASAEaiEADAILQffPAEH7xwBB6QxB5CMQAAALIAIgASgCACADIARqEJQLIARqIgAgAyACKAIAEQQACyADQSBqJAAgAAsSACAAQgGGIABCP4eFIAEQ2AQLEgAgAEEBdCAAQR91cyABENcBC2UAIABBAEgEQCABQQE6AAkgAUF/NgAFIAEgAEGAAXI6AAAgASAAQRx1QYABcjoABCABIABBFXZBgAFyOgADIAEgAEEOdkGAAXI6AAIgASAAQQd2QYABcjoAAUEKDwsgACABENcBC4UBAQF/QQEhAgJAAkACQAJAAkACQAJAAkAgACgCDA4RAQEBAgICAQECAgMEAAEFBgYHCyABKAIARQ8LIAEoAgBFDwsgASkDAFAPCyABKgIAQwAAAABbDwsgASsDAEQAAAAAAAAAAGEPCyABKAIAIgBFDQEgAC0AAEUPCyABKAIARSECCyACCw0AIABBpKQBQSQQHRoLDQAgAEGwowFBOBAdGgsNACAAQeihAUEwEB0aCzIAIABB1KABKAIANgIYIABBzKABKQIANwIQIABBxKABKQIANwIIIABBvKABKQIANwIACw4AIABBuJ8BQcgAEB0aCw0AIABB+J0BQSgQHRoLJgAgAEG0nQEpAgA3AhAgAEGsnQEpAgA3AgggAEGknQEpAgA3AgALDQAgAEHEnAFBJBAdGgsNACAAQaCaAUE4EB0aCyYAIABB2JkBKQMANwMQIABB0JkBKQMANwMIIABByJkBKQMANwMACyYAIABBhJkBKAIANgIQIABB/JgBKQIANwIIIABB9JgBKQIANwIACzIAIABBtJgBKAIANgIYIABBrJgBKQIANwIQIABBpJgBKQIANwIIIABBnJgBKQIANwIACzIAIABB6JQBKQMANwMYIABB4JQBKQMANwMQIABB2JQBKQMANwMIIABB0JQBKQMANwMACw4AIABB2JIBQcAAEB0aCyYAIABBlJIBKAIANgIQIABBjJIBKQIANwIIIABBhJIBKQIANwIACw0AIABBkJEBQTgQHRoLcgEBfyMAQRBrIgMkAAJAIAAtABBBAUYEQCABIAIpAwA3AwAgASACKQMINwMIDAELIAMgAjYCDCADIAA2AgggAygCDCEBIAMoAggiABDEASAAIAEpAwg3AwggACABKQMANwMAIABBAToAEAsgA0EQaiQACw0AIABBwPEAQTAQHRoLDgAgAEHI7gBB4AAQHRoLDQAgAEGo6wBBKBAdGgswACAAEMQBIAAgASgCCDYCCCAAIAEpAgA3AgAgAUIANwIAIAFBADYCCCAAQQA6ABALQwEBfyMAQRBrIgMkAAJAIAAtABBFBEAgASACEBwMAQsgAyACNgIMIAMgADYCCCADKAIIIAMoAgwQqwsLIANBEGokAAsOACAAKAIAIAEgAhCnCwsVACAAQYDoADYCACAAQQhqEAoaIAALDgAgAEEIahAKGiAAEAsLCgAgAEEIahAKGgsVACAAQdznADYCACAAQQhqEAoaIAALLwAgABBEIAAgASgCCDYCCCAAIAEpAgA3AgAgAUIANwIAIAFBADYCCCAAQQQ6ABgLbAECfyABIAAoAgQgACgCACABKAIEEOsKIgI2AgQgACgCACEDIAAgAjYCACABIAM2AgQgACgCBCECIAAgASgCCDYCBCABIAI2AgggACgCCCECIAAgASgCDDYCCCABIAI2AgwgASABKAIENgIACxUAIABB8OYANgIAIABBBGoQZhogAAtFAQF/IwBBEGsiAyQAAkAgAC0AGEEERgRAIAEgAhAcDAELIAMgAjYCDCADIAA2AgggAygCCCADKAIMELILCyADQRBqJAALDgAgAEEEahBmGiAAEAsLCgAgAEEEahBmGgsVACAAQczmADYCACAAQQRqEGYaIAALYgAgACABKAIANgIAIABBBGogAhAmGiAAIAMoAgg2AhggACADKQIANwIQIANCADcCACADQQA2AgggACAEKQMANwMgIAAgBSgCADYCKCAAIAYoAgA2AiwgACAHLQAAOgAwIAALEwAgAEEQahAKGiAAQQRqEDsgAAsNACAAIAEgAkEHEMUJCxoAIAAgASgCADYCACAAQQhqIAFBCGoQ4AMaCz0BAX8jAEEQayICJAAgAC0AEEEGRwRAIAIgATYCDCACIAA2AgggAigCCCIAEDcgAEEGOgAQCyACQRBqJAALFQAgAEHg5QA2AgAgAEEQahASGiAAC3EBAX8jAEEQayIDJAACQCAALQAQQQVGBEAgASACKQMANwMAIAEgAikDCDcDCAwBCyADIAI2AgwgAyAANgIIIAMoAgwhASADKAIIIgAQNyAAIAEpAwg3AwggACABKQMANwMAIABBBToAEAsgA0EQaiQACy8AIAAQNyAAIAEoAgg2AgggACABKQIANwIAIAFCADcCACABQQA2AgggAEEEOgAQC0UBAX8jAEEQayIDJAACQCAALQAQQQRGBEAgASACEBwMAQsgAyACNgIMIAMgADYCCCADKAIIIAMoAgwQwAsLIANBEGokAAvGAQEHfwJ/IAEQkAIhBAJAIAAoArgEIgNFDQAgACgCtAQCfyADQQFrIARxIANpIgJBAU0NABogBCADIARLDQAaIAQgA3ALIgZBAnRqKAIAIgVFDQAgA0EBayEHIAJBAUshCANAIAUoAgAiBUUNASAFKAIEIgIgBEcEQAJAIAhFBEAgAiAHcSECDAELIAIgA0kNACACIANwIQILIAIgBkcNAgwBCyAFQQhqIAEQIkUNAAsgBQwBC0EACyIBQRRqIABBpA5qIAEbCw0AIAAgASACQQMQxQkLOQEDfyAAKAKoAyEBIAAoAqQDIQADQCAAIAFGIgJFBEAgACIDQYACaiEAIAMpA4ABQgBVDQELCyACC50EAQl/IwBBkAFrIgUkAAJAIAAtALQCRQ0AQQEQFQRAIAVBCGoQEyEHIAVBATYCBCAHIABBwANqEBFBsxEQDRogBUEEahAUCyMAQZABayIDJAAgAEEQaiIBKAKsASEEIAEoAqgBIQIDQCACIARGBEAgASABKQPoATcD8AFBARAVBEAgA0EIahATIQggA0EBNgIEIAggAUGIAmoQEUGa0wAQDSABKQPwARByGiADQQRqEBQLIANBkAFqJAAFIAJBAToALCACQTBqIQIMAQsLIABBrAJqIQYgACgCqAIhAANAIAAgBkYNASMAQZABayIDJAACQCAAQSBqIgEtALgDRQ0AIAEoApABIAEoApQBRg0AQQAQFQRAIANBCGoQEyEJIANBADYCBCAJIAFBxANqEBFB5tQAEA0gASgClAEgASgCkAFrQThtEGkaIANBBGoQFAsgAUGoAmoiBCABQeABahDoAyABIAEoApQBIAEoApABa0E4ba03A8gCIANBBGoiAiABIARBASABKQOYAhD9BiABQdACaiACEBwgAhAKGiACIAEgBEEAIAEpA5gCEP0GIAFB3AJqIAIQHCACEAoaIAEoAmghBCABKAJkIQEDQCABIARHBEACQCABQRBqIgItAJgBRQRAIAIQhwcMAQsgAhB1EOkHCyABQdgBaiEBDAELCwsgA0GQAWokACAAEMIBIQAMAAsACyAFQZABaiQAC2MCAn8BfCMAQRBrIgMkAAJAIAAtABBBAkYEQCABIAIrAwA5AwAMAQsgAyACNgIMIAMgADYCCCADKAIMIQQgAygCCCIAEDcgBCsDACEFIABBAjoAECAAIAU5AwALIANBEGokAAteAQN/IwBBEGsiASQAIAEgADYCDCABKAIMIgAoAgAEQCAAKAIAIQMgACgCBCECA0AgAiADRwRAIAJBOGsQugshAgwBCwsgACADNgIEIAEoAgwoAgAQCwsgAUEQaiQAC2MCAn8BfiMAQRBrIgMkAAJAIAAtABBBAUYEQCABIAIpAwA3AwAMAQsgAyACNgIMIAMgADYCCCADKAIMIQQgAygCCCIAEDcgBCkDACEFIABBAToAECAAIAU3AwALIANBEGokAAuuAQEDfwJAIAAtACgiAiABLQAoRgRAIAJFDQEjAEEQayICJAACQCABQQhqIgEtABgiA0H/AUYiBCAAQQhqIgAtABhB/wFGcQ0AIAQEQCAAEH0MAQsgAiAANgIEIAJB0OUAKQMANwMIIAJBBGogACABIAJBCGogA0ECdGooAgARBAALIAJBEGokAA8LIAIEQCAALQAoBEAgAEEIahB9IABBADoAKAsPCyAAIAEQ2QYLC6wBAQJ/IAAtANgDBEAgABDnBCAAQQA6ANgDCyMAQRBrIgIkACABKAIAIQMgAkEEakGp2QAQDCEBIABBADYCACAAIAEoAgg2AgwgACABKQIANwIEIAFCADcCACABQQA2AgggAEEQahDUBiAAQQA6AKADIABBADoAgAMgAEGkA2oQyAEgAEEAOgDQAyAAQgA3A8gDIAAgAxD6BCABEAoaIABBAToA2AMgAkEQaiQAC2oBAn8gAEEANgIIIABCADcCACABKAIEIgIgASgCACIDRwRAIAIgA2tBDG0iAkHWqtWqAU8EQBABAAsgACACEK4JIgM2AgQgACADNgIAIAAgAyACQQxsajYCCCAAIAEoAgAgASgCBBCpCQsLYQICfwF+IwBBEGsiAyQAAkAgAC0AEEUEQCABIAIpAwA3AwAMAQsgAyACNgIMIAMgADYCCCADKAIMIQQgAygCCCIAEDcgBCkDACEFIABBADoAECAAIAU3AwALIANBEGokAAsNACAAIAFByOMAENUJCxYAIAAtALQCBEAgAEHQAmogARDYAQsLDgAgACgCACABIAIQuwsLDAAgACgCACACEL0LC7sBAQF/IwBBgAFrIgQkACAEIAIpAwg3AzggBCACKQMANwMwIARBGGogAxCYAiECIAQgBCkDODcDECAEIAQpAzA3AwggBEFAayIDIAEgBEEIaiACEL4BIAIQJQJAAkAgBC0AeEUNACADELoBIgEtAChFDQBBASECIAEtACBBAUcNACAAIAEpAxg3AwggACABKQMQNwMADAELQQAhAiAAQQA6AAALIAAgAjoAECAEQcgAahCqASAEQYABaiQACwkAIABBABDBBgsOACAAKAIAIAEgAhC/CwsYAQF/QQwQFyIAQQA2AgggAEIANwIAIAALDgAgACgCACABIAIQwwsLDgAgACgCACABIAIQxgsLDgAgACgCACABIAIQyAsLDgAgACgCACABIAIQzAsLPAEBf0HglwFBACABKAIEIAEtAAsiAiACwEEASCICGyABKAIAIAEgAhsQpwEhASAAQQE6ACAgACABNgIEC3wBAn8jAEEQayIC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ABEEAAsgAkEQaiQAC6YBAQd/IwBBEGsiBCQAIwBBEGsiBSQAAn9BASAAIAEQGw0AGkEAIAEgABAbDQAaIwBBEGsiBiQAAn9BASAAQQxqIgIgAUEMaiIDEBsNABpBACADIAIQGw0AGgJ/QQEgAEEYaiICIAFBGGoiAxAbDQAaQQAgAyACEBsNABogACgCJCABKAIkSAsLIQcgBkEQaiQAIAcLIQggBUEQaiQAIARBEGokACAICxUAIABB5OAANgIAIABBCGoQEhogAAsrAQF/IwBBEGsiBSQAIAUgATYCDCAAIAVBDGogAiADIAQQmgQgBUEQaiQACxUAIABBwOAANgIAIABBCGoQEhogAAs1AQF/IwBBEGsiBSQAIAUgAjoACyAFIAE2AgwgACAFQQxqIAVBC2ogAyAEEJoEIAVBEGokAAsOACAAKAIAIAEgAhDqCwsVACAAQZzgADYCACAAQQhqEBIaIAALFQAgAEH43wA2AgAgAEEIahASGiAACxUAIABB1N8ANgIAIABBCGoQEhogAAs/ACAAKAIAIQEjAEEQayIAJAAgAS0AGARAIAAgAjYCDCAAIAE2AgggACgCCCIBEEQgAUEAOgAYCyAAQRBqJAALFQAgAEGw3wA2AgAgAEEIahASGiAACxUAIABBjN8ANgIAIABBCGoQEhogAAsVACAAQejeADYCACAAQQhqEBIaIAALDAAgACAAKAIAEKkECwkAIAAQ6wQQCwsJACAAEOwEEAsLCQAgABDtBBALCwkAIAAQ7gQQCwsJACAAEO8EEAsLCQAgABDEAhALCwcAIAEQkQILDgAgACgCACABIAIQqwkLawEBfyAAKAIAIQMjAEEQayIAJAACQCADLQAQQQRGBEAgASACEIMBDAELIAAgAjYCDCAAIAM2AggjAEEQayIBJAAgACgCCCABQQRqIAAoAgwQECICEMALIAIQChogAUEQaiQACyAAQRBqJAALawEBfyAAKAIAIQMjAEEQayIAJAACQCADLQAYQQRGBEAgASACEIMBDAELIAAgAjYCDCAAIAM2AggjAEEQayIBJAAgACgCCCABQQRqIAAoAgwQECICELILIAIQChogAUEQaiQACyAAQRBqJAALlAEBA38jAEEgayIBJAAgACgCDCICBEAgAkEAIAAoAhBBA3QQHhoLIAAoAgQgACgCAGtBBHUhA0EAIQIDQCACIANGBEAgAUEgaiQABSABQRhqIAAgACgCACACQQR0ahDjAyABIAI2AhQgASABKAIYNgIQIAEgASkCEDcDCCAAIAFBCGogASgCHBAwIAJBAWohAgwBCwsLawEBfyAAKAIAIQMjAEEQayIAJAACQCADLQAYQQJGBEAgASACEPIGDAELIAAgAjYCDCAAIAM2AggjAEEgayIBJAAgACgCCCABQQhqIAAoAgwQ/gMiAhDfCyACEDcgAUEgaiQACyAAQRBqJAALCQAgAEEEENoJCwcAIAEQ7wMLBwAgARC8BwsHACABELMHCwcAIAEQtgcLBwAgARC9AQsgACABIAIpAwA3AwAgASACKQMQNwMQIAEgAikDCDcDCAtiAQJ/IwBBIGsiAiQAAkAgASAAKAIIIAAoAgAiA2tBA3VLBEAgAUGAgICAAk8NASAAIAJBDGogASAAKAIEIANrQQN1IABBCGoQswIiABDIBSAAELICCyACQSBqJAAPCxABAAuUAQEDfyMAQSBrIgEkACAAKAIMIgIEQCACQQAgACgCEEEDdBAeGgsgACgCBCAAKAIAa0ECdSEDQQAhAgNAIAIgA0YEQCABQSBqJAAFIAFBGGogACAAKAIAIAJBAnRqENIHIAEgAjYCFCABIAEoAhg2AhAgASABKQIQNwMIIAAgAUEIaiABKAIcEDAgAkEBaiECDAELCwvXAQEDfyAAKAIAIQMjAEEQayIAJAACQCADLQCYAUEBRgRAIAEgAigCADYCAAJAIAFBCGoiAy0ASCIEIAJBCGoiBS0ASEYEQCAERQ0BIAMgBRC+AwwBCyAEBEAgAxCsCAwBCyADIAUQtwYLIAFB2ABqIAJB2ABqEFogAUHkAGogAkHkAGoQWiABQfAAaiACQfAAahCIAyABIAIpA5ABNwOQAQwBCyAAIAI2AgwgACADNgIIIAAoAgwhASAAKAIIIgIQpQMgAiABEKMIQQE6AJgBCyAAQRBqJAALiQEBAX8gACgCACEDIwBBEGsiACQAAkAgAy0AmAFFBEAgASACKAIANgIAIAFBBGogAkEEahCiCCABQSRqIAJBJGoQnwggAUHEAGogAkHEAGoQiAMMAQsgACACNgIMIAAgAzYCCCAAKAIMIQEgACgCCCICEKUDIAIgARCkCEEAOgCYAQsgAEEQaiQAC5cBAQF/IAAoAgAhAyMAQRBrIgAkAAJAIAMtABBBAUYEQCABIAIQgwEMAQsgACACNgIMIAAgAzYCCCMAQRBrIgMkACAAKAIIIQEgA0EEaiAAKAIMEBAhAiABECUgASACKAIINgIIIAEgAikCADcCACACQgA3AgAgAkEANgIIIAFBAToAECACEAoaIANBEGokAAsgAEEQaiQAC2gCAn8BfiAAKAIAIQMjAEEQayIAJAACQCADLQAQRQRAIAEgAikDADcDAAwBCyAAIAI2AgwgACADNgIIIAAoAgwhBCAAKAIIIgEQJSAEKQMAIQUgAUEAOgAQIAEgBTcDAAsgAEEQaiQACwcAIAEQoAILlAEBA38jAEEgayIBJAAgACgCDCICBEAgAkEAIAAoAhBBA3QQHhoLIAAoAgQgACgCAGtBOG0hA0EAIQIDQCACIANGBEAgAUEgaiQABSABQRhqIAAgACgCACACQThsahCWBCABIAI2AhQgASABKAIYNgIQIAEgASkCEDcDCCAAIAFBCGogASgCHBAwIAJBAWohAgwBCwsLCQAgAEEHENsJCwoAIAEgAhCjCBoLCgAgASACEKQIGguWAQEDfyMAQSBrIgEkACAAKAIMIgIEQCACQQAgACgCEEEDdBAeGgsgACgCBCAAKAIAa0HYAW0hA0EAIQIDQCACIANGBEAgAUEgaiQABSABQRhqIAAgACgCACACQdgBbGoQ4wMgASACNgIUIAEgASgCGDYCECABIAEpAhA3AwggACABQQhqIAEoAhwQMCACQQFqIQIMAQsLCz8AIAFBCGohACABLQBQBEAgACABEM4ICyABQfAAahBNIAFB5ABqEA8aIAFB2ABqEA8aIAAtAEgEQCAAEFsaCwv1AQECfyABKAIIIQIgASgCBCEAA0AgACACRgRAAkAgAUEkaiECIAEoAighAyABKAIkIQADQCAAIANGDQEgASAAKQMYEJQDIABBKGohAAwACwALBSABIABBEGoQvwEgAEGAAWohAAwBCwsgAUHEAGoQTSABKAIwIgAEQCAAEAsLIwBBEGsiACQAIAAgAjYCDCAAKAIMIgIoAgAEQCACEK4FIAAoAgwoAgAQCwsgAEEQaiQAIAEoAhAiAARAIAAQCwsjAEEQayIAJAAgACABQQRqNgIMIAAoAgwiASgCAARAIAEQrwUgACgCDCgCABALCyAAQRBq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AAsACyAEKAIACyADRyEQCyAOQRBqJAAgEA8LIAcoAgAhBQwACwALDAAgABCRChogABALCzkBAX8jAEEQayIAJAAgACAENgIMIAAgAyACazYCCCAAQQxqIABBCGoQ1QMoAgAhBSAAQRBqJAAgBQs0AANAIAEgAkZFBEAgBCADIAEsAAAiACAAQQBIGzoAACAEQQFqIQQgAUEBaiEBDAELCyACCwwAIAIgASABQQBIGwsqAANAIAEgAkZFBEAgAyABLQAAOgAAIANBAWohAyABQQFqIQEMAQsLIAILDwAgACABIAJBsPoBEM8JCyIAIAFBAE4Ef0Gw+gEoAgAgAUH/AXFBAnRqKAIABSABC8ALDwAgACABIAJBqO4BEM8JCyIAIAFBAE4Ef0Go7gEoAgAgAUH/AXFBAnRqKAIABSABC8ALDAAgABCIChogABALCzUAA0AgASACRkUEQCAEIAEoAgAiACADIABBgAFJGzoAACAEQQFqIQQgAUEEaiEBDAELCyACCw4AIAEgAiABQYABSRvACyoAA0AgASACRkUEQCADIAEsAAA2AgAgA0EEaiEDIAFBAWohAQwBCwsgAgsPACAAIAEgAkGw+gEQzgkLHgAgAUH/AE0Ef0Gw+gEoAgAgAUECdGooAgAFIAELCw8AIAAgASACQajuARDOCQseACABQf8ATQR/QajuASgCACABQQJ0aigCAAUgAQsLQQACQANAIAIgA0YNAQJAIAIoAgAiAEH/AEsNACAAQQJ0QYCJAmooAgAgAXFFDQAgAkEEaiECDAELCyACIQMLIAMLQAADQAJAIAIgA0cEfyACKAIAIgBB/wBLDQEgAEECdEGAiQJqKAIAIAFxRQ0BIAIFIAMLDwsgAkEEaiECDAALAAtJAQF/A0AgASACRkUEQEEAIQAgAyABKAIAIgRB/wBNBH8gBEECdEGAiQJqKAIABUEACzYCACADQQRqIQMgAUEEaiEBDAELCyACCyUAQQAhACACQf8ATQR/IAJBAnRBgIkCaigCACABcUEARwVBAAsLDwAgACAAKAIAKAIEEQEACyIBAX8gACEBQazKAkGsygIoAgBBAWoiADYCACABIAA2AgQLDAAgABCNChogABALC70BACMAQRBrIgMkAAJAIAUQlgFFBEAgACAFKAIINgIIIAAgBSkCADcCAAwBCyAFKAIAIQIgBSgCBCEFIwBBEGsiBCQAAkACQAJAIAUQtAQEQCAAIgEgBRB7DAELIAVB7////wNLDQEgBEEIaiAAIAUQ8gJBAWoQ8QIgBCgCDBogACAEKAIIIgEQlQEgACAEKAIMEJQBIAAgBRBwCyABIAIgBUEBahCMAiAEQRBqJAAMAQsQaAALCyADQRBqJAALCQAgACAFEBAaC4gDAQl/IwBB4ANrIgAkACAAQdwDaiIGIAMQJCAGEHEhCiAFEA4EQCAFQQAQxQQoAgAgCkEtEHpGIQsLIAIgCyAAQdwDaiAAQdgDaiAAQdQDaiAAQdADaiAAQcQDahAnIgwgAEG4A2oQJyIGIABBrANqECciByAAQagDahCVCiAAQZIENgIQIABBCGpBACAAQRBqIgIQRiEIAkACfyAFEA4gACgCqANKBEAgBRAOIQkgACgCqAMhDSAHEA4gCSANa0EBdGogBhAOaiAAKAKoA2pBAWoMAQsgBxAOIAYQDmogACgCqANqQQJqCyIJQeUASQ0AIAggCUECdBBHEFEgCCgCACICDQAQGgALIAIgAEEEaiAAIAMoAgQgBRAgIAUQICAFEA5BAnRqIAogCyAAQdgDaiAAKALUAyAAKALQAyAMIAYgByAAKAKoAxCUCiABIAIgACgCBCAAKAIAIAMgBBCxAiEOIAgQRSAHEEAaIAYQQBogDBAKGiAAQdwDahAjIABB4ANqJAAgDgvBBAEMfyMAQaAIayIAJAAgACAFNwMQIAAgBjcDGCAAIABBsAdqIgc2AqwHIAcgAEEQahCOCyEHIABBkgQ2ApAEIABBiARqQQAgAEGQBGoiCRBGIQ4gAEGSBDYCkAQgAEGABGpBACAJEEYhCgJAIAdB5ABPBEAQNSEHIAAgBTcDACAAIAY3AwggAEGsB2ogB0H5MSAAEM8BIgdBf0YNASAOIAAoAqwHEFEgCiAHQQJ0EEcQUSAKELcCDQEgCigCACEJCyAAQfwDaiIIIAMQJCAIEHEiESAAKAKsByIIIAcgCGogCRDpASAHQQBKBEAgACgCrActAABBLUYhDwsgAiAPIABB/ANqIABB+ANqIABB9ANqIABB8ANqIABB5ANqECciECAAQdgDahAnIgggAEHMA2oQJyILIABByANqEJUKIABBkgQ2AjAgAEEoakEAIABBMGoiAhBGIQwCfyAAKALIAyINIAdIBEAgCxAOIAcgDWtBAXRqIAgQDmogACgCyANqQQFqDAELIAsQDiAIEA5qIAAoAsgDakECagsiDUHlAE8EQCAMIA1BAnQQRxBRIAwoAgAiAkUNAQsgAiAAQSRqIABBIGogAygCBCAJIAkgB0ECdGogESAPIABB+ANqIAAoAvQDIAAoAvADIBAgCCALIAAoAsgDEJQKIAEgAiAAKAIkIAAoAiAgAyAEELECIRIgDBBFIAsQQBogCBBAGiAQEAoaIABB/ANqECMgChBFIA4QRSAAQaAIaiQAIBIPCxAaAAuAAwEJfyMAQbABayIAJAAgAEGsAWoiBiADECQgBhBsIQogBRAOBEAgBUEAECEtAAAgCkEtEF5B/wFxRiELCyACIAsgAEGsAWogAEGoAWogAEGnAWogAEGmAWogAEGYAWoQJyIMIABBjAFqECciBiAAQYABahAnIgcgAEH8AGoQmQogAEGSBDYCECAAQQhqQQAgAEEQaiICEEYhCAJAAn8gBRAOIAAoAnxKBEAgBRAOIQkgACgCfCENIAcQDiAJIA1rQQF0aiAGEA5qIAAoAnxqQQFqDAELIAcQDiAGEA5qIAAoAnxqQQJqCyIJQeUASQ0AIAggCRBHEFEgCCgCACICDQAQGgALIAIgAEEEaiAAIAMoAgQgBRAgIAUQICAFEA5qIAogCyAAQagBaiAALACnASAALACmASAMIAYgByAAKAJ8EJgKIAEgAiAAKAIEIAAoAgAgAyAEEP8BIQ4gCBBFIAcQChogBhAKGiAMEAoaIABBrAFqECMgAEGwAWokACAOC7gEAQx/IwBBwANrIgAkACAAIAU3AxAgACAGNwMYIAAgAEHQAmoiBzYCzAIgByAAQRBqEI4LIQcgAEGSBDYC4AEgAEHYAWpBACAAQeABaiIJEEYhDiAAQZIENgLgASAAQdABakEAIAkQRiEKAkAgB0HkAE8EQBA1IQcgACAFNwMAIAAgBjcDCCAAQcwCaiAHQfkxIAAQzwEiB0F/Rg0BIA4gACgCzAIQUSAKIAcQRxBRIAoQtwINASAKKAIAIQkLIABBzAFqIgggAxAkIAgQbCIRIAAoAswCIgggByAIaiAJEIkCIAdBAEoEQCAAKALMAi0AAEEtRiEPCyACIA8gAEHMAWogAEHIAWogAEHHAWogAEHGAWogAEG4AWoQJyIQIABBrAFqECciCCAAQaABahAnIgsgAEGcAWoQmQogAEGSBDYCMCAAQShqQQAgAEEwaiICEEYhDAJ/IAAoApwBIg0gB0gEQCALEA4gByANa0EBdGogCBAOaiAAKAKcAWpBAWoMAQsgCxAOIAgQDmogACgCnAFqQQJqCyINQeUATwRAIAwgDRBHEFEgDCgCACICRQ0BCyACIABBJGogAEEgaiADKAIEIAkgByAJaiARIA8gAEHIAWogACwAxwEgACwAxgEgECAIIAsgACgCnAEQmAogASACIAAoAiQgACgCICADIAQQ/wEhEiAMEEUgCxAKGiAIEAoaIBAQChogAEHMAWoQIyAKEEUgDhBFIABBwANqJAAgEg8LEBoAC7kFAQZ/IwBBwANrIgAkACAAIAI2ArgDIAAgATYCvAMgAEGTBDYCFCAAQRhqIABBIGogAEEUaiIIEEYhCiAAQRBqIgEgBBAkIAEQcSEHIABBADoADyAAQbwDaiACIAMgASAEKAIEIAUgAEEPaiAHIAogCCAAQbADahCeCgRAIwBBEGsiASQAAkAgBhCWAQRAIAYoAgAhCyABQQA2AgwgCyABQQxqEIYBIAZBABBwDAELIAFBADYCCCAGIAFBCGoQhgEgBkEAEHsLIAFBEGokACAALQAPBEAgBiAHQS0QehCGBgsgB0EwEHohASAKKAIAIQIgACgCFCIHQQRrIQMDQAJAIAIgA08NACACKAIAIAFHDQAgAkEEaiECDAELCyMAQRBrIgMkACAGEA4hASAGEJAGIQQCQCACIAcQqAYiCEUNACAGECAgAk0EfyAGECAgBhAOQQJ0aiACTwVBAAtFBEAgCCAEIAFrSwRAIAYgBCABIARrIAhqIAEgARDjCQsgBhAgIAFBAnRqIQQDQCACIAdHBEAgBCACEIYBIAJBBGohAiAEQQRqIQQMAQsLIANBADYCBCAEIANBBGoQhgEgBiABIAhqEK8CDAELIwBBEGsiASQAIANBBGoiBCACIAcQwQogAUEQaiQAIAQQICEIIAQQDiEBIwBBEGsiByQAAkAgASAGEJAGIgkgBhAOIgJrTQRAIAFFDQEgBhAgIgkgAkECdGogCCABEIwCIAYgASACaiIBEK8CIAdBADYCDCAJIAFBAnRqIAdBDGoQhgEMAQsgBiAJIAEgCWsgAmogAiACQQAgASAIEOQJCyAHQRBqJAAgBBBAGgsgA0EQaiQACyAAQbwDaiAAQbgDahAtBEAgBSAFKAIAQQJyNgIACyAAKAK8AyEMIABBEGoQIyAKEEUgAEHAA2okACAMC9UDAQR/IwBB8ARrIgAkACAAIAI2AugEIAAgATYC7AQgAEGTBDYCECAAQcgBaiAAQdABaiAAQRBqIgEQRiEHIABBwAFqIgggBBAkIAgQcSEJIABBADoAvwECQCAAQewEaiACIAMgCCAEKAIEIAUgAEG/AWogCSAHIABBxAFqIABB4ARqEJ4KRQ0AIABBj88AKAAANgC3ASAAQYjPACkAADcDsAEgCSAAQbABaiAAQboBaiAAQYABahDpASAAQZIENgIQIABBCGpBACABEEYhAyABIQQCQCAAKALEASAHKAIAayIBQYkDTgRAIAMgAUECdUECahBHEFEgAygCAEUNASADKAIAIQQLIAAtAL8BBEAgBEEtOgAAIARBAWohBAsgBygCACECA0AgACgCxAEgAk0EQAJAIARBADoAACAAIAY2AgAgAEEQaiAAEMUKQQFHDQAgAxBFDAQLBSAEIABBsAFqIABBgAFqIgEgAUEoaiACEJQGIAFrQQJ1ai0AADoAACAEQQFqIQQgAkEEaiECDAELCxAaAAsQGgALIABB7ARqIABB6ARqEC0EQCAFIAUoAgBBAnI2AgALIAAoAuwEIQogAEHAAWoQIyAHEEUgAEHwBGokACAKC4gEAQV/IwBBkAFrIgAkACAAIAI2AogBIAAgATYCjAEgAEGTBDYCFCAAQRhqIABBIGogAEEUaiIIEEYhCSAAQRBqIgcgBBAkIAcQbCEBIABBADoADyAAQYwBaiACIAMgByAEKAIEIAUgAEEPaiABIAkgCCAAQYQBahCkCgRAAkAgBiwAC0EASARAIAYoAgBBADoAACAGQQA2AgQMAQsgBkEAOgALIAZBADoAAAsgAC0ADwRAIAYgAUEtEF4QnQELIAFBMBBeIQogCSgCACECIAAoAhQiB0EBayEDIApB/wFxIQEDQAJAIAIgA08NACACLQAAIAFHDQAgAkEBaiECDAELCyMAQRBrIgMkACAGEA4hASAGECghBAJAIAIgBxDRCiIIRQ0AIAYQICACTQR/IAYQICAGEA5qIAJPBUEAC0UEQCAIIAQgAWtLBEAgBiAEIAEgBGsgCGogASABEIcGCyAGECAgAWohBANAIAIgB0cEQCAEIAIQiQEgAkEBaiECIARBAWohBAwBCwsgA0EAOgAPIAQgA0EPahCJASAGIAEgCGoQrwIMAQsgBiADIAIgByAGEKEGIgEQICABEA4QbRogARAKGgsgA0EQaiQACyAAQYwBaiAAQYgBahAuBEAgBSAFKAIAQQJyNgIACyAAKAKMASELIABBEGoQIyAJEEUgAEGQAWokACALC8sDAQR/IwBBkAJrIgAkACAAIAI2AogCIAAgATYCjAIgAEGTBDYCECAAQZgBaiAAQaABaiAAQRBqIgEQRiEHIABBkAFqIgggBBAkIAgQbCEJIABBADoAjwECQCAAQYwCaiACIAMgCCAEKAIEIAUgAEGPAWogCSAHIABBlAFqIABBhAJqEKQKRQ0AIABBj88AKAAANgCHASAAQYjPACkAADcDgAEgCSAAQYABaiAAQYoBaiAAQfYAahCJAiAAQZIENgIQIABBCGpBACABEEYhAyABIQQCQCAAKAKUASAHKAIAayIBQeMATgRAIAMgAUECahBHEFEgAygCAEUNASADKAIAIQQLIAAtAI8BBEAgBEEtOgAAIARBAWohBAsgBygCACECA0AgACgClAEgAk0EQAJAIARBADoAACAAIAY2AgAgAEEQaiAAEMUKQQFHDQAgAxBFDAQLBSAEIABB9gBqIgEgAUEKaiACEJcGIABrIABqLQAKOgAAIARBAWohBCACQQFqIQIMAQsLEBoACxAaAAsgAEGMAmogAEGIAmoQLgRAIAUgBSgCAEECcjYCAAsgACgCjAIhCiAAQZABahAjIAcQRSAAQZACaiQAIAoLqQMBCH8jAEGgA2siCCQAIAggCEGgA2oiAzYCDCMAQZABayIHJAAgByAHQYQBajYCHCAAQQhqIAdBIGoiAiAHQRxqIAQgBSAGEKcKIAdCADcDECAHIAI2AgwgCEEQaiICIAgoAgwQ7QohBSAAKAIIIQAjAEEQayIEJAAgBCAANgIMIARBCGogBEEMahC1ASELIAIgB0EMaiAFIAdBEGoQwwohACALELQBIARBEGokACAAQX9GBEAQGgALIAggAiAAQQJ0ajYCDCAHQZABaiQAIAgoAgwhBCMAQRBrIgYkACAGQQhqIQ0jAEEgayIAJAAgAEEYaiACIAQQoAYgAEEQaiEMIABBDGohCSAAKAIYIQUgACgCHCEKIwBBEGsiBCQAIAQgBTYCCCAEIAE2AgwDQCAFIApHBEAgBEEMaiAFKAIAENwKIAQgBUEEaiIFNgIIDAELCyAMIARBCGogBEEMahDTASAEQRBqJAAgACACIAAoAhAQngY2AgwgACAAKAIUNgIIIA0gCSAAQQhqENMBIABBIGokACAGKAIMIQ4gBkEQaiQAIAMkACAOC5ICAQd/IwBBgAFrIgIkACACIAJB9ABqNgIMIABBCGogAkEQaiIDIAJBDGogBCAFIAYQpwogAigCDCEEIwBBEGsiBiQAIAZBCGohDCMAQSBrIgAkACAAQRhqIAMgBBCgBiAAQRBqIQsgAEEMaiEJIAAoAhghBSAAKAIcIQojAEEQayIEJAAgBCAFNgIIIAQgATYCDANAIAUgCkcEQCAEQQxqIAUsAAAQ4AogBCAFQQFqIgU2AggMAQsLIAsgBEEIaiAEQQxqENMBIARBEGokACAAIAMgACgCEBCeBjYCDCAAIAAoAhQ2AgggDCAJIABBCGoQ0wEgAEEgaiQAIAYoAgwhDSAGQRBqJAAgAkGAAWokACANC+wMAQJ/IwBBMGsiByQAIAcgATYCLCAEQQA2AgAgByADECQgBxBxIQggBxAjAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAZBwQBrDjkAARcEFwUXBgcXFxcKFxcXFw4PEBcXFxMVFxcXFxcXFwABAgMDFxcBFwgXFwkLFwwXDRcLFxcREhQWCyAAIAVBGGogB0EsaiACIAQgCBCrCgwYCyAAIAVBEGogB0EsaiACIAQgCBCqCgwXCyAHIAAgASACIAMgBCAFIABBCGogACgCCCgCDBECACIAECAgABAgIAAQDkECdGoQ5wE2AiwMFgsgB0EsaiACIAQgCEECEM0BIQACQCAEKAIAIgFBBHEgAEEBa0EeS3JFBEAgBSAANgIMDAELIAQgAUEEcjYCAAsMFQsgB0GYhwIpAwA3AxggB0GQhwIpAwA3AxAgB0GIhwIpAwA3AwggB0GAhwIpAwA3AwAgByAAIAEgAiADIAQgBSAHIAdBIGoQ5wE2AiwMFAsgB0G4hwIpAwA3AxggB0GwhwIpAwA3AxAgB0GohwIpAwA3AwggB0GghwIpAwA3AwAgByAAIAEgAiADIAQgBSAHIAdBIGoQ5wE2AiwMEwsgB0EsaiACIAQgCEECEM0BIQACQCAEKAIAIgFBBHEgAEEXSnJFBEAgBSAANgIIDAELIAQgAUEEcjYCAAsMEgsgB0EsaiACIAQgCEECEM0BIQACQCAEKAIAIgFBBHEgAEEBa0ELS3JFBEAgBSAANgIIDAELIAQgAUEEcjYCAAsMEQsgB0EsaiACIAQgCEEDEM0BIQACQCAEKAIAIgFBBHEgAEHtAkpyRQRAIAUgADYCHAwBCyAEIAFBBHI2AgALDBALIAdBLGogAiAEIAhBAhDNASEAAkAgBCgCACIBQQRxIABBAWsiAEELS3JFBEAgBSAANgIQDAELIAQgAUEEcjYCAAsMDwsgB0EsaiACIAQgCEECEM0BIQACQCAEKAIAIgFBBHEgAEE7SnJFBEAgBSAANgIEDAELIAQgAUEEcjYCAAsMDgsgB0EsaiEAIwBBEGsiASQAIAEgAjYCDANAAkAgACABQQxqEC0NACAIQQEgABBJEKUBRQ0AIAAQUxoMAQsLIAAgAUEMahAtBEAgBCAEKAIAQQJyNgIACyABQRBqJAAMDQsgB0EsaiEBAkAgAEEIaiAAKAIIKAIIEQIAIgAQDkEAIABBDGoQDmtGBEAgBCAEKAIAQQRyNgIADAELIAEgAiAAIABBGGogCCAEQQAQxgQiAiAARyAFKAIIIgFBDEdyRQRAIAVBADYCCAwBCyACIABrQQxHIAFBC0pyRQRAIAUgAUEMajYCCAsLDAwLIAdBwIcCQSwQHSIGIAAgASACIAMgBCAFIAYgBkEsahDnATYCLAwLCyAHQYCIAigCADYCECAHQfiHAikDADcDCCAHQfCHAikDADcDACAHIAAgASACIAMgBCAFIAcgB0EUahDnATYCLAwKCyAHQSxqIAIgBCAIQQIQzQEhAAJAIAQoAgAiAUEEcSAAQTxKckUEQCAFIAA2AgAMAQsgBCABQQRyNgIACwwJCyAHQaiIAikDADcDGCAHQaCIAikDADcDECAHQZiIAikDADcDCCAHQZCIAikDADcDACAHIAAgASACIAMgBCAFIAcgB0EgahDnATYCLAwICyAHQSxqIAIgBCAIQQEQzQEhAAJAIAQoAgAiAUEEcSAAQQZKckUEQCAFIAA2AhgMAQsgBCABQQRyNgIACwwHCyAAIAEgAiADIAQgBSAAKAIAKAIUEQgADAcLIAcgACABIAIgAyAEIAUgAEEIaiAAKAIIKAIYEQIAIgAQICAAECAgABAOQQJ0ahDnATYCLAwFCyAFQRRqIAdBLGogAiAEIAgQqAoMBAsgB0EsaiACIAQgCEEEEM0BIQAgBC0AAEEEcUUEQCAFIABB7A5rNgIUCwwDCyAGQSVGDQELIAQgBCgCAEEEcjYCAAwBCyMAQRBrIgAkACAAIAI2AgxBBiEBAkACQCAHQSxqIgIgAEEMaiIDEC0NAEEEIQEgCCACEEkQ9wJBJUcNAEECIQEgAhBTIAMQLUUNAQsgBCAEKAIAIAFyNgIACyAAQRBqJAALIAcoAiwLIQkgB0EwaiQAIAkLTAEDfyMAQRBrIgYkACAGIAE2AgwgBkEIaiIHIAMQJCAHEHEhASAHECMgBUEUaiAGQQxqIAIgBCABEKgKIAYoAgwhCCAGQRBqJAAgCAtOAQN/IwBBEGsiBiQAIAYgATYCDCAGQQhqIgcgAxAkIAcQcSEBIAcQIyAAIAVBEGogBkEMaiACIAQgARCqCiAGKAIMIQggBkEQaiQAIAgLTgEDfyMAQRBrIgYkACAGIAE2AgwgBkEIaiIHIAMQJCAHEHEhASAHECMgACAFQRhqIAZBDGogAiAEIAEQqwogBigCDCEIIAZBEGokACAICzEAIAAgASACIAMgBCAFIABBCGogACgCCCgCFBECACIAECAgABAgIAAQDkECdGoQ5wELXQECfyMAQSBrIgYkACAGQaiIAikDADcDGCAGQaCIAikDADcDECAGQZiIAikDADcDCCAGQZCIAikDADcDACAAIAEgAiADIAQgBSAGIAZBIGoiARDnASEHIAEkACAHC4gMAQJ/IwBBEGsiByQAIAcgATYCDCAEQQA2AgAgByADECQgBxBsIQggBxAjAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAZBwQBrDjkAARcEFwUXBgcXFxcKFxcXFw4PEBcXFxMVFxcXFxcXFwABAgMDFxcBFwgXFwkLFwwXDRcLFxcREhQWCyAAIAVBGGogB0EMaiACIAQgCBCuCgwYCyAAIAVBEGogB0EMaiACIAQgCBCtCgwXCyAHIAAgASACIAMgBCAFIABBCGogACgCCCgCDBECACIAECAgABAgIAAQDmoQ6AE2AgwMFgsgB0EMaiACIAQgCEECEM4BIQACQCAEKAIAIgFBBHEgAEEBa0EeS3JFBEAgBSAANgIMDAELIAQgAUEEcjYCAAsMFQsgB0Kl2r2pwuzLkvkANwMAIAcgACABIAIgAyAEIAUgByAHQQhqEOgBNgIMDBQLIAdCpbK1qdKty5LkADcDACAHIAAgASACIAMgBCAFIAcgB0EIahDoATYCDAwTCyAHQQxqIAIgBCAIQQIQzgEhAAJAIAQoAgAiAUEEcSAAQRdKckUEQCAFIAA2AggMAQsgBCABQQRyNgIACwwSCyAHQQxqIAIgBCAIQQIQzgEhAAJAIAQoAgAiAUEEcSAAQQFrQQtLckUEQCAFIAA2AggMAQsgBCABQQRyNgIACwwRCyAHQQxqIAIgBCAIQQMQzgEhAAJAIAQoAgAiAUEEcSAAQe0CSnJFBEAgBSAANgIcDAELIAQgAUEEcjYCAAsMEAsgB0EMaiACIAQgCEECEM4BIQACQCAEKAIAIgFBBHEgAEEBayIAQQtLckUEQCAFIAA2AhAMAQsgBCABQQRyNgIACwwPCyAHQQxqIAIgBCAIQQIQzgEhAAJAIAQoAgAiAUEEcSAAQTtKckUEQCAFIAA2AgQMAQsgBCABQQRyNgIACwwOCyAHQQxqIQAjAEEQayIBJAAgASACNgIMA0ACQCAAIAFBDGoQLg0AIAhBASAAEEoQpgFFDQAgABBUGgwBCwsgACABQQxqEC4EQCAEIAQoAgBBAnI2AgALIAFBEGokAAwNCyAHQQxqIQECQCAAQQhqIAAoAggoAggRAgAiABAOQQAgAEEMahAOa0YEQCAEIAQoAgBBBHI2AgAMAQsgASACIAAgAEEYaiAIIARBABDIBCICIABHIAUoAggiAUEMR3JFBEAgBUEANgIIDAELIAIgAGtBDEcgAUELSnJFBEAgBSABQQxqNgIICwsMDAsgB0HohgIoAAA2AAcgB0HhhgIpAAA3AwAgByAAIAEgAiADIAQgBSAHIAdBC2oQ6AE2AgwMCwsgB0HwhgItAAA6AAQgB0HshgIoAAA2AgAgByAAIAEgAiADIAQgBSAHIAdBBWoQ6AE2AgwMCgsgB0EMaiACIAQgCEECEM4BIQACQCAEKAIAIgFBBHEgAEE8SnJFBEAgBSAANgIADAELIAQgAUEEcjYCAAsMCQsgB0KlkOmp0snOktMANwMAIAcgACABIAIgAyAEIAUgByAHQQhqEOgBNgIMDAgLIAdBDGogAiAEIAhBARDOASEAAkAgBCgCACIBQQRxIABBBkpyRQRAIAUgADYCGAwBCyAEIAFBBHI2AgALDAcLIAAgASACIAMgBCAFIAAoAgAoAhQRCAAMBwsgByAAIAEgAiADIAQgBSAAQQhqIAAoAggoAhgRAgAiABAgIAAQICAAEA5qEOgBNgIMDAULIAVBFGogB0EMaiACIAQgCBCsCgwECyAHQQxqIAIgBCAIQQQQzgEhACAELQAAQQRxRQRAIAUgAEHsDms2AhQLDAMLIAZBJUYNAQsgBCAEKAIAQQRyNgIADAELIwBBEGsiACQAIAAgAjYCDEEGIQECQAJAIAdBDGoiAiAAQQxqIgMQLg0AQQQhASAIIAIQShD4AkElRw0AQQIhASACEFQgAxAuRQ0BCyAEIAQoAgAgAXI2AgALIABBEGokAAsgBygCDAshCSAHQRBqJAAgCQtMAQN/IwBBEGsiBiQAIAYgATYCDCAGQQhqIgcgAxAkIAcQbCEBIAcQIyAFQRRqIAZBDGogAiAEIAEQrAogBigCDCEIIAZBEGokACAIC04BA38jAEEQayIGJAAgBiABNgIMIAZBCGoiByADECQgBxBsIQEgBxAjIAAgBUEQaiAGQQxqIAIgBCABEK0KIAYoAgwhCCAGQRBqJAAgCAtOAQN/IwBBEGsiBiQAIAYgATYCDCAGQQhqIgcgAxAkIAcQbCEBIAcQIyAAIAVBGGogBkEMaiACIAQgARCuCiAGKAIMIQggBkEQaiQAIAgLLgAgACABIAIgAyAEIAUgAEEIaiAAKAIIKAIUEQIAIgAQICAAECAgABAOahDoAQtAAQJ/IwBBEGsiBiQAIAZCpZDpqdLJzpLTADcDCCAAIAEgAiADIAQgBSAGQQhqIAZBEGoiARDoASEHIAEkACAHC5UBAQd/IwBB0AFrIgAkABA1IQYgACAENgIAIABBsAFqIgcgByAHQRQgBkH8KyAAEIcBIghqIgQgAhDQASEGIABBEGoiBSACECQgBRBxIQogBRAjIAogByAEIAUQ6QEgASAFIAhBAnQgBWoiASAGIABrQQJ0IABqQbAFayAEIAZGGyABIAIgAxCxAiELIABB0AFqJAAgCwuHBAEIfwJ/IwBBoANrIgYkACAGQiU3A5gDIAZBmANqIgdBAXJBuM0AIAIoAgQQwQQhCCAGIAZB8AJqIgk2AuwCEDUhAAJ/IAgEQCACKAIIIQogBkFAayAFNwMAIAYgBDcDOCAGIAo2AjAgCUEeIAAgByAGQTBqEIcBDAELIAYgBDcDUCAGIAU3A1ggBkHwAmpBHiAAIAZBmANqIAZB0ABqEIcBCyEAIAZBkgQ2AoABIAZB5AJqQQAgBkGAAWoQRiEJIAZB8AJqIgohBwJAIABBHk4EQBA1IQACfyAIBEAgAigCCCEHIAYgBTcDECAGIAQ3AwggBiAHNgIAIAZB7AJqIAAgBkGYA2ogBhDPAQwBCyAGIAQ3AyAgBiAFNwMoIAZB7AJqIAAgBkGYA2ogBkEgahDPAQsiAEF/Rg0BIAkgBigC7AIQUSAGKALsAiEHCyAHIAAgB2oiCyACENABIQwgBkGSBDYCgAEgBkH4AGpBACAGQYABaiIHEEYhCAJAIAYoAuwCIAZB8AJqRgRAIAchAAwBCyAAQQN0EEciAEUNASAIIAAQUSAGKALsAiEKCyAGQewAaiIHIAIQJCAKIAwgCyAAIAZB9ABqIAZB8ABqIAcQsQogBxAjIAEgACAGKAJ0IAYoAnAgAiADELECIQ0gCBBFIAkQRSAGQaADaiQAIA0MAQsQGgALC+MDAQh/An8jAEHwAmsiBSQAIAVCJTcD6AIgBUHoAmoiBkEBckGp2QAgAigCBBDBBCEHIAUgBUHAAmoiCDYCvAIQNSEAAn8gBwRAIAIoAgghCSAFIAQ5AyggBSAJNgIgIAhBHiAAIAYgBUEgahCHAQwBCyAFIAQ5AzAgBUHAAmpBHiAAIAVB6AJqIAVBMGoQhwELIQAgBUGSBDYCUCAFQbQCakEAIAVB0ABqEEYhCCAFQcACaiIJIQYCQCAAQR5OBEAQNSEAAn8gBwRAIAIoAgghBiAFIAQ5AwggBSAGNgIAIAVBvAJqIAAgBUHoAmogBRDPAQwBCyAFIAQ5AxAgBUG8AmogACAFQegCaiAFQRBqEM8BCyIAQX9GDQEgCCAFKAK8AhBRIAUoArwCIQYLIAYgACAGaiIKIAIQ0AEhCyAFQZIENgJQIAVByABqQQAgBUHQAGoiBhBGIQcCQCAFKAK8AiAFQcACakYEQCAGIQAMAQsgAEEDdBBHIgBFDQEgByAAEFEgBSgCvAIhCQsgBUE8aiIGIAIQJCAJIAsgCiAAIAVBxABqIAVBQGsgBhCxCiAGECMgASAAIAUoAkQgBSgCQCACIAMQsQIhDCAHEEUgCBBFIAVB8AJqJAAgDAwBCxAaAAsLEQAgACABIAIgAyAEQQAQyQkLEQAgACABIAIgAyAEQQAQyAkLEQAgACABIAIgAyAEQQEQyQkLEQAgACABIAIgAyAEQQEQyAkLzQEBAX8jAEEgayIFJAAgBSABNgIcAkAgAigCBEEBcUUEQCAAIAEgAiADIAQgACgCACgCGBEJACECDAELIAVBEGoiACACECQgABD6AiEBIAAQIwJAIAQEQCAAIAEQpAEMAQsgBUEQaiABEKMBCyAFIAVBEGoQiAE2AgwDQCAFIAVBEGoiABCHAjYCCCAFQQxqIgEgBUEIahDRAQRAIAVBHGogASIAKAIAKAIAENwKIAAQzwMMAQUgBSgCHCECIAAQQBoLCwsgBUEgaiQAIAILjQEBB38jAEHgAGsiACQAEDUhBiAAIAQ2AgAgAEFAayIHIAcgB0EUIAZB/CsgABCHASIIaiIEIAIQ0AEhBiAAQRBqIgUgAhAkIAUQbCEKIAUQIyAKIAcgBCAFEIkCIAEgBSAFIAhqIgEgBiAAayAAakEwayAEIAZGGyABIAIgAxD/ASELIABB4ABqJAAgCwuHBAEIfwJ/IwBBgAJrIgYkACAGQiU3A/gBIAZB+AFqIgdBAXJBuM0AIAIoAgQQwQQhCCAGIAZB0AFqIgk2AswBEDUhAAJ/IAgEQCACKAIIIQogBkFAayAFNwMAIAYgBDcDOCAGIAo2AjAgCUEeIAAgByAGQTBqEIcBDAELIAYgBDcDUCAGIAU3A1ggBkHQAWpBHiAAIAZB+AFqIAZB0ABqEIcBCyEAIAZBkgQ2AoABIAZBxAFqQQAgBkGAAWoQRiEJIAZB0AFqIgohBwJAIABBHk4EQBA1IQACfyAIBEAgAigCCCEHIAYgBTcDECAGIAQ3AwggBiAHNgIAIAZBzAFqIAAgBkH4AWogBhDPAQwBCyAGIAQ3AyAgBiAFNwMoIAZBzAFqIAAgBkH4AWogBkEgahDPAQsiAEF/Rg0BIAkgBigCzAEQUSAGKALMASEHCyAHIAAgB2oiCyACENABIQwgBkGSBDYCgAEgBkH4AGpBACAGQYABaiIHEEYhCAJAIAYoAswBIAZB0AFqRgRAIAchAAwBCyAAQQF0EEciAEUNASAIIAAQUSAGKALMASEKCyAGQewAaiIHIAIQJCAKIAwgCyAAIAZB9ABqIAZB8ABqIAcQswogBxAjIAEgACAGKAJ0IAYoAnAgAiADEP8BIQ0gCBBFIAkQRSAGQYACaiQAIA0MAQsQGgALC+MDAQh/An8jAEHQAWsiBSQAIAVCJTcDyAEgBUHIAWoiBkEBckGp2QAgAigCBBDBBCEHIAUgBUGgAWoiCDYCnAEQNSEAAn8gBwRAIAIoAgghCSAFIAQ5AyggBSAJNgIgIAhBHiAAIAYgBUEgahCHAQwBCyAFIAQ5AzAgBUGgAWpBHiAAIAVByAFqIAVBMGoQhwELIQAgBUGSBDYCUCAFQZQBakEAIAVB0ABqEEYhCCAFQaABaiIJIQYCQCAAQR5OBEAQNSEAAn8gBwRAIAIoAgghBiAFIAQ5AwggBSAGNgIAIAVBnAFqIAAgBUHIAWogBRDPAQwBCyAFIAQ5AxAgBUGcAWogACAFQcgBaiAFQRBqEM8BCyIAQX9GDQEgCCAFKAKcARBRIAUoApwBIQYLIAYgACAGaiIKIAIQ0AEhCyAFQZIENgJQIAVByABqQQAgBUHQAGoiBhBGIQcCQCAFKAKcASAFQaABakYEQCAGIQAMAQsgAEEBdBBHIgBFDQEgByAAEFEgBSgCnAEhCQsgBUE8aiIGIAIQJCAJIAsgCiAAIAVBxABqIAVBQGsgBhCzCiAGECMgASAAIAUoAkQgBSgCQCACIAMQ/wEhDCAHEEUgCBBFIAVB0AFqJAAgDAwBCxAaAAsLEQAgACABIAIgAyAEQQAQywkLEQAgACABIAIgAyAEQQAQygkLEQAgACABIAIgAyAEQQEQywkLEQAgACABIAIgAyAEQQEQygkLzQEBAX8jAEEgayIFJAAgBSABNgIcAkAgAigCBEEBcUUEQCAAIAEgAiADIAQgACgCACgCGBEJACECDAELIAVBEGoiACACECQgABD9AiEBIAAQIwJAIAQEQCAAIAEQpAEMAQsgBUEQaiABEKMBCyAFIAVBEGoQiAE2AgwDQCAFIAVBEGoiABCIAjYCCCAFQQxqIgEgBUEIahDRAQRAIAVBHGogASIAKAIALAAAEOAKIAAQ0AMMAQUgBSgCHCECIAAQChoLCwsgBUEgaiQAIAIL8AIBBH8jAEHAAmsiACQAIAAgAjYCuAIgACABNgK8AiAAQcQBahAnIQYgAEEQaiICIAMQJCACEHFBwIYCQdqGAiAAQdABahDpASACECMgAEG4AWoQJyIDIAMQKBAfIAAgA0EAECEiATYCtAEgACACNgIMIABBADYCCANAAkAgAEG8AmogAEG4AmoQLQ0AIAAoArQBIAMQDiABakYEQCADEA4hAiADIAMQDkEBdBAfIAMgAxAoEB8gACACIANBABAhIgFqNgK0AQsgAEG8AmoiAhBJQRAgASAAQbQBaiAAQQhqQQAgBiAAQRBqIABBDGogAEHQAWoQ+QINACACEFMaDAELCyADIAAoArQBIAFrEB8gAxAgIQkQNSEHIAAgBTYCACAJIAcgABC2CkEBRwRAIARBBDYCAAsgAEG8AmogAEG4AmoQLQRAIAQgBCgCAEECcjYCAAsgACgCvAIhCCADEAoaIAYQChogAEHAAmokACAIC9EDAgF+AX8jAEGAA2siACQAIAAgAjYC+AIgACABNgL8AiAAQdwBaiADIABB8AFqIABB7AFqIABB6AFqEJYGIABB0AFqECciASABECgQHyAAIAFBABAhIgI2AswBIAAgAEEgajYCHCAAQQA2AhggAEEBOgAXIABBxQA6ABYDQAJAIABB/AJqIABB+AJqEC0NACAAKALMASABEA4gAmpGBEAgARAOIQMgASABEA5BAXQQHyABIAEQKBAfIAAgAyABQQAQISICajYCzAELIABB/AJqIgMQSSAAQRdqIABBFmogAiAAQcwBaiAAKALsASAAKALoASAAQdwBaiAAQSBqIABBHGogAEEYaiAAQfABahCVBg0AIAMQUxoMAQsLAkAgAEHcAWoQDkUNACAALQAXRQ0AIAAoAhwiAyAAQSBqa0GfAUoNACAAIANBBGo2AhwgAyAAKAIYNgIACyAAIAIgACgCzAEgBBC3CiAAKQMAIQYgBSAAKQMINwMIIAUgBjcDACAAQdwBaiAAQSBqIAAoAhwgBBBhIABB/AJqIABB+AJqEC0EQCAEIAQoAgBBAnI2AgALIAAoAvwCIQcgARAKGiAAQdwBahAKGiAAQYADaiQAIAcLugMBAX8jAEHwAmsiACQAIAAgAjYC6AIgACABNgLsAiAAQcwBaiADIABB4AFqIABB3AFqIABB2AFqEJYGIABBwAFqECciASABECgQHyAAIAFBABAhIgI2ArwBIAAgAEEQajYCDCAAQQA2AgggAEEBOgAHIABBxQA6AAYDQAJAIABB7AJqIABB6AJqEC0NACAAKAK8ASABEA4gAmpGBEAgARAOIQMgASABEA5BAXQQHyABIAEQKBAfIAAgAyABQQAQISICajYCvAELIABB7AJqIgMQSSAAQQdqIABBBmogAiAAQbwBaiAAKALcASAAKALYASAAQcwBaiAAQRBqIABBDGogAEEIaiAAQeABahCVBg0AIAMQUxoMAQsLAkAgAEHMAWoQDkUNACAALQAHRQ0AIAAoAgwiAyAAQRBqa0GfAUoNACAAIANBBGo2AgwgAyAAKAIINgIACyAFIAIgACgCvAEgBBC4CjkDACAAQcwBaiAAQRBqIAAoAgwgBBBhIABB7AJqIABB6AJqEC0EQCAEIAQoAgBBAnI2AgALIAAoAuwCIQYgARAKGiAAQcwBahAKGiAAQfACaiQAIAYLugMBAX8jAEHwAmsiACQAIAAgAjYC6AIgACABNgLsAiAAQcwBaiADIABB4AFqIABB3AFqIABB2AFqEJYGIABBwAFqECciASABECgQHyAAIAFBABAhIgI2ArwBIAAgAEEQajYCDCAAQQA2AgggAEEBOgAHIABBxQA6AAYDQAJAIABB7AJqIABB6AJqEC0NACAAKAK8ASABEA4gAmpGBEAgARAOIQMgASABEA5BAXQQHyABIAEQKBAfIAAgAyABQQAQISICajYCvAELIABB7AJqIgMQSSAAQQdqIABBBmogAiAAQbwBaiAAKALcASAAKALYASAAQcwBaiAAQRBqIABBDGogAEEIaiAAQeABahCVBg0AIAMQUxoMAQsLAkAgAEHMAWoQDkUNACAALQAHRQ0AIAAoAgwiAyAAQRBqa0GfAUoNACAAIANBBGo2AgwgAyAAKAIINgIACyAFIAIgACgCvAEgBBC5CjgCACAAQcwBaiAAQRBqIAAoAgwgBBBhIABB7AJqIABB6AJqEC0EQCAEIAQoAgBBAnI2AgALIAAoAuwCIQYgARAKGiAAQcwBahAKGiAAQfACaiQAIAYLmwMBA38jAEHQAmsiACQAIAAgAjYCyAIgACABNgLMAiADENIBIQYgAyAAQdABahDSAyEHIABBxAFqIAMg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IQEDQCADQQxrEEAiAyAGRw0ACwsgBkEgaiQAIAEL8AIBBH8jAEGAAmsiACQAIAAgAjYC+AEgACABNgL8ASAAQcQBahAnIQYgAEEQaiICIAMQJCACEGxBwIYCQdqGAiAAQdABahCJAiACECMgAEG4AWoQJyIDIAMQKBAfIAAgA0EAECEiATYCtAEgACACNgIMIABBADYCCANAAkAgAEH8AWogAEH4AWoQLg0AIAAoArQBIAMQDiABakYEQCADEA4hAiADIAMQDkEBdBAfIAMgAxAoEB8gACACIANBABAhIgFqNgK0AQsgAEH8AWoiAhBKQRAgASAAQbQBaiAAQQhqQQAgBiAAQRBqIABBDGogAEHQAWoQ+wINACACEFQaDAELCyADIAAoArQBIAFrEB8gAxAgIQkQNSEHIAAgBTYCACAJIAcgABC2CkEBRwRAIARBBDYCAAsgAEH8AWogAEH4AWoQLgRAIAQgBCgCAEECcjYCAAsgACgC/AEhCCADEAoaIAYQChogAEGAAmokACAIC9EDAgF+AX8jAEGQAmsiACQAIAAgAjYCiAIgACABNgKMAiAAQdABaiADIABB4AFqIABB3wFqIABB3gFqEJoGIABBxAFqECciASABECgQHyAAIAFBABAhIgI2AsABIAAgAEEgajYCHCAAQQA2AhggAEEBOgAXIABBxQA6ABYDQAJAIABBjAJqIABBiAJqEC4NACAAKALAASABEA4gAmpGBEAgARAOIQMgASABEA5BAXQQHyABIAEQKBAfIAAgAyABQQAQISICajYCwAELIABBjAJqIgMQSiAAQRdqIABBFmogAiAAQcABaiAALADfASAALADeASAAQdABaiAAQSBqIABBHGogAEEYaiAAQeABahCZBg0AIAMQVBoMAQsLAkAgAEHQAWoQDkUNACAALQAXRQ0AIAAoAhwiAyAAQSBqa0GfAUoNACAAIANBBGo2AhwgAyAAKAIYNgIACyAAIAIgACgCwAEgBBC3CiAAKQMAIQYgBSAAKQMINwMIIAUgBjcDACAAQdABaiAAQSBqIAAoAhwgBBBhIABBjAJqIABBiAJqEC4EQCAEIAQoAgBBAnI2AgALIAAoAowCIQcgARAKGiAAQdABahAKGiAAQZACaiQAIAcLugMBAX8jAEGAAmsiACQAIAAgAjYC+AEgACABNgL8ASAAQcABaiADIABB0AFqIABBzwFqIABBzgFqEJoGIABBtAFqECciASABECgQHyAAIAFBABAhIgI2ArABIAAgAEEQajYCDCAAQQA2AgggAEEBOgAHIABBxQA6AAYDQAJAIABB/AFqIABB+AFqEC4NACAAKAKwASABEA4gAmpGBEAgARAOIQMgASABEA5BAXQQHyABIAEQKBAfIAAgAyABQQAQISICajYCsAELIABB/AFqIgMQSiAAQQdqIABBBmogAiAAQbABaiAALADPASAALADOASAAQcABaiAAQRBqIABBDGogAEEIaiAAQdABahCZBg0AIAMQVBoMAQsLAkAgAEHAAWoQDkUNACAALQAHRQ0AIAAoAgwiAyAAQRBqa0GfAUoNACAAIANBBGo2AgwgAyAAKAIINgIACyAFIAIgACgCsAEgBBC4CjkDACAAQcABaiAAQRBqIAAoAgwgBBBhIABB/AFqIABB+AFqEC4EQCAEIAQoAgBBAnI2AgALIAAoAvwBIQYgARAKGiAAQcABahAKGiAAQYACaiQAIAYLugMBAX8jAEGAAmsiACQAIAAgAjYC+AEgACABNgL8ASAAQcABaiADIABB0AFqIABBzwFqIABBzgFqEJoGIABBtAFqECciASABECgQHyAAIAFBABAhIgI2ArABIAAgAEEQajYCDCAAQQA2AgggAEEBOgAHIABBxQA6AAYDQAJAIABB/AFqIABB+AFqEC4NACAAKAKwASABEA4gAmpGBEAgARAOIQMgASABEA5BAXQQHyABIAEQKBAfIAAgAyABQQAQISICajYCsAELIABB/AFqIgMQSiAAQQdqIABBBmogAiAAQbABaiAALADPASAALADOASAAQcABaiAAQRBqIABBDGogAEEIaiAAQdABahCZBg0AIAMQVBoMAQsLAkAgAEHAAWoQDkUNACAALQAHRQ0AIAAoAgwiAyAAQRBqa0GfAUoNACAAIANBBGo2AgwgAyAAKAIINgIACyAFIAIgACgCsAEgBBC5CjgCACAAQcABaiAAQRBqIAAoAgwgBBBhIABB/AFqIABB+AFqEC4EQCAEIAQoAgBBAnI2AgALIAAoAvwBIQYgARAKGiAAQcABahAKGiAAQYACaiQAIAYLkAMBAn8jAEGAAmsiACQAIAAgAjYC+AEgACABNgL8ASADENIBIQYgAEHEAWog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IAAgACgCDCIAQQFqNgIMIAAsAAAQuwILBABBfwu+AQEEfyMAQRBrIgQkAANAAkAgAiAFTA0AAkAgACgCDCIDIAAoAhAiBkkEQCAEQf////8HNgIMIAQgBiADazYCCCAEIAIgBWs2AgQgBEEMaiAEQQhqIARBBGoQpQYQpQYhAyABIAAoAgwgAygCACIDEJcBIAAgACgCDCADajYCDAwBCyAAIAAoAgAoAigRAgAiA0F/Rg0BIAEgA8A6AABBASEDCyABIANqIQEgAyAFaiEFDAELCyAEQRBqJAAgBQsJACAAQn8QpgYLCQAgAEJ/EKYGCwQAIAALDAAgABCnBhogABALC6gBAQV/IAAoAlQiAygCACEFIAMoAgQiBCAAKAIUIAAoAhwiB2siBiAEIAZJGyIGBEAgBSAHIAYQHRogAyADKAIAIAZqIgU2AgAgAyADKAIEIAZrIgQ2AgQLIAQgAiACIARLGyIEBEAgBSABIAQQHRogAyADKAIAIARqIgU2AgAgAyADKAIEIARrNgIECyAFQQA6AAAgACAAKAIsIgE2AhwgACABNgIUIAILBgAgARALCwYAIAEQRwsyACAAQeyiASgCADYCGCAAQeSiASkCADcCECAAQdyiASkCADcCCCAAQdSiASkCADcCAAsmACAAQaShASgCADYCECAAQZyhASkCADcCCCAAQZShASkCADcCAAsyACAAQfSeASgCADYCGCAAQeyeASkCADcCECAAQeSeASkCADcCCCAAQdyeASkCADcCAAsyACAAQYCcASkDADcDGCAAQfibASkDADcDECAAQfCbASkDADcDCCAAQeibASkDADcDAAsmACAAQaSbASkCADcCECAAQZybASkCADcCCCAAQZSbASkCADcCAAsmACAAQfCWASkCADcCECAAQeiWASkCADcCCCAAQeCWASkCADcCAAsyACAAQZyWASkCADcCGCAAQZSWASkCADcCECAAQYyWASkCADcCCCAAQYSWASkCADcCAAsyACAAQcSVASgCADYCGCAAQbyVASkCADcCECAAQbSVASkCADcCCCAAQayVASkCADcCAAsNACAAQdiTAUE4EB0aCw4AIABBsPIAQdAAEB0aCxoAIABB/PAAKAIANgIIIABB9PAAKQIANwIACw4AIABB6O8AQdAAEB0aCw0AIABB5O0AQSgQHRoLDQAgAEGA7QBBKBAdGgsNACAAQZDsAEEwEB0aC2gBAn8jAEEQayICJAAgAiABKAIINgIIIAIgASkCADcDACABQgA3AgAgAUEANgIIIAIoAgAgAiACLQALIgHAQQBIIgMbIAIoAgQgASADG60gACgCCCAAKAIEESwAIAIQChogAkEQaiQACxUAIAFBjOsANgIAIAEgACkCBDcCBAsKACAAQYzrABB5C3EBAn8jAEEQayIDJAAgASgCACEEIAMgAigCCDYCCCADIAIpAgA3AwAgAkIANwIAIAJBADYCCCAEIAMoAgAgAyADLQALIgHAQQBIIgIbIAMoAgQgASACG60gACgCCCAAKAIEERgAIAMQChogA0EQaiQACxUAIAFB6OoANgIAIAEgACkCBDcCBAsKACAAQejqABB5C8sCAQJ/IwBBQGoiBSQAIAEoAgAhBiAFIAJBCGooAgA2AiggBSACKQIANwMgIAJCADcCACACQQA2AgggBSADKAIINgIYIAUgAykCADcDECADQgA3AgAgA0EANgIIIAUgBCgCACICNgIEIAUgBCgCBCIDNgIIIAUgBCgCCDYCDCAEQQA2AgggBEIANwIAIAVBADYCPCAFQgA3AjQgBUE0aiADIAJrQQxtEIABA0AgAiADRkUEQCAFIAIoAgAgAiACLAALQQBIGzYCMCACQQxqIQIgBUE0aiAFQTBqEHYMAQsLIAYgBSgCICAFQSBqIgIgBSwAK0EASBsgBSgCECAFQRBqIgMgBSwAG0EASBsgBSgCNCIBIAUoAjggAWtBAnWtIAAoAgggACgCBBFGACAFQTRqEA8aIAVBBGoQOyADEAoaIAIQChogBUFAayQACxUAIAFBxOoANgIAIAEgACkCBDcCBAsKACAAQcTqABB5C7YBAQJ/IwBBIGsiBSQAIAItAAAhAiABKAIAIQYgBSADKAIINgIYIAUgAykCADcDECADQgA3AgAgA0EANgIIIAUgBCgCCDYCCCAFIAQpAgA3AwAgBEIANwIAIARBADYCCCAGIAIgBSgCECAFQRBqIgMgBS0AGyIBwEEASCICGyAFKAIUIAEgAhutIAUoAgAgBSAFLAALQQBIGyAAKAIIIAAoAgQRIQAgBRAKGiADEAoaIAVBIGokAAsVACABQaDqADYCACABIAApAgQ3AgQLCgAgAEGg6gAQeQsVACABQfzpADYCACABIAApAgQ3AgQLCgAgAEH86QAQeQsVACABQdjpADYCACABIAApAgQ3AgQLCgAgAEHY6QAQeQsVACABQbTpADYCACABIAApAgQ3AgQLCgAgAEG06QAQeQsVACABQZDpADYCACABIAApAgQ3AgQLCgAgAEGQ6QAQeQsVACABQezoADYCACABIAApAgQ3AgQLCgAgAEHs6AAQeQsVACABQcjoADYCACABIAApAgQ3AgQLCgAgAEHI6AAQeQvCAgIDfwF+IwBBMGsiBSQAIAEoAgAhBiAFIAIoAgAiATYCCCAFIAIoAgQiBzYCDCAFIAIoAgg2AhAgAkEANgIIIAJCADcCAAJAIAYEQCAGQQBBAEIAQQAgACgCCCAAKAIEESEADAELIAQtAAAhAiADKQMAIQggBUEANgIsIAVCADcCJCAFQQA2AiAgBUIANwIYIAVBJGogByABa0EYbSIDEIABIAVBGGogAxCAAQNAIAEgB0YEQEEAIAUoAiQgBSgCGCAIIAIgACgCCCAAKAIEESEAIAVBGGoQDxogBUEkahAPGgUgBSABKAIAIAEgASwAC0EASBs2AhQgBUEkaiAFQRRqIgMQdiAFIAEoAgwgAUEMaiABLAAXQQBIGzYCFCABQRhqIQEgBUEYaiADEHYMAQsLCyAFQQhqEOIEIAVBMGokAAsVACABQaToADYCACABIAApAgQ3AgQLCgAgAEGk6AAQeQspACABKAIAIABBCGoiASgCACABIAAsABNBAEgbIAAoAhQgACgCBBEEAAsYACABQYDoADYCACABQQRqIABBBGoQ2wQLIAEBf0EYEBciAUGA6AA2AgAgAUEEaiAAQQRqENsEIAELCQAgABCuCxALCw4AIAAoAgAgASACEKwLC4YBAQJ/IwBBEGsiAyQAIAEoAgAhBCADIAIoAgg2AgggAyACKQIANwMAIAJCADcCACACQQA2AgggBCAAQQhqIgEoAgAgASAALAATQQBIGyADKAIAIAMgAy0ACyIBwEEASCICGyADKAIEIAEgAhutIAAoAhQgACgCBBEwACADEAoaIANBEGokAAsYACABQdznADYCACABQQRqIABBBGoQ2wQLIAEBf0EYEBciAUHc5wA2AgAgAUEEaiAAQQRqENsEIAELCQAgABCxCxALC5QBAQF/IwBBIGsiAyQAIAMgASgCCDYCGCADIAEpAgA3AxAgAUIANwIAIAFBADYCCCADIAIoAgg2AgggAyACKQIANwMAIAJCADcCACACQQA2AgggAygCECADQRBqIgEgAywAG0EASBsgAygCACADIAMsAAtBAEgbIAAoAgggACgCBBEEACADEAoaIAEQChogA0EgaiQACxUAIAFBuOcANgIAIAEgACkCBDcCBAsKACAAQbjnABB5Cw4AIAEoAgAgAigCABAJCwsAIAFBlOcANgIACxEAQQgQFyIAQZTnADYCACAAC98BAQJ/IwBB0ABrIgUkACAFIAEoAgg2AkggBSABKQIANwNAIAFCADcCACABQQA2AgggBSACKAIANgI0IAUgAigCBDYCOCAFIAIoAgg2AjwgAkEANgIIIAJCADcCACADKAIAIQEgBUEQaiAEQQhqEM0LIQYgACgCBCAAQQRqIAAsAA9BAEgbIABBEGoiAygCACADIAAsABtBAEgbIAUoAkAgBUFAayIDIAUsAEtBAEgbIAVBNGoiBCABIAVBCGogACgCICAAKAIcERcAIAYQQyAEEFwgAxAKGiAFQdAAaiQACxgAIAFB8OYANgIAIAFBBGogAEEEahDcBAsgAQF/QSQQFyIBQfDmADYCACABQQRqIABBBGoQ3AQgAQsJACAAELQLEAsLPAAgASgCACAAKAIEIABBBGogACwAD0EASBsgAEEQaiIBKAIAIAEgACwAG0EASBsgACgCICAAKAIcEQYACxgAIAFBzOYANgIAIAFBBGogAEEEahDcBAsgAQF/QSQQFyIBQczmADYCACABQQRqIABBBGoQ3AQgAQsJACAAELgLEAsLFQAgAUGo5gA2AgAgASAAKQIENwIECwoAIABBqOYAEHkLhAEBAn8jAEEQayICJAAgAiABKAIINgIIIAIgASkCADcDACABQgA3AgAgAUEANgIIIwBBEGsiASQAIAAoAgQhAyABIAIoAgg2AgggASACKQIANwMAIAJCADcCACACQQA2AgggA0G4DmogARC6AyABEAoaIAFBEGokACACEAoaIAJBEGokAAsVACABQYTmADYCACABIAAoAgQ2AgQLCwAgAEGE5gAQygMLYQEDfyABKAIAGiMAQZABayIBJAAgAEEIaiIAKAIAIQJBARAVBEAgAUEIahATIQQgAUEBNgIEIARB09cAEA0gAkGYBGoQ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DhAKGiANEAoaIAwQChogBxAKGiACEBIaIAAQEhogBhAKGiADQbABaiQAIAEQEhogBBAKGiALEAoaIAoQChogCRAKGiAIQdAAaiQAQQALlgQBB38jAEFAaiIKJAAgCkE0aiABEAwhDCAKQShqIAIQDCENIApBHGoiCyADIASnEEEgCiAINgIIIAogBzYCBCAKQaDqADYCACAKIAo2AhAgACEPIAohASMAQcABayIJJAAgCUGQAWoiABCZCyAJIAwoAgAgDCAMLAALQQBIGzYCnAEgCSANKAIAIA0gDSwAC0EASBs2AqABIAsoAgQhCCAJIAsoAgAgCyALLQALIgfAQQBIIgMbNgKoASAJIAY2ArgBIAkgBTcDsAEgCSAIIAcgAxs2AqQBIAlBADYCiAEgCUIANwOAASAAKAIAQZiiAUcEQEHZFUHlyABB8QdBxTIQAAALIAlBgAFqIg4gABBZEF0gCUH/ADYCeCAJIA42AnwgACgCAEGYogFHBEBB2RVB5cgAQf8HQYIkEAAACyAAIAlB+ABqEGUgCUHIAGogARAyIQpBIBAXIgBBnOAANgIAIABBCGogChAyGiAJIAA2AnAgD0G4AiAOIAlB4ABqIghBASAJQTxqQanZABAMIgcgCUEwakGp2QAQDCIGIAlBJGpBqdkAEAwiAyAJQRhqQanZABAMIgIgCUEMakGp2QAQDCIAQQAQjAEgABAKGiACEAoaIAMQChogBhAKGiAHEAoaIAgQEhogChASGiAOEAoaIAlBwAFqJAAgARASGiALEAoaIA0QChogDBAKGiABQUBrJABBAAunDAEHfyMAQdAAayIIJAAgCEHEAGogARAMIQkgCEE4aiACEAwhCiAIQSxqIAMQDCELIAhBIGoiAUEANgIIIAFCADcCACAEKAIEIgIgBCgCACIDRwRAIAIgA2tBOG0iAkGlkskkTwRAEAEACyABIAIQkwgiAzYCBCABIAM2AgAgASADIAJBOGxqNgIIIAQoAgAhAiAEKAIEIQQgASgCBCEDA0AgAiAERwRAIAMgAigCADYCACADQQRqIAJBBGoQywsgA0EQaiACQRBqEBAaIAMgAikDIDcDICADIAIoAig2AiggAyACKAIsNgIsIAMgAi0AMDoAMCADQThqIQMgAkE4aiECDAELCyABIAM2AgQLIAggBzYCECAIIAY2Agwg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IAYQChogCxAKGiAJQTBqJABBAAvjAQICfwF+IwBBIGsiAyQAIANBADYCHCADQgA3AhQgA0EUaiACEMsBA38gAiAERgR/IAMgAygCFDYCCCADKQIYIQUgA0EANgIcIAMgBTcCDCADQgA3AhQjAEEQayIBJAAgASADQQhqIgIoAgA2AgQgASACKAIENgIIIAEgAigCCDYCDCACQQA2AgggAkIANwIAIABByANqIAFBBGoiBBDdBSAAQQE6AOADIAQQOyABQRBqJAAgAhA7IANBFGoQOyADQSBqJABBAAUgA0EUaiABIARBAnRqEMICIARBAWohBAwBCwsLRwEBfyMAQSBrIgMkACADIAI2AhAgAyABNgIMIANBuOcANgIIIAMgA0EIaiIBNgIYIABB0A5qIAEQ2AEgARASGiADQSBqJAALCwBBsMECIAA2AgALswMBB38jAEEgayIDJAAgA0GU5wA2AgggAyADQQhqIgQ2AhgjAEEgayIFJAAgBUEIaiAEEOADIQAjAEEQayICJAACQCAAQbDCAkYNAEHAwgIoAgAhASAAIAAoAhAiBkYEQCABQbDCAkYEQCAAIAIgACgCACgCDBEAACAAKAIQIgEgASgCACgCEBEBACAAQQA2AhBBwMICKAIAIgEgACABKAIAKAIMEQAAQcDCAigCACIBIAEoAgAoAhARAQBBwMICQQA2AgAgACAANgIQIAJBsMICIAIoAgAoAgwRAAAgAiACKAIAKAIQEQEAQcDCAkGwwgI2AgAMAgsgAEGwwgIgACgCACgCDBEAACAAKAIQIgEgASgCACgCEBEBACAAQcDCAigCADYCEEHAwgJBsMICNgIADAELIAFBsMICRgRAQbDCAiAAQbDCAigCACgCDBEAAEHAwgIoAgAiASABKAIAKAIQEQEAQcDCAiAAKAIQNgIAIAAgADYCEAwBCyAAIAE2AhBBwMICIAY2AgALIAJBEGokACAAEBIaIAVBIGokAEHIwgJBADYCACAEEBIaIANBIGokAAs/AQF/IAAoAgAiAiAAKAIERgRAQbECDwsgASACKAIIIAJBCGogAiwAE0EASBs2AgAgACAAKAIAKAIANgIAQQALWgEEfyMAQSBrIgIkAEEIEBchAyAAIAJBFGogARAMIgQQwgsoAgghBSAAIAJBCGogARAMIgAQwgsaIANBADYCBCAD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1wAQDSAGEBEaIAFBgAJqEBQMAQsgAyAGEJsBIQMgAUG4AWogCRBQIQQgAUIANwMoIAFCADcDICABQYACaiIFIAMgAUEgaiAEEL4BIAFB0AFqIAUQugEQxQIhCiABQYgCahCqASAEECUCQCAKLQAoRQRAQQMQFUUNASABQYQCahATIQ0gAUEDNgKAAiANQYLXABANIAkQERogBRAUDAELIAEgChCOASIEKQMQNwOwASABIAQpAwg3A6gBIAEgBCkDEDcDGCABIAQpAwg3AxAgAUGAAmoiByADIAFBEGoQjQUgASAHEIwFIgQoAgA2ApwBIAEgBCgCBDYCoAEgASAEKAIINgKkASAEQQA2AgggBEIANwIAIAcQiwUgASgCoAEhBSABKAKcASEEAkACQANAIAQgBUYiBw0BIAQQ9QQhDiAEQShqIQQgDhDFAyACECJFDQALQQMQFUUNASABQYQCahATIQ8gAUEDNgKAAiAPQYnTABANIAIQERogAUGAAmoQFAwBC0EBEBUEQCABQYQCahATIRAgAUEBNgKAAiAQQeTWABANIAIQERogAUGAAmoQFAsgAUGAAmogAxCaASEEIAEgASkDsAE3A1AgASABKQOoATcDSCADIAFBqAFqEI8DIRIgAUH4AGogAhDrBiERIAEgASkDUDcDCCABIAEpA0g3AwAgBCABIBIgAUHwAGoQ/QQgERBDIAFByABqIgMgBBCZASACEPcEIQUgAEG0BGogBhDoBiAJEOcGIQACQCAFBEAgAyACQQAQqAMgACABQTBqIAIgAxD2BCIAEOoGIAAQZhogAxAKGgwBCyAAQQE6AMwDCyAEEI0BCyABQZwBahDvAwsgChCRAgsgAUGQA2okACACEAoaIAkQChogBhAKGiAIQTBqJABBAEG1AiAHGwuzBAEIfyMAQSBrIgckACAHQRRqIAEQDCEEIAdBCGogAhAMIQYjAEGQAmsiAyQAQQEQFQRAIANBhAFqEBMhCiADQQE2AoABIApB/dgAEA0gBBARQYHVABANIAYQERogA0GAAWoQFAsgAEG0BGoiCCAEEPgEIgIgBhDbASIJBH8jAEEQayIFJAAgCSgCABogBUEEaiIBIAIgCRDQBiABEOkEIAVBEGokAEEBBUEACwRAIABByARqIAQQkQMgBhDlAyIBIAEpAwBCAXw3AwALIAggBBD4BCgCDEUEQCAIIAQQ2wEiBQRAIwBBEGsiAiQAIAUoAgAaIAJBBGoiASAIIAUQ0AYgARDPBiACQRBqJAALCwJAIAAtAKAOBEAgAEGIB2oiAiAEEIIBIABBjAdqRg0BIANBgAFqIAIgBBCbARCaASEFIANB6ABqIAYQUCEBIANCADcDGCADQgA3AxAgBSADQRBqIAEQxwIgARAlIANBxwBqIAUQmQEgAiAEEJsBQfDcABCPA1AEQCAAQeAEaiADQThqIAQQECIAEOUGIAAQChoLIAUQjQEMAQsgACgCpARBqAJqIABBmARqIgEQggEgACgCpAQiAEGsAmpGDQAgA0GAAWogAEGoAmogARCbARCaASEBIANBIGogBhBQIQAgA0IANwMIIANCADcDACABIAMgABDHAiAAECUgA0HHAGogARCZASABEI0BCyADQZACaiQAIAYQChogBBAKGiAHQSBqJAALPQECfyMAQSBrIgMkACAAIANBFGogARAMIgAgA0EIaiACEAwiARD5BCEEIAEQChogABAKGiADQSBqJAAgBAuKAgEDfyMAQdAAayIFJAAgACAFQcQAaiABEAwiASAFQThqIAIQDCICEPkEIQcgBSABKAIINgIIIAUgASkCADcDACABQgA3AgAgAUEANgIIIAUgAigCCDYCFCAFIAIpAgA3AgwgAkIANwIAIAJBADYCCCAFIAQ2AhwgBSADNgIYQSQQFyIAQfDmADYCACAAIAUoAgg2AgwgACAFKQMANwIEIAVBADYCCCAFQgA3AwAgACAFKAIUNgIYIAAgBSkCDDcCECAFQQA2AhQgBUIANwIMIAAgBSkDGDcCHCAFIAA2AjAgByAFQSBqIgAQzgsgABASGiAFEGYaIAIQChogARAKGiAFQdAAaiQAQQALsxECFn8CfSMAQZABayIKJAAgCkEANgKMASAKQgA3AoQBIApBhAFqIAQQywEDQCAEIA9GBEAgCkH4AGogARAMIRQgCkHsAGogAhAMIQMgCkHgAGoiFyAFIAanEEEgCiAKKAKEATYCVCAKKQKIASEGIApBADYCjAEgCiAGNwJYIApCADcChAEgCkHUAGohFiMAQZAEayIJJAAgAEG0BGogFBD4BCEEIAkgFzYC4AIjAEEgayIRJAAgESADNgIUIBEgCUGYAmo2AhAgESAJQeACajYCDCARQejc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oAM3AwAgBSAErTcDkAEgBSAFKQOYAzcDOCABIAVBOGogACAFQYgBakEAEO4BIAVBkAFqEEMgABAlIAVBmANqIAEQmQEgARCNASAGEJECCyAFQYAFaiQAIAIQChogCRAKGiAHEAoaIAhBMGokAAsJACAAIAE2AjgLCQAgACABNgJICwkAIAAgATYCQAsKACAAQQE6AOgOC+MDAQV/IAAEQCAAQdAOahASGiAAQbgOahASGiAAQaQOahDkBCAAQcAKaiIBLQDYAwRAIAEQ5wQLIABB4ARqENEGIABByARqIgMoAgghAQNAIAEEQCABKAIAIQQgAUEIahDWBiABEAsgBCEBDAELCyADEOIDIABBtARqIgMoAgghAQNAIAEEQCABKAIAIQUgAUEIahDOBiABEAsgBSEBDAELCyADEOIDIABBqARqIAAoAqwEEOEDIABBmARqEAoaIABBjARqEDsgAEH8A2ogACgCgAQQvwYgAEHoA2oQ5AQgAEHIA2oQOyAAQbADahASGiAAQZgDahASGiAAQYgDahAKGiAAQfgCahAKGiAAQeACahASGiAAQcgCahASGiAAQbACahASGiAAQZgCahASGiAAQYACahASGiAAQegBahASGiAAQdABahASGiAAQbgBahASGiAAQaABahASGiAAQYgBahASGiAAQdgAahDoCyAAQcwAahDpCyAAKAIwIgEEQCABIAEoAgQiAkEBazYCBCACRQRAIAEgASgCACgCCBEBAAJAIAFBCGoiAigCAARAIAIQjApBf0cNAQsgASABKAIAKAIQEQEACwsLIABBIGoQChogAEEUahAKGiAAEAoaCyAAEAsL3QsBD38jAEEwayIEJAAgBEEANgIsIARCADcCJCAEQSRqIAIQywEDfyACIANGBH9B8A4QFyEBIARBGGogABAMIQggBEEIaiAEQSRqIg4QpwIhByMAQZABayIDJAAgA0GEAWogCBAQIQkCQCAHLQAMBEAgA0H4AGogBxDLCwwBCyADQQA2AoABIANCADcCeAsjAEEQayIKJAAgCkEEakGp2QAQDCELIwBBEGsiDCQAIAFCADcDACABQgA3AAUgAUEQakEAQSYQHhogAUHcAGoiAEIANwIAIAFBADYCVCABIAFBzABqIgI2AlAgASACNgJMIAFBCjYCSCABQriXgICA9wI3A0AgAUEBOgA8IAFBDzYCOCABQQA2AsgBIAFBADYCsAEgAUEANgKYASABQQA6AGQgASAANgJYIAFCADcDaCABQgA3A3AgAUIANwN4IAFCADcDgAEgAUEANgLwAiABQQA2AtgCIAFBADYCwAIgAUEANgKoAiABIAFBgAJqNgKQAiABQaTkADYCgAIgASABQegBajYC+AEgAUGA5AA2AugBIAEgAUHQAWo2AuABIAFB2OMANgLQASABQgA3A4gDIAFBADYCkAMgAUEANgKoAyABQQA2AsADIAFBADYC0AMgAUIANwPYAyABQgA3A8gDIAFBADoA4AMgAUIANwD9AiABQgA3A/gCIAxBBGogCxAQIg8hAiMAQZABayIFJAAgASIAIAIQgwECQCACKAIEIAItAAsiASABwEEASCIBGyIGRQ0AIAYgAigCACACIAEbakEBay0AAEEvRg0AIwBBEGsiECQAQfnPABDWASEBIAVBBGoiAiABIAAoAgQgAC0ACyIGIAbAQQBIGyIGahCwCCINKAIAIA0gDSwAC0EASBsgACgCACAAIAAsAAtBAEgbIAYQVSAGakH5zwAgARBVIAFqQQA6AAAgEEEQaiQAIAAgAhAcIAIQChoLQQEQFQRAIAVBCGoQEyERIAVBATYCBCARQenRABANIAAQERogBUEEahAUCyAFQZABaiQAIA8QChogDEEQaiQAIAsQChogAEEBOgCEAyAAQYgDaiAJEBwgAEHIA2ogA0H4AGoiARDdBSAKQRBqJAAgARA7IAkQChogAEIANwPwAyAAQgA3A+gDIABBgARqIgFCADcDACAAQYCAgPwDNgL4AyAAQgA3A5AEIABCrAI3A4gEIAAgATYC/AMgAEGYBGogCBAQIQEgAEIANwK0BCAAIABBrARqNgKoBCAAQgA3AqwEIABCADcCvAQgAEIANwPIBCAAQYCAgPwDNgLEBCAAQgA3A9AEIABBgICA/AM2AtgEIABB4ARqIANB7ABqIAEQECICEOgEIQEgAhAKGiAAQgA3AqQOIABBADoAoA4gAEGYDmpBADoAACAAQQA6AMAKIABBrA5qQgA3AgAgAEEAOgDoDiAAQeAOakEANgIAIABByA5qQQA2AgAgAEG0DmpBgICA/AM2AgAgAyAANgJUIANByOQANgJQIAMgA0HQAGoiAjYCYCAAQZgDaiACENgBIAIQEhogAyAANgI8IANB7OQANgI4IAMgA0E4aiICNgJIIABBsANqIAIQ2AEgAhASGiADIAA2AiQgA0GQ5QA2AiAgAyADQSBqIgI2AjAgAEGIAWogAhDYASACEBIaIAMgADYCDCADQbTlADYCCCADIANBCGoiAjYCGCAAQZgCaiACENgBIAIQEhogACAHLQAMIgI6AKAOIAIEQCADIAE2AgQgAEHACmogA0EEahDKCyABQawCaiEFIAEoAqgCIQIDQCACIAVGBEAgAUEBOgC0AgUgAkEBOgDYAyACEMIBIQIMAQsLIABBkwtqQYACOwAAIABB8wpqQQA6AAAgAEHwCmpBgAI7AQAgAEHQCmpBADoAAAsgA0GQAWokACAHLQAMBEAgBxA7CyAIEAoaIA4QOyAEQTBqJAAgAAUgBEEkaiABIANBAnRqEMICIANBAWohAwwBCwsLxwEBA38jAEHQAGsiBSQAIAUgASgCCDYCSCAFIAEpAgA3A0AgAUIANwIAIAFBADYCCCAFIAIoAgA2AjQgBSACKAIENgI4IAUgAigCCDYCPCACQQA2AgggAkIANwIAIAMoAgAhASAFQRBqIARBCGoQzQshByAFKAJAIAVBQGsiBiAFLQBLIgPAQQBIIgQbIAUoAkQgAyAEG60gBUE0aiIDIAEgBUEIaiAAKAIIIAAoAgQRUgAgBxBDIAMQXCAGEAoaIAVB0ABqJAALFQAgAUGs4wA2AgAgASAAKQIENwIECwoAIABBrOMAEHkLFQAgAUGI4wA2AgAgASAAKQIENwIECwoAIABBiOMAEHkLWQEBfyMAQTBrIgMkACAAAn8gAUUEQCADQQA2AiggA0EYagwBCyADIAI2AgggAyABNgIEIANBrOMANgIAIAMgAzYCECADCyIBEM4LIAEQEhogA0EwaiQAQQALRQEBfyMAQSBrIgMkACADIAI2AhAgAyABNgIMIANBiOMANgIIIAMgA0EIaiIBNgIYIAAgARDABiABEBIaIANBIGokAEEAC10BAX8gACgCACIDIAAoAgRGBEBBsQIPCyABIAMoAhAgA0EQaiADLAAbQQBIGzYCACACIAAoAgAiASgCFCABLQAbIgEgAcBBAEgbrTcDACAAIAAoAgAQwgE2AgBBAAtqAQN/IwBBEGsiBCQAIABBqAJqIQMCQCABRQRAIAMoAgAhAQwBCyAEQQRqIgUgASACpxBBIAUgAygCBCADQQRqENsIIQEgBRAKGgtBCBAXIgMgAEGsAmo2AgQgAyABNgIAIARBEGokACADC5sBAQN/IwBBEGsiAyQAIANBBGoiBCABIAKnEEECQAJ/IABBqAJqIgVBBGohAQN/QQAgASgCACIBRQ0BGiAEIAFBEGoiABAbDQAgACAEEBsEfyABQQRqIQEMAQVBAQsLC0UEQEEAIQEMAQtBCBAXIQEgBSADQQRqEJsBIQAgAUEANgIEIAEgADYCAAsgA0EEahAKGiADQRBqJAAgAQsuAQJ/IwBBEGsiAyQAIANBBGoiBCABIAKnEEEgACAEEOUGIAQQChogA0EQaiQACy4BAn8jAEEQayIDJAAgA0EEaiIEIAEgAqcQQSAAIAQQkAMgBBAKGiADQRBqJAALkgMBBn8jAEHgAGsiBCQAAn9BtAIgACgCBEUNABoCQCACKAIAIAIoAgRGDQAgACgCACEFIAQgAUHo4gAgARsiASkDCDcDGCAEIAEpAwA3AxAgBEHIAGogBSAEQRBqIAIQigMgBC0AWEUNACAAKAIEIQEgBEFAayIFIAQpA1A3AwAgBCAEKQNINwM4IARBIGogAigCBEEYaxCYAiEAIAQgBSkDADcDCCAEIAQpAzg3AwAjAEGQAWsiAiQAAkAgAS0AQA0AIAEoAgAgBCAAEJgDDQAgAkEDOgCIASACIAM3A3AgAkHwAGohBQJAIAAtABBBAUYEQCACIAAoAgg2AmAgAiAAKQIANwNYIABCADcCACAAQQA2AgggAkE4aiAFEHghByABIAQgAkHYAGoiASACQTBqQQAQ/wQgBxBEIAEQChoMAQsgABDxASkDACEDIAJBEGogBRB4IQggASAEIAMgAkEIakEAEP4EIAgQRAsgBRBECyACQZABaiQAIAAQJUEADAELQbUCCyEJIARB4ABqJAAgCQvRAQEEfyMAQeAAayIDJAACf0G0AiAAKAIERQ0AGgJAIAIoAgAgAigCBEYNACAAKAIAIQQgAyABQejiACABGyIBKQMINwMYIAMgASkDADcDECADQcgAaiAEIANBEGogAhCKAyADLQBYRQ0AIAAoAgQhBSADQUBrIgQgAykDUDcDACADIAMpA0g3AzggA0EgaiACKAIEQRhrEJgCIQAgAyAEKQMANwMIIAMgAykDODcDACAFIAMgABDHAiAAECVBAAwBC0G1AgshBiADQeAAaiQAIAYL+AECBH8BfiMAQfAAayIEJAACQCAAKAIERQRAQbQCIQUMAQtBtQIhBSACKAIEIgYgAigCAEYNACAGQQhrLQAAQQFGDQAgACgCACEFIAQgAUHo4gAgARsiASkDCDcDGCAEIAEpAwA3AxAgBEHYAGogBSAEQRBqIAIQigMgBC0AaEUEQEG1AiEFDAELIAAoAgQhByAEIAQpA2A3A1AgBCAEKQNYNwNIIAIoAgRBGGsQ8QEpAwAhCCAEQShqIANBCGoQwgYhASAEIAQpA1A3AwggBCAEKQNINwMAQQAhBSAHIAQgCCAEQSBqEP0EIAEQQwsgBEHwAGokACAFC+wBAQR/IwBBkAFrIgQkAAJ/QbQCIAAoAgRFDQAaAkAgAigCACACKAIERg0AIAAoAgAhBSAEIAFB6OIAIAEbIgEpAwg3AyAgBCABKQMANwMYIARB+ABqIAUgBEEYaiACEIoDIAQtAIgBRQ0AIAAoAgQhBiAEIAQpA4ABNwNwIAQgBCkDeDcDaCAEQdAAaiACKAIEQRhrEJgCIQAgBEEwaiADQQhqEMIGIQMgBCAEKQNwNwMQIAQgBCkDaDcDCCAGIARBCGogACAEQShqQQAQ7gEgAxBDIAAQJUEADAELQbUCCyEHIARBkAFqJAAgBws8AQN/IwBBMGsiAiQAIAAoAgQiAQR/IAJBD2ogARCZASAAQQRqQQAQwQZBAAVBtAILIQMgAkEwaiQAIAMLhAEBA38jAEHQAGsiAiQAQbMCIQEgACgCBEUEQCACIAAoAgAQmgEhAUHIABAXIAFBKBAdIgNBKGogAUEoahAmGiADQTRqIAFBNGoQJhogAyABLwFAOwFAIAJBADYCTCAAQQRqIAMQwQYgAkHMAGoQ0gsgARCNAUEAIQELIAJB0ABqJAAgAQvcAQEDfyMAQdAAayIEJAACfwJAAkAgAigCACACKAIERgRAIAMgACgCACABQejiACABGxCPAzcDAAwBCyAAKAIAIQUgBCABQejiACABGyIBKQMINwMYIAQgASkDADcDECAEQThqIAUgBEEQaiACEIoDIAQtAEhFDQEgACgCACEBIAIoAgQhAiAEIARBQGspAwA3AwggBCAEKQM4NwMAIARBIGoiBSABIAQgAkEYaxDRCyAELQAwRQ0BIAMgACgCACAFEI8DNwMAC0EADAELQbUCCyEGIARB0ABqJAAgBgvGBAECfyMAQZACayIEJAAgAUHo4gAgARshAQJAIAIoAgAgAigCBEYEQCAAKAIAIQAgBCABKQMINwMQIAQgASkDADcDCCAEQfAAaiIBIAAgBEEIahDuAyAELQCYAQR/IAMgARDtAxDzC0EABUG1AgshAiAEQfgAahDsAwwBCyAAKAIAIQUgBCABKQMINwNQIAQgASkDADcDSCAEQfgBaiAFIARByABqIAIQigMgBC0AiAJFBEBBtQIhAgwBCyAAKAIAIQEgAigCBCEFIARBQGsgBCkDgAI3AwAgBCAEKQP4ATcDOCAEQeABaiABIARBOGogBUEYaxDRCyAELQDwAQRAIAAoAgAhACAEIAQpA+gBNwMwIAQgBCkD4AE3AyggBEHwAGoiASAAIARBKGoQ7gMgAyABEO0DEPMLIARB+ABqEOwDQQAhAgwBCyAAKAIAIQEgBCAEKQOAAjcDuAEgBCAEKQP4ATcDsAEgBEHYAGogAigCBEEYaxCYAiEAIAQgBCkDuAE3AyAgBCAEKQOwATcDGCAEQfAAaiICIAEgBEEYaiAAEL4BIARBsAFqIAIQugEQxQIhASAEQfgAahCqASAAECUgAS0AKAR/IAEQ9QQhAiMAQRBrIgAkAAJAIAMtABhFBEAgAyACEPIGDAELIAAgAjYCDCAAIAM2AggjAEEgayICJAAgACgCCCACQQhqIAAoAgwQ/gMiAxDxCyADEDcgAkEgaiQACyAAQRBqJABBAAVBtQILIQIgARCRAgsgBEGQAmokACACCxMAIAAEQCAAQQRqENILCyAAEAsLeQEBfyAAKAIAIgQgACgCBEYEQEGxAg8LAkACQCAERQ0AIAQtABBBAUcNACABIAQoAgAgBCAELAALQQBIGzYCACACIAQoAgQgBC0ACyIBIAHAQQBIG603AwAMAQsgAyAEEPEBKQMANwMACyAAIAAoAgBBGGo2AgBBAAsUAQF/QQgQFyIBIAApAgA3AgAgAQsyAQF/IwBBIGsiAiQAIAJBADoAGCACIAE3AwggACACQQhqIgAQ9QEgABAlIAJBIGokAAtgAQJ/IwBBMGsiAyQAIANBCGoiBCABIAKnEEEgAyADKAIQNgIgIANBADYCECADQQE6ACggAyADKQMINwMYIANCADcDCCAAIANBGGoiABD1ASAAECUgBBAKGiADQTBqJAALDwAgAARAIAAQXAsgABALCwsAQQwQFyAAEOsHC0kBAX8gAC0ACEUEQEGyAg8LIAAtAAhBAUcEQBAaAAsgACgCACICIAAoAgRGBEBBsQIPCyABIAI2AgAgACAAKAIAQSBqNgIAQQALfgEBfyAALQAIQQFHBH8gAC0ACARAEBoACyAAKAIAIgQgACgCBEYEQEGxAg8LIAEgBCgCACAEIAQsAAtBAEgbNgIAIAIgACgCACIBKAIEIAEtAAsiAiACwEEASButNwMAIAMgAUEQajYCACAAIAAoAgBBMGo2AgBBAAVBsgILC1UBAX8CQCAARQ0AAn8CQAJAIAAtABhBAWsOAgABAwtBDBAXIgEgACgCACkCADcCAEEADAELQQwQFyIBIAAoAgApAgA3AgBBAQshACABIAA6AAgLIAELFQAgAEUEQEEADwtBACAAIAAtABgbCw4AIAAoAgAgASACEMELCwoAIAAtABhBAkYLCgAgAC0AGEEBRgsIACAALQAYRQtYAQV/IwBBoAFrIgEkAEEBEBUEQCABQRhqEBMhBCABQQE2AhQgBEGg1gAQDSEFIAFBCGoiAyAAQQAQygYgBSADEBEaIAMQChogAUEUahAUCyABQaABaiQACxAAIAAEQCAAEL0BCyAAEAsLHwEBf0EgEBciAEEAOgAYIABBADoAECAAQgA3AwAgAAsnAQF/QbICIQIgAC0AEEEFRgR/IAEgABDzASkDCDcDAEEABUGyAgsLTQEBf0GyAiEDIAAtABBBBEYEfyABIAAQxQMiACgCACAAIAAsAAtBAEgbNgIAIAIgACgCBCAALQALIgAgAMBBAEgbrTcDAEEABUGyAgsLJwEBf0GyAiECIAAtABBBA0YEfyABIAAQ7wstAAA6AABBAAVBsgILCycBAX9BsgIhAiAALQAQQQJGBH8gASAAEPALKwMAOQMAQQAFQbICCwsmAQF/QbICIQIgAC0AEEEBRgR/IAEgABBqKQMANwMAQQAFQbICCwskAQF/QbICIQIgAC0AEAR/QbICBSABIAAQ8QEpAwA3AwBBAAsLCgAgAC0AEEEFRgsKACAALQAQQQZGCwoAIAAtABBBBEYLCgAgAC0AEEEDRgsKACAALQAQQQJGCwoAIAAtABBBAUYLCAAgAC0AEEULKQEBfyMAQRBrIgIkACACIAE3AwggAiABNwMAIAAgAhD+BiACQRBqJAALCwAgAEGA4QAQvQsLLgECfyMAQRBrIgMkACADQQRqIgQgASACpxBBIAAgBBD/BiAEEAoaIANBEGokAAslAQF/IwBBEGsiAiQAIAIgAToADyAAIAJBD2oQgAcgAkEQaiQACyUBAX8jAEEQayICJAAgAiABOQMIIAAgAkEIahCBByACQRBqJAALJQEBfyMAQRBrIgIkACACIAE3AwggACACQQhqEIIHIAJBEGokAAslAQF/IwBBEGsiAiQAIAIgATcDCCAAIAJBCGoQgwcgAkEQaiQACwkAIABBARDZCQthAQJ/IwBBEGsiAiQAAkAgAC0AGEEBRgRAIAAgASgCADYCAAwBCyACIAE2AgwgAiAANgIIIAIoAgwhAyACKAIIIgAQQyADKAIAIQEgAEEBOgAYIAAgATYCAAsgAkEQaiQACwkAIABBABDZCQuTAQEHfyMAQSBrIgIkACACQQA6ABggAkIANwMIIAJBCGohAyMAQRBrIgEkAAJAIABBCGoiBC0AGEUEQCAEIAMQ3QQMAQsgASADNgIMIAEgBDYCCCABKAIMIQYgASgCCCIHEEMgByAGEHRBADoAGAsgAUEQaiQAIAMQNyAABEBBACAEIAAtACAbIQULIAJBIGokACAFCxgAIABFBEBBAA8LQQAgAEEIaiAALQAgGwsdAQF/IAAtACBBAUYEfyAAEI4BKAIAQQFGBUEACwsbAQF/IAAtACBBAUYEfyAAEI4BKAIABUEBC0ULCAAgAC0AIEULEgAgAARAIABBCGoQQwsgABALCxgBAX9BKBAXIgFBCGogAEEIahDCBhogAQsfAQF/QSgQFyIAQgA3AwggAEEAOgAgIABBADoAGCAACwkAQbDCAhASGgupAgEJfyMAQcABayIDJAAgACgCBCEAAkAgAS8BACIBBEBBAhAVBEAgA0E4ahATIQggA0ECNgI0IAhBk9IAEA0gARBpGiADQTRqEBQLIAFB5QBGDQEgABDBAgwBC0EBEBUEQCADQThqEBMhCSADQQE2AjQgCUHk0wAQDSEKIANBHGoiASACKAIEKAIgEAwaIANBKGoiBSABEN4LIAogBRARQdXTABANIQsgA0EEaiIEIAIoAgQoAiwQDBogA0EQaiIGIAQQ3gsgCyAGEBEaIAYQChogBBAKGiAFEAoaIAEQChogA0E0ahAUCyAAQQE7ATQgACgC8AJFDQAgA0E0aiIBIAIoAgQiAigCNCACKAIwEEEgAEHgAmogARC6AyABEAoaCyADQcABaiQACxUAIAFByOIANgIAIAEgACgCBDYCBAsdAQF/QQgQFyIBQcjiADYCACABIAAoAgQ2AgQgAQv2AQEFfyMAQaABayIDJAAgACgCBCEAAkAgAS8BACIBBEBBAhAVBEAgA0EYahATIQUgA0ECNgIUIAVBk9IAEA0gARBpGiADQRRqEBQLIAFB5QBGDQEgABDBAgwBCyAAKAKwAQRAIABBoAFqIAIQugMLQQEQFQRAIANBGGoQEyEGIANBATYCFCAGQeTTABANIQcgA0EIaiIBIAIoAgQoAjQQDBogByABEBEaIAEQChogA0EUahAUCyAAQgA3A3ggAEEBOwE0IAAoAsACRQ0AIANBFGoiASAAQbACaiACEN4EIABB+AJqIAEQHCABEAoaCyADQaABaiQACxUAIAFBpOIANgIAIAEgACgCBDYCBAsdAQF/QQgQFyIBQaTiADYCACABIAAoAgQ2AgQgAQsJACAAEMQGEAsLCQAgABDFBhALCwkAIAAQxgYQCwsJACAAEMcGEAsLigYCCX8BfiMAQTBrIgQkACAAQQhqIQkCQCABLwEAIgAEQCAEQQA2AiwgBEIANwIkIAkgACAEQSRqIgBCAEEAEO0LIAAQ4gQMAQtBACEAIARBADYCLCAEQgA3AiQDQCACKAIEIgEoAgwgAE0EQCAEIAQoAiQ2AhggBCkCKCEMIARBADYCLCAEIAw3AhwgBEIANwIkIAlBACAEQRhqIgAgASkDGCABKAIUQQBHEO0LIAAQ4gQgBEEkahDiBAUgBEEYaiABKAIQIABBAnRqKAIAIgEoAgwQDCEHIARBDGoiCCABKAIUIAEoAhAQQQJAIARBJGoiBSgCBCIBIAUoAghJBEAgASAHKQIANwIAIAEgBygCCDYCCCAHQgA3AgAgB0EANgIIIAEgCCgCCDYCFCABIAgpAgA3AgwgCEIANwIAIAhBADYCCCAFIAFBGGo2AgQMAQsjAEEgayIKJAAgCkEMaiAFIAUoAgQgBSgCAGtBGG1BAWoQ5QEgBSgCBCAFKAIAa0EYbSAFQQhqEMYBIgEoAggiAyAHKQIANwIAIAMgBygCCDYCCCAHQgA3AgAgB0EANgIIIAMgCCgCCDYCFCADIAgpAgA3AgwgCEIANwIAIAhBADYCCCABIAEoAghBGGo2AgggBSgCBCEDIAUoAgAhCyABKAIEIQYDQCADIAtHBEAgBkEYayIGIANBGGsiAykCADcCACAGIAMoAgg2AgggA0IANwIAIANBADYCCCAGIAMoAhQ2AhQgBiADKQIMNwIMIANCADcCDCADQQA2AhQMAQsLIAEgBjYCBCAFKAIAIQMgBSAGNgIAIAEgAzYCBCAFKAIEIQMgBSABKAIINgIEIAEgAzYCCCAFKAIIIQMgBSABKAIMNgIIIAEgAzYCDCABIAEoAgQ2AgAgASgCBCEDA0AgAyABKAIIIgZHBEAgASAGQRhrIgY2AgggBhBmGgwBCwsgASgCACIBBEAgARALCyAKQSBqJAAgBSgCBBoLIAgQChogBxAKGiAAQQFqIQAMAQsLCyAEQTBqJAALDgAgACgCACABIAIQtQsLDQAgACABQZjhABDJAQsLACAAQZjhABDKAQsJACAAEO4LEAsLewEBfyAAKAIAIQMjAEEQayIAJAACQCADLQAYQQJGBEAgAigCACEDIAJBADYCACABIAMQsQcMAQsgACACNgIMIAAgAzYCCCAAKAIMIQEgACgCCCICEL0BIAEoAgAhAyABQQA2AgAgAkECOgAYIAIgAzYCAAsgAEEQaiQAC3sBAX8gACgCACEDIwBBEGsiACQAAkAgAy0AGEEBRgRAIAIoAgAhAyACQQA2AgAgASADELIHDAELIAAgAjYCDCAAIAM2AgggACgCDCEBIAAoAggiAhC9ASABKAIAIQMgAUEANgIAIAJBAToAGCACIAM2AgALIABBEGokAAtLAQF/IAAoAgAhAyMAQRBrIgAkAAJAIAMtABhFBEAgASACEN0EDAELIAAgAjYCDCAAIAM2AgggACgCCCAAKAIMEPELCyAAQRBqJAALZAEBfyMAQRBrIgMkACAAQQhqIQACQCABLwEAIgEEQCAAIAEgA0EEakGp2QAQDCIBEOMEDAELIANBBGoiASACKAIEIgIoAhAgAigCDBBBIABBACABEOMECyABEAoaIANBEGokAAsNACAAIAFB5OAAEMkBCwsAIABB5OAAEMoBCwkAIAAQ9QsQCwsOACAAKAIAIAEgAhDkCwv4AQIEfwF+IwBBMGsiAyQAIABBCGohBQJ/IAEvAQAiAQRAIANBJGpBqdkAEAwhAiADQRhqQanZABAMIQAgA0EANgIUIANCADcCDCAFIAEgAiAAIANBDGoiARD2CyABDAELIANBJGoiASACKAIEKAIMEAwaIANBGGoiACACKAIEKAIQEAwaIANBDGoiBEEANgIIIARCADcCACAEIAIoAgQoAhQQywEDQCACKAIEIgY1AhQgB1YEQCAEIAYoAhggB6dBAnRqEMICIAdCAXwhBwwBCwsgBUEAIAEgACAEEPYLIAEhAiAECxA7IAAQChogAhAKGiADQTBqJAALDQAgACABQcDgABDJAQsLACAAQcDgABDKAQsJACAAEPcLEAsLnwEBA38jAEEgayIDJAAgAEEIaiEEAkAgAS8BACIABEAgBCAAQQAgA0EUakGp2QAQDCICIANBCGpBqdkAEAwiARD4CwwBCyACKAIEKAIMIQUgA0EUaiIAIAIoAgQiASgCFCABKAIQEEEgA0EIaiIBIAIoAgQoAhgQDBogBEEAIAVBAEcgACABEPgLIAAhAgsgARAKGiACEAoaIANBIGokAAsNACAAIAFBnOAAEMkBCwsAIABBnOAAEMoBCwkAIAAQ+gsQCwsNACAAIAFB+N8AEMkBCwsAIABB+N8AEMoBCwkAIAAQ+wsQCwsNACAAIAFB1N8AEMkBCwsAIABB1N8AEMoBCwkAIAAQ/AsQCwsNACAAIAFBsN8AEMkBCwsAIABBsN8AEMoBCwkAIAAQ/gsQCwsNACAAIAFBjN8AEMkBCwsAIABBjN8AEMoBCwkAIAAQ/wsQCwsNACAAIAFB6N4AEMkBCwsAIABB6N4AEMoBCwkAIAAQgAwQCwt8AQJ/IwBBEGsiAyQAIABBCGohAAJAIAEvAQAiAQRAIAAgASADQQRqQanZABAMIgEQ4wQMAQsgA0EEaiEBAkAgAigCBCICKAIcIgRFBEAgAUGp2QAQDBoMAQsgASACKAIgIAQQQQsgAEEAIAEQ4wQLIAEQChogA0EQaiQACw0AIAAgAUHE3gAQyQELCwAgAEHE3gAQygELCQAgABDMBhALCwu5/wG4AwBBgAgLqVEBAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACQAAAAlAAAAJgAAACcAAAAoAAAAKQAAACoAAAArAAAAAAAAACwAAAAtAAAAfQBpbmZpbml0eQBGZWJydWFyeQBKYW51YXJ5AEp1bHkARGlnZXN0T25seQBDb3VudE9ubHkAS2V5c09ubHkASGFzaEtleQBSb3V0aW5nS2V5AFVuaXF1ZUtleQBTeW5jS2V5AHNpemVvZl9lbHRfaW5fcmVwZWF0ZWRfYXJyYXkAVGh1cnNkYXkAVHVlc2RheQBXZWRuZXNkYXkAU2F0dXJkYXkAU3VuZGF5AE1vbmRheQBGcmlkYXkATWF5ACVtLyVkLyV5AENvbm5JbmRleABOYW1lc3BhY2VJbmRleAAtKyAgIDBYMHgALTBYKzBYIDBYLTB4KzB4IDB4AF9fbmV4dF9wcmltZSBvdmVyZmxvdwBOb3YAVGh1AFRpbWVvdXQAQXVndXN0AENSU1lOQ19fVkFMVUVfVFlQRV9fTGlzdABDcnN5bmNfX04xUUxRdWVyeVJlcXVlc3QAY3JzeW5jLk4xUUxRdWVyeVJlcXVlc3QAQ3JzeW5jX19SYW5nZURvY3NSZXF1ZXN0AGNyc3luYy5SYW5nZURvY3NSZXF1ZXN0AEdhbGFjdHVzX19Fc3RhYmxpc2hSZXF1ZXN0AENyc3luY19fRXN0YWJsaXNoUmVxdWVzdABnYWxhY3R1cy5Fc3RhYmxpc2hSZXF1ZXN0AGNyc3luYy5Fc3RhYmxpc2hSZXF1ZXN0AENyc3luY19fQmF0Y2hSZXF1ZXN0AGNyc3luYy5CYXRjaFJlcXVlc3QAQ3JzeW5jX19VcGRhdGVSZXF1ZXN0AGNyc3luYy5VcGRhdGVSZXF1ZXN0AENyc3luY19fRGF0YWJhc2VSZXF1ZXN0AGNyc3luYy5EYXRhYmFzZVJlcXVlc3QAR2FsYWN0dXNfX1NoYWtlSGFuZFJlcXVlc3QAZ2FsYWN0dXMuU2hha2VIYW5kUmVxdWVzdABDcnN5bmNfX1F1ZXJ5RG9jUmVxdWVzdABjcnN5bmMuUXVlcnlEb2NSZXF1ZXN0AENyc3luY19fUHV0RG9jUmVxdWVzdABjcnN5bmMuUHV0RG9jUmVxdWVzdABDcnN5bmNfX0dldERvY1JlcXVlc3QAY3JzeW5jLkdldERvY1JlcXVlc3QAQ3JzeW5jX19EZWxEb2NSZXF1ZXN0AGNyc3luYy5EZWxEb2NSZXF1ZXN0AEJlc3QAQ1JTWU5DX19VUERBVEVfTUVUSE9EX19MaXN0SW5zZXJ0AFN0YXJ0AHJlY2VpdmVkIGVtcHR5IHNuYXBzaG90AGZhaWwgdG8gcmVjdiBzbmFwc2hvdABzZW5kaW5nIHNuYXBzaG90AENvbm5lY3Rpb25Db3VudABTdHJlYW1Db3VudAAgY3JlYXRlIGNoZWNrcG9pbnQARW5kcG9pbnQAQ3JzeW5jX19UaWNrZXRFdmVudABjcnN5bmMuVGlja2V0RXZlbnQAQ3JzeW5jX19QZXJtaXNzaW9uRXZlbnQAY3JzeW5jLlBlcm1pc3Npb25FdmVudABDcnN5bmNfX0tlZXBhbGl2ZUV2ZW50AGNyc3luYy5LZWVwYWxpdmVFdmVudABDb250ZW50AHNob3VsZCBoYXZlIG9ubHkgdXNlZCBoYXNoZXMgdGhhdCBhcmUgaW4gdGhlIGRvY3VtZW50AENyc3luY19fRG9jdW1lbnQAY3JzeW5jLkRvY3VtZW50AFN0YXRlbWVudABJbnN0YW50AExpbWl0AENSU1lOQ19fVVBEQVRFX01FVEhPRF9fQ291bnRlclNldABDUlNZTkNfX1VQREFURV9NRVRIT0RfX1NldABDUlNZTkNfX1ZBTFVFX1RZUEVfX0RpY3QAIGNvbXBhY3QAT2N0AENSU1lOQ19fVkFMVUVfVFlQRV9fRmxvYXQAU2F0AGdhbGFjdHVzAERvY3VtZW50cwBDbGllbnRzAEdyYW50cwBSZXN1bHRzAFRpY2tldHMAU3VjY2VzcwBDbHVzdGVycwBPcHRpb25zAFBlcm1zAEl0ZW1zAFBhcmFtcwBQYXRocwBkaWZmcwBVcGRhdGVzAEZvcmJpZHMATG9hZHMARG9jcwBUcwAlcwBBcHIAbWVzc2FnZS0+YmFzZS5kZXNjcmlwdG9yID09ICZjcnN5bmNfX24xX3FscXVlcnlfcmVxdWVzdF9fZGVzY3JpcHRvcgBtZXNzYWdlLT5iYXNlLmRlc2NyaXB0b3IgPT0gJmNyc3luY19fcmFuZ2VfZG9jc19yZXF1ZXN0X19kZXNjcmlwdG9yAG1lc3NhZ2UtPmJhc2UuZGVzY3JpcHRvciA9PSAmZ2FsYWN0dXNfX2VzdGFibGlzaF9yZXF1ZXN0X19kZXNjcmlwdG9yAG1lc3NhZ2UtPmJhc2UuZGVzY3JpcHRvciA9PSAmY3JzeW5jX19lc3RhYmxpc2hfcmVxdWVzdF9fZGVzY3JpcHRvcgBtZXNzYWdlLT5iYXNlLmRlc2NyaXB0b3IgPT0gJmNyc3luY19fYmF0Y2hfcmVxdWVzdF9fZGVzY3JpcHRvcgBtZXNzYWdlLT5iYXNlLmRlc2NyaXB0b3IgPT0gJmNyc3luY19fdXBkYXRlX3JlcXVlc3RfX2Rlc2NyaXB0b3IAbWVzc2FnZS0+YmFzZS5kZXNjcmlwdG9yID09ICZjcnN5bmNfX2RhdGFiYXNlX3JlcXVlc3RfX2Rlc2NyaXB0b3IAbWVzc2FnZS0+YmFzZS5kZXNjcmlwdG9yID09ICZnYWxhY3R1c19fc2hha2VfaGFuZF9yZXF1ZXN0X19kZXNjcmlwdG9yAG1lc3NhZ2UtPmJhc2UuZGVzY3JpcHRvciA9PSAmY3JzeW5jX19xdWVyeV9kb2NfcmVxdWVzdF9fZGVzY3JpcHRvcgBtZXNzYWdlLT5iYXNlLmRlc2NyaXB0b3IgPT0gJmNyc3luY19fcHV0X2RvY19yZXF1ZXN0X19kZXNjcmlwdG9yAG1lc3NhZ2UtPmJhc2UuZGVzY3JpcHRvciA9PSAmY3JzeW5jX19nZXRfZG9jX3JlcXVlc3RfX2Rlc2NyaXB0b3IAbWVzc2FnZS0+YmFzZS5kZXNjcmlwdG9yID09ICZjcnN5bmNfX2RlbF9kb2NfcmVxdWVzdF9fZGVzY3JpcHRvcgBtZXNzYWdlLT5iYXNlLmRlc2NyaXB0b3IgPT0gJmNyc3luY19fdGlja2V0X2V2ZW50X19kZXNjcmlwdG9yAG1lc3NhZ2UtPmJhc2UuZGVzY3JpcHRvciA9PSAmY3JzeW5jX19wZXJtaXNzaW9uX2V2ZW50X19kZXNjcmlwdG9yAG1lc3NhZ2UtPmJhc2UuZGVzY3JpcHRvciA9PSAmY3JzeW5jX19rZWVwYWxpdmVfZXZlbnRfX2Rlc2NyaXB0b3IAbWVzc2FnZS0+YmFzZS5kZXNjcmlwdG9yID09ICZnYWxhY3R1c19fZXh0X2hlYWRlcl9fZGVzY3JpcHRvcgBtZXNzYWdlLT5iYXNlLmRlc2NyaXB0b3IgPT0gJmNyc3luY19fbjFfcWxxdWVyeV9yZXNwb25zZV9fZGVzY3JpcHRvcgBtZXNzYWdlLT5iYXNlLmRlc2NyaXB0b3IgPT0gJmdhbGFjdHVzX19yZW5ld19rZXlfcmVzcG9uc2VfX2Rlc2NyaXB0b3IAbWVzc2FnZS0+YmFzZS5kZXNjcmlwdG9yID09ICZjcnN5bmNfX3JhbmdlX2RvY3NfcmVzcG9uc2VfX2Rlc2NyaXB0b3IAbWVzc2FnZS0+YmFzZS5kZXNjcmlwdG9yID09ICZnYWxhY3R1c19fZXN0YWJsaXNoX3Jlc3BvbnNlX19kZXNjcmlwdG9yAG1lc3NhZ2UtPmJhc2UuZGVzY3JpcHRvciA9PSAmY3JzeW5jX19lc3RhYmxpc2hfcmVzcG9uc2VfX2Rlc2NyaXB0b3IAbWVzc2FnZS0+YmFzZS5kZXNjcmlwdG9yID09ICZnYWxhY3R1c19fc2hha2VfaGFuZF9yZXNwb25zZV9fZGVzY3JpcHRvcgBtZXNzYWdlLT5iYXNlLmRlc2NyaXB0b3IgPT0gJmNyc3luY19fcXVlcnlfZG9jX3Jlc3BvbnNlX19kZXNjcmlwdG9yAG1lc3NhZ2UtPmJhc2UuZGVzY3JpcHRvciA9PSAmY3JzeW5jX19nZXRfZG9jX3Jlc3BvbnNlX19kZXNjcmlwdG9yAG1lc3NhZ2UtPmJhc2UuZGVzY3JpcHRvciA9PSAmY3JzeW5jX19zeW5jX21lc3NhZ2VfX2Rlc2NyaXB0b3IAbWVzc2FnZS0+YmFzZS5kZXNjcmlwdG9yID09ICZjcnN5bmNfX3NoYWtlaGFuZF9fZGVzY3JpcHRvcgB2ZWN0b3IAQ2x1c3RlcgBwcm90b2J1Zl9jX21lc3NhZ2VfcGFja190b19idWZmZXIAcmVwZWF0ZWRfZmllbGRfcGFja190b19idWZmZXIAcmVxdWlyZWRfZmllbGRfcGFja190b19idWZmZXIAY3JzeW5jX19uMV9xbHF1ZXJ5X3JlcXVlc3RfX3BhY2tfdG9fYnVmZmVyAGNyc3luY19fcmFuZ2VfZG9jc19yZXF1ZXN0X19wYWNrX3RvX2J1ZmZlcgBnYWxhY3R1c19fZXN0YWJsaXNoX3JlcXVlc3RfX3BhY2tfdG9fYnVmZmVyAGNyc3luY19fZXN0YWJsaXNoX3JlcXVlc3RfX3BhY2tfdG9fYnVmZmVyAGNyc3luY19fYmF0Y2hfcmVxdWVzdF9fcGFja190b19idWZmZXIAY3JzeW5jX191cGRhdGVfcmVxdWVzdF9fcGFja190b19idWZmZXIAY3JzeW5jX19kYXRhYmFzZV9yZXF1ZXN0X19wYWNrX3RvX2J1ZmZlcgBnYWxhY3R1c19fc2hha2VfaGFuZF9yZXF1ZXN0X19wYWNrX3RvX2J1ZmZlcgBjcnN5bmNfX3F1ZXJ5X2RvY19yZXF1ZXN0X19wYWNrX3RvX2J1ZmZlcgBjcnN5bmNfX3B1dF9kb2NfcmVxdWVzdF9fcGFja190b19idWZmZXIAY3JzeW5jX19nZXRfZG9jX3JlcXVlc3RfX3BhY2tfdG9fYnVmZmVyAGNyc3luY19fZGVsX2RvY19yZXF1ZXN0X19wYWNrX3RvX2J1ZmZlcgBjcnN5bmNfX3RpY2tldF9ldmVudF9fcGFja190b19idWZmZXIAY3JzeW5jX19rZWVwYWxpdmVfZXZlbnRfX3BhY2tfdG9fYnVmZmVyAGdhbGFjdHVzX19leHRfaGVhZGVyX19wYWNrX3RvX2J1ZmZlcgBjcnN5bmNfX3N5bmNfbWVzc2FnZV9fcGFja190b19idWZmZXIAY3JzeW5jX19zaGFrZWhhbmRfX3BhY2tfdG9fYnVmZmVyAGNvbHVtbnMgb3V0IG9mIG9yZGVyAF9mb2xkZXIATGVhZGVyAEdhbGFjdHVzX19FeHRIZWFkZXIAZ2FsYWN0dXMuRXh0SGVhZGVyAE9jdG9iZXIATm92ZW1iZXIAU2VwdGVtYmVyAHBhcnNlX21lbWJlcgBwYXJzZV9wYWNrZWRfcmVwZWF0ZWRfbWVtYmVyAERlY2VtYmVyAExvY2FsQWRkcgBSZW1vdGVBZGRyAGlvc19iYXNlOjpjbGVhcgBNYXIARGlmZlNlcQBtZWRpYV9zZXJ2ZXJfbGlicmFyeS9jcmR0L2RvY3VtZW50LmNwcABtZWRpYV9zZXJ2ZXJfbGlicmFyeS9jcmR0L21lcmtsZV9zZWFyY2hfdHJlZS5jcHAAU2VwAENyc3luY19fVXBkYXRlT3AAY3JzeW5jLlVwZGF0ZU9wACVJOiVNOiVTICVwAEdhbGFjdHVzX19QZWVySW5mbwBnYWxhY3R1cy5QZWVySW5mbwBTdW4ASnVuAFJlYXNvbgBQZXJtSnNvbgBCaURpcmVjdGlvbgBUcnkgdG8gZXN0YWJsaXNoIGNvbm5lY3Rpb24AVHJ5IHRvIGVzdGFibGlzaCBuZXdzeW5jIGNvbm5lY3Rpb24AQ29sbGVjdGlvbgBDcnN5bmNfX09wZXJhdGlvbgBjcnN5bmMuT3BlcmF0aW9uAENyc3luY19fUGVybWlzc2lvbgBjcnN5bmMuUGVybWlzc2lvbgBWZXJzaW9uAE1vbgB0bXAgPT0gcGF5bG9hZF9sZW4AbmFuAEphbgBRdW9ydW0AQ3JzeW5jX19LZWVwYWxpdmVJdGVtAGNyc3luYy5LZWVwYWxpdmVJdGVtAENyc3luY19fSXRlbQBjcnN5bmMuSXRlbQBJbnNlcnRFbGVtAEp1bABUdGwAR2FsYWN0dXNfX1BlZXJQcm90b2NvbABnYWxhY3R1cy5QZWVyUHJvdG9jb2wAbnVsbABDb2xsAEFwcmlsAEV4aXN0c0ZhaWwAX2ludGVydmFsAF9lcGhlbWVyYWwATG9jYWwAcHJvdG9idWZfY19tZXNzYWdlX3VucGFjawBGcmkAZ2V0X3BhY2tlZF9wYXlsb2FkX2xlbmd0aABQYXRoAG9wIGZpZWxkIGNvdW50IGRvZXMgbm90IG1hdGNoAG1hZ2ljIG51bWJlciBkb2VzIG5vdCBtYXRjaABjaGVja3N1bSBkb2VzIG5vdCBtYXRjaABNYXJjaAAuL21lZGlhX3NlcnZlcl9saWJyYXJ5L2NyZHQvbWVya2xlX3NlYXJjaF90cmVlLmgAQXVnACByZWN2IGVyciBtc2cAYmFzaWNfc3RyaW5nAENSU1lOQ19fVkFMVUVfVFlQRV9fU3RyaW5nAEZsYWcAaW5mAEdhbGFjdHVzX19JbnRlcmVzdERpZmYAZ2FsYWN0dXMuSW50ZXJlc3REaWZmACUuMExmACVMZgBwcm90b2J1Zl9jX21lc3NhZ2VfZ2V0X3BhY2tlZF9zaXplAHJlcXVpcmVkX2ZpZWxkX2dldF9wYWNrZWRfc2l6ZQBjcnN5bmNfX24xX3FscXVlcnlfcmVxdWVzdF9fZ2V0X3BhY2tlZF9zaXplAGNyc3luY19fcmFuZ2VfZG9jc19yZXF1ZXN0X19nZXRfcGFja2VkX3NpemUAZ2FsYWN0dXNfX2VzdGFibGlzaF9yZXF1ZXN0X19nZXRfcGFja2VkX3NpemUAY3JzeW5jX19lc3RhYmxpc2hfcmVxdWVzdF9fZ2V0X3BhY2tlZF9zaXplAGNyc3luY19fYmF0Y2hfcmVxdWVzdF9fZ2V0X3BhY2tlZF9zaXplAGNyc3luY19fdXBkYXRlX3JlcXVlc3RfX2dldF9wYWNrZWRfc2l6ZQBjcnN5bmNfX2RhdGFiYXNlX3JlcXVlc3RfX2dldF9wYWNrZWRfc2l6ZQBnYWxhY3R1c19fc2hha2VfaGFuZF9yZXF1ZXN0X19nZXRfcGFja2VkX3NpemUAY3JzeW5jX19xdWVyeV9kb2NfcmVxdWVzdF9fZ2V0X3BhY2tlZF9zaXplAGNyc3luY19fcHV0X2RvY19yZXF1ZXN0X19nZXRfcGFja2VkX3NpemUAY3JzeW5jX19nZXRfZG9jX3JlcXVlc3RfX2dldF9wYWNrZWRfc2l6ZQBjcnN5bmNfX2RlbF9kb2NfcmVxdWVzdF9fZ2V0X3BhY2tlZF9zaXplAGNyc3luY19fdGlja2V0X2V2ZW50X19nZXRfcGFja2VkX3NpemUAY3JzeW5jX19rZWVwYWxpdmVfZXZlbnRfX2dldF9wYWNrZWRfc2l6ZQBnYWxhY3R1c19fZXh0X2hlYWRlcl9fZ2V0X3BhY2tlZF9zaXplAGNyc3luY19fc3luY19tZXNzYWdlX19nZXRfcGFja2VkX3NpemUAY3JzeW5jX19zaGFrZWhhbmRfX2dldF9wYWNrZWRfc2l6ZQB0cnVlAFZhbHVlAFR1ZQBSZW1vdGUAQ1JTWU5DX19PUEVSQVRJT05fX1dyaXRlAENSU1lOQ19fVVBEQVRFX01FVEhPRF9fRGVsZXRlACwgcmVzZXQgY29ubmVjdGlvbiBzdGF0ZQBDcmVhdGUAQ1JTWU5DX19VUERBVEVfTUVUSE9EX19VcGRhdGUAVHJhdmVyc2UAQ3JzeW5jX19OMVFMUXVlcnlSZXNwb25zZQBjcnN5bmMuTjFRTFF1ZXJ5UmVzcG9uc2UAR2FsYWN0dXNfX1JlbmV3S2V5UmVzcG9uc2UAZ2FsYWN0dXMuUmVuZXdLZXlSZXNwb25zZQBDcnN5bmNfX1JhbmdlRG9jc1Jlc3BvbnNlAGNyc3luYy5SYW5nZURvY3NSZXNwb25zZQBHYWxhY3R1c19fRXN0YWJsaXNoUmVzcG9uc2UAQ3JzeW5jX19Fc3RhYmxpc2hSZXNwb25zZQBnYWxhY3R1cy5Fc3RhYmxpc2hSZXNwb25zZQBjcnN5bmMuRXN0YWJsaXNoUmVzcG9uc2UAR2FsYWN0dXNfX1NoYWtlSGFuZFJlc3BvbnNlAGdhbGFjdHVzLlNoYWtlSGFuZFJlc3BvbnNlAENyc3luY19fUXVlcnlEb2NSZXNwb25zZQBjcnN5bmMuUXVlcnlEb2NSZXNwb25zZQBDcnN5bmNfX0dldERvY1Jlc3BvbnNlAGNyc3luYy5HZXREb2NSZXNwb25zZQBmYWxzZQBEYXRhYmFzZQBjaGFuZ2UgaXMgZWFybGllciB0aGFuIHBlZXIgYmFzZQBTY29yZQBNb3JlAENsaWVudFR5cGUAQ3JzeW5jX19WYWx1ZVR5cGUAY3JzeW5jLlZhbHVlVHlwZQBKdW5lAE5hbWUAQXZhaWxhYmxlAElnbm9yZVByaXZpbGVnZQBDcnN5bmNfX1ByaXZpbGVnZQBjcnN5bmMuUHJpdmlsZWdlAENyc3luY19fU3luY01lc3NhZ2UAY3JzeW5jLlN5bmNNZXNzYWdlAGJhc2UgaXMgbm90IGJlZm9yZSBzaGFyZWQgaGVhZHMsIHRvIHByb2JlIG1vZGUAcmVjdiBlcnIsIHRvIHByb2JlIG1vZGUAYmFzZSBpcyBub3QgYmVmb3JlIGxhc3Qgc3luYywgdG8gcHJvYmUgbW9kZQBHYWxhY3R1c19fUGVlck1vZGUAZ2FsYWN0dXMuUGVlck1vZGUAQXN5bmNNb2RlAEFkYXB0b3Igc3VnZ2VzdCBkaXNjb25uZWN0IGZvciBuYW1lc3BhY2UATmFtZXNwYWNlAENyc3luY19fVXBkYXRlTWV0aG9kAGNyc3luYy5VcGRhdGVNZXRob2QAY2hlY2twb2ludCBub3QgZm91bmQAVXB0aW1lSW5TZWNvbmQAR2V0Q2hhbmdlc1RvU2VuZABDcnN5bmNfX1NoYWtlaGFuZABjcnN5bmMuU2hha2VoYW5kAEVuZABSZW1vdmVkAGNvbm5lY3Rpb24gdGltZW91dGVkAElnbm9yZUV4cGlyZWQAZGVjb2RlIG9wcyBmYWlsZWQAcGFyc2UgZm9sZGVyIG1zZyBmYWlsZWQAY2xvY2tfZ2V0dGltZShDTE9DS19SRUFMVElNRSkgZmFpbGVkAGNsb2NrX2dldHRpbWUoQ0xPQ0tfTU9OT1RPTklDKSBmYWlsZWQAcHJvdG9idWZfY19tZXNzYWdlX2ZyZWVfdW5wYWNrZWQAY3JzeW5jX19kYXRhYmFzZV9yZXF1ZXN0X19mcmVlX3VucGFja2VkAGNyc3luY19fcGVybWlzc2lvbl9ldmVudF9fZnJlZV91bnBhY2tlZABjcnN5bmNfX24xX3FscXVlcnlfcmVzcG9uc2VfX2ZyZWVfdW5wYWNrZWQAZ2FsYWN0dXNfX3JlbmV3X2tleV9yZXNwb25zZV9fZnJlZV91bnBhY2tlZABjcnN5bmNfX3JhbmdlX2RvY3NfcmVzcG9uc2VfX2ZyZWVfdW5wYWNrZWQAZ2FsYWN0dXNfX2VzdGFibGlzaF9yZXNwb25zZV9fZnJlZV91bnBhY2tlZABjcnN5bmNfX2VzdGFibGlzaF9yZXNwb25zZV9fZnJlZV91bnBhY2tlZABnYWxhY3R1c19fc2hha2VfaGFuZF9yZXNwb25zZV9fZnJlZV91bnBhY2tlZABjcnN5bmNfX3F1ZXJ5X2RvY19yZXNwb25zZV9fZnJlZV91bnBhY2tlZABjcnN5bmNfX2dldF9kb2NfcmVzcG9uc2VfX2ZyZWVfdW5wYWNrZWQAY3JzeW5jX19zeW5jX21lc3NhZ2VfX2ZyZWVfdW5wYWNrZWQAc3VjY2Vzc2Z1bGx5IHN5bmNlZABoZWFkcyBlcXVhbCwgcGVlciBzeW5jZWQAV2VkAHBhY2tfYnVmZmVyX3BhY2tlZF9wYXlsb2FkAEdhbGFjdHVzX19RdW9ydW1Mb2FkAGdhbGFjdHVzLlF1b3J1bUxvYWQAVG90YWxMb2FkAENSU1lOQ19fT1BFUkFUSU9OX19SZWFkAExlYXNlSWQAQXV0b0NyZWF0ZURvYwBjcnN5bmMAc3RhcnQgYSByb3VuZCBvZiBzeW5jAHN0YXJ0IGEgcm91bmQgb2YgdG9tYnN0b25lIHN5bmMAQ1JTWU5DX19VUERBVEVfTUVUSE9EX19Db3VudGVySW5jAERlYwBtZWRpYV9zZXJ2ZXJfbGlicmFyeS90aGlyZF9wYXJ0eS9ldGNkLWMvcHJvdG9idWYtYy5jAG1lZGlhX3NlcnZlcl9saWJyYXJ5L3RoaXJkX3BhcnR5L2V0Y2QtYy9wcm94eS5wYi1jLmMAbWVkaWFfc2VydmVyX2xpYnJhcnkvdGhpcmRfcGFydHkvZXRjZC1jL2Nyc3luYy5wYi1jLmMARmViAF0AXVsAcmVtb3ZlIGludGVyZXN0OiBbAGFkZCBpbnRlcmVzdDogWwBBWgBHQUxBQ1RVU19fUEVFUl9NT0RFX19QRUVSX01PREVfUFJPWFkAJWEgJWIgJWQgJUg6JU06JVMgJVkAUE9TSVgAR0FMQUNUVVNfX1BFRVJfTU9ERV9fUEVFUl9NT0RFX0NMVVNURVJfQ0xJRU5UAEdBTEFDVFVTX19QRUVSX01PREVfX1BFRVJfTU9ERV9DTElFTlQAU3BsaXRPZmZMVABHQUxBQ1RVU19fUEVFUl9NT0RFX19QRUVSX01PREVfU0lERUNBUl9ESVJFQ1QAR0FMQUNUVVNfX1BFRVJfTU9ERV9fUEVFUl9NT0RFX0VNUwAlSDolTTolUwBHQUxBQ1RVU19fUEVFUl9NT0RFX19QRUVSX01PREVfTUlHUkFUT1IAR0FMQUNUVVNfX1BFRVJfTU9ERV9fUEVFUl9NT0RFX0NPT1JESU5BVE9SAEdBTEFDVFVTX19QRUVSX01PREVfX1BFRVJfTU9ERV9TWU5DX0NFTlRFUgBHQUxBQ1RVU19fUEVFUl9NT0RFX19QRUVSX01PREVfU0lERUNBUgBHQUxBQ1RVU19fUEVFUl9QUk9UT0NPTF9fUFJPVE9DT0xfVENQAE5BTgBQTQBBTQBUVEwAcnYtPmRlc2NyaXB0b3IgIT0gTlVMTABMQ19BTEwATEFORwBJTkYASUQAR0FMQUNUVVNfX1BFRVJfUFJPVE9DT0xfX1BST1RPQ09MX0dSUEMAKChtZXNzYWdlKS0+ZGVzY3JpcHRvciktPm1hZ2ljID09IFBST1RPQlVGX0NfX01FU1NBR0VfREVTQ1JJUFRPUl9NQUdJQwAoZGVzYyktPm1hZ2ljID09IFBST1RPQlVGX0NfX01FU1NBR0VfREVTQ1JJUFRPUl9NQUdJQwBJREMALCBlcnI6AHJlY3YgdXJpOgAsIHNlcWlkOgAwMTIzNDU2Nzg5AEMuVVRGLTgAbm9kZS5jaGlsZHJlbl8uc2l6ZSgpID09IG5vZGUuZWxlbWVudHNfLnNpemUoKSArIDEAY2hpbGRyZW5fLnNpemUoKSA9PSBlbGVtZW50c18uc2l6ZSgpICsgMQAwAC8AIGFscmVhZHkgdGltZW91dC4ALCBpZ25vcmUuAC4qKioqKi4ALAAqAChudWxsKQAhc3luY19zdGF0ZS0+dGhlaXJfaGF2ZS0+ZW1wdHkoKQAhZWxlbWVudHNfLmVtcHR5KCkAZ3RfZWxlbXMuc2l6ZSgpICsgMSA9PSBndF9jaGlsZHJlbi5zaXplKCkAICAgICIAIGNvbGwgbXNnIHR5cGUgZG9lcyBub3QgbWF0Y2ghAHN5bmMgbXNnIHR5cGUgZG9lcyBub3QgbWF0Y2ghAFB1cmUgdmlydHVhbCBmdW5jdGlvbiBjYWxsZWQhAFNldCBuYW1lc3BhY2UgYXMgAHB1cmdlZCB0byAAIHdpdGggZXJybm8gAEZhaWxlZCB0byBlc3RhYmxpc2ggY29ubiAAUmVjZWl2ZSB3cm9uZyB0ZXJtIABVbmtub3duIHVyaSAAIG9uIHVyaSAAY29tbWFuZCAAUmVjZWl2ZSB1bmtvd24gc2VxaWQgAF0gAGRvYyBub3QgZXhpc3Q6IAByZWFkYWJsZSBleGlzdDogAGNoZWNrcG9pbnQ6IABkZXAgbm90IG1ldDogACBpbml0aWFsIGRvY3M6IAB1cGRhdGUgZm9sZGVyOiAALCBsb2NhbF9hZGRyOiAAZXN0YWJsaXNoIGNvbm5lY3Rpb24gc3VjY2Vzc2Z1bGx5LCByZW1vdGVfYWRkcjogAGludmFsaWQgb3AgYWN0aW9uOiAALCBnZW5lcmF0aW9uOiAALCBjdXJyZW50IHZlcnNpb246IAAsIHZlcnNpb246IABjb21wYWN0IG51bTogAHNuYXBzaG90dGluZywgY2hhbmdlIG51bTogACwgY29sbDogAGNvbXBhY3QgY2xvY2s6IABzZW50IHVyaTogAGNvbXBhY3QgbnVtIGRvZXMgbm90IG1hdGNoOiAAcmVjdiBtc2c6IABpZ25vcmUgbXNnOiAAbmVlZGVkIGhhc2ggbWlzc2lu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AAA8cgAAUHIAAAAAAACgcwAABAIAAAUCAAD0AQAA9QEAAAYCAAAHAgAA+AEAAPkBAAD6AQAACAIAAPwBAAAJAgAA/gEAAAoCAABOU3QzX18yOWJhc2ljX2lvc0ljTlNfMTFjaGFyX3RyYWl0c0ljRUVFRQAAAOifAACgcgAAhHQAAE5TdDNfXzIxNWJhc2ljX3N0cmVhbWJ1ZkljTlNfMTFjaGFyX3RyYWl0c0ljRUVFRQAAAADAnwAA2HIAAE5TdDNfXzIxM2Jhc2ljX29zdHJlYW1JY05TXzExY2hhcl90cmFpdHNJY0VFRUUAAESgAAAUcwAAAAAAAAEAAADMcgAAA/T//05TdDNfXzIxNWJhc2ljX3N0cmluZ2J1ZkljTlNfMTFjaGFyX3RyYWl0c0ljRUVOU185YWxsb2NhdG9ySWNFRUVFAAAA6J8AAFxzAAAMcwAAOAAAAAAAAABUdAAACwIAAAwCAADI////yP///1R0AAANAgAADgIAALhzAADwcwAABHQAAMxzAAA4AAAAAAAAAERzAAAAAgAAAQIAAMj////I////RHMAAAICAAADAgAATlN0M19fMjE5YmFzaWNfb3N0cmluZ3N0cmVhbUljTlNfMTFjaGFyX3RyYWl0c0ljRUVOU185YWxsb2NhdG9ySWNFRUVFAAAA6J8AAAx0AABEcwAAAAAAAIR0AAAPAgAAEAIAAE5TdDNfXzI4aW9zX2Jhc2VFAAAAwJ8AAHB0AAAAAAAA/////////////////////////////////////////////////////////////////wABAgMEBQYHCAn/////////CgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiP///////8KCwwNDg8QERITFBUWFxgZGhscHR4fICEiI/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AAQIEBwMGBQAAAAAAAAACAADAAwAAwAQAAMAFAADABgAAwAcAAMAIAADACQAAwAoAAMALAADADAAAwA0AAMAOAADADwAAwBAA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") || (b = G, G = g.locateFile ? g.locateFile(b, C) : C + b);
        var v, F = (A2) => {
          for (; A2.length > 0; )
            A2.shift()(g);
        }, K = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0, Y = (A2, e2) => A2 ? ((A3, e3, t2) => {
          for (var g2 = e3 + t2, o2 = e3; A3[o2] && !(o2 >= g2); )
            ++o2;
          if (o2 - e3 > 16 && A3.buffer && K)
            return K.decode(A3.subarray(e3, o2));
          for (var I2 = ""; e3 < o2; ) {
            var i3 = A3[e3++];
            if (128 & i3) {
              var r2 = 63 & A3[e3++];
              if (192 != (224 & i3)) {
                var n2 = 63 & A3[e3++];
                if ((i3 = 224 == (240 & i3) ? (15 & i3) << 12 | r2 << 6 | n2 : (7 & i3) << 18 | r2 << 12 | n2 << 6 | 63 & A3[e3++]) < 65536)
                  I2 += String.fromCharCode(i3);
                else {
                  var C2 = i3 - 65536;
                  I2 += String.fromCharCode(55296 | C2 >> 10, 56320 | 1023 & C2);
                }
              } else
                I2 += String.fromCharCode((31 & i3) << 6 | r2);
            } else
              I2 += String.fromCharCode(i3);
          }
          return I2;
        })(Q, A2, e2) : "", J = (A2) => {
          var e2 = (A2 - s.buffer.byteLength + 65535) / 65536;
          try {
            return s.grow(e2), R2(), 1;
          } catch (A3) {
          }
        }, P = {}, q = () => {
          if (!q.strings) {
            var A2 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: I || "./this.program" };
            for (var e2 in P)
              void 0 === P[e2] ? delete A2[e2] : A2[e2] = P[e2];
            var t2 = [];
            for (var e2 in A2)
              t2.push("".concat(e2, "=").concat(A2[e2]));
            q.strings = t2;
          }
          return q.strings;
        }, x = (A2) => A2 % 4 == 0 && (A2 % 100 != 0 || A2 % 400 == 0), H = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], $ = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], j = (A2) => {
          for (var e2 = 0, t2 = 0; t2 < A2.length; ++t2) {
            var g2 = A2.charCodeAt(t2);
            g2 <= 127 ? e2++ : g2 <= 2047 ? e2 += 2 : g2 >= 55296 && g2 <= 57343 ? (e2 += 4, ++t2) : e2 += 3;
          }
          return e2;
        }, V = (A2, e2, t2, g2) => {
          if (!(g2 > 0))
            return 0;
          for (var o2 = t2, I2 = t2 + g2 - 1, i3 = 0; i3 < A2.length; ++i3) {
            var r2 = A2.charCodeAt(i3);
            if (r2 >= 55296 && r2 <= 57343 && (r2 = 65536 + ((1023 & r2) << 10) | 1023 & A2.charCodeAt(++i3)), r2 <= 127) {
              if (t2 >= I2)
                break;
              e2[t2++] = r2;
            } else if (r2 <= 2047) {
              if (t2 + 1 >= I2)
                break;
              e2[t2++] = 192 | r2 >> 6, e2[t2++] = 128 | 63 & r2;
            } else if (r2 <= 65535) {
              if (t2 + 2 >= I2)
                break;
              e2[t2++] = 224 | r2 >> 12, e2[t2++] = 128 | r2 >> 6 & 63, e2[t2++] = 128 | 63 & r2;
            } else {
              if (t2 + 3 >= I2)
                break;
              e2[t2++] = 240 | r2 >> 18, e2[t2++] = 128 | r2 >> 12 & 63, e2[t2++] = 128 | r2 >> 6 & 63, e2[t2++] = 128 | 63 & r2;
            }
          }
          return e2[t2] = 0, t2 - o2;
        }, W = (A2, e2, t2, g2) => {
          var o2 = h[g2 + 40 >> 2], I2 = { tm_sec: l[g2 >> 2], tm_min: l[g2 + 4 >> 2], tm_hour: l[g2 + 8 >> 2], tm_mday: l[g2 + 12 >> 2], tm_mon: l[g2 + 16 >> 2], tm_year: l[g2 + 20 >> 2], tm_wday: l[g2 + 24 >> 2], tm_yday: l[g2 + 28 >> 2], tm_isdst: l[g2 + 32 >> 2], tm_gmtoff: l[g2 + 36 >> 2], tm_zone: o2 ? Y(o2) : "" }, i3 = Y(t2), r2 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" };
          for (var n2 in r2)
            i3 = i3.replace(new RegExp(n2, "g"), r2[n2]);
          var C2 = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], E2 = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
          function s2(A3, e3, t3) {
            for (var g3 = "number" == typeof A3 ? A3.toString() : A3 || ""; g3.length < e3; )
              g3 = t3[0] + g3;
            return g3;
          }
          function B2(A3, e3) {
            return s2(A3, e3, "0");
          }
          function Q2(A3, e3) {
            function t3(A4) {
              return A4 < 0 ? -1 : A4 > 0 ? 1 : 0;
            }
            var g3;
            return 0 === (g3 = t3(A3.getFullYear() - e3.getFullYear())) && 0 === (g3 = t3(A3.getMonth() - e3.getMonth())) && (g3 = t3(A3.getDate() - e3.getDate())), g3;
          }
          function c2(A3) {
            switch (A3.getDay()) {
              case 0:
                return new Date(A3.getFullYear() - 1, 11, 29);
              case 1:
                return A3;
              case 2:
                return new Date(A3.getFullYear(), 0, 3);
              case 3:
                return new Date(A3.getFullYear(), 0, 2);
              case 4:
                return new Date(A3.getFullYear(), 0, 1);
              case 5:
                return new Date(A3.getFullYear() - 1, 11, 31);
              case 6:
                return new Date(A3.getFullYear() - 1, 11, 30);
            }
          }
          function u2(A3) {
            var e3 = ((A4, e4) => {
              for (var t4 = new Date(A4.getTime()); e4 > 0; ) {
                var g4 = x(t4.getFullYear()), o4 = t4.getMonth(), I4 = (g4 ? H : $)[o4];
                if (!(e4 > I4 - t4.getDate()))
                  return t4.setDate(t4.getDate() + e4), t4;
                e4 -= I4 - t4.getDate() + 1, t4.setDate(1), o4 < 11 ? t4.setMonth(o4 + 1) : (t4.setMonth(0), t4.setFullYear(t4.getFullYear() + 1));
              }
              return t4;
            })(new Date(A3.tm_year + 1900, 0, 1), A3.tm_yday), t3 = new Date(e3.getFullYear(), 0, 4), g3 = new Date(e3.getFullYear() + 1, 0, 4), o3 = c2(t3), I3 = c2(g3);
            return Q2(o3, e3) <= 0 ? Q2(I3, e3) <= 0 ? e3.getFullYear() + 1 : e3.getFullYear() : e3.getFullYear() - 1;
          }
          var d2 = { "%a": (A3) => C2[A3.tm_wday].substring(0, 3), "%A": (A3) => C2[A3.tm_wday], "%b": (A3) => E2[A3.tm_mon].substring(0, 3), "%B": (A3) => E2[A3.tm_mon], "%C": (A3) => B2((A3.tm_year + 1900) / 100 | 0, 2), "%d": (A3) => B2(A3.tm_mday, 2), "%e": (A3) => s2(A3.tm_mday, 2, " "), "%g": (A3) => u2(A3).toString().substring(2), "%G": (A3) => u2(A3), "%H": (A3) => B2(A3.tm_hour, 2), "%I": (A3) => {
            var e3 = A3.tm_hour;
            return 0 == e3 ? e3 = 12 : e3 > 12 && (e3 -= 12), B2(e3, 2);
          }, "%j": (A3) => B2(A3.tm_mday + ((A4, e3) => {
            for (var t3 = 0, g3 = 0; g3 <= e3; t3 += A4[g3++])
              ;
            return t3;
          })(x(A3.tm_year + 1900) ? H : $, A3.tm_mon - 1), 3), "%m": (A3) => B2(A3.tm_mon + 1, 2), "%M": (A3) => B2(A3.tm_min, 2), "%n": () => "\n", "%p": (A3) => A3.tm_hour >= 0 && A3.tm_hour < 12 ? "AM" : "PM", "%S": (A3) => B2(A3.tm_sec, 2), "%t": () => "	", "%u": (A3) => A3.tm_wday || 7, "%U": (A3) => {
            var e3 = A3.tm_yday + 7 - A3.tm_wday;
            return B2(Math.floor(e3 / 7), 2);
          }, "%V": (A3) => {
            var e3 = Math.floor((A3.tm_yday + 7 - (A3.tm_wday + 6) % 7) / 7);
            if ((A3.tm_wday + 371 - A3.tm_yday - 2) % 7 <= 2 && e3++, e3) {
              if (53 == e3) {
                var t3 = (A3.tm_wday + 371 - A3.tm_yday) % 7;
                4 == t3 || 3 == t3 && x(A3.tm_year) || (e3 = 1);
              }
            } else {
              e3 = 52;
              var g3 = (A3.tm_wday + 7 - A3.tm_yday - 1) % 7;
              (4 == g3 || 5 == g3 && x(A3.tm_year % 400 - 1)) && e3++;
            }
            return B2(e3, 2);
          }, "%w": (A3) => A3.tm_wday, "%W": (A3) => {
            var e3 = A3.tm_yday + 7 - (A3.tm_wday + 6) % 7;
            return B2(Math.floor(e3 / 7), 2);
          }, "%y": (A3) => (A3.tm_year + 1900).toString().substring(2), "%Y": (A3) => A3.tm_year + 1900, "%z": (A3) => {
            var e3 = A3.tm_gmtoff, t3 = e3 >= 0;
            return e3 = (e3 = Math.abs(e3) / 60) / 60 * 100 + e3 % 60, (t3 ? "+" : "-") + String("0000" + e3).slice(-4);
          }, "%Z": (A3) => A3.tm_zone, "%%": () => "%" };
          for (var n2 in i3 = i3.replace(/%%/g, "\0\0"), d2)
            i3.includes(n2) && (i3 = i3.replace(new RegExp(n2, "g"), d2[n2](I2)));
          i3 = i3.replace(/\0\0/g, "%");
          var D2, y2, p3, R3, w2, _2 = (y2 = j(D2 = i3) + 1, p3 = new Array(y2), V(D2, p3, 0, p3.length), p3);
          return _2.length > e2 ? 0 : (R3 = _2, w2 = A2, a.set(R3, w2), _2.length - 1);
        }, Z = (A2, e2) => {
          A2 < 128 ? e2.push(A2) : e2.push(A2 % 128 | 128, A2 >> 7);
        }, X = (A2, e2) => {
          if ("function" == typeof WebAssembly.Function)
            return new WebAssembly.Function(((A3) => {
              for (var e3 = { i: "i32", j: "i64", f: "f32", d: "f64", p: "i32" }, t3 = { parameters: [], results: "v" == A3[0] ? [] : [e3[A3[0]]] }, g3 = 1; g3 < A3.length; ++g3)
                t3.parameters.push(e3[A3[g3]]);
              return t3;
            })(e2), A2);
          var t2 = [1];
          ((A3, e3) => {
            var t3 = A3.slice(0, 1), g3 = A3.slice(1), o3 = { i: 127, p: 127, j: 126, f: 125, d: 124 };
            e3.push(96), Z(g3.length, e3);
            for (var I2 = 0; I2 < g3.length; ++I2)
              e3.push(o3[g3[I2]]);
            "v" == t3 ? e3.push(0) : e3.push(1, o3[t3]);
          })(e2, t2);
          var g2 = [0, 97, 115, 109, 1, 0, 0, 0, 1];
          Z(t2.length, g2), g2.push.apply(g2, t2), g2.push(2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0);
          var o2 = new WebAssembly.Module(new Uint8Array(g2));
          return new WebAssembly.Instance(o2, { e: { f: A2 } }).exports.f;
        }, z = (A2) => y.get(A2), AA = void 0, eA = (A2) => (AA || (AA = /* @__PURE__ */ new WeakMap(), ((A3, e2) => {
          if (AA)
            for (var t2 = A3; t2 < A3 + e2; t2++) {
              var g2 = z(t2);
              g2 && AA.set(g2, t2);
            }
        })(0, y.length)), AA.get(A2) || 0), tA = [], gA = (A2, e2) => y.set(A2, e2), oA = { a: (A2, e2, t2, g2) => {
          L("Assertion failed: ".concat(Y(A2), ", at: ") + [e2 ? Y(e2) : "unknown filename", t2, g2 ? Y(g2) : "unknown function"]);
        }, f: () => true, b: () => {
          L("");
        }, g: () => Date.now(), i: () => performance.now(), h: (A2) => {
          var e2 = Q.length, t2 = 2147483648;
          if ((A2 >>>= 0) > t2)
            return false;
          for (var g2 = (A3, e3) => A3 + (e3 - A3 % e3) % e3, o2 = 1; o2 <= 4; o2 *= 2) {
            var I2 = e2 * (1 + 0.2 / o2);
            I2 = Math.min(I2, A2 + 100663296);
            var i3 = Math.min(t2, g2(Math.max(A2, I2), 65536));
            if (J(i3))
              return true;
          }
          return false;
        }, d: (A2, e2) => {
          var t2 = 0;
          return q().forEach((g2, o2) => {
            var I2 = e2 + t2;
            h[A2 + 4 * o2 >> 2] = I2, ((A3, e3) => {
              for (var t3 = 0; t3 < A3.length; ++t3)
                a[0 | e3++] = A3.charCodeAt(t3);
              a[0 | e3] = 0;
            })(g2, I2), t2 += g2.length + 1;
          }), 0;
        }, e: (A2, e2) => {
          var t2 = q();
          h[A2 >> 2] = t2.length;
          var g2 = 0;
          return t2.forEach((A3) => g2 += A3.length + 1), h[e2 >> 2] = g2, 0;
        }, j: function(A2, e2) {
          g.rtejsLog(A2, Y(e2));
        }, c: (A2, e2, t2, g2, o2) => W(A2, e2, t2, g2) }, IA = function() {
          var A2, e2, o2, I2 = { a: oA };
          function i3(A3, e3) {
            var t2, o3 = A3.exports;
            return s = (IA = o3).k, R2(), y = IA.m, t2 = IA.l, _.unshift(t2), function() {
              if (M--, g.monitorRunDependencies && g.monitorRunDependencies(M), 0 == M && k) {
                var A4 = k;
                k = null, A4();
              }
            }(), o3;
          }
          if (M++, g.monitorRunDependencies && g.monitorRunDependencies(M), g.instantiateWasm)
            try {
              return g.instantiateWasm(I2, i3);
            } catch (A3) {
              B("Module.instantiateWasm callback failed with error: ".concat(A3)), t(A3);
            }
          return (A2 = G, e2 = I2, o2 = function(A3) {
            i3(A3.instance);
          }, O(A2, e2, o2)).catch(t), {};
        }();
        function iA() {
          function A2() {
            v || (v = true, g.calledRun = true, p2 || (F(_), e(g), g.onRuntimeInitialized && g.onRuntimeInitialized(), function() {
              if (g.postRun)
                for ("function" == typeof g.postRun && (g.postRun = [g.postRun]); g.postRun.length; )
                  N(g.postRun.shift());
              F(S);
            }()));
          }
          M > 0 || (function() {
            if (g.preRun)
              for ("function" == typeof g.preRun && (g.preRun = [g.preRun]); g.preRun.length; )
                f(g.preRun.shift());
            F(w);
          }(), M > 0 || (g.setStatus ? (g.setStatus("Running..."), setTimeout(function() {
            setTimeout(function() {
              g.setStatus("");
            }, 1), A2();
          }, 1)) : A2()));
        }
        if (g._free = (A2) => (g._free = IA.n)(A2), g._malloc = (A2) => (g._malloc = IA.o)(A2), g._rte_crdt_value_create = () => (g._rte_crdt_value_create = IA.p)(), g._rte_crdt_value_clone = (A2) => (g._rte_crdt_value_clone = IA.q)(A2), g._rte_crdt_value_destroy = (A2) => (g._rte_crdt_value_destroy = IA.r)(A2), g._rte_crdt_value_is_scalar = (A2) => (g._rte_crdt_value_is_scalar = IA.s)(A2), g._rte_crdt_value_is_map = (A2) => (g._rte_crdt_value_is_map = IA.t)(A2), g._rte_crdt_value_is_list = (A2) => (g._rte_crdt_value_is_list = IA.u)(A2), g._rte_crdt_value_get_scalar = (A2) => (g._rte_crdt_value_get_scalar = IA.v)(A2), g._rte_crdt_value_set_scalar = (A2) => (g._rte_crdt_value_set_scalar = IA.w)(A2), g._rte_crdt_value_set_map = (A2) => (g._rte_crdt_value_set_map = IA.x)(A2), g._rte_crdt_value_set_list = (A2) => (g._rte_crdt_value_set_list = IA.y)(A2), g._rte_crdt_scalar_value_set_i64 = (A2, e2) => (g._rte_crdt_scalar_value_set_i64 = IA.z)(A2, e2), g._rte_crdt_scalar_value_set_u64 = (A2, e2) => (g._rte_crdt_scalar_value_set_u64 = IA.A)(A2, e2), g._rte_crdt_scalar_value_set_double = (A2, e2) => (g._rte_crdt_scalar_value_set_double = IA.B)(A2, e2), g._rte_crdt_scalar_value_set_bool = (A2, e2) => (g._rte_crdt_scalar_value_set_bool = IA.C)(A2, e2), g._rte_crdt_scalar_value_set_bytes = (A2, e2, t2) => (g._rte_crdt_scalar_value_set_bytes = IA.D)(A2, e2, t2), g._rte_crdt_scalar_value_set_null = (A2) => (g._rte_crdt_scalar_value_set_null = IA.E)(A2), g._rte_crdt_scalar_value_set_counter = (A2, e2) => (g._rte_crdt_scalar_value_set_counter = IA.F)(A2, e2), g._rte_crdt_scalar_value_is_i64 = (A2) => (g._rte_crdt_scalar_value_is_i64 = IA.G)(A2), g._rte_crdt_scalar_value_is_u64 = (A2) => (g._rte_crdt_scalar_value_is_u64 = IA.H)(A2), g._rte_crdt_scalar_value_is_double = (A2) => (g._rte_crdt_scalar_value_is_double = IA.I)(A2), g._rte_crdt_scalar_value_is_bool = (A2) => (g._rte_crdt_scalar_value_is_bool = IA.J)(A2), g._rte_crdt_scalar_value_is_bytes = (A2) => (g._rte_crdt_scalar_value_is_bytes = IA.K)(A2), g._rte_crdt_scalar_value_is_null = (A2) => (g._rte_crdt_scalar_value_is_null = IA.L)(A2), g._rte_crdt_scalar_value_is_counter = (A2) => (g._rte_crdt_scalar_value_is_counter = IA.M)(A2), g._rte_crdt_scalar_value_get_i64 = (A2, e2) => (g._rte_crdt_scalar_value_get_i64 = IA.N)(A2, e2), g._rte_crdt_scalar_value_get_u64 = (A2, e2) => (g._rte_crdt_scalar_value_get_u64 = IA.O)(A2, e2), g._rte_crdt_scalar_value_get_double = (A2, e2) => (g._rte_crdt_scalar_value_get_double = IA.P)(A2, e2), g._rte_crdt_scalar_value_get_bool = (A2, e2) => (g._rte_crdt_scalar_value_get_bool = IA.Q)(A2, e2), g._rte_crdt_scalar_value_get_bytes = (A2, e2, t2) => (g._rte_crdt_scalar_value_get_bytes = IA.R)(A2, e2, t2), g._rte_crdt_scalar_value_get_counter = (A2, e2) => (g._rte_crdt_scalar_value_get_counter = IA.S)(A2, e2), g._rte_crdt_nested_value_create = () => (g._rte_crdt_nested_value_create = IA.T)(), g._rte_crdt_nested_value_destroy = (A2) => (g._rte_crdt_nested_value_destroy = IA.U)(A2), g._rte_crdt_nested_value_print = (A2) => (g._rte_crdt_nested_value_print = IA.V)(A2), g._rte_crdt_nested_value_is_scalar = (A2) => (g._rte_crdt_nested_value_is_scalar = IA.W)(A2), g._rte_crdt_nested_value_is_map = (A2) => (g._rte_crdt_nested_value_is_map = IA.X)(A2), g._rte_crdt_nested_value_is_list = (A2) => (g._rte_crdt_nested_value_is_list = IA.Y)(A2), g._rte_crdt_nested_value_get_scalar = (A2) => (g._rte_crdt_nested_value_get_scalar = IA.Z)(A2), g._rte_crdt_nested_value_iterator_create = (A2) => (g._rte_crdt_nested_value_iterator_create = IA._)(A2), g._rte_crdt_nested_value_iterator_destroy = (A2) => (g._rte_crdt_nested_value_iterator_destroy = IA.$)(A2), g._rte_crdt_nested_value_iterator_next_key_value = (A2, e2, t2, o2) => (g._rte_crdt_nested_value_iterator_next_key_value = IA.aa)(A2, e2, t2, o2), g._rte_crdt_nested_value_iterator_next_value = (A2, e2) => (g._rte_crdt_nested_value_iterator_next_value = IA.ba)(A2, e2), g._rte_crdt_path_create = () => (g._rte_crdt_path_create = IA.ca)(), g._rte_crdt_path_clone = (A2) => (g._rte_crdt_path_clone = IA.da)(A2), g._rte_crdt_path_destroy = (A2) => (g._rte_crdt_path_destroy = IA.ea)(A2), g._rte_crdt_path_add_property = (A2, e2, t2) => (g._rte_crdt_path_add_property = IA.fa)(A2, e2, t2), g._rte_crdt_path_add_index = (A2, e2) => (g._rte_crdt_path_add_index = IA.ga)(A2, e2), g._rte_crdt_path_iterator_create = (A2) => (g._rte_crdt_path_iterator_create = IA.ha)(A2), g._rte_crdt_path_iterator_destroy = (A2) => (g._rte_crdt_path_iterator_destroy = IA.ia)(A2), g._rte_crdt_path_iterator_next = (A2, e2, t2, o2) => (g._rte_crdt_path_iterator_next = IA.ja)(A2, e2, t2, o2), g._rte_crdt_document_destroy = (A2) => (g._rte_crdt_document_destroy = IA.ka)(A2), g._rte_crdt_document_get = (A2, e2, t2, o2) => (g._rte_crdt_document_get = IA.la)(A2, e2, t2, o2), g._rte_crdt_document_obj_size = (A2, e2, t2, o2) => (g._rte_crdt_document_obj_size = IA.ma)(A2, e2, t2, o2), g._rte_crdt_document_batch_write_begin = (A2) => (g._rte_crdt_document_batch_write_begin = IA.na)(A2), g._rte_crdt_document_batch_write_end = (A2) => (g._rte_crdt_document_batch_write_end = IA.oa)(A2), g._rte_crdt_document_put = (A2, e2, t2, o2) => (g._rte_crdt_document_put = IA.pa)(A2, e2, t2, o2), g._rte_crdt_document_insert = (A2, e2, t2, o2) => (g._rte_crdt_document_insert = IA.qa)(A2, e2, t2, o2), g._rte_crdt_document_delete = (A2, e2, t2) => (g._rte_crdt_document_delete = IA.ra)(A2, e2, t2), g._rte_crdt_document_increment = (A2, e2, t2, o2) => (g._rte_crdt_document_increment = IA.sa)(A2, e2, t2, o2), g._rte_crdt_collection_put_doc = (A2, e2, t2) => (g._rte_crdt_collection_put_doc = IA.ta)(A2, e2, t2), g._rte_crdt_collection_delete_doc = (A2, e2, t2) => (g._rte_crdt_collection_delete_doc = IA.ua)(A2, e2, t2), g._rte_crdt_collection_ref_doc = (A2, e2, t2) => (g._rte_crdt_collection_ref_doc = IA.va)(A2, e2, t2), g._rte_crdt_collection_iterator_create = (A2, e2, t2) => (g._rte_crdt_collection_iterator_create = IA.wa)(A2, e2, t2), g._rte_crdt_collection_iterator_destroy = (A2) => (g._rte_crdt_collection_iterator_destroy = IA.xa)(A2), g._rte_crdt_collection_iterator_next = (A2, e2, t2) => (g._rte_crdt_collection_iterator_next = IA.ya)(A2, e2, t2), g._rte_crdt_collection_init = (A2, e2, t2) => (g._rte_crdt_collection_init = IA.za)(A2, e2, t2), g._rte_crdt_collection_subscribe = (A2, e2, t2) => (g._rte_crdt_collection_subscribe = IA.Aa)(A2, e2, t2), g._sync_client_create = (A2, e2, t2) => (g._sync_client_create = IA.Ba)(A2, e2, t2), g._sync_client_destroy = (A2) => (g._sync_client_destroy = IA.Ca)(A2), g._sync_client_enable_dynamic_readable = (A2) => (g._sync_client_enable_dynamic_readable = IA.Da)(A2), g._sync_client_set_shakehand_interval = (A2, e2) => (g._sync_client_set_shakehand_interval = IA.Ea)(A2, e2), g._sync_client_set_connection_timeout = (A2, e2) => (g._sync_client_set_connection_timeout = IA.Fa)(A2, e2), g._sync_client_set_request_timeout = (A2, e2) => (g._sync_client_set_request_timeout = IA.Ga)(A2, e2), g._sync_client_set_doc_ttl = (A2, e2, t2, o2, I2) => (g._sync_client_set_doc_ttl = IA.Ha)(A2, e2, t2, o2, I2), g._sync_client_set_sync_interval = (A2, e2, t2, o2) => (g._sync_client_set_sync_interval = IA.Ia)(A2, e2, t2, o2), g._sync_client_init = (A2, e2, t2) => (g._sync_client_init = IA.Ja)(A2, e2, t2), g._sync_buffer_create = () => (g._sync_buffer_create = IA.Ka)(), g._sync_buffer_destroy = (A2) => (g._sync_buffer_destroy = IA.La)(A2), g._sync_buffer_data = (A2) => (g._sync_buffer_data = IA.Ma)(A2), g._sync_buffer_length = (A2) => (g._sync_buffer_length = IA.Na)(A2), g._batch_ops_create = () => (g._batch_ops_create = IA.Oa)(), g._batch_ops_destroy = (A2) => (g._batch_ops_destroy = IA.Pa)(A2), g._batch_ops_add = (A2, e2, t2, o2, I2, i3, r2, n2, C2, E2) => (g._batch_ops_add = IA.Qa)(A2, e2, t2, o2, I2, i3, r2, n2, C2, E2), g._sync_client_tick = (A2, e2) => (g._sync_client_tick = IA.Ra)(A2, e2), g._sync_client_shakehand = (A2, e2) => (g._sync_client_shakehand = IA.Sa)(A2, e2), g._sync_client_on_recv = (A2, e2, t2, o2) => (g._sync_client_on_recv = IA.Ta)(A2, e2, t2, o2), g._sync_client_reset_connection = (A2) => (g._sync_client_reset_connection = IA.Ua)(A2), g._sync_client_compact = (A2) => (g._sync_client_compact = IA.Va)(A2), g._sync_client_synced = (A2) => (g._sync_client_synced = IA.Wa)(A2), g._sync_client_create_coll = (A2, e2, t2, o2, I2, i3, r2, n2, C2) => (g._sync_client_create_coll = IA.Xa)(A2, e2, t2, o2, I2, i3, r2, n2, C2), g._sync_client_subscribe = (A2, e2, t2, o2, I2) => (g._sync_client_subscribe = IA.Ya)(A2, e2, t2, o2, I2), g._sync_client_get_coll = (A2, e2, t2) => (g._sync_client_get_coll = IA.Za)(A2, e2, t2), g._sync_client_delete_coll = (A2, e2, t2) => (g._sync_client_delete_coll = IA._a)(A2, e2, t2), g._sync_client_add_readable = (A2, e2, t2, o2) => (g._sync_client_add_readable = IA.$a)(A2, e2, t2, o2), g._sync_client_remove_readable = (A2, e2, t2, o2) => (g._sync_client_remove_readable = IA.ab)(A2, e2, t2, o2), g._sync_collection_iterator_create = (A2, e2) => (g._sync_collection_iterator_create = IA.bb)(A2, e2), g._sync_collection_iterator_next = (A2, e2) => (g._sync_collection_iterator_next = IA.cb)(A2, e2), g._sync_client_enable_js_logging = () => (g._sync_client_enable_js_logging = IA.db)(), g._sync_client_set_log_level = (A2) => (g._sync_client_set_log_level = IA.eb)(A2), g._sync_client_set_exception_callback = (A2, e2, t2) => (g._sync_client_set_exception_callback = IA.fb)(A2, e2, t2), g._sync_client_renew_tickets = (A2, e2, t2) => (g._sync_client_renew_tickets = IA.gb)(A2, e2, t2), g._sync_client_keepalive = (A2, e2, t2, o2, I2) => (g._sync_client_keepalive = IA.hb)(A2, e2, t2, o2, I2), g._sync_client_connect_database = (A2, e2, t2, o2, I2, i3) => (g._sync_client_connect_database = IA.ib)(A2, e2, t2, o2, I2, i3), g._sync_client_disconnect_database = (A2, e2, t2, o2) => (g._sync_client_disconnect_database = IA.jb)(A2, e2, t2, o2), g._sync_client_query_doc = (A2, e2, t2, o2, I2, i3, r2, n2, C2, E2, s2) => (g._sync_client_query_doc = IA.kb)(A2, e2, t2, o2, I2, i3, r2, n2, C2, E2, s2), g._sync_client_put_doc = (A2, e2, t2, o2, I2, i3, r2, n2, C2) => (g._sync_client_put_doc = IA.lb)(A2, e2, t2, o2, I2, i3, r2, n2, C2), g._sync_client_put_doc_ex = (A2, e2, t2, o2, I2, i3, r2, n2, C2, E2) => (g._sync_client_put_doc_ex = IA.mb)(A2, e2, t2, o2, I2, i3, r2, n2, C2, E2), g._sync_client_delete_doc = (A2, e2, t2, o2, I2, i3) => (g._sync_client_delete_doc = IA.nb)(A2, e2, t2, o2, I2, i3), g._sync_client_update_doc = (A2, e2, t2, o2, I2, i3, r2, n2, C2, E2, s2, B2, a2, Q2, c2, l2) => (g._sync_client_update_doc = IA.ob)(A2, e2, t2, o2, I2, i3, r2, n2, C2, E2, s2, B2, a2, Q2, c2, l2), g._sync_client_update_doc_ex = (A2, e2, t2, o2, I2, i3, r2, n2, C2, E2, s2, B2, a2, Q2, c2, l2, h2) => (g._sync_client_update_doc_ex = IA.pb)(A2, e2, t2, o2, I2, i3, r2, n2, C2, E2, s2, B2, a2, Q2, c2, l2, h2), g._sync_client_batch_update = (A2, e2, t2, o2, I2, i3, r2, n2) => (g._sync_client_batch_update = IA.qb)(A2, e2, t2, o2, I2, i3, r2, n2), g._sync_client_n1ql_query = (A2, e2, t2, o2, I2, i3, r2, n2, C2) => (g._sync_client_n1ql_query = IA.rb)(A2, e2, t2, o2, I2, i3, r2, n2, C2), g._sync_client_range_docs = (A2, e2, t2, o2, I2, i3, r2, n2) => (g._sync_client_range_docs = IA.sb)(A2, e2, t2, o2, I2, i3, r2, n2), g._sync_client_get_doc = (A2, e2, t2, o2, I2, i3, r2) => (g._sync_client_get_doc = IA.tb)(A2, e2, t2, o2, I2, i3, r2), g._sync_client_set_permission_callback = (A2, e2, t2) => (g._sync_client_set_permission_callback = IA.ub)(A2, e2, t2), g.___start_em_js = 41160, g.___stop_em_js = 41254, g.addFunction = (A2, e2) => {
          var t2 = eA(A2);
          if (t2)
            return t2;
          var g2 = (() => {
            if (tA.length)
              return tA.pop();
            try {
              y.grow(1);
            } catch (A3) {
              if (!(A3 instanceof RangeError))
                throw A3;
              throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.";
            }
            return y.length - 1;
          })();
          try {
            gA(g2, A2);
          } catch (t3) {
            if (!(t3 instanceof TypeError))
              throw t3;
            var o2 = X(A2, e2);
            gA(g2, o2);
          }
          return AA.set(A2, g2), g2;
        }, g.removeFunction = (A2) => {
          AA.delete(z(A2)), tA.push(A2);
        }, g.setValue = function(A2, e2) {
          let t2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "i8";
          switch (t2.endsWith("*") && (t2 = "*"), t2) {
            case "i1":
            case "i8":
              a[0 | A2] = e2;
              break;
            case "i16":
              c[A2 >> 1] = e2;
              break;
            case "i32":
              l[A2 >> 2] = e2;
              break;
            case "i64":
              d[A2 >> 3] = BigInt(e2);
              break;
            case "float":
              u[A2 >> 2] = e2;
              break;
            case "double":
              D[A2 >> 3] = e2;
              break;
            case "*":
              h[A2 >> 2] = e2;
              break;
            default:
              L("invalid type for setValue: ".concat(t2));
          }
        }, g.getValue = function(A2) {
          let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "i8";
          switch (e2.endsWith("*") && (e2 = "*"), e2) {
            case "i1":
            case "i8":
              return a[0 | A2];
            case "i16":
              return c[A2 >> 1];
            case "i32":
              return l[A2 >> 2];
            case "i64":
              return d[A2 >> 3];
            case "float":
              return u[A2 >> 2];
            case "double":
              return D[A2 >> 3];
            case "*":
              return h[A2 >> 2];
            default:
              L("invalid type for getValue: ".concat(e2));
          }
        }, g.UTF8ToString = Y, g.stringToUTF8 = (A2, e2, t2) => V(A2, Q, e2, t2), g.lengthBytesUTF8 = j, k = function A2() {
          v || iA(), v || (k = A2);
        }, g.preInit)
          for ("function" == typeof g.preInit && (g.preInit = [g.preInit]); g.preInit.length > 0; )
            g.preInit.pop()();
        return iA(), A.ready;
      };
      const getUTCTimestamp = () => {
        const A = /* @__PURE__ */ new Date();
        return "".concat(A.toISOString().split("T")[1].replace(/\..+/, ""), ".").concat(A.getMilliseconds());
      };
      let wasmReject, wasmResolve;
      const wasmPromise = new Promise((A, e) => {
        wasmReject = e, wasmResolve = A;
      });
      let Module, isBrowser;
      async function initWasm(A) {
        Module = await wasmPromise, initFunc(A);
      }
      function setBrowser(A) {
        isBrowser = A;
      }
      createModule({ rtejsLog: (A, e) => {
        switch (A) {
          case 0:
            console.debug(e, " ----------rtejslog");
            break;
          case 1:
            console.info(e, " ----------rtejslog");
            break;
          case 2:
            console.warn(e, " ----------rtejslog");
            break;
          case 3:
            console.error(e, " ----------rtejslog");
        }
      } }).then((A) => {
        wasmResolve(A), console.log(getUTCTimestamp(), "wasm-module initialized");
      }).catch((A) => {
        wasmReject(A);
      });
      class QueryDocBuffer {
        constructor() {
          this.docs = /* @__PURE__ */ new Map(), this.count = -1, this.more = false;
        }
        SetDocs(A, e) {
          this.docs.set(A, e);
        }
        SetCount(A) {
          if (!isInteger(A))
            throw new TypeError("The num is expected to be an integer, but a double was got.");
          this.count = A;
        }
        SetMore(A) {
          this.more = A;
        }
      }
      class SyncClient {
        constructor(A) {
          this.appId = A.appId, this.logLevel = A.logLevel, this.shakehandInterval = A.shakehandInterval, this.manualShakehand = A.manualShakehand, this.manualTick = A.manualTick, this.uuidPrefix = A.uuidPrefix, this.getLogger = A.getLogger, this.reuseConn = A.reuseConn, this.tickets = /* @__PURE__ */ new Map(), this.exceptionCb = null, this.exceptionChan = new eventsExports.EventEmitter();
          const e = getPtrWithStr(this.uuidPrefix + "_" + uuid_1.v4()), [t, g] = getPtrStringList(Array.from(this.tickets.values()));
          this.clientPtr = Module._sync_client_create(e, t, this.tickets.size);
          for (let A2 = 0; A2 < g.length; A2++) {
            releasePtr(g[A2]);
          }
          releasePtr(e), this.timer = null, this.databaseConnected = /* @__PURE__ */ new Map(), this.tickBufferPtr = 0, this.connected = false, Module._sync_client_enable_js_logging(), Module._sync_client_set_log_level(this.logLevel), this.manualShakehand ? (Module._sync_client_set_shakehand_interval(this.clientPtr, 0), this.shakehandBufferPtr = Module._sync_buffer_create()) : (Module._sync_client_set_shakehand_interval(this.clientPtr, this.shakehandInterval), this.shakehandBufferPtr = 0), null !== this.reuseConn && (this.tickBufferPtr = Module._sync_buffer_create(), this.reuseConn().internalEmitter.on("connected", () => {
            this.connected = true, this.manualTick || (tickLoop(this), this.timer = setInterval(() => {
              tickLoop(this);
            }, 2e3));
          }), this.reuseConn().internalEmitter.on("disconnected", () => {
            this.connected = false, this.manualTick || clearInterval(this.timer), Module._sync_client_reset_connection(this.clientPtr);
          }), this.reuseConn().internalEmitter.on("received-packet", (A2) => {
            try {
              const e2 = A2.length * A2.BYTES_PER_ELEMENT, t2 = Module._malloc(e2);
              Module.HEAPU8.set(A2, t2);
              const g2 = Module._sync_client_on_recv(this.clientPtr, t2, BigInt(e2), this.tickBufferPtr);
              if (Module._free(t2), 101 === g2)
                Module._sync_client_reset_connection(this.clientPtr);
              else {
                const A3 = new Uint8Array(Module.HEAPU8.buffer, Module._sync_buffer_data(this.tickBufferPtr), Number(Module._sync_buffer_length(this.tickBufferPtr))).slice();
                if (0 != A3.length) {
                  this.reuseConn().sendPacket(A3);
                  logger((/* @__PURE__ */ new Date()).toString() + " : recv and send packet", this.getLogger, "info");
                }
              }
            } catch (A3) {
              logger("recvError : ".concat(A3), this.getLogger, "error");
            }
          }));
        }
        async Login() {
          if (null === this.reuseConn) {
            if (!(this.tickets.size > 0))
              throw new Error("Tickets should be set before logging in.");
            await fetchHelper(this, isBrowser), logger("Open the WebSocket successfully", this.getLogger, "info");
          }
        }
        Logout() {
          this.tickBufferPtr && 0 !== this.tickBufferPtr && (Module._sync_buffer_destroy(this.tickBufferPtr), this.tickBufferPtr = 0), null === this.reuseConn && clearInterval(this.timer), this.manualShakehand && this.shakehandBufferPtr && 0 !== this.shakehandBufferPtr && (Module._sync_buffer_destroy(this.shakehandBufferPtr), this.shakehandBufferPtr = 0), null != this.exceptionCb && Module.removeFunction(this.exceptionCb), this.connected = false, logger("Logout successfully", this.getLogger, "info");
        }
        async ConnectDatabase(A) {
          try {
            if (await promisify(connectDatabase)({ client: this, databaseName: A }), !this.databaseConnected.has(A)) {
              const e = new SyncDatabase(A, this);
              this.databaseConnected.set(A, e);
            }
          } catch (A2) {
            throw logger("Database connection failed by the error : ".concat(A2), this.getLogger, "error"), new Error("Database connection failed by the error: ".concat(A2));
          }
        }
        async DisConnectDatabase(A) {
          if (this.databaseConnected.has(A))
            try {
              await promisify(disconnectDatabase)({ client: this, databaseName: A }), this.databaseConnected.delete(A);
            } catch (A2) {
              logger("Database disconnection failed by the error : ".concat(A2), this.getLogger, "error");
            }
        }
        Database(A) {
          return this.databaseConnected.has(A) ? this.databaseConnected.get(A) : null;
        }
        SetTicket(A, e) {
          this.tickets.set(A, e);
          const [t, g] = getPtrStringList(Array.from(this.tickets.values()));
          Module._sync_client_renew_tickets(this.clientPtr, t, this.tickets.size), this.connected && tickLoop(this), releasePtr(t);
          for (let A2 = 0; A2 < g.length; A2++) {
            releasePtr(g[A2]);
          }
        }
        RemoveTicket(A) {
          if (this.tickets.has(A)) {
            this.tickets.delete(A);
            const [e, t] = getPtrStringList(Array.from(this.tickets.values()));
            Module._sync_client_renew_tickets(this.clientPtr, e, this.tickets.size), this.connected && tickLoop(this), releasePtr(e);
            for (let A2 = 0; A2 < t.length; A2++) {
              releasePtr(t[A2]);
            }
          }
        }
        async QueryDoc(A, e, t) {
          const g = new QueryDocBuffer();
          try {
            await promisify(queryDoc)({ client: this, database: A, coll: e, option: t, buffer: g });
          } catch (A2) {
            logger("Query Doc is failed by the error : ".concat(A2), this.getLogger, "error");
          }
          if (g.count >= 0)
            return t.countOnly ? [null, g.count, g.more] : t.keysOnly ? [Array.from(g.docs.keys()).sort(), g.count, g.more] : [new Map([...g.docs].sort()), g.count, g.more];
          throw new Error("The query doc operation is failed");
        }
        Shakehand() {
          if (!this.manualShakehand)
            throw new Error("The manualShakehand is set to false for this client.");
          shakehandOnce(this);
        }
        Tick() {
          if (!this.manualTick)
            throw new Error("The manualTick is set to false for this client.");
          tickLoop(this);
        }
        SetConnectionTimeout(A) {
          if (!isInteger(A) || A <= 0)
            throw new TypeError("The seconds is expected to be a positive integer.");
          Module._sync_client_set_connection_timeout(this.clientPtr, A);
        }
        GetConnectionState() {
          return this.connected;
        }
        ExceptionCallback() {
          return null != this.exceptionCb && Module.removeFunction(this.exceptionCb), exceptionCallback(this), this.exceptionChan;
        }
        EnableDynamicReadable() {
          Module._sync_client_enable_dynamic_readable(this.clientPtr);
        }
        Synced() {
          return Module._sync_client_synced(this.clientPtr);
        }
      }
      class SyncConfig {
        constructor(A, e, t, g, o, I) {
          let i2 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null, r = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null;
          if (!isInteger(e))
            throw new TypeError("The logLevel is expected to be an int, but a double was got.");
          if (!isInteger(t))
            throw new TypeError("The shakehandInterval is expected to be an integer, but a double was got.");
          this.appId = A, this.logLevel = e, this.shakehandInterval = t, this.manualShakehand = g, this.manualTick = o, this.uuidPrefix = I, this.getLogger = i2, this.reuseConn = r;
        }
      }
      class QueryOption {
        constructor(A, e, t, g, o) {
          let I = !(arguments.length > 5 && void 0 !== arguments[5]) || arguments[5], i2 = arguments.length > 6 && void 0 !== arguments[6] && arguments[6], r = arguments.length > 7 && void 0 !== arguments[7] && arguments[7];
          if (!isInteger(o) || o < 0)
            throw new TypeError("The limit is expected to be an int greater than or equal to zero, but a double or a negative int was got.");
          this.start = A, this.end = e, this.keysOnly = t, this.countOnly = g, this.limit = o, this.startIncluded = I, this.endIncluded = i2, this.ignoreExpired = r;
        }
      }
      async function CreateClient(A) {
        return await initWasm(A.getLogger), "object" == typeof process ? setBrowser(false) : "object" == typeof window && setBrowser(true), new SyncClient(A);
      }
      class VirtualSyncSocket {
        get env() {
          var A;
          return null === (A = this.getSockets()[0]) || void 0 === A ? void 0 : A.env;
        }
        constructor(A) {
          _defineProperty$1(this, "getSockets", void 0), _defineProperty$1(this, "internalEmitter", new eventsExports.EventEmitter()), this.getSockets = A, this.internalEmitter.setMaxListeners(512);
        }
        sendPacket(A) {
          var e, t;
          null === (e = this.getSockets()[0]) || void 0 === e || null === (t = e.sendSyncPacket) || void 0 === t || t.call(e, A);
        }
      }
      class RTMSession extends EventBase {
        constructor(A, e, t, g, o) {
          super(e, "RTMSession"), _defineProperty$1(this, "context", void 0), _defineProperty$1(this, "connectionController", void 0), _defineProperty$1(this, "syncClient", void 0), _defineProperty$1(this, "virtualSocket", void 0), _defineProperty$1(this, "_syncTicket", void 0), _defineProperty$1(this, "dbObj", void 0), _defineProperty$1(this, "cacheCrdtState", void 0), _defineProperty$1(this, "exceptionCallback", void 0), this.context = A, this.cacheCrdtState = g, this.exceptionCallback = o, this.connectionController = new ConnectionController(A, t, e, this.manualShakeHand.bind(this), this._initSync.bind(this)), this.connectionController.on("syncTicketUpdated", (A2) => {
            this.updateSyncTicket(A2);
          }), this.connectionController.on("syncConnected", () => {
            this.emitSyncConnected();
          }), this.connectionController.on("syncDisconnected", (A2) => {
            this.warn("virtual socket disconnected, reason: %s", A2), this.emitSyncDisconnected(), this.connectionController.syncEstablishState = SyncEstablishState.DISCONNECTED;
          }), this.connectionController.on("syncPacket", (A2) => {
            this.handlePacket(A2);
          }), this.connectionController.on("userJoined", () => {
            this.emit("userJoined");
          });
        }
        sendOperationPacketUseOneEnv(A, e, t, g) {
          this.connectionController.sendOperationPacketUseOneEnv(A, e, t, g);
        }
        sendOperationPacket(A, e, t) {
          this.connectionController.sendOperationPacket(A, e, t);
        }
        onOperationPacket(A) {
          return this.connectionController.onOperationPacket(A);
        }
        recoverEdges4RenewToken() {
          this.connectionController.connection.apClient.recoverEdges4RenewToken();
        }
        clearEdges4RenewToken() {
          this.connectionController.connection.apClient.clearEdges4RenewToken();
        }
        genApEdgeInfo$(A, e) {
          return this.connectionController.connection.apClient.genApEdgeInfo$(A, e);
        }
        updateRegTicket(A) {
          this.connectionController.updateRegTicket(A);
        }
        get isCanceledLogin() {
          return this.connectionController.connection.cancelLogin;
        }
        resetCancelLogin() {
          this.connectionController.connection.cancelLogin = false;
        }
        cancelLogin() {
          this.connectionController.emit("login-cancel"), this.connectionController.loginSubject$.next(), this.connectionController.connection.cancelLogin = true, this.connectionController.connection.apClient.apFinish$.next(), this.connectionController.connection.endLogin$.next();
        }
        async logoutRegistrar(A) {
          return await this.connectionController.logoutHandler(A);
        }
        loginHandler() {
          return this.connectionController.loginHandler();
        }
        removeConnectionControllerAllListeners() {
          this.connectionController.removeAllListeners();
        }
        stopLogin() {
          this.connectionController.connection.apClient.apFinish$.next(void 0), this.connectionController.connection.stopLogin();
        }
        getVirtualSyncSocket() {
          return this.connectionController.getVirtualSyncSocket();
        }
        notifyNetworkChange(A) {
          this.connectionController.notifyNetworkChange(A);
        }
        validateSyncConnected(A) {
          if (!this.getSyncConnected()) {
            const { code: e, reason: t } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_PRESENCE_NOT_CONNECTED);
            throw new RtmUnavailableError(A, [t], e);
          }
        }
        updateSyncTicket(A) {
          const { ticket: e } = A;
          this._syncTicket = e;
        }
        handlePacket(A) {
          var e;
          const t = A.length, g = getSyncPacketUri(A);
          var o;
          102 !== g && this.log("env_%s: received packet, uri: %d, length: %d", null === (o = this.virtualSocket) || void 0 === o ? void 0 : o.env, g, t);
          null === (e = this.virtualSocket) || void 0 === e || e.internalEmitter.emit("received-packet", A);
        }
        emitSyncConnected() {
          var A;
          null === (A = this.virtualSocket) || void 0 === A || A.internalEmitter.emit("connected");
        }
        emitSyncDisconnected() {
          var A;
          null === (A = this.virtualSocket) || void 0 === A || A.internalEmitter.emit("disconnected");
        }
        async _initSync() {
          if (this.context.disablePresence)
            return;
          this.log("start logging sync...");
          if (!(void 0 === this.syncClient))
            return this.log("not firstInit"), await this.connectDatabase(), this.cacheCrdtState(), this.manualShakeHand(), void this.emitSyncConnected();
          let A = 0;
          switch (this.context.rtmConfig.logLevel) {
            case "debug":
              A = 0;
              break;
            case "info":
              A = 1;
              break;
            case "warn":
              A = 2;
              break;
            default:
              A = 3;
          }
          const e = new VirtualSyncSocket(this.getVirtualSyncSocket.bind(this));
          this.virtualSocket = e, e.internalEmitter.on("connected", () => {
            this.log("virtual socket connected");
          });
          const t = new SyncConfig(this.context.appId, A, 3e3, true, true, this.context.uid, () => ({ handleDebugLog: this.log, handleInfoLog: this.info, handleWarnLog: this.warn, handleErrorLog: this.logError }), () => e);
          try {
            var g, o;
            const A2 = this.context.heartbeatInterval + (null !== (g = getParameter("RTM_LINK_KEEP_ALIVE_TIMEOUT")) && void 0 !== g ? g : CONFIGURABLE_KEY_RTM_LINK_KEEP_ALIVE_TIMEOUT), e2 = await CreateClient(t);
            this.log("create sync client success");
            const I = e2.ExceptionCallback();
            null == I || I.addListener("exception", async (A3) => {
              let [e3, t2] = A3;
              if (this.logError("exception info: %o", { db: e3, coll: t2 }), e3 !== PRESENCE_DATABASE)
                return;
              const { prefixChannelName: g2 = "" } = extractPrefixChannelName(t2), o2 = this.context.getChannelLastSubOrJoinOptions(g2);
              this.exceptionCallback(g2, o2);
            }), e2.SetConnectionTimeout(A2 / 1e3), this.emitSyncConnected(), this.syncClient = e2, e2.SetTicket("rtm", null !== (o = this._syncTicket) && void 0 !== o ? o : this.context.appId), await this.connectDatabase();
          } catch (A2) {
            this.logError("init sync error: ".concat(A2));
            const { code: e2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_LOGIN_REJECTED);
            throw new RtmUnavailableError(OperationName.login, [t2 + "init sync error"], e2);
          }
        }
        async connectDatabase() {
          var A, e;
          if (this.context.disablePresence)
            return;
          this.sendTick(), this.log("send tick success, will connect sync database"), this.log("".concat(SYNC_RPC_START, ": syncClient connectDatabase")), await timeoutPromise(null == this || null === (A = this.syncClient) || void 0 === A ? void 0 : A.ConnectDatabase(PRESENCE_DATABASE), DEFAULT_RPC_TIMEOUT_TIME, OperationName.login, RTMErrorCode.RTM_ERROR_LOGIN_TIMEOUT), this.log("".concat(SYNC_RPC_END, ": syncClient connectDatabase")), this.sendTick();
          const t = null == this || null === (e = this.syncClient) || void 0 === e ? void 0 : e.Database(PRESENCE_DATABASE);
          this.dbObj = t, this.connectionController.cancelSyncTimer();
        }
        async renewSyncTicket(A) {
          if (this.context.disablePresence)
            return;
          const e = OperationName.renewToken;
          try {
            var t;
            this.log("".concat(SYNC_RPC_START, ": ").concat(e)), null === (t = this.syncClient) || void 0 === t || t.SetTicket("rtm", A), this.sendTick(), this.log("".concat(SYNC_RPC_END, ": ").concat(e));
          } catch (A2) {
            this.logError("".concat(SYNC_RPC_END, ": ").concat(e, " by rpc failure. error is ").concat(A2));
          }
          return true;
        }
        leaveColl(A) {
          var e;
          const t = this.getChannelCollName(A);
          null === (e = this.dbObj) || void 0 === e || e.DestroyCollection(t), this.sendTick();
        }
        delChannelDoc(A) {
          try {
            var e;
            const t = this.getChannelCollName(A), g = this.getColl(A, true, "delChannelDoc");
            g && (null === (e = this.dbObj) || void 0 === e || e.CancelAutoKeepalive(t, this.context.uid)), null == g || g.DelDoc(this.context.uid), this.sendTick(), this.log("Delete channel(".concat(replaceRangeWithAsterisk(A), ") document succeed."));
          } catch (A2) {
            this.logError("Delete channel document failed, error: %o", A2);
          }
        }
        async createColl(A, e, t) {
          var g;
          return null === (g = this.dbObj) || void 0 === g ? void 0 : g.CreateCollection(this.getChannelCollName(A), e, t);
        }
        async logoutSyncHandler() {
          var A;
          if (!this.context.disablePresence) {
            this.log("".concat(SYNC_RPC_START, ": disconnectDatabase"));
            try {
              var e;
              await timeoutPromise(null === (e = this.syncClient) || void 0 === e ? void 0 : e.DisConnectDatabase(PRESENCE_DATABASE), DEFAULT_RPC_TIMEOUT_TIME, OperationName.logout, 0);
            } catch (A2) {
              this.warn("disconnectDatabase timeout");
            }
            this.log("".concat(SYNC_RPC_END, ": disconnectDatabase")), null === (A = this.syncClient) || void 0 === A || A.Logout(), this.sendTick(), this.log("virtual socket disconnected, reason: logout"), this.emitSyncDisconnected();
          }
        }
        async requestRpc(A, e) {
          var t;
          if (this.context.disablePresence)
            return;
          const g = new QueryOption(e.start, e.end, e.keysOnly, e.countOnly, e.limit, e.startIncluded, e.endIncluded, e.ignoreExpired);
          return null === (t = this.syncClient) || void 0 === t ? void 0 : t.QueryDoc(PRESENCE_DATABASE, A === K_GLOBAL_PRESENCE_COLLECTION ? K_GLOBAL_PRESENCE_COLLECTION : this.getChannelCollName(A), g);
        }
        getColl(A) {
          var e;
          let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], g = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "";
          const o = this.getChannelCollName(A), I = null === (e = this.dbObj) || void 0 === e ? void 0 : e.Coll(o);
          return null === I && t && this.warn("coll(".concat(o, ") is null in ").concat(g, ".")), I || null;
        }
        getChannelCollName(A) {
          return getChannelQueryString(this.context.vid, A);
        }
        manualShakeHand() {
          var A;
          this.context.disablePresence || this.getSyncConnected() && (null === (A = this.syncClient) || void 0 === A || A.Shakehand());
        }
        sendTick() {
          var A;
          this.context.disablePresence || this.getSyncConnected() && (null === (A = this.syncClient) || void 0 === A || A.Tick());
        }
        getSynced() {
          var A;
          if (!this.context.disablePresence)
            return null === (A = this.syncClient) || void 0 === A ? void 0 : A.Synced();
        }
        getSyncConnected() {
          var A;
          if (!this.context.disablePresence)
            return null === (A = this.syncClient) || void 0 === A ? void 0 : A.GetConnectionState();
        }
        getDocByUid(A, e) {
          const { funcName: t = "", uid: g = this.context.uid } = e, o = this.getColl(A, true, t);
          return null == o ? void 0 : o.Doc(g);
        }
        setAutoKeepalive(A) {
          var e;
          const t = this.getChannelCollName(A);
          null === (e = this.dbObj) || void 0 === e || e.SetAutoKeepalive(t, this.context.uid, this.context.rtmConfig.presenceTimeout);
        }
        updateLoggedOut(A) {
          this.connectionController.updateLoggedOut(A);
        }
      }
      function genGetRTMSession(A) {
        return () => {
          const e = A();
          if (!e) {
            const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_NOT_CONNECTED);
            throw new RtmInvalidStatusError("Client is not logged in. Cannot do the operation", [e2], A2);
          }
          return e;
        };
      }
      class LocalTopic extends EventBase {
        constructor(A, e, t, g) {
          super(e, "LocalTopic"), _defineProperty$1(this, "_context", void 0), _defineProperty$1(this, "_topicName", void 0), _defineProperty$1(this, "_localDatachannel", void 0), this._context = A, this._topicName = t, this._localDatachannel = g;
        }
        getDataChannel() {
          return this._localDatachannel;
        }
        async publishTopicMessage(A, e, t) {
          const g = this._localDatachannel, o = this._topicName;
          if (!g) {
            const { code: e2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_TOPIC_NOT_JOINED);
            throw new RtmUnavailableError(A, [t2], e2);
          }
          if ("open" !== g.readyState) {
            this.log("send topic(%s) message failed. readyState of datachannel is ".concat(g.readyState), o);
            const { code: e2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_PUBLISH_MESSAGE_FAILED);
            throw new RtmUnavailableError(A, [t2], e2);
          }
          const { initEncryption: I, iv: i2, key: r, keyLength: n } = this._context.encryptionInfo, C = I, E = "string" == typeof e ? new TextEncoder().encode(e) : e, s = E.byteLength;
          try {
            const A2 = C ? encrypt(E, r, i2, n) : E, o2 = "string" == typeof e ? 1 : 0;
            g.send(this._encodeMessage(A2, s, C, o2, null == t ? void 0 : t.customType));
          } catch (e2) {
            const { code: t2, reason: g2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_ENCRYPT_MESSAGE_FAILED);
            throw new RtmUnavailableError(A, [g2], t2);
          }
        }
        _encodeMessage(A, e, t, g, o) {
          return StreamMessageProtocol.encode(_objectSpread2({ messageType: g, payload: A, encrypted: t, payloadLength: e }, o ? { customType: o } : {})).finish();
        }
      }
      class RemoteTopic extends EventBase {
        constructor(A, e, t, g, o) {
          super(e, "RemoteTopic"), _defineProperty$1(this, "_context", void 0), _defineProperty$1(this, "_topicName", void 0), _defineProperty$1(this, "_channelName", void 0), _defineProperty$1(this, "_emitTopicMessage", void 0), _defineProperty$1(this, "_users", /* @__PURE__ */ new Map()), this._context = A, this._topicName = t, this._channelName = g, this._emitTopicMessage = o;
        }
        addUserWithDc(A, e) {
          this._users.set(A, e);
        }
        addUserWithoutDc(A, e) {
          this._users.set(A, { subscribedState: "PRE_SUBSCRIBE", meta: "", id: 0, user: e });
        }
        updateUserDatachannelInfo(A, e) {
          if (this._users.has(A)) {
            const t = this._users.get(A);
            if (t) {
              const { subscribedState: g, datachannel: o } = t, { meta: I, id: i2, user: r } = e;
              this._users.set(A, { meta: I, id: i2, subscribedState: g, datachannel: o, user: r });
            }
          } else
            this.warn("update user datachannel info failure, not pre_subscribe the user in the topic.");
        }
        removeUser(A) {
          this._users.delete(A);
        }
        removeUserDatachannel(A) {
          const e = this._users.get(A);
          e && this._users.set(A, _objectSpread2(_objectSpread2({}, e), {}, { datachannel: void 0 }));
        }
        handleSubscription(A, e) {
          this._fillUserDatachannel(e, A), this._addMessageEvent(A, e), this._updateSubscribeState(e, "SUBSCRIBED");
        }
        handleUnsubscription(A) {
          this._context.internalEmitter.emit("unsubscribeTopicMessage", { topicName: this._topicName, userId: A }), this._updateSubscribeState(A, "UNSUBSCRIBE");
        }
        getUsers() {
          return this._users;
        }
        getSubscribedUsers() {
          return Array.from(this._users.keys()).filter((A) => {
            var e;
            return "SUBSCRIBED" === (null === (e = this._users.get(A)) || void 0 === e ? void 0 : e.subscribedState);
          });
        }
        getPreSubscribedUsers() {
          return Array.from(this._users.keys()).filter((A) => {
            var e;
            return "PRE_SUBSCRIBE" === (null === (e = this._users.get(A)) || void 0 === e ? void 0 : e.subscribedState);
          });
        }
        getAllSubscribedUserCount() {
          return this.getSubscribedUsers().length + this.getPreSubscribedUsers().length;
        }
        _updateSubscribeState(A, e) {
          const t = this._users.get(A);
          if (t) {
            const { subscribedState: g, id: o, meta: I, datachannel: i2, user: r } = t;
            let n = false;
            switch (g) {
              case "PRE_SUBSCRIBE":
                "UNSUBSCRIBE" === e ? this._users.delete(A) : "SUBSCRIBED" === e && (n = true);
                break;
              case "SUBSCRIBED":
                ("UNSUBSCRIBE" === e || "PRE_SUBSCRIBE" === e) && (n = true);
                break;
              case "UNSUBSCRIBE":
                n = true;
            }
            n && this._users.set(A, { subscribedState: e, id: o, meta: I, datachannel: i2, user: r });
          }
        }
        _fillUserDatachannel(A, e) {
          const t = this._users.get(A);
          t && this._users.set(A, _objectSpread2(_objectSpread2({}, t), {}, { datachannel: e }));
        }
        _decodeMessage(A) {
          return StreamMessageProtocol.decode(A);
        }
        _addMessageEvent(A, e) {
          const t = (A2) => {
            var t2;
            if ("SUBSCRIBED" !== (null === (t2 = this._users.get(e)) || void 0 === t2 ? void 0 : t2.subscribedState))
              return void this.warn("Received a message from %s(topic: %s), but not subscribed.", e, this._topicName);
            const g = this._decodeMessage(new Uint8Array(A2)), { encrypted: o, payloadLength: I, messageType: i2, payload: r, customType: n } = g, { key: C, iv: E, keyLength: s } = this._context.encryptionInfo;
            if (o && !C)
              return void this.warn("Received a message with encryption but the key is not ready yet.");
            if (!o && C)
              return void this.warn("Received a message without encryption but the key is ready.");
            let B;
            B = 1 === i2 ? new TextDecoder().decode(o ? decrypt(r, C, E, s).slice(0, I) : r) : o ? decrypt(r, C, E, s).slice(0, I) : r, this._emitTopicMessage({ channelName: this._channelName, channelType: "STREAM", topicName: this._topicName, message: B, publisher: e, messageType: 1 === i2 ? "STRING" : "BINARY", customType: n, timestamp: getUTCTimeBaseREG(this._context.offsetTime) });
          };
          null == A || A.on("open", () => {
            this.log("".concat(this._channelName, "(").concat(this._topicName, ") remote dc opened."));
          }), null == A || A.on("close", () => {
            this.warn("".concat(this._channelName, "(").concat(this._topicName, ") remote dc closed."));
          }), null == A || A.on("error", (A2) => {
            this.logError("error occurs in ".concat(this._channelName, "(").concat(this._topicName, ") remote dc. error is %o"), A2);
          }), A.on("message", t), this.log("".concat(this._channelName, "(").concat(this._topicName, ") msg event added")), this._context.internalEmitter.on("unsubscribeTopicMessage", (g) => {
            let { userId: o, topicName: I } = g;
            o === e && I === this._topicName && A.off("message", t);
          });
        }
      }
      class ApiRateLimiter {
        constructor() {
          _defineProperty$1(this, "operationsTimeCache", {});
        }
        canMakeOperation(A, e) {
          var t, g;
          let o = null !== (t = getParameter("API_RATE_LIMIT").get(A)) && void 0 !== t ? t : 0;
          null != e && e.times && (o = e.times);
          const I = Date.now();
          if (this.operationsTimeCache[A] || (this.operationsTimeCache[A] = []), this.operationsTimeCache[A] = this.operationsTimeCache[A].filter((A2) => A2 > I - API_QPS_SECOND), this.operationsTimeCache[A].length < o)
            return void this.operationsTimeCache[A].push(I);
          const i2 = RTMErrorCode.RTM_ERROR_OPERATION_RATE_EXCEED_LIMITATION, { code: r, reason: n } = getErrorInfoByCode(null !== (g = null == e ? void 0 : e.code) && void 0 !== g ? g : i2);
          if (true === getParameter("ENABLE_API_RATE_LIMIT"))
            throw new RtmUnavailableError(A, [n], r);
        }
      }
      const { SubscribeTopicErrorCode } = RTMStreamChannelStatusCode;
      class StreamChannelImpl extends EventBase {
        constructor(A, e, t, g, o, I, i2, r, n, C) {
          var E;
          super(e, "StreamChannelImpl", true), _defineProperty$1(this, "_channelName", void 0), _defineProperty$1(this, "_prefixChannelName", void 0), _defineProperty$1(this, "_context", void 0), _defineProperty$1(this, "_getRTMSession", void 0), _defineProperty$1(this, "_emitRtmEvent", void 0), _defineProperty$1(this, "_getStreamChannelList", void 0), _defineProperty$1(this, "_validateRtmConnection", void 0), _defineProperty$1(this, "_updateOptionsReJoinOrSub", void 0), _defineProperty$1(this, "_unsubLockAMeta", void 0), _defineProperty$1(this, "_absent", void 0), _defineProperty$1(this, "_userId4RTC", void 0), _defineProperty$1(this, "_isJoinedChannel", false), _defineProperty$1(this, "_joinedAndSubscribed", false), _defineProperty$1(this, "_rtcClient", void 0), _defineProperty$1(this, "_rtcClientSid", void 0), _defineProperty$1(this, "_isReuseRtcClient", false), _defineProperty$1(this, "_localTopics", /* @__PURE__ */ new Map()), _defineProperty$1(this, "_remoteTopics", /* @__PURE__ */ new Map()), _defineProperty$1(this, "_firstSnapshot4topic", true), _defineProperty$1(this, "_apiRateLimit", new ApiRateLimiter()), _defineProperty$1(this, "_privatePermitUseMessageChn", false), _defineProperty$1(this, "_linkState", "IDLE"), _defineProperty$1(this, "_controlReconnectTimer", null), _defineProperty$1(this, "_handleConnectionStateChange", async (A2, e2, t2) => {
            if (this.log("rtc state: pre(%s), now(%s), reason: %s.", e2, A2, t2), "RECONNECTING" === e2 && this._controlReconnectTimer && clearTimeout(this._controlReconnectTimer), this._isJoinedChannel && "DISCONNECTED" === A2 && (this._firstSnapshot4topic = true, this._privatePermitUseMessageChn && (await this._unsubLockAMeta(this._prefixChannelName), "LEAVE" === t2 || "UID_BANNED" === t2 ? this._absent(this._prefixChannelName) : this._absent(this._prefixChannelName, false)), this._handleLeaveEffects(), t2 && "LEAVE" !== t2)) {
              this.warn("streamChannel connection state change to DISCONNECTED, reason: %s", t2);
              let A3 = LinkStateChangeReasonDescription.KICKED_OUT_BY_SERVER, e3 = "KICKED_OUT_BY_SERVER";
              if (t2 === AgoraRTC.ConnectionDisconnectedReason.TOKEN_EXPIRE)
                A3 = LinkStateChangeReasonDescription.TOKEN_EXPIRED, e3 = "TOKEN_EXPIRED";
              this._updateLinkState("FAILED", "SERVER_REJECT", e3, A3);
            }
            "RECONNECTING" === A2 && (this._updateLinkState("CONNECTING", "AUTO_RECONNECT", "AUTO_RECONNECT", LinkStateChangeReasonDescription.AUTO_RECONNECT), this._controlReconnectTimer = setTimeout(async () => {
              this.warn("streamChannel reconnect timeout, force leave."), await this.leave();
            }, RECONNECT_STREAM_CHANNEL_TIMEOUT)), "CONNECTED" === A2 && this._isJoinedChannel && this._updateLinkState("CONNECTED", "RECONNECTED", "RECONNECT_SUCCESS", LinkStateChangeReasonDescription.RECONNECT_SUCCESS);
            const g2 = { channelName: this._channelName, state: A2, reason: (null != t2 ? t2 : "CONNECTED" === A2) ? "OK" : "", timestamp: getUTCTimeBaseREG(this._context.offsetTime) };
            this._emitRtmEvent("status", g2);
          }), _defineProperty$1(this, "_handleUserPublishedList", (A2) => {
            if (!this._firstSnapshot4topic)
              return void this._handleUpdatedTopicsInOffline(A2);
            const e2 = [];
            if (A2.forEach((A3) => {
              var t2;
              null === (t2 = A3.dataChannels) || void 0 === t2 || t2.forEach((t3) => {
                t3.getConfig() && e2.push({ user: A3, config: t3.getConfig(), dc: t3 });
              });
            }), this._firstSnapshot4topic = false, 0 === e2.length) {
              const A3 = { eventType: "SNAPSHOT", channelName: this._channelName, publisher: "", topicInfos: [], totalTopics: 0, timestamp: getUTCTimeBaseREG(this._context.offsetTime) };
              return this._emitRtmEvent("topic", A3), void this._reportTopicUpdate("SNAPSHOT", {});
            }
            this._handleReceivedDcs(e2, "", "SNAPSHOT");
          }), _defineProperty$1(this, "_handleUserPublished", (A2, e2, t2) => {
            var g2;
            if ("datachannel" !== e2 || void 0 === t2)
              return;
            const o2 = null === (g2 = A2.dataChannels) || void 0 === g2 ? void 0 : g2.find((A3) => A3.id === t2.id);
            this._handleReceivedDcs([{ user: A2, config: t2, dc: o2 }], A2.uid.toString(), "REMOTE_JOIN");
          }), _defineProperty$1(this, "_handleUserUnPublished", (A2, e2, t2) => {
            if ("datachannel" !== e2)
              return;
            const g2 = null == t2 ? void 0 : t2.metadata;
            if (void 0 === g2)
              return;
            const o2 = this._decodeMetadata(g2), I2 = o2.topic, i3 = o2.metadata;
            this._emitTopicLeft(I2, A2, i3);
          }), _defineProperty$1(this, "_handleTokenPrivilegeWillExpire", () => {
            this._emitRtmEvent("tokenPrivilegeWillExpire", this._channelName);
          }), _defineProperty$1(this, "_handleUserJoined", (A2) => {
            const e2 = this._prefixChannelName;
            this._context.internalEmitter.emit("presence-user-joined", { channelName: e2, userId: A2.uid.toString() });
          }), _defineProperty$1(this, "_handlerUserLeft", (A2) => {
            const e2 = this._prefixChannelName;
            this._context.internalEmitter.emit("presence-user-left", { channelName: e2, userId: A2.uid.toString() });
          }), _defineProperty$1(this, "_emitTopicMessage", (A2) => {
            this._emitRtmEvent("message", A2);
          }), _defineProperty$1(this, "_emitTopicLeft", (A2, e2, t2) => {
            const g2 = e2.uid.toString(), o2 = this._getInitTopicEventData("REMOTE_LEAVE", this._channelName, g2, 1);
            o2.topicInfos.push({ publishers: [{ publisherUserId: g2, publisherMeta: t2 }], topicName: A2, totalPublisher: 1 }), this._emitRtmEvent("topic", o2), this._reportTopicUpdate("REMOTE_LEAVE", { [A2]: { publishers: [{ publisherUserId: g2, publisherMeta: t2 }], publisherCount: 1 } });
            const I2 = this._remoteTopics.get(A2);
            null != I2 && I2.getSubscribedUsers().includes(g2) ? null == I2 || I2.addUserWithoutDc(g2, e2) : this._deleteRemoteDc(A2, g2);
          });
          switch (null !== (E = A.rtmConfig.logLevel) && void 0 !== E ? E : "none") {
            case "debug":
              AgoraRTC.setLogLevel(0);
              break;
            case "info":
              AgoraRTC.setLogLevel(1);
              break;
            case "warn":
              AgoraRTC.setLogLevel(2);
              break;
            case "none":
              AgoraRTC.setLogLevel(4);
              break;
            default:
              AgoraRTC.setLogLevel(3);
          }
          this._channelName = t.channelName, this._prefixChannelName = getChannelNameByType(this._channelName, "STREAM"), this._context = A, A.rtmConfig.useStringUserId ? this._userId4RTC = A.userId : this._userId4RTC = Number(A.userId), this._emitRtmEvent = g, this._getStreamChannelList = o, this._validateRtmConnection = function(A2) {
            I(A2, arguments.length > 1 && void 0 !== arguments[1] && arguments[1]);
          }, this._getRTMSession = genGetRTMSession(i2), this.setMaxListeners(512), this._updateOptionsReJoinOrSub = r, this._unsubLockAMeta = n, this._absent = C, A.rtmConfig.privateConfig && !A.rtmConfig.privateConfig.serviceType.includes("MESSAGE") || (this._privatePermitUseMessageChn = true), AgoraRTC.setParameter("ENABLE_DATASTREAM_2", true), AgoraRTC.setParameter("DATASTREAM_MAX_RETRANSMITS", 0), AgoraRTC.setParameter("AP_RTM", true), this._context.config.logUpload && AgoraRTC.setParameter("UPLOAD_LOG", true);
          const s = [];
          this._isReuseRtcClient = s.length > 0, this.log("Create streamChannel, isReuseRtcClient: ".concat(this._isReuseRtcClient)), this._rtcClient = this._isReuseRtcClient ? s[0] : AgoraRTC.createClient({ codec: "vp8", mode: "rtc" }), this._rtcClientSid = this._rtcClient._sessionId, this.info("rtcClientSid: ".concat(this._rtcClientSid)), this._rtcClient.setRTMConfig({ apRTM: true, rtmFlag: 3 });
        }
        async leaveVosWeb() {
          this._isJoinedChannel && (this.removeAllListeners(), await this.leave(false));
        }
        async join(A) {
          var e;
          const t = getParameter("AREA_CONFIG");
          if (t) {
            const { areaCodes: A2, excludedArea: e2 } = t;
            AgoraRTC.setArea({ areaCode: A2, excludedArea: e2 });
          }
          const g = OperationName.join, o = linkStateCodeMap[this._linkState], { currentResolve: I } = await this._context.operationControl.awaitPromise(g + this._prefixChannelName);
          this._privatePermitUseMessageChn || this._context.initReportEvent();
          let i2 = null !== (e = this._rtcClient._sessionId) && void 0 !== e ? e : "";
          try {
            if ("CONNECTING" === this._linkState) {
              const { code: A2, reason: e3 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_DUPLICATE_OPERATION);
              throw new RtmUnavailableError(g, [e3], A2);
            }
            const e2 = { timestamp: 0 };
            this._isJoinedChannel || this._updateLinkState("CONNECTING", "JOIN", "IDLE" === this._linkState ? "JOIN" : "REJOIN", "IDLE" === this._linkState ? LinkStateChangeReasonDescription.JOIN : LinkStateChangeReasonDescription.REJOIN);
            try {
              var r, n, C, E;
              this._updatePrivateSettings(), this._apiRateLimit.canMakeOperation("join"), this._privatePermitUseMessageChn && (this._validateRtmConnection(g), this._validateSessionExist(g), this._validateJoinOptions(A, g)), null !== (r = A) && void 0 !== r && r.token && validateToken(A.token, this._context.appId, g, (A2) => {
                this.warn(A2);
              }), "" !== (null === (n = A) || void 0 === n ? void 0 : n.token) && void 0 !== (null === (C = A) || void 0 === C ? void 0 : C.token) || (A = _objectSpread2(_objectSpread2({}, A), {}, { token: this._context.appId }));
              const e3 = null !== (E = getParameter("STREAM_CHANNEL_COUNT")) && void 0 !== E ? E : SUB_STREAM_CHANNEL_LIMITATION;
              if (this._getStreamChannelList().length >= e3) {
                this.log("exceed join channel limit ".concat(e3));
                const { code: A2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_INSTANCE_EXCEED_LIMITATION);
                throw new RtmUnavailableError(g, [t2], A2);
              }
            } catch (A2) {
              var s;
              this.logError(A2);
              const { reason: e3 } = A2;
              throw this._handleJoinFailedState(null !== (s = null == A2 ? void 0 : A2.errorCode) && void 0 !== s ? s : e3), A2;
            }
            try {
              if (!this._isJoinedChannel) {
                this._addAllRtcListeners();
                let e3 = false;
                const t2 = AgoraRTC.__CLIENT_LIST__.map((A2) => "channel(".concat(A2.channelName, "), state: ").concat(A2.connectionState, "}"));
                this.log("FusionSDK: ".concat(FUSION, ". clientList of rtc: ").concat(t2));
                try {
                  var B;
                  this.log("Join streamChannel, isReuseRtcClient: ".concat(e3)), this._context.internalEmitter.emit("stream-channel-joined", this._channelName);
                  const t3 = this._rtcClient.connectionState;
                  if (FUSION && e3)
                    ;
                  else {
                    if (!("CONNECTED" === t3 || "CONNECTING" === t3 || "RECONNECTING" === t3)) {
                      var a, Q, c;
                      const e4 = null === (a = A) || void 0 === a ? void 0 : a.token;
                      this._context.config.cloudProxy && 0 === (null !== (Q = null === (c = this._context.rtmConfig.privateConfig) || void 0 === c || null === (c = c.accessPointHosts) || void 0 === c ? void 0 : c.length) && void 0 !== Q ? Q : 0) && this._rtcClient.startProxyServer(5), this._firstSnapshot4topic = true, await timeoutPromise(this._rtcClient.join(this._context.appId, this._channelName, e4 || null, this._context.userId), JOIN_TIMEOUT, g, RTMErrorCode.RTM_ERROR_CHANNEL_JOIN_FAILED, true);
                    }
                  }
                  i2 = null !== (B = this._rtcClient._sessionId) && void 0 !== B ? B : "";
                } catch (A2) {
                  var l, h;
                  if (i2 = null !== (l = this._rtcClient._sessionId) && void 0 !== l ? l : "", this._context.internalEmitter.emit("stream-channel-leaved", this._channelName), await this._validCancelJoin(g), isRtmError(A2))
                    throw isTimeout(A2) && await this._rtcClient.leave(), A2;
                  this.logError(A2);
                  const e4 = null !== (h = null == A2 ? void 0 : A2.code) && void 0 !== h ? h : AgoraRTCErrorCode.UNEXPECTED_ERROR;
                  if (e4 === AgoraRTCErrorCode.CAN_NOT_GET_GATEWAY_SERVER) {
                    const { code: A3, reason: e5 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_INVALID_TOKEN);
                    throw new RtmUnavailableError(g, [e5], A3);
                  }
                  if (e4 === AgoraRTCErrorCode.OPERATION_ABORTED) {
                    const { code: A3, reason: e5 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_JOIN_CANCELED);
                    throw new RtmUnavailableError(g, [e5], A3);
                  }
                  if (e4 === AgoraRTCErrorCode.UNEXPECTED_RESPONSE && A2.message.includes("DATASTREAM2_NOT_AVAILABLE")) {
                    const { code: A3, reason: e5 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_NOT_AVAILABLE);
                    throw new RtmUnavailableError(g, [e5], A3);
                  }
                  const { code: t3, reason: o2 } = convertDataChannelJoinCodeToSdkCode(e4, RTMErrorCode.RTM_ERROR_CHANNEL_JOIN_FAILED);
                  throw new RtmUnavailableError(g, [o2 + "Join channel failure, server code is ".concat(e4)], t3);
                }
                await this._validCancelJoin(g), this._updateLinkState("CONNECTED", "JOIN", "JOIN_SUCCESS", LinkStateChangeReasonDescription.JOIN_SUCCESS), this._isJoinedChannel = true;
              }
              return this._privatePermitUseMessageChn && (this.log("stream channel joined success, start sub other options"), await this._subscribe(A)), this._joinedAndSubscribed = true, I(e2), e2;
            } catch (A2) {
              var u;
              I(false);
              const { reason: e3 } = A2;
              throw false === this._joinedAndSubscribed && this._handleJoinFailedState(null !== (u = null == A2 ? void 0 : A2.errorCode) && void 0 !== u ? u : e3), A2;
            }
          } catch (A2) {
            throw I(void 0), A2;
          } finally {
            var d;
            const { sid: e2, elapse: t2, opid: g2 } = this._getSidAndElapse4Report(), I2 = this._privatePermitUseMessageChn ? null === (d = this._context) || void 0 === d ? void 0 : d.getNewJoinFlag(handleSubOptionsAsDefault(A)) : 0;
            this._context.addReportEvents("StreamChnJoin", { lts: getReportLts(), userId: this._context.uid, elapse: t2, sid: e2, seq: Long$1.fromNumber(g2), vid: Long$1.fromValue(this._context.vid || "0"), channelName: this._channelName, joinOptionsFlag: I2, rtcSid: i2, preState: o });
          }
        }
        async leave() {
          let A = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
          const e = OperationName.leave, { sid: t, elapse: g, opid: o } = this._getSidAndElapse4Report();
          this._context.addReportEvents("StreamChnLeave", { lts: getReportLts(), vid: Long$1.fromValue(this._context.vid || "0"), sid: t, seq: Long$1.fromNumber(o), userId: this._context.uid, elapse: g, channelName: this._channelName, preState: linkStateCodeMap[this._linkState] }), this._context.forceReportEvents(), this._privatePermitUseMessageChn && A && (this._validateRtmConnection(e), this._validateSessionExist(e));
          const I = { timestamp: 0 };
          if ("FAILED" === this._linkState)
            return this._updateLinkState("IDLE", "LEAVE", "LEAVE", LinkStateChangeReasonDescription.LEAVE), this._localLeave(), I;
          if ("CONNECTING" === this._linkState)
            return await this._rtcClient.leave(), this._updateLinkState("IDLE", "LEAVE", "LEAVE", LinkStateChangeReasonDescription.LEAVE), this._localLeave(), I;
          let i2;
          this._checkIsJoinedChannel(e);
          const r = new Promise((A2, e2) => {
            i2 = A2;
          });
          this.log("Leave streamChannel, isReuseRtcClient: ".concat(this._isReuseRtcClient));
          const n = [];
          try {
            const A2 = this._isReuseRtcClient && FUSION;
            await Promise.all([A2 ? this._fusionSdkLeave() : this._rtcClient.leave(), ...n.map((A3) => fromPromise(this._rtcClient.unpublish(A3), (A4) => A4)), ...this._isReuseRtcClient && FUSION && this._privatePermitUseMessageChn ? [this._unsubLockAMeta(this._prefixChannelName), this._handleLeaveEffects(), () => {
              this._firstSnapshot4topic = true;
            }] : []]), this._context.config.cloudProxy && !A2 && this._rtcClient.stopProxyServer(), i2(I);
          } catch (A2) {
            if (this.logError(A2), isRtmError(A2))
              throw A2;
            const t2 = (null == A2 ? void 0 : A2.code) || AgoraRTCErrorCode.UNEXPECTED_ERROR, { code: g2, reason: o2 } = convertDataChannelJoinCodeToSdkCode(t2, RTMErrorCode.RTM_ERROR_CHANNEL_LEAVE_FAILED);
            throw new RtmUnavailableError(e, [o2 + "Leave channel failure, server code is  ".concat(t2)], g2);
          } finally {
            this._context.deleteChannel(this._prefixChannelName), this._updateLinkState("IDLE", "LEAVE", "LEAVE", LinkStateChangeReasonDescription.LEAVE);
          }
          return r;
        }
        async renewStreamChannelToken(A) {
          const e = OperationName.renewToken;
          this._checkIsJoinedChannel(e);
          try {
            await this._rtcClient.renewToken(A);
          } catch (A2) {
            var t;
            this.logError(A2);
            const g = null !== (t = null == A2 ? void 0 : A2.code) && void 0 !== t ? t : AgoraRTCErrorCode.UNEXPECTED_ERROR, { code: o, reason: I } = convertDataChannelJoinCodeToSdkCode(g, RTMErrorCode.RTM_ERROR_INVALID_TOKEN);
            throw new RtmUnavailableError(e, [I + "RenewToken of streamChannel failure, server code is ".concat(g)], o);
          }
        }
        async joinTopic(A, e) {
          const t = OperationName.joinTopic, g = { timestamp: 0, topicName: A };
          let o = 0;
          const I = false, i2 = (() => {
            const A2 = Array.from(this._localTopics.values()).filter((A3) => void 0 !== A3).filter((A3) => void 0 !== (null == A3 ? void 0 : A3.getDataChannel())).map((A3) => {
              var e2;
              return null == A3 || null === (e2 = A3.getDataChannel()) || void 0 === e2 ? void 0 : e2.getConfig().id;
            });
            for (let e2 = 0; e2 < JOIN_TOPIC_LIMITATION; e2++)
              if (-1 === A2.findIndex((A3) => A3 === e2))
                return e2;
            return -1;
          })();
          try {
            var r;
            if (this._apiRateLimit.canMakeOperation("joinTopic"), this._privatePermitUseMessageChn && (this._validateRtmConnection(t), this._validateSessionExist(t)), validateTopicName(A, t), this._checkIsJoinedChannel(t), this._localTopics.has(A))
              return this.log("topic(%s) already exists", A), g;
            if (this._localTopics.size >= JOIN_TOPIC_LIMITATION) {
              this.log("exceed create topic limit");
              const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_EXCEED_TOPIC_LIMITATION);
              throw new RtmUnavailableError(t, [e2], A2);
            }
            e = { meta: null };
            const o2 = TopicMetadata.encode({ metadata: null === (r = e) || void 0 === r ? void 0 : r.meta, topic: A }).finish();
            this._localTopics.set(A, void 0);
            const C2 = await fromPromise(this._rtcClient.publish({ id: i2, ordered: I, metadata: String.fromCharCode(...o2) }), (A2) => A2);
            if (C2.isErr()) {
              var n;
              this._localTopics.delete(A);
              const e2 = null == C2 || null === (n = C2.error) || void 0 === n ? void 0 : n.code;
              throw new RtmUnavailableError(t, ["JoinTopic failure, code of rtcClient.publish api is ".concat(e2)], RTMErrorCode.RTM_ERROR_CHANNEL_JOIN_TOPIC_FAILED);
            }
            {
              const e2 = C2.value, t2 = new LocalTopic(this._context, this.logger, A, e2);
              null == e2 || e2.on("open", () => {
                this.log("".concat(this._channelName, "(").concat(A, ") local dc opened."));
              }), null == e2 || e2.on("close", () => {
                this.warn("".concat(this._channelName, "(").concat(A, ") local dc closed."));
              }), null == e2 || e2.on("error", (e3) => {
                this.logError("error occurs in ".concat(this._channelName, "(").concat(A, ") local dc. error is %o"), e3);
              }), this._localTopics.set(A, t2);
            }
          } catch (A2) {
            var C;
            if (A2 instanceof RTMBaseError)
              o = null !== (C = A2.errorCode) && void 0 !== C ? C : 0;
            throw A2;
          } finally {
            const { sid: e2, elapse: t2, opid: g2 } = this._getSidAndElapse4Report();
            this._context.addReportEvents("TopicJoin", { lts: getReportLts(), vid: Long$1.fromValue(this._context.vid || "0"), sid: e2, userId: this._context.uid, elapse: t2, channelName: this._channelName, topicName: A, qos: Number(I), priority: 0, syncWithMedia: Number(false), streamId: i2, errorCode: Long$1.fromNumber(o), seq: Long$1.fromNumber(g2) });
          }
          return g;
        }
        async publishTopicMessage(A, e, t) {
          var g;
          const o = OperationName.publishTopicMessage;
          this._apiRateLimit.canMakeOperation("publishTopicMsg"), this._privatePermitUseMessageChn && (this._validateRtmConnection(o), this._validateSessionExist(o));
          const I = { timestamp: 0, topicName: A };
          if (validateTopicName(A, o), this._checkIsJoinedChannel(o), null != t && t.customType && validateCustomType(null == t ? void 0 : t.customType, o), "string" == typeof e && !e) {
            const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_INVALID_MESSAGE);
            throw new RtmInvalidArgumentError(o, [e2], A2);
          }
          if (("string" == typeof e ? new TextEncoder().encode(e).buffer : e.buffer).byteLength + new Blob([null !== (g = null == t ? void 0 : t.customType) && void 0 !== g ? g : ""]).size > TOPIC_MESSAGE_SIZE) {
            const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_MESSAGE_LENGTH_EXCEED_LIMITATION);
            throw new RtmInvalidArgumentError(o, [e2], A2);
          }
          if ("CONNECTED" !== this._rtcClient.connectionState) {
            const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_NOT_JOINED);
            throw new RtmUnavailableError(o, [e2], A2);
          }
          const i2 = this._localTopics.get(A);
          if (!i2) {
            const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_TOPIC_NOT_JOINED);
            throw new RtmUnavailableError(o, [e2], A2);
          }
          return await (null == i2 ? void 0 : i2.publishTopicMessage(o, e, t)), I;
        }
        async leaveTopic(A) {
          var e, t;
          const g = OperationName.leaveTopic, o = null === (e = this._localTopics.get(A)) || void 0 === e ? void 0 : e.getDataChannel(), I = null !== (t = null == o ? void 0 : o.id) && void 0 !== t ? t : 0, { sid: i2, elapse: r, opid: n } = this._getSidAndElapse4Report();
          this._context.addReportEvents("TopicLeave", { sid: i2, elapse: r, lts: getReportLts(), vid: Long$1.fromValue(this._context.vid || "0"), userId: this._context.uid, channelName: this._channelName, topicName: A, streamId: I, seq: Long$1.fromNumber(n) }), this._privatePermitUseMessageChn && (this._validateRtmConnection(g), this._validateSessionExist(g));
          const C = { timestamp: 0, topicName: A };
          if (validateTopicName(A, g), this._checkIsJoinedChannel(g), !this._localTopics.has(A)) {
            const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_TOPIC_NOT_JOINED);
            throw new RtmUnavailableError(g, [e2], A2);
          }
          try {
            await this._rtcClient.unpublish(o), this._localTopics.delete(A);
          } catch (A2) {
            var E;
            this.logError(A2);
            const e2 = null !== (E = null == A2 ? void 0 : A2.code) && void 0 !== E ? E : AgoraRTCErrorCode.UNEXPECTED_ERROR, { code: t2, reason: o2 } = convertDataChannelJoinCodeToSdkCode(e2, RTMErrorCode.RTM_ERROR_CHANNEL_IN_ERROR_STATE);
            throw new RtmUnavailableError(g, [o2 + "LeaveTopic failure, server code is  ".concat(e2), t2]);
          }
          return C;
        }
        async subscribeTopic(A, e) {
          var t, g, o;
          const I = OperationName.subscribeTopic, { currentResolve: i2, currentReject: r } = await this._context.operationControl.awaitPromise(I + STREAM_CHANNEL_PREFIX + A), n = null !== (t = null == e || null === (g = e.users) || void 0 === g ? void 0 : g.filter((A2) => !isValidId(A2))) && void 0 !== t ? t : [];
          (null == e ? void 0 : e.users) && (e.users = null == e || null === (o = e.users) || void 0 === o ? void 0 : o.filter((A2) => isValidId(A2))), null != e && e.users && (e.users = [...new Set(e.users)]);
          let C = false, E = false, s = 0;
          const B = { failedUsers: n, failedDetails: n.map((e2) => ({ user: e2, errorCode: SubscribeTopicErrorCode.INVALID_PARAMS, timestamp: 0, topicName: A })), succeedUsers: [], timestamp: 0, topicName: A }, a = /* @__PURE__ */ new Set();
          try {
            var Q, c, l, h, u;
            this._apiRateLimit.canMakeOperation("subscribeTopic"), this._privatePermitUseMessageChn && (this._validateRtmConnection(I), this._validateSessionExist(I)), validateTopicName(A, I), this._checkIsJoinedChannel(I);
            const t2 = () => Array.from(this._remoteTopics.values()).filter((A2) => A2.getAllSubscribedUserCount() > 0).length;
            if (t2() > SUB_TOPIC_LIMITATION) {
              this.log("subscribed topic(%s) failed, exceed subscribe topic limit ".concat(SUB_TOPIC_LIMITATION), A);
              const { code: e2, reason: t3 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_EXCEED_TOPIC_LIMITATION);
              throw new RtmUnavailableError(I, [t3], e2);
            }
            const g2 = this._remoteTopics.get(A);
            if ((null !== (Q = null == g2 ? void 0 : g2.getAllSubscribedUserCount()) && void 0 !== Q ? Q : 0) >= SUB_TOPIC_USER_LIMITATION) {
              this.log("subscribe topic(".concat(A, ") exceed user limit: ").concat(SUB_TOPIC_USER_LIMITATION));
              const { code: e2, reason: t3 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_EXCEED_TOPIC_USER_LIMITATION);
              throw new RtmUnavailableError(I, [t3], e2);
            }
            if (!(this._remoteTopics.has(A) || null != e && e.users && 0 !== e.users.length)) {
              if (this._localTopics.has(A))
                return i2(void 0), B;
              const { code: e2, reason: t3 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_TOPIC_NOT_EXIST);
              throw new RtmUnavailableError(I, [t3], e2);
            }
            if (!this._remoteTopics.has(A) && ((null == e || null === (c = e.users) || void 0 === c ? void 0 : c.length) || 0) > 0) {
              this.log("createTopicHere");
              const t3 = new RemoteTopic(this._context, this.logger, A, this._channelName, this._emitTopicMessage), g3 = SUB_TOPIC_USER_LIMITATION - (null == t3 ? void 0 : t3.getAllSubscribedUserCount()), o3 = shuffle$1((null == e ? void 0 : e.users) || []).filter((e2, t4) => (t4 + 1 > g3 && (C = true, B.failedDetails.push({ user: e2, errorCode: SubscribeTopicErrorCode.SUB_USER_EXCEED_LIMITATION, timestamp: 0, topicName: A }), B.failedUsers.push(e2)), t4 + 1 <= g3));
              return this.log("shuffle pre subscribe topic(%s), users: %o", A, o3.map((A2) => replaceRangeWithAsterisk(A2))), o3.forEach((e2) => {
                a.add(e2), t3.addUserWithoutDc(e2), this._remoteTopics.set(A, t3);
              }), this.log("".concat(A, " not existent in channel").concat(this._channelName, ".")), B.succeedUsers = [...a], this.log("subscribed ".concat(this._channelName, "(").concat(A, "), resp is %o"), B), i2(void 0), B;
            }
            let o2 = [];
            var d, D;
            if (null != e && e.users && 0 !== e.users.length)
              o2 = (null == e || null === (d = e.users) || void 0 === d ? void 0 : d.filter((e2) => {
                const t3 = null == g2 ? void 0 : g2.getPreSubscribedUsers().includes(e2), o3 = null == g2 ? void 0 : g2.getSubscribedUsers().includes(e2), I2 = !(null != g2 && g2.getUsers().has(e2));
                return t3 || o3 ? this.log("subscribe ".concat(replaceRangeWithAsterisk(e2), " in topic(").concat(A, ") already.")) : I2 && (a.add(e2), null == g2 || g2.addUserWithoutDc(e2), this.log("pre subscribe user(".concat(replaceRangeWithAsterisk(e2), ")"))), this.log("can't sub the user ".concat(e2, ", isPreSubscribed: ").concat(t3, ", isSubscribed: ").concat(o3, ", isUserNotPublishTopic: ").concat(I2)), !t3 && !o3 && !I2;
              })) || [];
            else
              (null !== (D = null == g2 ? void 0 : g2.getUsers()) && void 0 !== D ? D : /* @__PURE__ */ new Map()).forEach((A2, e2) => {
                "UNSUBSCRIBE" === A2.subscribedState && o2.push(e2);
              });
            o2.length > SUB_TOPIC_USER_LIMITATION - (null !== (l = null === (h = this._remoteTopics.get(A)) || void 0 === h ? void 0 : h.getAllSubscribedUserCount()) && void 0 !== l ? l : 0) && (C = true);
            const r2 = await this._patchSubscribeTopic(A, o2);
            return this.log("".concat(I, " result: preSubUsers(").concat([...a], "), subUsers(").concat(r2.succeedUsers, ")")), B.succeedUsers = [...a, ...r2.succeedUsers], B.failedUsers = [...B.failedUsers, ...r2.failedUsers], B.failedDetails = [...B.failedDetails, ...r2.failedDetails], B.failedUsers.length === (null == e || null === (u = e.users) || void 0 === u ? void 0 : u.length) || B.failedUsers.length, i2(void 0), B;
          } catch (A2) {
            throw i2(void 0), A2;
          } finally {
            E = a.size > 0, s = B.succeedUsers.length, this.log("subscribe topic(".concat(A, "), randomSubscribe: ").concat(C, ", containPreSubscribeUsers: ").concat(E, ", preUsersCount: ").concat(a.size, ", succeedUsersCount: ").concat(s, ", failedUsersCount: ").concat(B.failedUsers.length));
            const { sid: e2, elapse: t2, opid: g2 } = this._getSidAndElapse4Report();
            this._context.addReportEvents("TopicSubscribe", { lts: getReportLts(), vid: Long$1.fromValue(this._context.vid || "0"), sid: e2, userId: this._context.uid, elapse: t2, channelName: this._channelName, topicName: A, seq: Long$1.fromNumber(g2), randomSubscribe: Number(C), preSubscribe: Number(E), userCount: s });
          }
        }
        async unsubscribeTopic(A, e) {
          var t, g, o;
          const I = OperationName.unsubscribeTopic, { sid: i2, elapse: r, opid: n } = this._getSidAndElapse4Report();
          this._context.addReportEvents("TopicUnsubscribe", { lts: getReportLts(), vid: Long$1.fromValue(this._context.vid || "0"), sid: i2, userId: this._context.uid, elapse: r, channelName: this._channelName, topicName: A, seq: Long$1.fromNumber(n) }), this._privatePermitUseMessageChn && (this._validateRtmConnection(I), this._validateSessionExist(I)), validateTopicName(A, I), this._checkIsJoinedChannel(I);
          const C = this._remoteTopics.get(A);
          if (null == C || !C.getAllSubscribedUserCount()) {
            const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_TOPIC_NOT_SUBSCRIBED);
            throw new RtmUnavailableError(I, [e2], A2);
          }
          const E = null !== (t = null == e || null === (g = e.users) || void 0 === g ? void 0 : g.filter((A2) => !isValidId(A2))) && void 0 !== t ? t : [], s = { failedUsers: E, failedDetails: E.map((e2) => ({ user: e2, errorCode: SubscribeTopicErrorCode.INVALID_PARAMS, timestamp: 0, topicName: A })), timestamp: 0, succeedUsers: [], topicName: A };
          let B = [];
          if (null != e && e.users && 0 !== e.users.length)
            B = e.users.filter((A2) => isValidId(A2)).filter((e2) => {
              const t2 = C.getPreSubscribedUsers().includes(e2), g2 = C.getSubscribedUsers().includes(e2);
              return t2 ? (this._deleteRemoteDc(A, e2), s.succeedUsers.push(e2)) : g2 || (s.failedDetails.push({ user: e2, errorCode: SubscribeTopicErrorCode.NOT_SUBSCRIBED_USER, timestamp: 0, topicName: A }), s.failedUsers.push(e2)), g2;
            });
          else {
            C.getSubscribedUsers().forEach((A2) => {
              B.push(A2);
            });
            C.getPreSubscribedUsers().forEach((e2) => {
              this._deleteRemoteDc(A, e2), s.succeedUsers.push(e2);
            });
          }
          try {
            const e2 = await Promise.all(B.map((e3) => {
              const t2 = null == C ? void 0 : C.getUsers().get(e3);
              if (!t2)
                throw this.warn("unsubscribe topic(".concat(A, ")-user(").concat(replaceRangeWithAsterisk(e3), ") failed, user not in remoteTopic users.")), new Error();
              const { id: g2, user: o2 } = t2;
              return fromPromise(this._rtcClient.unsubscribe(o2 || this._userIdToRTCRemoteUser(e3), "datachannel", g2), (A2) => A2);
            }));
            e2.map((A2, e3) => ({ userId: B[e3], result: A2 })).forEach((e3) => {
              let { userId: t2, result: g2 } = e3;
              if (g2.isErr()) {
                var o2, i3, r2;
                this.logError(g2.error);
                const e4 = null !== (o2 = null == g2 || null === (i3 = g2.error) || void 0 === i3 ? void 0 : i3.code) && void 0 !== o2 ? o2 : AgoraRTCErrorCode.UNEXPECTED_ERROR;
                s.failedDetails.push({ user: t2, reason: "Unsubscribe topic failure, web_rtc code is ".concat(e4, ", the reason of web_rtc is that ").concat(null == g2 || null === (r2 = g2.error) || void 0 === r2 ? void 0 : r2.toString()), timestamp: 0, topicName: A }), s.failedUsers.push(t2);
                const { code: n2, reason: C2 } = convertDataChannelJoinCodeToSdkCode(e4, RTMErrorCode.RTM_ERROR_CHANNEL_IN_ERROR_STATE);
                throw new RtmUnavailableError(I, [C2 + "unsubscribeTopic failure, server code is ".concat(e4)], n2);
              }
              s.succeedUsers.push(t2), C.handleUnsubscription(t2);
            });
          } catch (A2) {
            throw A2;
          }
          s.failedUsers.length === (null == e || null === (o = e.users) || void 0 === o ? void 0 : o.length) || s.failedUsers.length, this.log("".concat(I, " success. sdk resp is %o"), s);
          return s.succeedUsers.forEach((e2) => {
            this._context.internalEmitter.emit("unsubscribeTopicMessage", { topicName: A, userId: e2 });
          }), { timestamp: 0 };
        }
        getSubscribedUserList(A) {
          const e = OperationName.getSubscribedUserList;
          this._privatePermitUseMessageChn && (this._validateRtmConnection(e), this._validateSessionExist(e)), validateTopicName(A, e), this._checkIsJoinedChannel(e);
          const t = this._remoteTopics.get(A);
          if (null == t || !t.getAllSubscribedUserCount()) {
            const { code: A2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_TOPIC_NOT_SUBSCRIBED);
            throw new RtmUnavailableError(e, [t2], A2);
          }
          const g = { subscribed: [], timestamp: 0, topicName: A };
          return g.subscribed = [...t.getSubscribedUsers(), ...t.getPreSubscribedUsers()], g;
        }
        setStreamChannelParameter(A, e) {
          AgoraRTC.setParameter(A, e);
        }
        async _handleLeaveEffects() {
          this._clearLocalCache4topic(), this._isJoinedChannel = false, this._joinedAndSubscribed = false, this._context.internalEmitter.emit("stream-channel-leaved", this._channelName), this._removeAllRtcListeners();
        }
        _handleUpdatedTopicsInOffline(A) {
          const e = /* @__PURE__ */ new Map();
          this._remoteTopics.forEach((A2, t2) => {
            e.set(t2, A2);
          });
          const t = /* @__PURE__ */ new Map();
          A.forEach((A2) => {
            var e2;
            null === (e2 = A2.dataChannels) || void 0 === e2 || e2.forEach((e3) => {
              if (e3.getConfig()) {
                var g;
                const { metadata: o } = e3.getConfig(), I = this._decodeMetadata(o), { topic: i2 } = I, r = null !== (g = t.get(i2)) && void 0 !== g ? g : [];
                r.push({ user: A2, dc: e3.getConfig() }), t.set(i2, r);
              }
            });
          }), t.forEach((A2, t2) => {
            var g, o;
            const I = null !== (g = null === (o = e.get(t2)) || void 0 === o ? void 0 : o.getUsers()) && void 0 !== g ? g : /* @__PURE__ */ new Map(), i2 = A2.filter((A3) => {
              var e2;
              let { user: t3 } = A3;
              return !I.has(t3.uid.toString()) && "PRE_SUBSCRIBE" !== (null === (e2 = I.get(t3.uid.toString())) || void 0 === e2 ? void 0 : e2.subscribedState);
            });
            i2.length > 0 && this.log("joined topic: %s, users: %o", t2, Array.from(i2.values()).map((A3) => {
              var e2;
              return null === (e2 = A3.user) || void 0 === e2 ? void 0 : e2.uid;
            })), i2.forEach((A3) => {
              let { user: e2, dc: t3 } = A3;
              this._handleUserPublished(e2, "datachannel", t3);
            });
          }), e.forEach((A2, e2) => {
            var g;
            const o = A2.getUsers(), I = null !== (g = t.get(e2)) && void 0 !== g ? g : [], i2 = Array.from(o.values()).filter((A3) => "PRE_SUBSCRIBE" !== A3.subscribedState && !I.find((e3) => {
              var t2;
              let { user: g2 } = e3;
              return g2.uid === (null === (t2 = A3.user) || void 0 === t2 ? void 0 : t2.uid);
            }));
            i2.length > 0 && this.log("left topic: %s, users: %o", e2, Array.from(i2.values()).map((A3) => {
              var e3;
              return null === (e3 = A3.user) || void 0 === e3 ? void 0 : e3.uid;
            })), i2.forEach((A3) => {
              this._emitTopicLeft(e2, A3.user, A3.meta);
            });
          });
        }
        _removeAllRtcListeners() {
          this._rtcClient.off("connection-state-change", this._handleConnectionStateChange), this._rtcClient.off("published-user-list", this._handleUserPublishedList), this._rtcClient.off("user-published", this._handleUserPublished), this._rtcClient.off("user-unpublished", this._handleUserUnPublished), this._rtcClient.off("token-privilege-will-expire", this._handleTokenPrivilegeWillExpire), this._rtcClient.off("user-joined", this._handleUserJoined), this._rtcClient.off("user-left", this._handlerUserLeft);
        }
        _addAllRtcListeners() {
          this._rtcClient.on("connection-state-change", this._handleConnectionStateChange), this._rtcClient.on("published-user-list", this._handleUserPublishedList), this._rtcClient.on("user-published", this._handleUserPublished), this._rtcClient.on("user-unpublished", this._handleUserUnPublished), this._rtcClient.on("token-privilege-will-expire", this._handleTokenPrivilegeWillExpire), this._rtcClient.on("user-joined", this._handleUserJoined), this._rtcClient.on("user-left", this._handlerUserLeft);
        }
        async _handleReceivedDcs(A, e, t) {
          const g = /* @__PURE__ */ new Map();
          for (let e2 = 0; e2 < A.length; e2++) {
            var o;
            const { user: t2, config: I, dc: i2 } = A[e2], r = null == I ? void 0 : I.metadata;
            if (void 0 === r) {
              this.log("meta of datachannel is invalid. user(".concat(t2, "), channel(").concat(this._channelName, "), dc(").concat(I, ")"));
              continue;
            }
            const n = t2.uid.toString(), C = this._decodeMetadata(r), E = C.topic, s = C.metadata, B = null == I ? void 0 : I.id;
            g.has(E) || g.set(E, []), null === (o = g.get(E)) || void 0 === o || o.push({ publisherUserId: n, publisherMeta: s }), this._addOrUpdateRemoteDc(E, n, t2, s, B, i2);
            const a = this._remoteTopics.get(E);
            null != a && a.getPreSubscribedUsers().includes(n) && await this._handlePreSubscribeTopic(E, n);
          }
          this._emitTopic(e, t, g);
        }
        _emitTopic(A, e, t) {
          const g = this._getInitTopicEventData(e, this._channelName, A, t.size);
          t.forEach((A2, e2) => {
            g.topicInfos.push({ publishers: A2, topicName: e2, totalPublisher: A2.length });
          }), 0 === g.topicInfos.length && this.log("length of topicInfos is 0 in emitTopic."), this._emitRtmEvent("topic", g);
          const o = {};
          t.forEach((A2, e2) => {
            o[e2] = { publishers: A2, publisherCount: A2.length };
          }), this._reportTopicUpdate(e, o);
        }
        _getInitTopicEventData(A, e, t, g) {
          return { eventType: A, channelName: e, publisher: t, topicInfos: [], totalTopics: g, timestamp: getUTCTimeBaseREG(this._context.offsetTime) };
        }
        _userIdToRTCRemoteUser(A) {
          return { uid: "number" == typeof this._context.userId ? parseInt$2(A) : A, hasAudio: false, hasVideo: false, dataChannels: [] };
        }
        _addOrUpdateRemoteDc(A, e, t, g, o, I) {
          if (!this._remoteTopics.has(A)) {
            const e2 = new RemoteTopic(this._context, this.logger, A, this._channelName, this._emitTopicMessage);
            this._remoteTopics.set(A, e2);
          }
          const i2 = this._remoteTopics.get(A);
          i2.getUsers().has(e) ? i2.updateUserDatachannelInfo(e, { meta: g, id: o, user: t }) : i2.addUserWithDc(e, { subscribedState: "UNSUBSCRIBE", meta: g, id: o, datachannel: I, user: t });
        }
        _deleteRemoteDc(A, e) {
          const t = this._remoteTopics.get(A);
          null == t || t.removeUser(e), 0 === (null == t ? void 0 : t.getUsers().size) && this._remoteTopics.delete(A);
        }
        _decodeMetadata(A) {
          return TopicMetadata.decode(new TextEncoder().encode(A));
        }
        async _handlePreSubscribeTopic(A, e) {
          const t = this._remoteTopics.get(A), g = null == t ? void 0 : t.getUsers().get(e);
          if (!g)
            return void this.log("handlePreSubscribeTopic failed. remoteDcInfo is undefined. topicName: ".concat(A, ", userId: ").concat(replaceRangeWithAsterisk(e)));
          const { id: o, user: I } = g, i2 = await fromPromise(this._rtcClient.subscribe(I || this._userIdToRTCRemoteUser(e), "datachannel", o), (A2) => A2);
          if (i2.isErr()) {
            var r;
            const t2 = null == i2 || null === (r = i2.error) || void 0 === r ? void 0 : r.code;
            this.log("subscribe predictive user(".concat(replaceRangeWithAsterisk(e), ") in topic(").concat(A, ") failed, code is ").concat(t2));
          }
          if (i2.isOk()) {
            const g2 = i2.value;
            this.log("pre-subtopic ".concat(this._channelName, "(").concat(A, ") succeed.")), null == t || t.handleSubscription(g2, e);
          }
        }
        async _patchSubscribeTopic(A, e) {
          var t;
          const g = { succeedUsers: [], failedUsers: [], failedDetails: [], timestamp: 0, topicName: A }, o = this._remoteTopics.get(A), I = SUB_TOPIC_USER_LIMITATION - (null !== (t = null == o ? void 0 : o.getAllSubscribedUserCount()) && void 0 !== t ? t : 0), i2 = shuffle$1(e).filter((e2, t2) => (t2 + 1 > I && (g.failedDetails.push({ user: e2, errorCode: SubscribeTopicErrorCode.SUB_USER_EXCEED_LIMITATION, timestamp: 0, topicName: A }), g.failedUsers.push(e2)), t2 + 1 <= I));
          this.log("subscribe topic(%s) users: %o", A, i2.map((A2) => replaceRangeWithAsterisk(A2)));
          const r = (await Promise.all(i2.map((e2) => {
            const t2 = null == o ? void 0 : o.getUsers().get(e2);
            if (!t2)
              throw this.warn("subscribe topic(".concat(A, ")-user(").concat(replaceRangeWithAsterisk(e2), ") failed, user not in remoteTopic users.")), new Error();
            const { id: g2, user: I2 } = t2;
            return fromPromise(this._rtcClient.subscribe(I2 || this._userIdToRTCRemoteUser(e2), "datachannel", g2), (A2) => A2);
          }))).map((A2, e2) => ({ userId: i2[e2], result: A2 }));
          return r.forEach((e2) => {
            if (e2.result.isErr()) {
              var t2, I2;
              const o2 = null === (t2 = e2.result.error) || void 0 === t2 ? void 0 : t2.code, i3 = SubscribeTopicErrorCode.UNKNOWN_ERROR;
              g.failedDetails.push({ user: e2.userId, errorCode: i3, reason: "Subscribe topic failure, web_rtc code is ".concat(o2, ", the reason of web_rtc is that ").concat(null == e2 || null === (I2 = e2.result) || void 0 === I2 || null === (I2 = I2.error) || void 0 === I2 ? void 0 : I2.toString()), timestamp: 0, topicName: A }), g.failedUsers.push(e2.userId), this.warn(e2.result, "WEB_RTCerror"), this.log("subscribe user(".concat(e2.userId, ") in topic(").concat(A, ") failed, code is ").concat(o2));
            } else {
              g.succeedUsers.push(e2.userId);
              const t3 = e2.result.value;
              this.log("subtopic ".concat(this._channelName, "(").concat(A, ") succeed.")), null == o || o.handleSubscription(t3, e2.userId);
            }
          }), g;
        }
        _clearLocalCache4topic() {
          this._localTopics = /* @__PURE__ */ new Map(), this._remoteTopics = /* @__PURE__ */ new Map();
        }
        _checkIsJoinedChannel(A) {
          if (!this._isJoinedChannel || "CONNECTED" !== this._linkState) {
            this.warn("".concat(this._channelName, " have not joined stream channel when ").concat(A));
            const { code: e, reason: t } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_NOT_JOINED);
            throw new RtmUnavailableError(A, [t], e);
          }
        }
        _updatePrivateSettings() {
          const A = this._context.rtmConfig.privateConfig;
          if (null != A && A.accessPointHosts) {
            var e;
            const t = A.logUploadHosts, g = A.eventUploadHosts, o = 443, I = getPrivateSettingsPortAndDomains(A.accessPointHosts);
            this._rtcClient.setLocalAccessPointsV2({ accessPoints: { serverList: I.hostname, domain: "edge." + sample$1(null !== (e = A.originDomains) && void 0 !== e ? e : ["agora.io"]), port: I.port }, log: t ? _objectSpread2({}, getPrivateSettingsPortAndDomains(t, o)) : void 0, report: g ? _objectSpread2({}, getPrivateSettingsPortAndDomains(g, o)) : void 0 });
          } else
            A && this.warn("use private settings but apHosts is set to empty");
        }
        _updateLinkState(A, e, t) {
          let g = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "";
          if (this._linkState === A)
            return;
          this._privatePermitUseMessageChn && this._context.sendReport("LinkStateChange", { elapse: getElapse(this._context.startTime), lts: Long$1.fromNumber(Date.now()), reason: LinkStateChangeReason4Report[t], sid: getSid(this._context.instanceId || Long$1.fromNumber(0)), vid: Long$1.fromString(getParameter("VID").get(this._context.appId) || "0"), userid: this._context.uid, currentState: linkStateCodeMap[A], previousState: linkStateCodeMap[this._linkState], operation: linkOperationCodeMap[e], serviceType: 1, streamChannelName: this._channelName }), "FAILED" !== A && "IDLE" !== A || (this._firstSnapshot4topic = true);
          const o = { currentState: A, previousState: this._linkState, serviceType: "STREAM", operation: e, reason: g, reasonCode: t, affectedChannels: [this._channelName], unrestoredChannels: [], timestamp: getUTCTimeBaseREG(this._context.offsetTime), isResumed: "CONNECTED" === A && this._isJoinedChannel };
          this._linkState = A, this._emitRtmEvent("linkState", o);
        }
        async _subscribe(A) {
          let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          const t = OperationName.join, g = handleJoinOptionsAsDefault(A), o = getRandomInt(0, Number.MAX_SAFE_INTEGER), { code: I, reason: i2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_JOIN_FAILED), r = this._context.notInChannel(this._prefixChannelName), n = this._context.getChannelLastSubOrJoinOptions(this._prefixChannelName);
          this._context.setLastSubOrJoinOptionsCache(this._prefixChannelName, g);
          try {
            await Promise.all([this._updateOptionsReJoinOrSub(this._prefixChannelName, r, n, A, e)]);
          } catch (A2) {
            throw new RtmUnknownError(t, [i2 + A2], I);
          } finally {
            var C;
            null === (C = this._context) || void 0 === C || C.reportChnJoin(this._prefixChannelName, n, g, o);
          }
        }
        _localLeave() {
          this._isJoinedChannel = false, this._joinedAndSubscribed = false, this._removeAllRtcListeners(), this._clearLocalCache4topic(), this._context.internalEmitter.emit("stream-channel-leaved", this._channelName);
        }
        async _fusionSdkJoin() {
          const A = { channelName: this._channelName, state: "CONNECTING", reason: "OK", timestamp: getUTCTimeBaseREG(this._context.offsetTime) };
          this._emitRtmEvent("status", A), await this._rtcClient.setRTMConfig({ apRTM: true, rtmFlag: 1 }), this._isJoinedChannel = true;
          const e = { channelName: this._channelName, state: "CONNECTED", reason: "OK", timestamp: getUTCTimeBaseREG(this._context.offsetTime) };
          this._emitRtmEvent("status", e), this._handleUserPublishedList(this._rtcClient.remoteUsers);
        }
        async _fusionSdkLeave() {
          const A = { channelName: this._channelName, state: "DISCONNECTING", reason: "LEAVE", timestamp: getUTCTimeBaseREG(this._context.offsetTime) };
          this._emitRtmEvent("status", A), await this._rtcClient.setRTMConfig({ apRTM: true, rtmFlag: 0 }), this._isJoinedChannel = false;
          const e = { channelName: this._channelName, state: "DISCONNECTED", reason: "LEAVE", timestamp: getUTCTimeBaseREG(this._context.offsetTime) };
          this._emitRtmEvent("status", e);
        }
        _validateSessionExist(A) {
          if (void 0 === this._getRTMSession()) {
            const { code: e, reason: t } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_NOT_CONNECTED);
            throw new RtmInvalidStatusError(A, [t], e);
          }
        }
        _handleJoinFailedState(A) {
          if ("string" == typeof A)
            return void this._updateLinkState("FAILED", "JOIN", "JOIN_FAILED", A);
          if (A === RTMErrorCode.RTM_ERROR_CHANNEL_JOIN_CANCELED)
            return;
          let e = LinkStateChangeReasonDescription.JOIN_FAILED, t = "JOIN_FAILED";
          switch (A) {
            case RTMErrorCode.RTM_ERROR_CHANNEL_INSTANCE_EXCEED_LIMITATION:
              e = LinkStateChangeReasonDescription.CHANNEL_INSTANCE_EXCEED_LIMITATION, t = "CHANNEL_INSTANCE_EXCEED_LIMITATION";
              break;
            case RTMErrorCode.RTM_ERROR_OPERATION_RATE_EXCEED_LIMITATION:
              e = LinkStateChangeReasonDescription.OPERATION_RATE_EXCEED_LIMITATION, t = "OPERATION_RATE_EXCEED_LIMITATION";
              break;
            case RTMErrorCode.RTM_ERROR_INVALID_TOKEN:
              e = LinkStateChangeReasonDescription.INVALID_TOKEN, t = "INVALID_TOKEN";
              break;
            case RTMErrorCode.RTM_ERROR_INCONSISTENT_APPID:
              e = LinkStateChangeReasonDescription.INCONSISTENT_APP_ID, t = "INCONSISTENT_APP_ID";
              break;
            case RTMErrorCode.RTM_ERROR_DUPLICATE_OPERATION:
            case RTMErrorCode.RTM_ERROR_NOT_CONNECTED:
            case RTMErrorCode.RTM_ERROR_NOT_CONNECTED:
              e = LinkStateChangeReasonDescription.CHANNEL_IN_ERROR_STATE, t = "CHANNEL_IN_ERROR_STATE";
              break;
            case RTMErrorCode.RTM_ERROR_LOCK_NOT_AVAILABLE:
              e = LinkStateChangeReasonDescription.LOCK_NOT_AVAILABLE, t = "LOCK_NOT_AVAILABLE";
              break;
            case RTMErrorCode.RTM_ERROR_STORAGE_NOT_AVAILABLE:
              e = LinkStateChangeReasonDescription.STORAGE_NOT_AVAILABLE, t = "STORAGE_NOT_AVAILABLE";
              break;
            case RTMErrorCode.RTM_ERROR_CHANNEL_NOT_AVAILABLE:
              e = LinkStateChangeReasonDescription.STREAM_CHANNEL_NOT_AVAILABLE, t = "STREAM_CHANNEL_NOT_AVAILABLE";
          }
          this._updateLinkState("FAILED", "JOIN", t, e);
        }
        async _validCancelJoin(A) {
          if ("IDLE" === this._linkState) {
            this._isReuseRtcClient, await this._rtcClient.leave(), this._context.config.cloudProxy && this._rtcClient.stopProxyServer();
            const { code: e, reason: t } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_JOIN_CANCELED);
            throw new RtmUnavailableError(A, [t], e);
          }
        }
        _validateJoinOptions(A, e) {
          const t = getParameter("STORAGE_CHANNEL_SUB_ENABLED"), g = "true" === (void 0 !== t ? String(t) : this._context.consoleConfig["storage.channel_subscribe_enabled"]);
          if (null != A && A.withMetadata && !g) {
            const { code: A2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_NOT_AVAILABLE);
            throw new RtmUnavailableError(e, [t2], A2);
          }
          const o = getParameter("LOCK_ENABLED"), I = "true" === (void 0 !== o ? String(o) : this._context.consoleConfig["lock.enabled"]);
          if (null != A && A.withLock && !I) {
            const { code: A2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_LOCK_NOT_AVAILABLE);
            throw new RtmUnavailableError(e, [t2], A2);
          }
        }
        _getSidAndElapse4Report() {
          return { sid: this._privatePermitUseMessageChn ? getSid(this._context.instanceId || Long$1.fromNumber(0)) : "", elapse: this._privatePermitUseMessageChn ? getElapse(this._context.startTime) : Long$1.fromNumber(0), opid: getRandomInt(0, Number.MAX_SAFE_INTEGER) };
        }
        _reportTopicUpdate(A, e) {
          const t = JSON.stringify(e), { sid: g, elapse: o } = this._getSidAndElapse4Report();
          this._context.addReportEvents("TopicUpdateEvent", { sid: g, elapse: o, lts: getReportLts(), vid: Long$1.fromValue(this._context.vid || "0"), userId: this._context.uid, channelName: this._channelName, topicEventType: topicEventTypeMap[A], topicInfo: t });
        }
      }
      var _class$5;
      let StreamChannel = (_class$5 = class extends EventBase {
        get _streamChannelImpl() {
          return this.streamChannelImpl;
        }
        constructor(A, e, t, g, o, I, i2, r, n, C) {
          super(e, "StreamChannel", true, true), _defineProperty$1(this, "streamChannelImpl", void 0), this.streamChannelImpl = new StreamChannelImpl(A, e, t, g, o, I, i2, r, n, C);
        }
        async join(A) {
          return this.streamChannelImpl.join(A);
        }
        async renewStreamChannelToken(A) {
          return this.streamChannelImpl.renewStreamChannelToken(A);
        }
        async leave() {
          return this.streamChannelImpl.leave();
        }
        async joinTopic(A, e) {
          return this.streamChannelImpl.joinTopic(A, e);
        }
        async publishTopicMessage(A, e, t) {
          return this.streamChannelImpl.publishTopicMessage(A, e, t);
        }
        async leaveTopic(A) {
          return this.streamChannelImpl.leaveTopic(A);
        }
        async subscribeTopic(A, e) {
          return this.streamChannelImpl.subscribeTopic(A, e);
        }
        async unsubscribeTopic(A, e) {
          return this.streamChannelImpl.unsubscribeTopic(A, e);
        }
        getSubscribedUserList(A) {
          return this.streamChannelImpl.getSubscribedUserList(A);
        }
      }, _applyDecoratedDescriptor(_class$5.prototype, "join", [loggedSensitive], Object.getOwnPropertyDescriptor(_class$5.prototype, "join"), _class$5.prototype), _applyDecoratedDescriptor(_class$5.prototype, "leave", [loggedSensitive], Object.getOwnPropertyDescriptor(_class$5.prototype, "leave"), _class$5.prototype), _applyDecoratedDescriptor(_class$5.prototype, "joinTopic", [loggedSensitive], Object.getOwnPropertyDescriptor(_class$5.prototype, "joinTopic"), _class$5.prototype), _applyDecoratedDescriptor(_class$5.prototype, "publishTopicMessage", [loggedSensitive], Object.getOwnPropertyDescriptor(_class$5.prototype, "publishTopicMessage"), _class$5.prototype), _applyDecoratedDescriptor(_class$5.prototype, "leaveTopic", [loggedSensitive], Object.getOwnPropertyDescriptor(_class$5.prototype, "leaveTopic"), _class$5.prototype), _applyDecoratedDescriptor(_class$5.prototype, "subscribeTopic", [loggedSensitive], Object.getOwnPropertyDescriptor(_class$5.prototype, "subscribeTopic"), _class$5.prototype), _applyDecoratedDescriptor(_class$5.prototype, "unsubscribeTopic", [loggedSensitive], Object.getOwnPropertyDescriptor(_class$5.prototype, "unsubscribeTopic"), _class$5.prototype), _applyDecoratedDescriptor(_class$5.prototype, "getSubscribedUserList", [loggedSensitive], Object.getOwnPropertyDescriptor(_class$5.prototype, "getSubscribedUserList"), _class$5.prototype), _class$5);
      class PresenceImpl extends EventBase {
        constructor(A, e, t, g, o, I) {
          super(A, "PresenceImpl", true), _defineProperty$1(this, "_context", void 0), _defineProperty$1(this, "_getRTMSession", void 0), _defineProperty$1(this, "_getRtmLinkState", void 0), _defineProperty$1(this, "_requestChannelMemberList", void 0), _defineProperty$1(this, "_getBackoffEventsMap", void 0), _defineProperty$1(this, "_apiRateLimit", new ApiRateLimiter()), this._context = e, this._getRTMSession = genGetRTMSession(t), this._getRtmLinkState = g, this._getBackoffEventsMap = o, this._requestChannelMemberList = I;
        }
        async _whoNowUseReg(A) {
          const e = await this._requestChannelMemberList(A), t = { totalOccupancy: null == e ? void 0 : e.totalSize, occupants: [], nextPage: "", timestamp: getUTCTimeBaseREG(this._context.offsetTime) };
          return e.memberInfos.forEach((A2) => {
            var e2;
            t.occupants.push({ userId: null !== (e2 = A2.account) && void 0 !== e2 ? e2 : "", states: {}, statesCount: 0 });
          }), t;
        }
        async _requestWhoNow(A, e, t) {
          const g = this._getRTMSession().getColl(A, true, "requestWhoNow"), o = [];
          if (this.log("".concat(OperationName.whoNow, " by crdt")), g) {
            var I;
            (null !== (I = null == g ? void 0 : g.Docs()) && void 0 !== I ? I : /* @__PURE__ */ new Map()).forEach((A2, e2) => {
              const g2 = A2.Get(), I2 = g2[K_PRESENCE_EXPIRED];
              delete g2[K_PRESENCE_EXPIRED], I2 || o.push({ userId: e2, states: t ? g2 : {}, statesCount: t ? Object.keys(g2).length : 0 });
            });
          }
          return { occupants: e ? o : [], totalOccupancy: o.length, nextPage: "", timestamp: 0 };
        }
        async _requestRpcGetState(A, e) {
          const t = this._getRTMSession(), g = Date.now(), o = this._context.incGetSeq();
          let I = 0;
          try {
            t.validateSyncConnected(OperationName.presenceGetState);
            const g2 = { start: e, end: "", keysOnly: false, countOnly: false, limit: 1 }, [o2] = await timeoutPromise(t.requestRpc(A, g2), COMMON_REQUEST_TIMEOUT, OperationName.presenceGetState, RTMErrorCode.RTM_ERROR_PRESENCE_OPERATION_TIMEOUT);
            let I2 = {};
            return o2.forEach((A2, t2) => {
              if (t2 === e) {
                try {
                  I2 = JSON.parse(A2);
                } catch (A3) {
                  this.logError("parse doc error: %o", A3);
                }
                delete I2[K_PRESENCE_EXPIRED];
              }
            }), I2;
          } catch (A2) {
            const { serverCode: e2, errorCode: t2 } = A2;
            throw I = null != e2 ? e2 : t2, A2;
          } finally {
            this._reportRpcEvent("getState", { requestts: g, reqSeq: o, errCode: I, target: e });
          }
        }
        async _requestRPCWhoNow(A, e, t, g) {
          const o = Date.now(), I = this._context.incGetSeq();
          let i2 = 0;
          try {
            var r;
            const o2 = t && !g, I2 = !t && !g, i3 = Number(getParameter("PRESENCE_THRESHOLD") || (null === (r = this._context.consoleConfig) || void 0 === r ? void 0 : r["presence.occupancy"])) || 0, n = I2;
            I2 && e && this.warn("countOnly and page is not compatible. page of param will be ignored.");
            const C = { start: n ? "" : atob(e), end: "", keysOnly: o2, countOnly: I2, limit: n ? 0 : i3, startIncluded: !e, endIncluded: true, ignoreExpired: true }, [E, s, B] = await timeoutPromise(this._getRTMSession().requestRpc(A, C), COMMON_REQUEST_TIMEOUT, OperationName.whoNow, RTMErrorCode.RTM_ERROR_PRESENCE_OPERATION_TIMEOUT), a = [], Q = { timestamp: 0, occupants: a, nextPage: "", totalOccupancy: s };
            if (I2)
              return Q;
            {
              let A2 = "";
              if (o2)
                E.forEach((e2) => {
                  a.push({ userId: e2, states: {}, statesCount: 0 }), a.length === E.length && B && (A2 = e2);
                });
              else {
                let e2 = 0;
                E.forEach((t2, o3) => {
                  let I3 = {};
                  try {
                    I3 = JSON.parse(t2);
                  } catch (A3) {
                    this.logError("parse doc error: %o", A3);
                  }
                  I3[K_PRESENCE_EXPIRED] ? e2++ : (delete I3[K_PRESENCE_EXPIRED], a.push({ userId: o3, states: g ? I3 : {}, statesCount: Object.keys(I3).length }), a.length === E.size && B && (A2 = o3));
                }), Q.totalOccupancy -= e2;
              }
              if (B) {
                const e2 = btoa(A2);
                Q.nextPage = e2;
              }
              return Q;
            }
          } catch (A2) {
            const { serverCode: e2, errorCode: t2 } = A2;
            throw i2 = null != e2 ? e2 : t2, A2;
          } finally {
            this._reportRpcEvent("whoNow", { requestts: o, reqSeq: I, errCode: i2, target: A });
          }
        }
        async _requestRpcWhereNow(A) {
          const e = this._getRTMSession(), t = Date.now(), g = this._context.incGetSeq();
          let o = 0;
          try {
            e.validateSyncConnected(OperationName.whereNow);
            const t2 = false, g2 = false, o2 = getGlobalPresenceString(this._context.vid) + "/" + A, I = { start: o2, end: "", keysOnly: t2, countOnly: g2, limit: 1 };
            this.log("whereNow query options: %o", I);
            const [i2] = await timeoutPromise(e.requestRpc(K_GLOBAL_PRESENCE_COLLECTION, I), COMMON_REQUEST_TIMEOUT, OperationName.whereNow, RTMErrorCode.RTM_ERROR_PRESENCE_OPERATION_TIMEOUT, true), r = { channels: [], totalChannel: 0, timestamp: 0 };
            return i2.forEach((A2, e2) => {
              if (e2 === o2) {
                let e3 = null;
                try {
                  e3 = JSON.parse(A2), this.log("whereNow doc: %o", e3);
                } catch (A3) {
                  e3 = {}, this.logError("parse doc error: %o", A3);
                }
                const t3 = Object.keys(e3).filter((A3) => A3[0] !== K_SYNC_INTERNAL_KEY_PREFIX);
                this.log("whereNow channels: %o", t3), t3.forEach((A3) => {
                  const { channelName: e4, channelType: t4 } = getChannelDetailByName(A3);
                  r.channels.push({ channelName: e4, channelType: t4 });
                }), r.totalChannel = t3.length;
              }
            }), r;
          } catch (A2) {
            if (A2 instanceof RTMBaseError) {
              const { serverCode: e2, errorCode: t2 } = A2;
              throw o = null != e2 ? e2 : t2, A2;
            }
            {
              const { reason: e2, code: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_PRESENCE_OPERATION_FAILED);
              throw new RtmUnavailableError(OperationName.whereNow, [e2 + String(A2)], t2);
            }
          } finally {
            this._reportRpcEvent("whereNow", { requestts: t, reqSeq: g, errCode: o, target: A });
          }
        }
        _reportRpcEvent(A, e) {
          let { requestts: t, reqSeq: g, errCode: o, target: I } = e;
          this._context.addReportEvents("SyncOperateEvent", { lts: Long$1.fromNumber(Date.now()), ip: "", userid: this._context.uid, vid: Long$1.fromString(getParameter("VID").get(this._context.appId) || "0"), sid: this._context.sid, usersid: this._context.sid, requestts: Long$1.fromNumber(t), replyts: Long$1.fromNumber(Date.now()), target: I, eventtype: A, revision: Long$1.fromNumber(0), uuid: "".concat(g, "_").concat(this._context.instanceId), sdktype: 4, flags: Long$1.fromNumber(0), code: o, seq: g, index: { index1: this._context.uid, index2: this._context.appId, index3: "logUpload=".concat(this._context.config.logUpload) }, lock: "", lockrev: Long$1.fromNumber(0), subtarget: this._context.uid, sdkip: "" });
        }
        async _getOtherStateByRPC(A, e, t) {
          const g = await this._requestRpcGetState(e, A);
          t.states = g, t.statesCount = Object.keys(g).length;
        }
        _getStateByCrdt(A, e, t) {
          var g;
          const o = this._getRTMSession(), I = OperationName.presenceGetState, i2 = o.getDocByUid(e, { funcName: "requestGetState", uid: A });
          if (isNil$1(i2)) {
            const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_PRESENCE_USER_NOT_EXIST);
            throw new RtmUnavailableError(I, [e2], A2);
          }
          const r = null !== (g = null == i2 ? void 0 : i2.Get()) && void 0 !== g ? g : {};
          delete r[K_PRESENCE_EXPIRED], t.statesCount = Object.keys(r).length, t.states = r;
        }
        _getLocalState(A, e, t) {
          const g = {}, o = this._getLocalStateCache().get(A);
          null == o || o.forEach((A2, e2) => {
            g[e2] = A2;
          }), this._logSdkStateInOperateState(e), t.states = g, t.statesCount = Object.keys(g).length;
        }
        async whoNow(A, e, t) {
          var g, o;
          const I = OperationName.whoNow, i2 = getChannelNameByType(A, e);
          if (this._context.enablePrivate && (null === (g = this._context.rtmConfig.privateConfig) || void 0 === g || !g.serviceType.includes("MESSAGE"))) {
            const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_SERVICE_NOT_SUPPORTED);
            throw new RtmUnavailableError(I, e2, A2);
          }
          if (this._getBackoffEventsMap().has(i2) && "MESSAGE" === e) {
            if ("CONNECTED" !== this._getRtmLinkState()) {
              const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_NOT_CONNECTED);
              throw new RtmInvalidStatusError(I, [e2], A2);
            }
            return await this._whoNowUseReg(A);
          }
          this._apiRateLimit.canMakeOperation("whoNow"), validateChannelType(I, e);
          const r = false !== (null == t ? void 0 : t.includedUserId), n = true === (null == t ? void 0 : t.includedState), C = null !== (o = null == t ? void 0 : t.page) && void 0 !== o ? o : "";
          if (this._validateRtmConnection(I), validateKey(A, I, "channel"), false === (null == t ? void 0 : t.includedUserId) && true === (null == t ? void 0 : t.includedState)) {
            const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_PRESENCE_INVALID_ARGUMENT);
            throw new RtmInvalidArgumentError(I, [e2 + "include uid is false but include state is true"], A2);
          }
          const E = this._getRTMSession();
          return this._context.getChannelOptionsByKey(i2, "withPresence") ? null === E.getColl(i2) ? await this._requestRPCWhoNow(i2, C, r, n) : await this._requestWhoNow(i2, r, n) : await this._requestRPCWhoNow(i2, C, r, n);
        }
        async getOnlineUsers(A, e, t) {
          try {
            return await this.whoNow(A, e, t);
          } catch (A2) {
            throw A2 instanceof RTMBaseError && (A2.operation = OperationName.getOnlineUsers), A2;
          }
        }
        async whereNow(A) {
          const e = OperationName.whereNow;
          return this._apiRateLimit.canMakeOperation("whereNow"), this._validateRtmConnection(e), "" === A && (A = this._context.uid), validateKey(A, e, "uid"), await this._requestRpcWhereNow(A);
        }
        async getUserChannels(A) {
          try {
            return await this.whereNow(A);
          } catch (A2) {
            throw A2 instanceof RTMBaseError && (A2.operation = OperationName.getUserChannels), A2;
          }
        }
        async setState(A, e, t) {
          const g = OperationName.presenceSetState;
          this._apiRateLimit.canMakeOperation("modifyState"), validateChannelType(g, e), this._validateRtmConnection(g, false), validateKey(A, g, "channel");
          const o = getChannelNameByType(A, e), I = Object.keys(t).length, { states: i2 } = await this.getState(this._context.uid, A, e, true), r = (/* @__PURE__ */ new Set([...Object.keys(i2), ...Object.keys(t)])).size;
          if (0 === I) {
            const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_PRESENCE_INVALID_ARGUMENT);
            throw new RtmInvalidArgumentError(g, [e2 + "state of parameter is empty"], A2);
          }
          if (I > MAX_STATE_COUNT || r > MAX_STATE_COUNT) {
            const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_PRESENCE_STATE_COUNT_OVERFLOW);
            throw new RtmLimitExceededError(g, [e2], A2);
          }
          if (this._getLocalStateCache().size > K_PRESENCE_MAX_CHANNEL_COUNT) {
            const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_PRESENCE_CACHED_TOO_MANY_STATES);
            throw new RtmLimitExceededError(g, [e2], A2);
          }
          validStateOfPresence(t, g);
          if (this._needOperationByCrdt(o)) {
            const A2 = this._getRTMSession();
            this.log("".concat(g, " by crdt"));
            const e2 = A2.getDocByUid(o, { funcName: "requestSetState" });
            null == e2 || e2.Set(t), A2.sendTick();
          }
          return (this._needOperationByLocal() || this._context.getChannelOptionsByKey(o, "beQuiet") || this._context.notInChannel(o)) && this._logSdkStateInOperateState(g), this._updatePresenceStateCache(o, g, t), { timestamp: 0 };
        }
        async getState(A, e, t) {
          let g = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
          const o = OperationName.presenceGetState;
          if (g || this._apiRateLimit.canMakeOperation("getState"), validateChannelType(o, t), this._context.uid !== A && "FAILED" === this._getRtmLinkState()) {
            const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_NOT_CONNECTED);
            throw new RtmInvalidStatusError(o, [e2], A2);
          }
          this._validateRtmConnection(o, this._context.uid !== A), validateKey(e, o, "channel"), validateKey(A, o, "uid");
          const I = getChannelNameByType(e, t), i2 = { statesCount: 0, states: {}, userId: A, timestamp: 0 };
          return this._context.notInChannel(I) ? A === this._context.uid ? (this.log("not in channel, get self state by local cache"), this._getLocalState(I, o, i2)) : (this.log("not in channel, get other state by rpc api."), await this._getOtherStateByRPC(A, I, i2)) : this._context.isInChannel(I) && (A !== this._context.uid ? this._context.getChannelOptionsByKey(I, "withPresence") ? (this.log("in channel with presence, get other state by crdt"), this._getRTMSession().validateSyncConnected(OperationName.presenceGetState), this._getStateByCrdt(A, I, i2)) : (this.log("in channel without presence, get other state by rpc api."), await this._getOtherStateByRPC(A, I, i2)) : this._needOperationByCrdt(I) ? (this.log("in channel, has doc, get self state by crdt"), this._getStateByCrdt(this._context.uid, I, i2)) : A === this._context.uid && (this.log("in channel, get self state by local cache"), this._getLocalState(I, o, i2))), i2;
        }
        async removeState(A, e, t) {
          var g, o, I, i2, r, n, C;
          const E = OperationName.presenceRemoveState;
          this._apiRateLimit.canMakeOperation("modifyState"), validateChannelType(E, e), this._validateRtmConnection(E, false), validateKey(A, E, "channel");
          const s = !(null != t && null !== (g = t.states) && void 0 !== g && g.length);
          if (!s && null != t && null !== (o = t.states) && void 0 !== o && o.length && new Set(t.states).size !== (null === (I = t.states) || void 0 === I ? void 0 : I.length)) {
            const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_PRESENCE_STATE_DUPLICATE_KEY);
            throw new RtmInvalidArgumentError(E, [e2], A2);
          }
          if ((null !== (i2 = null == t || null === (r = t.states) || void 0 === r ? void 0 : r.length) && void 0 !== i2 ? i2 : 0) > MAX_STATE_COUNT) {
            const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_PRESENCE_STATE_COUNT_OVERFLOW);
            throw new RtmLimitExceededError(E, [e2], A2);
          }
          null == t || null === (n = t.states) || void 0 === n || n.forEach((A2) => {
            validStateKeyOfPresence(A2, E);
          });
          const B = getChannelNameByType(A, e), a = {};
          if (null == t || null === (C = t.states) || void 0 === C || C.forEach((A2) => {
            a[A2] = "";
          }), this._needOperationByCrdt(B)) {
            var Q;
            this.log("".concat(E, " by crdt. isClear: ").concat(s));
            const A2 = this._getRTMSession(), e2 = A2.getDocByUid(B, { funcName: "requestRemoveState" }), t2 = null !== (Q = null == e2 ? void 0 : e2.Get()) && void 0 !== Q ? Q : {};
            null == e2 || e2.Del(Object.keys(s ? t2 : a)), A2.sendTick();
          }
          return (this._needOperationByLocal() || this._context.getChannelOptionsByKey(B, "beQuiet") || this._context.notInChannel(B)) && this._logSdkStateInOperateState(E), this._updatePresenceStateCache(B, E, a), { timestamp: 0 };
        }
        _validateRtmConnection(A) {
          var e;
          let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          if (this._context.enablePrivate && (null === (e = this._context.rtmConfig.privateConfig) || void 0 === e || !e.serviceType.includes("MESSAGE"))) {
            const { code: e2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_SERVICE_NOT_SUPPORTED);
            throw new RtmUnavailableError(A, t2, e2);
          }
          const g = this._getRtmLinkState();
          if ("IDLE" === g || t && "CONNECTED" !== g) {
            this.log("The client state is ".concat(g, ", cannot do the operation(").concat(A, ")"));
            const { code: e2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_NOT_CONNECTED);
            throw new RtmInvalidStatusError(A, [t2], e2);
          }
          t && this._getRTMSession().validateSyncConnected(A);
        }
        _needOperationByLocal() {
          var A;
          const e = this._getRtmLinkState();
          return "IDLE" !== e && "CONNECTED" !== e || (!!this._noRTMSession() || !(null !== (A = this._getRTMSession()) && void 0 !== A && A.getSyncConnected() || !getParameter("DECOUPLE_SYNC")));
        }
        _needOperationByCrdt(A) {
          let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._context.uid;
          return !this._noRTMSession() && !!this._getRTMSession().getDocByUid(A, { funcName: "needOperationByCrdt", uid: e });
        }
        _getLocalStateCache() {
          return this._context.localStateCache;
        }
        _updatePresenceStateCache(A, e, t) {
          var g;
          const o = null !== (g = this._getLocalStateCache().get(A)) && void 0 !== g ? g : /* @__PURE__ */ new Map();
          if (e === OperationName.presenceSetState)
            for (const A2 in t)
              o.set(A2, t[A2]);
          else if (e === OperationName.presenceRemoveState)
            if (0 === Object.keys(t).length)
              o.clear();
            else
              for (const A2 in t)
                o.delete(A2);
          this._getLocalStateCache().set(A, o);
        }
        _noRTMSession() {
          try {
            this._getRTMSession();
          } catch (A) {
            const { errorCode: e } = A;
            if (e === RTMErrorCode.RTM_ERROR_NOT_CONNECTED)
              return true;
          }
          return false;
        }
        _logSdkStateInOperateState(A) {
          var e;
          const t = !this._noRTMSession() && (null === (e = this._getRTMSession()) || void 0 === e ? void 0 : e.getSyncConnected());
          this.log("reconnecting, quiet or not in channel, ".concat(A, " by local cache. decouple: ").concat(getParameter("DECOUPLE_SYNC"), ", syncConnected: ").concat(t));
        }
      }
      var _class$4;
      let Presence = (_class$4 = class extends EventBase {
        constructor(A, e, t, g, o, I) {
          super(A, "Presence", true, true), _defineProperty$1(this, "presenceImpl", void 0), this.presenceImpl = new PresenceImpl(A, e, t, g, o, I);
        }
        async whoNow(A, e, t) {
          return await this.presenceImpl.whoNow(A, e, t);
        }
        async getOnlineUsers(A, e, t) {
          return await this.presenceImpl.getOnlineUsers(A, e, t);
        }
        async whereNow(A) {
          return await this.presenceImpl.whereNow(A);
        }
        async getUserChannels(A) {
          return await this.presenceImpl.getUserChannels(A);
        }
        async setState(A, e, t) {
          return await this.presenceImpl.setState(A, e, t);
        }
        async getState(A, e, t) {
          return await this.presenceImpl.getState(A, e, t);
        }
        async removeState(A, e, t) {
          return await this.presenceImpl.removeState(A, e, t);
        }
      }, _applyDecoratedDescriptor(_class$4.prototype, "whoNow", [loggedSensitive], Object.getOwnPropertyDescriptor(_class$4.prototype, "whoNow"), _class$4.prototype), _applyDecoratedDescriptor(_class$4.prototype, "getOnlineUsers", [loggedSensitive], Object.getOwnPropertyDescriptor(_class$4.prototype, "getOnlineUsers"), _class$4.prototype), _applyDecoratedDescriptor(_class$4.prototype, "whereNow", [loggedSensitive], Object.getOwnPropertyDescriptor(_class$4.prototype, "whereNow"), _class$4.prototype), _applyDecoratedDescriptor(_class$4.prototype, "getUserChannels", [loggedSensitive], Object.getOwnPropertyDescriptor(_class$4.prototype, "getUserChannels"), _class$4.prototype), _applyDecoratedDescriptor(_class$4.prototype, "setState", [loggedSensitive], Object.getOwnPropertyDescriptor(_class$4.prototype, "setState"), _class$4.prototype), _applyDecoratedDescriptor(_class$4.prototype, "getState", [loggedSensitive], Object.getOwnPropertyDescriptor(_class$4.prototype, "getState"), _class$4.prototype), _applyDecoratedDescriptor(_class$4.prototype, "removeState", [loggedSensitive], Object.getOwnPropertyDescriptor(_class$4.prototype, "removeState"), _class$4.prototype), _class$4);
      class LockImpl extends EventBase {
        get localAcquiredLocks() {
          return this._localAcquiredLocks;
        }
        constructor(A, e, t, g) {
          super(A, "LockImpl", true), _defineProperty$1(this, "_context", void 0), _defineProperty$1(this, "_getRTMSession", void 0), _defineProperty$1(this, "_validateRtmConnection", void 0), _defineProperty$1(this, "_setOperationNoRes", /* @__PURE__ */ new Set()), _defineProperty$1(this, "_removeOperationNoRes", /* @__PURE__ */ new Set()), _defineProperty$1(this, "_releaseOperationNoRes", /* @__PURE__ */ new Set()), _defineProperty$1(this, "_revokeOperationNoRes", /* @__PURE__ */ new Set()), _defineProperty$1(this, "_acquireOperationNoRes", /* @__PURE__ */ new Map()), _defineProperty$1(this, "_notifyAcquireRetryReject", new Subject()), _defineProperty$1(this, "_apiRateLimit", new ApiRateLimiter()), _defineProperty$1(this, "_localAcquiredLocks", /* @__PURE__ */ new Map()), _defineProperty$1(this, "_notifyLockReAcquire", new Subject()), _defineProperty$1(this, "_lockSubscriptions", { lockAcquires: /* @__PURE__ */ new Map() }), this._context = e, this._context.internalEmitter.on("StateLockUpdate", (A2) => {
            this._onLockUpdate(A2);
          }), this._getRTMSession = genGetRTMSession(t), this._validateRtmConnection = g;
        }
        hasLock() {
          let A = false;
          return this._localAcquiredLocks.size > 0 && this._localAcquiredLocks.forEach((e) => {
            e.size > 0 && (A = true);
          }), this._acquireOperationNoRes.size > 0 && (A = true), A;
        }
        releaseLockModel() {
          this._clearLocalAcquiredLocks(), this._clearLockOperationsWithRetry();
        }
        notifyLockReAcquire(A) {
          this._notifyLockReAcquire.next({ env: A, allReAcquire: true });
        }
        async setLock(A, e, t, g) {
          const o = OperationName.setLock;
          this._apiRateLimit.canMakeOperation("setLock"), validateChannelType(o, e), this._validateRtmConnection(o), this._validateEnableLock(o);
          const I = { timestamp: 0, channelName: A, channelType: e, lockName: t };
          this._validateChannelAndLock(A, t, o), void 0 !== (null == g ? void 0 : g.ttl) && (g.ttl < getParameter("LOCK_TTL") ? g.ttl = getParameter("LOCK_TTL") : g.ttl > MAX_LOCK_TTL && (g.ttl = MAX_LOCK_TTL));
          const i2 = getChannelNameByType(A, e), r = getPrefixLockName(t);
          this._setOperationNoRes.has("".concat(i2).concat(r)) && this._throwInvalidOperationError(o), this._setOperationNoRes.add("".concat(i2).concat(r));
          try {
            var n;
            const A2 = this._requestSetLock(i2, t, { ttl: null !== (n = null == g ? void 0 : g.ttl) && void 0 !== n ? n : getParameter("LOCK_TTL") });
            await A2.toPromise();
          } catch (A2) {
            if (isRtmError(A2)) {
              if (this.logError(A2), isNoLogged(A2))
                throw A2;
              if (isTimeout(A2)) {
                const { code: A3, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_LOCK_OPERATION_TIMEOUT);
                throw new RtmUnavailableError(o, [e2], A3);
              }
              if (null != A2.code) {
                const { code: e2, reason: t2 } = getErrorInfoByCode(A2.code);
                throw new RtmUnavailableError(o, [t2], e2);
              }
              this.logError("error code is undefined, %o", A2);
            } else
              this.logError("not rtm error, %o", A2);
          } finally {
            this._setOperationNoRes.delete("".concat(i2).concat(r));
          }
          return I;
        }
        async removeLock(A, e, t) {
          const g = OperationName.removeLock;
          this._apiRateLimit.canMakeOperation("removeLock"), validateChannelType(g, e), this._validateRtmConnection(g), this._validateEnableLock(g);
          const o = { timestamp: 0, channelName: A, channelType: e, lockName: t };
          this._validateChannelAndLock(A, t, g);
          const I = getChannelNameByType(A, e), i2 = getPrefixLockName(t);
          this._removeOperationNoRes.has("".concat(I).concat(i2)) && this._throwInvalidOperationError(g), this._removeOperationNoRes.add("".concat(I).concat(i2));
          try {
            const A2 = this._requestRemoveLock(I, t);
            await A2.toPromise();
          } catch (A2) {
            if (isRtmError(A2)) {
              if (this.logError(A2), isNoLogged(A2))
                throw A2;
              if (isTimeout(A2)) {
                const { code: A3, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_LOCK_OPERATION_TIMEOUT);
                throw new RtmUnavailableError(g, [e2], A3);
              }
              if (null != A2.code) {
                const { code: e2, reason: t2 } = getErrorInfoByCode(A2.code);
                throw new RtmUnavailableError(g, [t2], e2);
              }
              this.logError("error code is undefined, %o", A2);
            } else
              this.logError("not rtm error, %o", A2);
          } finally {
            this._removeOperationNoRes.delete("".concat(I).concat(i2));
          }
          return o;
        }
        async acquireLock(A, e, t, g) {
          var o, I;
          const i2 = OperationName.acquireLock;
          this._apiRateLimit.canMakeOperation("acquireLock"), validateChannelType(i2, e), this._validateRtmConnection(i2), this._validateEnableLock(i2), this._validateChannelAndLock(A, t, i2);
          const r = getChannelNameByType(A, e), n = getPrefixLockName(t);
          if (null === (o = this._localAcquiredLocks.get(r)) || void 0 === o ? void 0 : o.get(t)) {
            const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_LOCK_OPERATION_PERFORMING);
            throw new RtmUnavailableError(i2, [e2], A2);
          }
          let C, E;
          this._acquireOperationNoRes.has("".concat(r).concat(n)) && this._throwInvalidOperationError(i2);
          const s = new Promise((A2, e2) => {
            C = e2, E = A2;
          });
          this._acquireOperationNoRes.set("".concat(r).concat(n), { retry: null !== (I = null == g ? void 0 : g.retry) && void 0 !== I && I, reqSeq: void 0, resolve: E, reject: C });
          try {
            await this._requestAcquireLock(r, t, { retry: null == g ? void 0 : g.retry, reject: C, resolve: E }), E({ lockName: t, channelName: A, channelType: e, timestamp: 0 });
          } catch (A2) {
            if (this.logError(A2), isRtmError(A2))
              throw A2;
            this.logError("acquireLock not match rtm error, %o", A2);
          } finally {
            this._acquireOperationNoRes.delete("".concat(r).concat(n));
          }
          return s;
        }
        async releaseLock(A, e, t) {
          var g, o;
          const I = OperationName.releaseLock;
          this._apiRateLimit.canMakeOperation("releaseLock"), validateChannelType(I, e), this._validateRtmConnection(I), this._validateEnableLock(I);
          const i2 = { timestamp: 0, channelName: A, channelType: e, lockName: t };
          this._validateChannelAndLock(A, t, I);
          const r = getChannelNameByType(A, e), n = getPrefixLockName(t);
          if (!(null !== (g = this._acquireOperationNoRes.get("".concat(r).concat(n))) && void 0 !== g && g.retry || null !== (o = this._localAcquiredLocks.get(r)) && void 0 !== o && o.get(t))) {
            const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_LOCK_NOT_ACQUIRED);
            throw new RtmUnavailableError(I, [e2], A2);
          }
          this._releaseOperationNoRes.has("".concat(r).concat(n)) && this._throwInvalidOperationError(I), this._releaseOperationNoRes.add("".concat(r).concat(n));
          try {
            const A2 = this._requestReleaseLock(r, t);
            await A2.toPromise();
          } catch (A2) {
            if (isRtmError(A2)) {
              if (this.logError(A2), isNoLogged(A2))
                throw A2;
              if (isTimeout(A2)) {
                const { code: A3, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_LOCK_OPERATION_TIMEOUT);
                throw new RtmUnavailableError(I, [e2], A3);
              }
              if (null != A2.code) {
                const { code: e2, reason: t2 } = getErrorInfoByCode(A2.code);
                throw new RtmUnavailableError(I, [t2], e2);
              }
              this.logError("error code is undefined, %o", A2);
            } else
              this.logError("not rtm error, %o", A2);
          } finally {
            this._releaseOperationNoRes.delete("".concat(r).concat(n));
          }
          return i2;
        }
        async revokeLock(A, e, t, g) {
          const o = OperationName.revokeLock;
          this._apiRateLimit.canMakeOperation("revokeLock"), validateChannelType(o, e), this._validateRtmConnection(o), this._validateEnableLock(o);
          const I = { timestamp: 0, channelName: A, channelType: e, lockName: t };
          this._validateChannelAndLock(A, t, o), validateKey(g, o, "uid");
          const i2 = getChannelNameByType(A, e), r = getPrefixLockName(t);
          this._revokeOperationNoRes.has("".concat(i2).concat(r)) && this._throwInvalidOperationError(o), this._revokeOperationNoRes.add("".concat(i2).concat(r));
          try {
            const A2 = this._requestRevokeLock(i2, t, g);
            await A2.toPromise();
          } catch (A2) {
            if (isRtmError(A2)) {
              if (this.logError(A2), isNoLogged(A2))
                throw A2;
              if (isTimeout(A2)) {
                const { code: A3, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_LOCK_OPERATION_TIMEOUT);
                throw new RtmUnavailableError(o, [e2], A3);
              }
              if (null != A2.code) {
                const { code: e2, reason: t2 } = getErrorInfoByCode(A2.code);
                throw new RtmUnavailableError(o, [t2], e2);
              }
              this.logError("error code is undefined, %o", A2);
            } else
              this.logError("not rtm error, %o", A2);
          } finally {
            this._revokeOperationNoRes.delete("".concat(i2).concat(r));
          }
          return I;
        }
        async getLock(A, e) {
          const t = OperationName.getLock;
          this._apiRateLimit.canMakeOperation("getLock"), validateChannelType(t, e), this._validateRtmConnection(t), this._validateEnableLock(t);
          const g = { timestamp: 0, totalLocks: 0, lockDetails: [], channelName: A, channelType: e };
          validateKey(A, t, "channel");
          const o = getChannelNameByType(A, e);
          try {
            const A2 = this._requestGetLock(o), e2 = await A2.toPromise();
            g.totalLocks = e2.length, g.lockDetails = e2.map((A3) => {
              var e3, t2, g2, o2;
              let I = null;
              try {
                (null == A3 ? void 0 : A3.lockState) && (I = JSON.parse(A3.lockState));
              } catch (A4) {
                this.logError("parse lockState error, %o", A4);
              }
              return { lockName: null !== (e3 = A3.lockName) && void 0 !== e3 ? e3 : "", ttl: null === (t2 = I) || void 0 === t2 ? void 0 : t2.create_ttl, owner: null !== (g2 = null === (o2 = I) || void 0 === o2 ? void 0 : o2.user) && void 0 !== g2 ? g2 : "" };
            });
          } catch (A2) {
            if (isRtmError(A2)) {
              if (this.logError(A2), isNoLogged(A2))
                throw A2;
              if (isTimeout(A2)) {
                const { code: A3, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_LOCK_OPERATION_TIMEOUT);
                throw new RtmUnavailableError(t, [e2], A3);
              }
              if (null != A2.code) {
                const { code: e2, reason: g2 } = getErrorInfoByCode(A2.code);
                throw new RtmUnavailableError(t, [g2], e2);
              }
              this.logError("error code is undefined, %o", A2);
            } else
              this.logError("not rtm error, %o", A2);
          }
          return g;
        }
        async _requestAcquireLock(A, e, t) {
          const g = OperationName.acquireLock, o = getPrefixLockName(e), I = null == t ? void 0 : t.resolve, i2 = null == t ? void 0 : t.reject, r = this._context.incGetSeq(), n = Long$1.fromNumber(Date.now());
          this._context.addReportEvents("SyncLockAcquireEvent", { code: 0, target: A, lock: e, ttl: Long$1.fromNumber(0), flags: new Long$1(1048577, 0, true), uuid: "", lts: Long$1.fromNumber(Date.now()), vid: Long$1.fromString(this._context.vid || "0"), ip: "", userid: this._context.uid, sid: this._context.sid, lockrev: Long$1.fromNumber(0), leaseid: this._context.uid, eventtype: "Acquire", sdktype: 4, requestts: n, replyts: Long$1.fromNumber(Date.now()), usersid: this._context.sid, sdkip: "" });
          const C = fromEvent(this, "lockReleasedOrExpired").pipe(filter((e2) => e2 === "".concat(A).concat(o)), take(1)), E = this._notifyLockReAcquire.pipe(filter((e2) => (null == e2 ? void 0 : e2.prefixChannelLockName) === "".concat(A).concat(o) || true === (null == e2 ? void 0 : e2.allReAcquire)), switchMap((C2) => {
            var E2, s2;
            const B2 = !(null === (E2 = this._localAcquiredLocks.get(A)) || void 0 === E2 ? void 0 : E2.has(e)) && (null == t ? void 0 : t.retry), a = r;
            this._sendLockPacket(g, "StateLockAcquire", { target: A, requestUuid: "".concat(a, "_").concat(this._context.instanceId), lock: e, ttl: new Long$1(0, 0, true), flags: new Long$1(B2 ? 1310721 : 1048577, 0, true) }, C2.env), I && i2 && this._acquireOperationNoRes.set("".concat(A).concat(o), { retry: null !== (s2 = null == t ? void 0 : t.retry) && void 0 !== s2 && s2, reqSeq: a, resolve: I, reject: i2 });
            const Q = (t2) => {
              let { code: o2, target: I2, lock: i3, lockRev: r2, reason: n2 } = t2;
              const { code: C3, reason: E3 } = convertLockServerCodeToSdkCode(o2);
              if (C3 !== RTMErrorCode.RTM_ERROR_OK) {
                throw new RtmUnavailableError(g, [E3], C3);
              }
              return this._updateLocalAcquiredLocks(A, e, "add", r2.toNumber()), { target: I2, lock: i3, lockRev: r2, reason: n2, code: o2 };
            }, c = (t2) => {
              var g2;
              let { lock: o2, code: I2, target: i3, lockRev: r2, eventReportInfo: C3 } = t2;
              this.log("acquire lock with lock(".concat(e, "), channel: ").concat(replaceRangeWithAsterisk(A), ", retry: ").concat(B2, ", serverCode is ").concat(I2));
              const { code: E3 } = convertLockServerCodeToSdkCode(I2);
              this._context.addReportEvents("SyncLockAcquireEvent", { code: E3, target: i3, lock: e, ttl: Long$1.fromNumber(0), flags: new Long$1(B2 ? 1310721 : 1048577, 0, true), uuid: "", lts: Long$1.fromNumber(Date.now()), vid: Long$1.fromString(this._context.vid || "0"), ip: null !== (g2 = null == C3 ? void 0 : C3.ip) && void 0 !== g2 ? g2 : "", userid: this._context.uid, sid: this._context.sid, lockrev: r2, leaseid: this._context.uid, eventtype: "AcquireResult", sdktype: 4, requestts: n, replyts: Long$1.fromNumber(Date.now()), usersid: this._context.sid, sdkip: "" }), E3 !== RTMErrorCode.RTM_ERROR_OK || o2 === e && i3 === A || (this.log("RTM service Error: acquired unexpected lock on channel '%s', lock '%s', member '%s'", replaceRangeWithAsterisk(A), replaceRangeWithAsterisk(o2), replaceRangeWithAsterisk(this._context.uid || "")), this._requestReleaseLock(i3, o2).toPromise()), this._clearReAcquireEffect(A, e, { lockRev: r2, code: I2 });
            };
            return B2 ? this._onOperationPacket("StateLockAcquireResult").pipe(first((A2) => {
              let { requestUuid: e2 } = A2;
              return "".concat(a, "_").concat(this._context.instanceId) === e2;
            }), tap(() => {
              this._acquireOperationNoRes.delete("".concat(A).concat(o));
            }), tap(c), map$1(Q), takeUntil(this._notifyAcquireRetryReject.pipe(filter((e2) => e2 === "".concat(A).concat(o))))) : race(genTimeoutError(RTMErrorCode.RTM_ERROR_LOCK_OPERATION_TIMEOUT), this._onOperationPacket("StateLockAcquireResult").pipe(first((A2) => {
              let { requestUuid: e2 } = A2;
              return "".concat(a, "_").concat(this._context.instanceId) === e2;
            }), tap(() => {
              this._acquireOperationNoRes.delete("".concat(A).concat(o));
            }), tap(c), map$1(Q)));
          }), takeUntil(C), share()), s = () => {
            this._lockSubscriptions.lockAcquires.delete(A);
          };
          this._lockSubscriptions.lockAcquires.set(A, E.subscribe({ error: s, complete: s })), this._notifyLockReAcquire.next({ env: void 0, prefixChannelLockName: "".concat(A).concat(o) });
          const B = await E.pipe(take(1), catchError((A2) => (A2 instanceof TimeoutError && this.warn("acquire channel lock timeout"), throwError(A2)))).toPromise();
          return B;
        }
        _requestSetLock(A, e, t) {
          var g;
          const o = OperationName.setLock, I = this._context.incGetSeq();
          return this._sendLockPacket(o, "StateLockCreate", { target: A, requestUuid: "".concat(I, "_").concat(this._context.instanceId), lock: e, ttl: Long$1.fromNumber(null !== (g = null == t ? void 0 : t.ttl) && void 0 !== g ? g : getParameter("LOCK_TTL")), flags: new Long$1(1048577, 0, true) }), race(genTimeoutError(RTMErrorCode.RTM_ERROR_LOCK_OPERATION_TIMEOUT), this._onOperationPacket("StateLockCreateResult").pipe(first((A2) => {
            let { requestUuid: e2 } = A2;
            return "".concat(I, "_").concat(this._context.instanceId) === e2;
          }), map$1((A2) => {
            let { code: e2 } = A2;
            const { code: t2, reason: g2 } = convertLockServerCodeToSdkCode(e2);
            if (t2 !== RTMErrorCode.RTM_ERROR_OK)
              throw new RtmUnavailableError(o, [g2], t2);
          })));
        }
        _clearReAcquireEffect(A, e, t) {
          var g;
          const { lockRev: o, code: I } = t, i2 = null === (g = this._localAcquiredLocks.get(A)) || void 0 === g ? void 0 : g.get(e);
          if (i2 && i2.revision !== o.toNumber()) {
            this.log("newRev: ".concat(o, ", rev: ").concat(null == i2 ? void 0 : i2.revision, ", code: ").concat(I, " for reacquire."));
            const { channelName: t2, channelType: g2 } = getChannelDetailByName(A), r = { channelType: g2, channelName: t2, eventType: "EXPIRED", lockName: e, ttl: 0, publisher: "", snapshot: [], owner: "", timestamp: getUTCTimeBaseREG(this._context.offsetTime) };
            this._emitLockExpired(r), this._requestReleaseLock(A, e).toPromise();
          }
        }
        _requestReleaseLock(A, e) {
          const t = OperationName.releaseLock, g = this._context.incGetSeq(), o = Long$1.fromNumber(Date.now());
          return this._context.addReportEvents("SyncLockReleaseEvent", { code: 0, target: A, lock: e, flags: new Long$1(1048577, 0, true), uuid: "", lts: Long$1.fromNumber(Date.now()), vid: Long$1.fromString(this._context.vid || "0"), ip: "", userid: this._context.uid, sid: this._context.sid, leaseid: this._context.uid, eventtype: "Release", sdktype: 4, requestts: o, replyts: Long$1.fromNumber(Date.now()), usersid: this._context.sid, sdkip: "" }), this._sendLockPacket(t, "StateLockRelease", { target: A, requestUuid: "".concat(g, "_").concat(this._context.instanceId), lock: e, flags: new Long$1(1048577, 0, true) }), race(genTimeoutError(RTMErrorCode.RTM_ERROR_LOCK_OPERATION_TIMEOUT), this._onOperationPacket("StateLockReleaseResult").pipe(first((A2) => {
            let { requestUuid: e2 } = A2;
            return "".concat(g, "_").concat(this._context.instanceId) === e2;
          }), map$1((g2) => {
            let { code: I } = g2;
            const { code: i2, reason: r } = convertLockServerCodeToSdkCode(I);
            if (this._context.addReportEvents("SyncLockReleaseEvent", { code: i2, target: A, lock: e, flags: new Long$1(1048577, 0, true), uuid: "", lts: Long$1.fromNumber(Date.now()), vid: Long$1.fromString(this._context.vid || "0"), ip: "", userid: this._context.uid, sid: this._context.sid, leaseid: this._context.uid, eventtype: "ReleaseResult", sdktype: 4, requestts: o, replyts: Long$1.fromNumber(Date.now()), usersid: this._context.sid, sdkip: "" }), i2 !== RTMErrorCode.RTM_ERROR_OK)
              throw new RtmUnavailableError(t, [r], i2);
            {
              const t2 = { channelName: A, lockName: e };
              this._updateLocalAcquiredLocks(A, e, "delete"), this.emit("lockReleasedOrExpired", "".concat(t2.channelName).concat(getPrefixLockName(t2.lockName)));
            }
          })));
        }
        _requestRemoveLock(A, e) {
          const t = OperationName.removeLock, g = this._context.incGetSeq();
          return this._sendLockPacket(t, "StateLockDelete", { target: A, lock: e, requestUuid: "".concat(g, "_").concat(this._context.instanceId), flags: new Long$1(1048577, 0, true) }), race(genTimeoutError(RTMErrorCode.RTM_ERROR_LOCK_OPERATION_TIMEOUT), this._onOperationPacket("StateLockDeleteResult").pipe(first((A2) => {
            let { requestUuid: e2 } = A2;
            return "".concat(g, "_").concat(this._context.instanceId) === e2;
          }), map$1((A2) => {
            let { code: e2 } = A2;
            const { code: g2, reason: o } = convertLockServerCodeToSdkCode(e2);
            if (g2 !== RTMErrorCode.RTM_ERROR_OK)
              throw new RtmUnavailableError(t, [o], g2);
          })));
        }
        _requestRevokeLock(A, e, t) {
          const g = OperationName.revokeLock, o = this._context.incGetSeq(), I = Long$1.fromNumber(Date.now());
          return this._context.addReportEvents("SyncLockDisableEvent", { code: 0, target: A, lock: e, flags: new Long$1(1048577, 0, true), uuid: "", lts: Long$1.fromNumber(Date.now()), vid: Long$1.fromString(this._context.vid || "0"), ip: "", userid: this._context.uid, sid: this._context.sid, leaseid: t, eventtype: "Disable", sdktype: 4, requestts: I, replyts: Long$1.fromNumber(Date.now()), usersid: this._context.sid, sdkip: "" }), this._sendLockPacket(g, "StateLockDisable", { target: A, requestUuid: "".concat(o, "_").concat(this._context.instanceId), lock: e, userId: t, flags: new Long$1(1048577, 0, true) }), race(genTimeoutError(RTMErrorCode.RTM_ERROR_LOCK_OPERATION_TIMEOUT), this._onOperationPacket("StateLockDisableResult").pipe(first((A2) => {
            let { requestUuid: e2 } = A2;
            return "".concat(o, "_").concat(this._context.instanceId) === e2;
          }), map$1((o2) => {
            let { code: i2 } = o2;
            const { code: r, reason: n } = convertLockServerCodeToSdkCode(i2);
            if (this._context.addReportEvents("SyncLockDisableEvent", { code: r, target: A, lock: e, flags: new Long$1(1048577, 0, true), uuid: "", lts: Long$1.fromNumber(Date.now()), vid: Long$1.fromString(this._context.vid || "0"), ip: "", userid: this._context.uid, sid: this._context.sid, leaseid: t, eventtype: "DisableResult", sdktype: 4, requestts: I, replyts: Long$1.fromNumber(Date.now()), usersid: this._context.sid, sdkip: "" }), r !== RTMErrorCode.RTM_ERROR_OK)
              throw new RtmUnavailableError(g, [n], r);
          })));
        }
        _requestGetLock(A) {
          const e = OperationName.getLock, t = this._context.incGetSeq();
          return this._sendLockPacket(e, "StateLockList", { target: A, sequence: t, flags: new Long$1(1048577, 0, true) }), race(genTimeoutError(RTMErrorCode.RTM_ERROR_LOCK_OPERATION_TIMEOUT), this._onOperationPacket("StateLockListResult").pipe(first((A2) => {
            let { sequence: e2 } = A2;
            return t.eq(e2);
          }), map$1((A2) => {
            let { code: t2, lockStates: g } = A2;
            const { code: o, reason: I } = convertLockServerCodeToSdkCode(t2);
            if (o !== RTMErrorCode.RTM_ERROR_OK)
              throw new RtmUnavailableError(e, [I], o);
            return g;
          })));
        }
        _validateChannelAndLock(A, e, t) {
          validateKey(A, t, "channel"), validateKey(e, t, "lock-name");
        }
        _throwInvalidOperationError(A) {
          const { code: e, reason: t } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_LOCK_OPERATION_PERFORMING);
          throw new RtmUnavailableError(A, [t], e);
        }
        _sendLockPacket(A, e, t, g) {
          void 0 !== g ? this._sendLockPacketUseOneEnv(A, g, e, t) : this._getRTMSession().sendOperationPacket(A, e, t);
        }
        _sendLockPacketUseOneEnv(A, e, t, g) {
          this._getRTMSession().sendOperationPacketUseOneEnv(A, e, t, g);
        }
        _onOperationPacket(A) {
          return this._getRTMSession().onOperationPacket(A);
        }
        _onLockUpdate(A) {
          const { target: e, flags: t, code: g, lock: o } = A, { channelName: I, channelType: i2 } = getChannelDetailByName(e);
          if (this._context.addReportEvents("SyncLockUpdateEvent", { vid: Long$1.fromValue(this._context.vid || "0"), code: g, sid: this._context.sid, lts: Long$1.fromNumber(Date.now()), userid: this._context.uid, replyts: Long$1.fromNumber(Date.now()), target: e, eventtype: g === SyncServerErrorCode.kLockWatching ? "Watch" : "Expire", sdktype: 4, flags: t, lock: o, usersid: this._context.sid, ip: "", sdkip: "" }), g === SyncServerErrorCode.kLockWatching)
            this._onLockWatching({ prefixChannelName: e, lockName: o });
          else if (g === SyncServerErrorCode.kLockExpired) {
            const A2 = { channelType: i2, channelName: I, eventType: "EXPIRED", lockName: o, ttl: 0, publisher: "", snapshot: [], owner: "", timestamp: getUTCTimeBaseREG(this._context.offsetTime) };
            this._emitLockExpired(A2);
          }
        }
        _onLockWatching(A) {
          const { prefixChannelName: e, lockName: t } = A;
          this.info("lock is watching: ".concat(e).concat(getPrefixLockName(t)));
        }
        _emitLockExpired(A) {
          var e;
          const t = getChannelNameByType(A.channelName, A.channelType);
          null !== (e = this._localAcquiredLocks.get(t)) && void 0 !== e && e.get(A.lockName) && (this._context.internalEmitter.emit("lock", _objectSpread2(_objectSpread2({}, A), {}, { ttl: 0 })), this.emit("lockReleasedOrExpired", "".concat(t).concat(getPrefixLockName(A.lockName))), this._updateLocalAcquiredLocks(t, null == A ? void 0 : A.lockName, "delete"));
        }
        _updateLocalAcquiredLocks(A, e, t, g) {
          var o;
          const I = null !== (o = this._localAcquiredLocks.get(A)) && void 0 !== o ? o : /* @__PURE__ */ new Map();
          "delete" === t ? null == I || I.delete(e) : (I.set(e, { revision: g }), this._localAcquiredLocks.set(A, I));
        }
        _validateEnableLock(A) {
          const e = getParameter("LOCK_ENABLED");
          if ("true" !== (void 0 !== e ? String(e) : this._context.consoleConfig["lock.enabled"])) {
            const { code: e2, reason: t } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_LOCK_NOT_AVAILABLE);
            throw new RtmUnavailableError(A, [t], e2);
          }
        }
        _clearLocalAcquiredLocks() {
          this._localAcquiredLocks.clear();
        }
        _clearLockOperationsWithRetry() {
          this._acquireOperationNoRes.forEach((A, e) => {
            const { reject: t } = A, { code: g, reason: o } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_LOCK_ACQUIRE_FAILED);
            t && t(new RtmUnavailableError(OperationName.acquireLock, [o], g)), this._notifyAcquireRetryReject.next(e), this.emit("lockReleasedOrExpired", e);
          }), this._acquireOperationNoRes.clear();
        }
      }
      var _class$3;
      let Lock = (_class$3 = class extends EventBase {
        constructor(A, e, t, g) {
          super(A, "Lock", true, true), _defineProperty$1(this, "lockImpl", void 0), this.lockImpl = new LockImpl(A, e, t, g);
        }
        async setLock(A, e, t, g) {
          return await this.lockImpl.setLock(A, e, t, g);
        }
        async removeLock(A, e, t) {
          return await this.lockImpl.removeLock(A, e, t);
        }
        async acquireLock(A, e, t, g) {
          return await this.lockImpl.acquireLock(A, e, t, g);
        }
        async releaseLock(A, e, t) {
          return await this.lockImpl.releaseLock(A, e, t);
        }
        async revokeLock(A, e, t, g) {
          return await this.lockImpl.revokeLock(A, e, t, g);
        }
        async getLock(A, e) {
          return await this.lockImpl.getLock(A, e);
        }
      }, _applyDecoratedDescriptor(_class$3.prototype, "setLock", [loggedSensitive], Object.getOwnPropertyDescriptor(_class$3.prototype, "setLock"), _class$3.prototype), _applyDecoratedDescriptor(_class$3.prototype, "removeLock", [loggedSensitive], Object.getOwnPropertyDescriptor(_class$3.prototype, "removeLock"), _class$3.prototype), _applyDecoratedDescriptor(_class$3.prototype, "acquireLock", [loggedSensitive], Object.getOwnPropertyDescriptor(_class$3.prototype, "acquireLock"), _class$3.prototype), _applyDecoratedDescriptor(_class$3.prototype, "releaseLock", [loggedSensitive], Object.getOwnPropertyDescriptor(_class$3.prototype, "releaseLock"), _class$3.prototype), _applyDecoratedDescriptor(_class$3.prototype, "revokeLock", [loggedSensitive], Object.getOwnPropertyDescriptor(_class$3.prototype, "revokeLock"), _class$3.prototype), _applyDecoratedDescriptor(_class$3.prototype, "getLock", [loggedSensitive], Object.getOwnPropertyDescriptor(_class$3.prototype, "getLock"), _class$3.prototype), _class$3);
      var StatePrefixEnum = function(A) {
        return A.STATE_REVISION_KEY_PREFIX = "_rev_", A.STATE_TIMESTAMP_PREFIX = "_t_", A.STATE_AUTHOR_PREFIX = "_m_", A.STATE_REVISION = "_rev", A.STATE_INTERNAL_PREFIX = "_", A;
      }(StatePrefixEnum || {}), _class$2;
      class MetadataItem {
        constructor(A) {
          var e, t, g, o, I;
          _defineProperty$1(this, "key", void 0), _defineProperty$1(this, "value", void 0), _defineProperty$1(this, "revision", void 0), _defineProperty$1(this, "updateTs", void 0), _defineProperty$1(this, "authorUserId", void 0), this.key = null !== (e = null == A ? void 0 : A.key) && void 0 !== e ? e : "", this.value = null !== (t = null == A ? void 0 : A.value) && void 0 !== t ? t : "", this.revision = null !== (g = null == A ? void 0 : A.revision) && void 0 !== g ? g : -1, this.updateTs = null !== (o = null == A ? void 0 : A.updateTs) && void 0 !== o ? o : 0, this.authorUserId = null !== (I = null == A ? void 0 : A.authorUserId) && void 0 !== I ? I : "";
        }
        setKey(A) {
          if ("string" != typeof A) {
            const { code: A2, reason: e } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_INVALID_KEY);
            throw new RtmInvalidArgumentError(OperationName.storage, [e], A2);
          }
          this.key = A, this.key = A;
        }
        getKey() {
          if ("string" == typeof this.key)
            return this.key;
          throw new RtmInternalError("Cannot get MetaDataItem key");
        }
        setValue(A) {
          if ("string" != typeof A && !isNull$2(null)) {
            const { code: A2, reason: e } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_INVALID_VALUE);
            throw new RtmInvalidArgumentError(OperationName.storage, [e], A2);
          }
          this.value = A;
        }
        getValue() {
          if ("string" == typeof this.value || isNull$2(null))
            return this.value;
          throw new RtmInternalError("Cannot get MetaDataItem value");
        }
        setRevision(A) {
          if ("number" != typeof A || A % 1 != 0) {
            const { code: A2, reason: e } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_INVALID_REVISION);
            throw new RtmInvalidArgumentError(OperationName.storage, [e], A2);
          }
          this.revision = A;
        }
        getRevision() {
          if ("number" == typeof this.revision)
            return this.revision;
          throw new RtmInternalError("Cannot get MetaDataItem revision");
        }
        getUpdateTs() {
          return this.updateTs;
        }
        getAuthorUserId() {
          return this.authorUserId;
        }
      }
      function getRequestInfo(A, e) {
        const t = { [StatePrefixEnum.STATE_REVISION]: void 0 !== e && e >= 0 ? e : void 0 };
        for (let e2 = 0; e2 < A.length; e2++) {
          const g = A[e2];
          t[g.getKey()] = g.getValue(), t["".concat(StatePrefixEnum.STATE_REVISION_KEY_PREFIX).concat(g.getKey())] = g.getRevision() >= 0 || -2 === g.getRevision() ? g.getRevision() : void 0;
        }
        return omitBy$1(t, isUndefined$2);
      }
      function covertStateStringToMetaData(A) {
        const e = JSON.parse(A), t = { majorRevision: e[StatePrefixEnum.STATE_REVISION], items: [] }, g = omit$1(e, StatePrefixEnum.STATE_REVISION), o = Object.keys(g).filter((A2) => "_" !== A2[0]);
        return t.items = o.map((A2) => new MetadataItem({ key: A2, value: g[A2], revision: g["".concat(StatePrefixEnum.STATE_REVISION_KEY_PREFIX).concat(A2)], updateTs: g["".concat(StatePrefixEnum.STATE_TIMESTAMP_PREFIX).concat(A2)], authorUserId: g["".concat(StatePrefixEnum.STATE_AUTHOR_PREFIX).concat(A2)] })), t;
      }
      class StorageImpl extends EventBase {
        constructor(A, e, t, g, o, I, i2) {
          super(A, "StorageImpl", true), _defineProperty$1(this, "_context", void 0), _defineProperty$1(this, "_localAcquiredLocks", void 0), _defineProperty$1(this, "_channelMetaEventInfos", void 0), _defineProperty$1(this, "_userMetaEventInfos", void 0), _defineProperty$1(this, "_getRTMSession", void 0), _defineProperty$1(this, "_validateRtmConnection", void 0), _defineProperty$1(this, "_apiRateLimit", new ApiRateLimiter()), _defineProperty$1(this, "_notifyUserMetaReSub", new Subject()), _defineProperty$1(this, "_metadataSubscriptions", { userMetadataSubs: /* @__PURE__ */ new Map() }), _defineProperty$1(this, "_userMetadataSub", /* @__PURE__ */ new Set()), this._context = e, this._getRTMSession = genGetRTMSession(t), this._validateRtmConnection = g, this._localAcquiredLocks = o, this._channelMetaEventInfos = I, this._userMetaEventInfos = i2;
        }
        isSubedUserMetadata(A) {
          return this._userMetadataSub.has(A);
        }
        unsubAllUserMetadata() {
          this._userMetadataSub.forEach((A) => {
            this.requestUnsubscribeUserMetadata(A);
          });
        }
        releaseStorageModel() {
          this._userMetadataSub.forEach((A) => {
            this.emit("unsubUserMetadata", A);
          }), this._userMetadataSub.clear();
        }
        requestUnsubscribeUserMetadata(A) {
          const e = OperationName.unsubscribeUserMetadata, t = this._context.incGetSeq(), g = Date.now();
          this._sendStoragePacket(e, "StateUnsubscribe", { sequence: t, target: A, subTarget: "", flags: Long$1.fromNumber(0) }), this._userMetaEventInfos.delete(A), this._userMetadataSub.delete(A), this._context.addReportEvents("SyncSubscribeEvent", { lts: Long$1.fromNumber(Date.now()), userid: this._context.uid, vid: Long$1.fromString(this._context.vid || "0"), sid: this._context.sid, usersid: this._context.sid, target: A, requestts: Long$1.fromNumber(g), replyts: Long$1.fromNumber(Date.now()), eventtype: "UnSubscribe", sdktype: 4, flags: Long$1.fromNumber(0), code: 0, seq: t, index: { index1: this._context.uid, index2: this._context.appId, index3: "logUpload=".concat(this._context.config.logUpload) }, subtarget: this._context.uid }), this.emit("unsubUserMetadata", A);
        }
        notifyUserMetaReSub(A) {
          this._notifyUserMetaReSub.next({ env: A, allReSub: true });
        }
        async setChannelMetadata(A, e, t, g) {
          var o;
          const I = OperationName.setChannelMetadata;
          this._apiRateLimit.canMakeOperation("channelMetaModify"), validateChannelType(I, e), this._validateRtmConnection(I), this._validateEnableStorage(I);
          const i2 = { totalCount: 0, timestamp: 0, channelName: A, channelType: e };
          this._validateSessionExist(I);
          const r = getChannelNameByType(A, e);
          let n;
          if (validateKey(A, I, "channel"), null != g && g.lockName) {
            var C;
            validateKey(g.lockName, I, "metadata-lock");
            const A2 = null === (C = this._localAcquiredLocks.get(r)) || void 0 === C ? void 0 : C.get(g.lockName);
            null != A2 && A2.revision || this._throwNotAcquiredError(I), n = null == A2 ? void 0 : A2.revision;
          }
          const E = /* @__PURE__ */ new Map();
          t.forEach((A2) => {
            var e2;
            const t2 = new MetadataItem();
            t2.setKey(A2.key), t2.setRevision(null !== (e2 = A2.revision) && void 0 !== e2 ? e2 : -1), t2.setValue(A2.value), E.set(A2.key, t2);
          });
          const s = [];
          E.forEach((A2) => {
            s.push(A2);
          });
          const B = null !== (o = null == g ? void 0 : g.majorRevision) && void 0 !== o ? o : -1;
          validMetaDataItem(I, { items: s, maxMetaDataCount: MAX_METADATA_COUNT, maxMetaValueSize: RTM_METADATA_VALUE_MAX_LENGTH, majorRevision: B, type: "Set" });
          const a = JSON.stringify(getRequestInfo(s, B));
          validateMetaDataSize(I, a);
          try {
            const A2 = this._requestSetChannelMetadata(a, { majorRevision: B, enableRecordTs: null == g ? void 0 : g.addTimeStamp, enableRecordUserId: null == g ? void 0 : g.addUserId }, r, null == g ? void 0 : g.lockName, n).toPromise();
            await A2;
          } catch (A2) {
            if (isRtmError(A2)) {
              if (this.logError(A2), isNoLogged(A2))
                throw A2;
              if (isTimeout(A2)) {
                const { code: A3, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_OPERATION_TIMEOUT);
                throw new RtmUnavailableError(I, [e2], A3);
              }
              if (null != A2.code) {
                const { code: e2, reason: t2 } = getErrorInfoByCode(A2.code);
                throw new RtmUnavailableError(I, [t2], e2);
              }
              this.logError("error code is undefined, %o", A2);
            } else
              this.logError("not rtm error, %o", A2);
          }
          return i2;
        }
        async removeChannelMetadata(A, e, t) {
          var g;
          const o = OperationName.removeChannelMetadata;
          this._apiRateLimit.canMakeOperation("channelMetaModify"), validateChannelType(o, e), this._validateRtmConnection(o), this._validateEnableStorage(o);
          const I = { totalCount: 0, timestamp: 0, channelName: A, channelType: e }, i2 = getChannelNameByType(A, e);
          this._validateSessionExist(o), validateKey(A, o, "channel");
          const r = null == t ? void 0 : t.data, n = !r || 0 === r.length, C = /* @__PURE__ */ new Map();
          null == r || r.forEach((A2) => {
            var e2, t2;
            if (new Blob([null !== (e2 = A2.value) && void 0 !== e2 ? e2 : ""]).size > RTM_METADATA_VALUE_MAX_LENGTH) {
              const { code: A3, reason: e3 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_VALUE_LENGTH_OVERFLOW);
              throw new RtmLimitExceededError(o, [e3], A3);
            }
            const g2 = new MetadataItem();
            g2.setKey(A2.key), g2.setRevision(null !== (t2 = A2.revision) && void 0 !== t2 ? t2 : -1), C.set(A2.key, g2);
          });
          const E = [];
          var s;
          (C.forEach((A2) => {
            E.push(A2);
          }), n) ? null != t && t.majorRevision && validMetaDataMajorRevisionForRemove(o, t.majorRevision) : validMetaDataItem(o, { items: E, maxMetaDataCount: MAX_METADATA_COUNT, maxMetaValueSize: RTM_METADATA_VALUE_MAX_LENGTH, majorRevision: null !== (s = null == t ? void 0 : t.majorRevision) && void 0 !== s ? s : -1, type: "Delete" });
          let B;
          if (null != t && t.lockName) {
            var a, Q;
            validateKey(t.lockName, o, "metadata-lock");
            const A2 = null === (a = this._localAcquiredLocks.get(i2)) || void 0 === a ? void 0 : a.get(t.lockName);
            null != A2 && A2.revision || this._throwNotAcquiredError(o), B = null !== (Q = null == A2 ? void 0 : A2.revision) && void 0 !== Q ? Q : void 0;
          }
          const c = JSON.stringify(getRequestInfo(cloneDeep$1(E).map((A2) => (A2.setValue(null), A2)), null !== (g = null == t ? void 0 : t.majorRevision) && void 0 !== g ? g : -1));
          validateMetaDataSize(o, c);
          try {
            var l, h;
            const A2 = n ? this._requestClearChannelMetadata({ majorRevision: null !== (l = null == t ? void 0 : t.majorRevision) && void 0 !== l ? l : -1, enableRecordTs: null == t ? void 0 : t.addTimeStamp, enableRecordUserId: null == t ? void 0 : t.addUserId }, i2, null == t ? void 0 : t.lockName, B).toPromise() : this._requestRemoveChannelMetadata(c, { majorRevision: null !== (h = null == t ? void 0 : t.majorRevision) && void 0 !== h ? h : -1, enableRecordTs: null == t ? void 0 : t.addTimeStamp, enableRecordUserId: null == t ? void 0 : t.addUserId }, i2, null == t ? void 0 : t.lockName, B).toPromise();
            await A2;
          } catch (A2) {
            if (isRtmError(A2)) {
              if (this.logError(A2), isNoLogged(A2))
                throw A2;
              if (isTimeout(A2)) {
                const { code: A3, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_OPERATION_TIMEOUT);
                throw new RtmUnavailableError(o, [e2], A3);
              }
              if (null != A2.code) {
                const { code: e2, reason: t2 } = getErrorInfoByCode(A2.code);
                throw new RtmUnavailableError(o, [t2], e2);
              }
              this.logError("error code is undefined, %o", A2);
            } else
              this.logError("not rtm error, %o", A2);
          }
          return I;
        }
        async updateChannelMetadata(A, e, t, g) {
          var o, I;
          const i2 = OperationName.updateChannelMetadata;
          this._apiRateLimit.canMakeOperation("channelMetaModify"), validateChannelType(i2, e), this._validateRtmConnection(i2), this._validateEnableStorage(i2);
          const r = { timestamp: 0, totalCount: 0, channelName: A, channelType: e }, n = getChannelNameByType(A, e);
          this._validateSessionExist(i2), validateKey(A, i2, "channel");
          const C = /* @__PURE__ */ new Map();
          t.forEach((A2) => {
            var e2;
            const t2 = new MetadataItem();
            t2.setKey(A2.key), t2.setRevision(null !== (e2 = A2.revision) && void 0 !== e2 ? e2 : -1), t2.setValue(A2.value), C.set(A2.key, t2);
          });
          const E = [];
          let s;
          if (C.forEach((A2) => {
            E.push(A2);
          }), validMetaDataItem(i2, { items: E, maxMetaDataCount: MAX_METADATA_COUNT, maxMetaValueSize: RTM_METADATA_VALUE_MAX_LENGTH, majorRevision: null !== (o = null == g ? void 0 : g.majorRevision) && void 0 !== o ? o : -1, type: "Update" }), null != g && g.lockName) {
            var B, a;
            validateKey(null == g ? void 0 : g.lockName, i2, "metadata-lock");
            const A2 = null === (B = this._localAcquiredLocks.get(n)) || void 0 === B ? void 0 : B.get(g.lockName);
            null != A2 && A2.revision || this._throwNotAcquiredError(i2), s = null !== (a = null == A2 ? void 0 : A2.revision) && void 0 !== a ? a : void 0;
          }
          const Q = JSON.stringify(getRequestInfo(cloneDeep$1(E).map((A2) => (-1 === A2.getRevision() && A2.setRevision(-2), A2)), null !== (I = null == g ? void 0 : g.majorRevision) && void 0 !== I ? I : -1));
          validateMetaDataSize(i2, Q);
          try {
            var c;
            const A2 = this._requestUpdateChannelMetadata(Q, { majorRevision: null !== (c = null == g ? void 0 : g.majorRevision) && void 0 !== c ? c : -1, enableRecordTs: null == g ? void 0 : g.addTimeStamp, enableRecordUserId: null == g ? void 0 : g.addUserId }, n, null == g ? void 0 : g.lockName, s).toPromise();
            await A2;
          } catch (A2) {
            if (isRtmError(A2)) {
              if (this.logError(A2), isNoLogged(A2))
                throw A2;
              if (isTimeout(A2)) {
                const { code: A3, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_OPERATION_TIMEOUT);
                throw new RtmUnavailableError(i2, [e2], A3);
              }
              if (null != A2.code) {
                const { code: e2, reason: t2 } = getErrorInfoByCode(A2.code);
                throw new RtmUnavailableError(i2, [t2], e2);
              }
              this.logError("error code is undefined, %o", A2);
            } else
              this.logError("not rtm error, %o", A2);
          }
          return r;
        }
        async getChannelMetadata(A, e) {
          const t = OperationName.getChannelMetadata;
          this._apiRateLimit.canMakeOperation("channelMetaGet"), validateChannelType(t, e), this._validateRtmConnection(t), this._validateEnableStorage(t);
          const g = { totalCount: 0, majorRevision: 0, metadata: {}, timestamp: 0, channelName: A, channelType: e };
          this._validateSessionExist(t), validateKey(A, t, "channel");
          try {
            const t2 = this._requestGetChannelMetadata(getChannelNameByType(A, e)), o = await t2.pipe(map$1((A2) => covertStateStringToMetaData(A2))).toPromise();
            g.majorRevision = o.majorRevision, g.totalCount = o.items.length, o.items.forEach((A2) => {
              var e2;
              g.metadata[A2.getKey()] = { value: null !== (e2 = A2.getValue()) && void 0 !== e2 ? e2 : "", revision: A2.getRevision(), updated: A2.getUpdateTs(), authorUid: A2.getAuthorUserId() };
            });
          } catch (A2) {
            if (isRtmError(A2)) {
              if (this.logError(A2), isNoLogged(A2))
                throw A2;
              if (isTimeout(A2)) {
                const { code: A3, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_OPERATION_TIMEOUT);
                throw new RtmUnavailableError(t, [e2], A3);
              }
              if (null != A2.code) {
                const { code: e2, reason: g2 } = getErrorInfoByCode(A2.code);
                throw new RtmUnavailableError(t, [g2], e2);
              }
              this.logError("error code is undefined, %o", A2);
            } else
              this.logError("not rtm error, %o", A2);
          }
          return g;
        }
        async setUserMetadata(A, e) {
          var t;
          const g = OperationName.setUserMetadata;
          this._apiRateLimit.canMakeOperation("userMetaModify"), this._validateRtmConnection(g), this._validateEnableStorage(g);
          const o = null == e ? void 0 : e.userId, I = { timestamp: 0, totalCount: 0, userId: o || this._context.uid };
          this._validateSessionExist(g), o && validateKey(o, g, "uid");
          const i2 = /* @__PURE__ */ new Map();
          A.forEach((A2) => {
            var e2;
            const t2 = new MetadataItem();
            t2.setKey(A2.key), t2.setRevision(null !== (e2 = A2.revision) && void 0 !== e2 ? e2 : -1), t2.setValue(A2.value), i2.set(A2.key, t2);
          });
          const r = [];
          i2.forEach((A2) => {
            r.push(A2);
          });
          const n = null !== (t = null == e ? void 0 : e.majorRevision) && void 0 !== t ? t : -1;
          validMetaDataItem(g, { items: r, maxMetaDataCount: MAX_METADATA_COUNT, maxMetaValueSize: RTM_METADATA_VALUE_MAX_LENGTH, majorRevision: n, type: "Set" });
          const C = JSON.stringify(getRequestInfo(r, n));
          validateMetaDataSize(g, C);
          try {
            await this._requestSetUserMetadata(C, { majorRevision: n, enableRecordTs: null == e ? void 0 : e.addTimeStamp, enableRecordUserId: null == e ? void 0 : e.addUserId }, o).toPromise();
          } catch (A2) {
            if (isRtmError(A2)) {
              if (this.logError(A2), isNoLogged(A2))
                throw A2;
              if (isTimeout(A2)) {
                const { code: A3, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_OPERATION_TIMEOUT);
                throw new RtmUnavailableError(g, [e2], A3);
              }
              if (null != A2.code) {
                const { code: e2, reason: t2 } = getErrorInfoByCode(A2.code);
                throw new RtmUnavailableError(g, [t2], e2);
              }
              this.logError("error code is undefined, %o", A2);
            } else
              this.logError("not rtm error, %o", A2);
          }
          return I;
        }
        async removeUserMetadata(A) {
          const e = OperationName.removeUserMetadata;
          this._apiRateLimit.canMakeOperation("userMetaModify"), this._validateRtmConnection(e), this._validateEnableStorage(e);
          const t = null == A ? void 0 : A.userId, g = { timestamp: 0, totalCount: 0, userId: t || this._context.uid };
          this._validateSessionExist(e), t && validateKey(t, e, "uid");
          const o = null == A ? void 0 : A.data, I = !o || 0 === o.length, i2 = /* @__PURE__ */ new Map();
          null == o || o.forEach((A2) => {
            var t2, g2;
            if (new Blob([null !== (t2 = A2.value) && void 0 !== t2 ? t2 : ""]).size > RTM_METADATA_VALUE_MAX_LENGTH) {
              const { code: A3, reason: t3 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_VALUE_LENGTH_OVERFLOW);
              throw new RtmLimitExceededError(e, [t3], A3);
            }
            const o2 = new MetadataItem();
            o2.setKey(A2.key), o2.setRevision(null !== (g2 = A2.revision) && void 0 !== g2 ? g2 : -1), i2.set(A2.key, o2);
          });
          const r = [];
          var n;
          (i2.forEach((A2) => {
            r.push(A2);
          }), I) ? null != A && A.majorRevision && validMetaDataMajorRevisionForRemove(e, A.majorRevision) : validMetaDataItem(e, { items: r, maxMetaDataCount: MAX_METADATA_COUNT, maxMetaValueSize: RTM_METADATA_VALUE_MAX_LENGTH, majorRevision: null !== (n = null == A ? void 0 : A.majorRevision) && void 0 !== n ? n : -1, type: "Delete" });
          try {
            var C, E, s;
            const g2 = JSON.stringify(getRequestInfo(cloneDeep$1(r).map((A2) => (A2.setValue(null), A2)), null !== (C = null == A ? void 0 : A.majorRevision) && void 0 !== C ? C : -1));
            validateMetaDataSize(e, g2);
            const o2 = I ? this._requestClearUserMetadata({ majorRevision: null !== (E = null == A ? void 0 : A.majorRevision) && void 0 !== E ? E : -1, enableRecordTs: null == A ? void 0 : A.addTimeStamp, enableRecordUserId: null == A ? void 0 : A.addUserId }, t).toPromise() : this._requestRemoveUserMetadata(g2, { majorRevision: null !== (s = null == A ? void 0 : A.majorRevision) && void 0 !== s ? s : -1, enableRecordTs: null == A ? void 0 : A.addTimeStamp, enableRecordUserId: null == A ? void 0 : A.addUserId }, t).toPromise();
            await o2;
          } catch (A2) {
            if (isRtmError(A2)) {
              if (this.logError(A2), isNoLogged(A2))
                throw A2;
              if (isTimeout(A2)) {
                const { code: A3, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_OPERATION_TIMEOUT);
                throw new RtmUnavailableError(e, [t2], A3);
              }
              if (null != A2.code) {
                const { code: t2, reason: g2 } = getErrorInfoByCode(A2.code);
                throw new RtmUnavailableError(e, [g2], t2);
              }
              this.logError("error code is undefined, %o", A2);
            } else
              this.logError("not rtm error, %o", A2);
          }
          return g;
        }
        async updateUserMetadata(A, e) {
          var t, g;
          const o = OperationName.updateUserMetadata;
          this._apiRateLimit.canMakeOperation("userMetaModify"), this._validateRtmConnection(o), this._validateEnableStorage(o);
          const I = null == e ? void 0 : e.userId, i2 = { timestamp: 0, totalCount: 0, userId: I || this._context.uid };
          this._validateSessionExist(o), I && validateKey(I, o, "uid");
          const r = /* @__PURE__ */ new Map();
          null == A || A.forEach((A2) => {
            var e2;
            const t2 = new MetadataItem();
            t2.setKey(A2.key), t2.setRevision(null !== (e2 = A2.revision) && void 0 !== e2 ? e2 : -1), t2.setValue(A2.value), r.set(A2.key, t2);
          });
          const n = [];
          r.forEach((A2) => {
            n.push(A2);
          }), validMetaDataItem(o, { items: n, maxMetaDataCount: MAX_METADATA_COUNT, maxMetaValueSize: RTM_METADATA_VALUE_MAX_LENGTH, majorRevision: null !== (t = null == e ? void 0 : e.majorRevision) && void 0 !== t ? t : -1, type: "Update" });
          const C = JSON.stringify(getRequestInfo(cloneDeep$1(n).map((A2) => (-1 === A2.getRevision() && A2.setRevision(-2), A2)), null !== (g = null == e ? void 0 : e.majorRevision) && void 0 !== g ? g : -1));
          validateMetaDataSize(o, C);
          try {
            var E;
            await this._requestUpdateUserMetadata(C, { majorRevision: null !== (E = null == e ? void 0 : e.majorRevision) && void 0 !== E ? E : -1, enableRecordTs: null == e ? void 0 : e.addTimeStamp, enableRecordUserId: null == e ? void 0 : e.addUserId }, I).toPromise();
          } catch (A2) {
            if (isRtmError(A2)) {
              if (this.logError(A2), isNoLogged(A2))
                throw A2;
              if (isTimeout(A2)) {
                const { code: A3, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_OPERATION_TIMEOUT);
                throw new RtmUnavailableError(o, [e2], A3);
              }
              if (null != A2.code) {
                const { code: e2, reason: t2 } = getErrorInfoByCode(A2.code);
                throw new RtmUnavailableError(o, [t2], e2);
              }
              this.logError("error code is undefined, %o", A2);
            } else
              this.logError("not rtm error, %o", A2);
          }
          return i2;
        }
        async getUserMetadata(A) {
          const e = OperationName.getUserMetadata;
          this._apiRateLimit.canMakeOperation("userMetaGet"), this._validateRtmConnection(e), this._validateEnableStorage(e);
          const t = null == A ? void 0 : A.userId, g = { timestamp: 0, totalCount: 0, majorRevision: 0, metadata: {}, userId: t || this._context.uid };
          this._validateSessionExist(e), t && validateKey(t, e, "uid");
          try {
            const A2 = covertStateStringToMetaData(await this._requestGetUserMetadata(t || this._context.uid).toPromise());
            g.totalCount = A2.items.length, g.majorRevision = A2.majorRevision, A2.items.forEach((A3) => {
              var e2;
              g.metadata[A3.getKey()] = { value: null !== (e2 = A3.getValue()) && void 0 !== e2 ? e2 : "", revision: A3.getRevision(), updated: A3.getUpdateTs(), authorUid: A3.getAuthorUserId() };
            });
          } catch (A2) {
            if (isRtmError(A2)) {
              if (this.logError(A2), isNoLogged(A2))
                throw A2;
              if (isTimeout(A2)) {
                const { code: A3, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_OPERATION_TIMEOUT);
                throw new RtmUnavailableError(e, [t2], A3);
              }
              if (null != A2.code) {
                const { code: t2, reason: g2 } = getErrorInfoByCode(A2.code);
                throw new RtmUnavailableError(e, [g2], t2);
              }
              this.logError("error code is undefined, %o", A2);
            } else
              this.logError("not rtm error, %o", A2);
          }
          return g;
        }
        async subscribeUserMetadata(A) {
          const e = OperationName.subscribeUserMetadata;
          this._apiRateLimit.canMakeOperation("userMetaSub"), this._validateRtmConnection(e), this._validateEnableStorage(e), this._validateEnableStorageSub(e);
          const t = { timestamp: 0, userId: A || this._context.uid };
          if (this._validateSessionExist(e), validateKey(A, e, "uid"), this._userMetadataSub.has(A))
            return t;
          if (this._userMetadataSub.size >= MAX_SUBSCRIPTION_USER) {
            const { code: A2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_SUBSCRIBE_USER_EXCEED_LIMITATION);
            throw new RtmLimitExceededError(e, [t2], A2);
          }
          try {
            await this._requestSubscribeUserMetadata(A), this._userMetadataSub.add(A);
          } catch (t2) {
            if (isRtmError(t2)) {
              if (this.logError(t2), isNoLogged(t2))
                throw t2;
              if (t2.code) {
                const { code: A2, reason: g } = getErrorInfoByCode(t2.code);
                throw new RtmUnavailableError(e, [g], A2);
              }
              this.logError("error code is undefined, %o", t2);
            } else {
              if (isTimeout(t2)) {
                const { code: t3, reason: g } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_OPERATION_TIMEOUT);
                throw this.emit("unsubUserMetadata", A), new RtmUnavailableError(e, [g], t3);
              }
              this.logError("".concat(e, " occurs error not of rtm, %o"), t2);
            }
          }
          return t;
        }
        async unsubscribeUserMetadata(A) {
          const e = OperationName.unsubscribeUserMetadata;
          this._validateRtmConnection(e), this._validateEnableStorage(e);
          const t = { timestamp: 0, userId: A || this._context.uid };
          if (this._validateSessionExist(e), validateKey(A, e, "uid"), !this._userMetadataSub.has(A)) {
            const { code: A2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_NOT_SUBSCRIBE);
            throw new RtmInvalidStatusError(e, [t2], A2);
          }
          try {
            this.requestUnsubscribeUserMetadata(A), this._userMetadataSub.delete(A);
          } catch (A2) {
            if (isRtmError(A2))
              throw A2;
          }
          return t;
        }
        async _requestSubscribeUserMetadata(A) {
          const e = OperationName.subscribeUserMetadata, t = fromEvent(this, "unsubUserMetadata").pipe(filter((e2) => A === e2), take(1)), g = this._context.incGetSeq(), o = Date.now(), I = this._notifyUserMetaReSub.pipe(filter((e2) => (null == e2 ? void 0 : e2.userId) === A || true === (null == e2 ? void 0 : e2.allReSub)), switchMap((t2) => {
            const I2 = g;
            return this._sendStoragePacket(OperationName.subscribe, "StateSubscribe", { sequence: I2, target: A, subTarget: "", flags: Long$1.fromNumber(0) }, t2.env), this._onOperationPacket("StateSubscribeResult").pipe(first((A2) => {
              let { sequence: e2 } = A2;
              return I2.eq(e2);
            }), tap((t3) => {
              let { code: I3 } = t3;
              const { code: i3, reason: r } = convertServerCodeToSdkCodeForSub(I3);
              if (this._context.addReportEvents("SyncSubscribeEvent", { lts: Long$1.fromNumber(Date.now()), userid: this._context.uid, vid: Long$1.fromString(this._context.vid || "0"), sid: this._context.sid, usersid: this._context.sid, target: A, requestts: Long$1.fromNumber(o), replyts: Long$1.fromNumber(Date.now()), eventtype: "Subscribe", sdktype: 4, flags: Long$1.fromNumber(0), code: i3, seq: g, index: { index1: this._context.uid, index2: this._context.appId, index3: "logUpload=".concat(this._context.config.logUpload) }, subtarget: this._context.uid }), i3 !== RTMErrorCode.RTM_ERROR_OK)
                throw new RtmUnavailableError(e, [r], i3);
              this._userMetadataSub.add(A);
            }));
          }), takeUntil(t), share()), i2 = () => {
            this._metadataSubscriptions.userMetadataSubs.delete(A);
          };
          this._metadataSubscriptions.userMetadataSubs.set(A, I.subscribe({ error: i2, complete: i2 })), this._notifyUserMetaReSub.next({ env: void 0, userId: A }), await I.pipe(take(1), timeout(COMMON_REQUEST_TIMEOUT), catchError((e2) => (e2 instanceof TimeoutError && (this.warn("subscribe user metadata timeout"), this._context.addReportEvents("SyncSubscribeEvent", { lts: Long$1.fromNumber(Date.now()), userid: this._context.uid, vid: Long$1.fromString(this._context.vid || "0"), sid: this._context.sid, usersid: this._context.sid, target: A, requestts: Long$1.fromNumber(o), replyts: Long$1.fromNumber(Date.now()), eventtype: "Subscribe", sdktype: 4, flags: Long$1.fromNumber(0), code: RTMErrorCode.RTM_ERROR_STORAGE_OPERATION_TIMEOUT, seq: g, index: { index1: this._context.uid, index2: this._context.appId, index3: "logUpload=".concat(this._context.config.logUpload) }, subtarget: this._context.uid })), throwError(e2)))).toPromise();
        }
        _sendStoragePacket(A, e, t, g) {
          void 0 !== g ? this._sendStoragePacketUseOneEnv(A, g, e, t) : this._getRTMSession().sendOperationPacket(A, e, t);
        }
        _sendStoragePacketUseOneEnv(A, e, t, g) {
          this._getRTMSession().sendOperationPacketUseOneEnv(A, e, t, g);
        }
        _onOperationPacket(A) {
          return this._getRTMSession().onOperationPacket(A);
        }
        _requestSetChannelMetadata(A) {
          let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { majorRevision: -1, enableRecordTs: false, enableRecordUserId: false }, t = arguments.length > 2 ? arguments[2] : void 0, g = arguments.length > 3 ? arguments[3] : void 0, o = arguments.length > 4 ? arguments[4] : void 0;
          const I = OperationName.setChannelMetadata, i2 = 1 << 17, r = this._context.incGetSeq(), n = Date.now(), C = null == e ? void 0 : e.majorRevision;
          return this._sendStoragePacket(I, "StateModify", { sequence: r, target: t, requestUuid: "".concat(r, "_").concat(this._context.instanceId), value: A, lock: null != g ? g : "", lockRev: Long$1.fromNumber(null != o ? o : 0), baseRevision: Long$1.fromNumber(C >= 0 ? C : 0), author: e.enableRecordUserId ? this._context.uid : "", flags: e.enableRecordTs ? new Long$1(1572865 | (C >= 0 ? i2 : 0), 0, true) : new Long$1(1048577 | (C >= 0 ? i2 : 0), 0, true) }), race(genTimeoutError(RTMErrorCode.RTM_ERROR_STORAGE_OPERATION_TIMEOUT), this._onOperationPacket("StateRequestResult").pipe(first((A2) => {
            let { sequence: e2 } = A2;
            return r.eq(e2);
          }), map$1((A2) => {
            let { code: E } = A2;
            const { code: s, reason: B } = convertMetadataServerCodeToSdkCode(E);
            if (this._context.addReportEvents("SyncOperateEvent", { lts: Long$1.fromNumber(Date.now()), ip: "", userid: this._context.uid, vid: Long$1.fromString(this._context.vid || "0"), sid: this._context.sid, usersid: this._context.sid, requestts: Long$1.fromNumber(n), replyts: Long$1.fromNumber(Date.now()), target: t, eventtype: "Set", revision: Long$1.fromNumber(e.majorRevision), uuid: "".concat(r, "_").concat(this._context.instanceId), sdktype: 4, flags: e.enableRecordTs ? new Long$1(1572865 | (C >= 0 ? i2 : 0), 0, true) : new Long$1(1048577 | (C >= 0 ? i2 : 0), 0, true), code: s, seq: r, index: { index1: this._context.uid, index2: this._context.appId, index3: "logUpload=".concat(this._context.config.logUpload) }, lock: null != g ? g : "", lockrev: Long$1.fromNumber(null != o ? o : 0), subtarget: this._context.uid, sdkip: "" }), s !== RTMErrorCode.RTM_ERROR_OK)
              throw new RtmUnavailableError(I, [B], s);
          })));
        }
        _requestGetChannelMetadata(A) {
          const e = OperationName.getChannelMetadata, t = this._context.incGetSeq(), g = Date.now();
          return this._sendStoragePacket(e, "StateGet", { target: A, subTarget: "", lock: "", sequence: t, flags: new Long$1(1048577, 0, true), lockRev: Long$1.fromNumber(0) }), race(genTimeoutError(RTMErrorCode.RTM_ERROR_STORAGE_OPERATION_TIMEOUT), this._onOperationPacket("StateGetResult").pipe(first((A2) => {
            let { sequence: e2 } = A2;
            return t.eq(e2);
          }), map$1((o) => {
            let { code: I, allStates: i2 } = o;
            const { code: r, reason: n } = convertMetadataServerCodeToSdkCode(I), C = 0 === r ? covertStateStringToMetaData(i2).majorRevision : 0;
            if (this._context.addReportEvents("SyncOperateEvent", { lts: Long$1.fromNumber(Date.now()), ip: "", userid: this._context.uid, vid: Long$1.fromString(this._context.vid || "0"), sid: this._context.sid, usersid: this._context.sid, requestts: Long$1.fromNumber(g), replyts: Long$1.fromNumber(Date.now()), target: A, eventtype: "Get", revision: Long$1.fromNumber(C), uuid: "".concat(t, "_").concat(this._context.instanceId), sdktype: 4, flags: new Long$1(1048577, 0, true), code: r, seq: t, index: { index1: this._context.uid, index2: this._context.appId, index3: "logUpload=".concat(this._context.config.logUpload) }, lock: "", lockrev: Long$1.fromNumber(0), subtarget: this._context.uid, sdkip: "" }), r !== RTMErrorCode.RTM_ERROR_OK)
              throw new RtmUnavailableError(e, [n], r);
            return i2;
          }), filter((e2) => {
            var t2;
            return covertStateStringToMetaData(e2).majorRevision >= (null !== (t2 = this._channelMetaEventInfos.get(A)) && void 0 !== t2 ? t2 : 0);
          })));
        }
        _requestRemoveChannelMetadata(A) {
          let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { majorRevision: -1, enableRecordTs: false, enableRecordUserId: false }, t = arguments.length > 2 ? arguments[2] : void 0, g = arguments.length > 3 ? arguments[3] : void 0, o = arguments.length > 4 ? arguments[4] : void 0;
          const I = OperationName.removeChannelMetadata, i2 = 1 << 17, r = null == e ? void 0 : e.majorRevision, n = this._context.incGetSeq(), C = Date.now();
          return this._sendStoragePacket(I, "StateModify", { sequence: n, target: t, requestUuid: "".concat(n, "_").concat(this._context.instanceId), lock: null != g ? g : "", lockRev: Long$1.fromNumber(null != o ? o : 0), value: A, baseRevision: Long$1.fromNumber(r >= 0 ? r : 0), author: e.enableRecordUserId ? this._context.uid : "", flags: e.enableRecordTs ? new Long$1(1572865 | (r >= 0 ? i2 : 0), 0, true) : new Long$1(1048577 | (r >= 0 ? i2 : 0), 0, true) }), race(genTimeoutError(RTMErrorCode.RTM_ERROR_STORAGE_OPERATION_TIMEOUT), this._onOperationPacket("StateRequestResult").pipe(first((A2) => {
            let { sequence: e2 } = A2;
            return n.eq(e2);
          }), map$1((A2) => {
            let { code: E } = A2;
            const { code: s, reason: B } = convertMetadataServerCodeToSdkCode(E);
            if (this._context.addReportEvents("SyncOperateEvent", { lts: Long$1.fromNumber(Date.now()), ip: "", userid: this._context.uid, vid: Long$1.fromString(this._context.vid || "0"), sid: this._context.sid, usersid: this._context.sid, requestts: Long$1.fromNumber(C), replyts: Long$1.fromNumber(Date.now()), target: t, eventtype: "Delete", revision: Long$1.fromNumber(e.majorRevision), uuid: "".concat(n, "_").concat(this._context.instanceId), sdktype: 4, flags: e.enableRecordTs ? new Long$1(1572865 | (r >= 0 ? i2 : 0), 0, true) : new Long$1(1048577 | (r >= 0 ? i2 : 0), 0, true), code: s, seq: n, index: { index1: this._context.uid, index2: this._context.appId, index3: "logUpload=".concat(this._context.config.logUpload) }, lock: null != g ? g : "", lockrev: Long$1.fromNumber(null != o ? o : 0), subtarget: this._context.uid, sdkip: "" }), s !== RTMErrorCode.RTM_ERROR_OK)
              throw new RtmUnavailableError(I, [B], s);
          })));
        }
        _requestClearChannelMetadata() {
          let A = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { majorRevision: -1, enableRecordTs: false, enableRecordUserId: false }, e = arguments.length > 1 ? arguments[1] : void 0, t = arguments.length > 2 ? arguments[2] : void 0, g = arguments.length > 3 ? arguments[3] : void 0;
          const o = OperationName.removeChannelMetadata, I = 1 << 17, i2 = null == A ? void 0 : A.majorRevision, r = this._context.incGetSeq(), n = Date.now();
          return this._sendStoragePacket(o, "StateSet", { sequence: r, target: e, requestUuid: "".concat(r, "_").concat(this._context.instanceId), lock: null != t ? t : "", lockRev: Long$1.fromNumber(null != g ? g : 0), value: JSON.stringify({}), baseRevision: Long$1.fromNumber(i2 >= 0 ? i2 : 0), author: A.enableRecordUserId ? this._context.uid : "", flags: A.enableRecordTs ? new Long$1(1572865 | (i2 >= 0 ? I : 0), 0, true) : new Long$1(1048577 | (i2 >= 0 ? I : 0), 0, true) }), race(genTimeoutError(RTMErrorCode.RTM_ERROR_STORAGE_OPERATION_TIMEOUT), this._onOperationPacket("StateRequestResult").pipe(first((A2) => {
            let { sequence: e2 } = A2;
            return r.eq(e2);
          }), map$1((C) => {
            let { code: E } = C;
            const { code: s, reason: B } = convertMetadataServerCodeToSdkCode(E);
            if (this._context.addReportEvents("SyncOperateEvent", { lts: Long$1.fromNumber(Date.now()), ip: "", userid: this._context.uid, vid: Long$1.fromString(this._context.vid || "0"), sid: this._context.sid, usersid: this._context.sid, requestts: Long$1.fromNumber(n), replyts: Long$1.fromNumber(Date.now()), target: e, eventtype: "Clear", revision: Long$1.fromNumber(A.majorRevision), uuid: "".concat(r, "_").concat(this._context.instanceId), sdktype: 4, flags: A.enableRecordTs ? new Long$1(1572865 | (i2 >= 0 ? I : 0), 0, true) : new Long$1(1048577 | (i2 >= 0 ? I : 0), 0, true), code: s, seq: r, index: { index1: this._context.uid, index2: this._context.appId, index3: "logUpload=".concat(this._context.config.logUpload) }, lock: null != t ? t : "", lockrev: Long$1.fromNumber(null != g ? g : 0), subtarget: this._context.uid, sdkip: "" }), s !== RTMErrorCode.RTM_ERROR_OK)
              throw new RtmUnavailableError(o, [B], s);
          })));
        }
        _requestUpdateChannelMetadata(A) {
          let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { majorRevision: -1, enableRecordTs: false, enableRecordUserId: false }, t = arguments.length > 2 ? arguments[2] : void 0, g = arguments.length > 3 ? arguments[3] : void 0, o = arguments.length > 4 ? arguments[4] : void 0;
          const I = OperationName.updateChannelMetadata, i2 = 1 << 17, r = null == e ? void 0 : e.majorRevision, n = this._context.incGetSeq(), C = Date.now();
          return this._sendStoragePacket(I, "StateModify", { sequence: n, target: t, requestUuid: "".concat(n, "_").concat(this._context.instanceId), lock: null != g ? g : "", lockRev: Long$1.fromNumber(null != o ? o : 0), value: A, baseRevision: Long$1.fromNumber(r >= 0 ? r : 0), author: e.enableRecordUserId ? this._context.uid : "", flags: e.enableRecordTs ? new Long$1(1572865 | (r >= 0 ? i2 : 0), 0, true) : new Long$1(1048577 | (r >= 0 ? i2 : 0), 0, true) }), race(genTimeoutError(RTMErrorCode.RTM_ERROR_STORAGE_OPERATION_TIMEOUT), this._onOperationPacket("StateRequestResult").pipe(first((A2) => {
            let { sequence: e2 } = A2;
            return n.eq(e2);
          }), map$1((A2) => {
            let { code: E } = A2;
            const { code: s, reason: B } = convertMetadataServerCodeToSdkCode(E);
            if (this._context.addReportEvents("SyncOperateEvent", { lts: Long$1.fromNumber(Date.now()), ip: "", userid: this._context.uid, vid: Long$1.fromString(this._context.vid || "0"), sid: this._context.sid, usersid: this._context.sid, requestts: Long$1.fromNumber(C), replyts: Long$1.fromNumber(Date.now()), target: t, eventtype: "Update", revision: Long$1.fromNumber(e.majorRevision), uuid: "".concat(n, "_").concat(this._context.instanceId), sdktype: 4, flags: e.enableRecordTs ? new Long$1(1572865 | (r >= 0 ? i2 : 0), 0, true) : new Long$1(1048577 | (r >= 0 ? i2 : 0), 0, true), code: s, seq: n, index: { index1: this._context.uid, index2: this._context.appId, index3: "logUpload=".concat(this._context.config.logUpload) }, lock: null != g ? g : "", lockrev: Long$1.fromNumber(null != o ? o : 0), subtarget: this._context.uid, sdkip: "" }), s !== RTMErrorCode.RTM_ERROR_OK)
              throw new RtmUnavailableError(I, [B], s);
          })));
        }
        _requestSetUserMetadata(A) {
          let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { majorRevision: -1, enableRecordTs: false, enableRecordUserId: false }, t = arguments.length > 2 ? arguments[2] : void 0;
          const g = OperationName.setUserMetadata, o = 1 << 20, I = 1 << 17, i2 = this._context.incGetSeq(), r = Date.now(), n = null == e ? void 0 : e.majorRevision;
          return this._sendStoragePacket(g, "StateModify", { sequence: i2, target: null != t ? t : this._context.uid, requestUuid: "".concat(i2, "_").concat(this._context.instanceId), value: A, lock: "", lockRev: Long$1.fromNumber(0), baseRevision: Long$1.fromNumber(n >= 0 ? n : 0), author: e.enableRecordUserId ? this._context.uid : "", flags: e.enableRecordTs ? new Long$1(1572864 | (n >= 0 ? I : 0), 0, true) : new Long$1(o | (n >= 0 ? I : 0), 0, true) }), race(genTimeoutError(RTMErrorCode.RTM_ERROR_STORAGE_OPERATION_TIMEOUT), this._onOperationPacket("StateRequestResult").pipe(first((A2) => {
            let { sequence: e2 } = A2;
            return i2.eq(e2);
          }), tap((A2) => {
            let { code: t2 } = A2;
            const { code: C, reason: E } = convertMetadataServerCodeToSdkCode(t2);
            if (this._context.addReportEvents("SyncOperateEvent", { lts: Long$1.fromNumber(Date.now()), ip: "", userid: this._context.uid, vid: Long$1.fromString(this._context.vid || "0"), sid: this._context.sid, usersid: this._context.sid, requestts: Long$1.fromNumber(r), replyts: Long$1.fromNumber(Date.now()), target: this._context.uid, eventtype: "Set", revision: Long$1.fromNumber(e.majorRevision), uuid: "".concat(i2, "_").concat(this._context.instanceId), sdktype: 4, flags: e.enableRecordTs ? new Long$1(1572864 | (n >= 0 ? I : 0), 0, true) : new Long$1(o | (n >= 0 ? I : 0), 0, true), code: C, seq: i2, index: { index1: this._context.uid, index2: this._context.appId, index3: "logUpload=".concat(this._context.config.logUpload) }, lock: "", lockrev: Long$1.fromNumber(0), subtarget: this._context.uid, sdkip: "" }), C !== RTMErrorCode.RTM_ERROR_OK)
              throw new RtmUnavailableError(g, [E], C);
          })));
        }
        _throwNotAcquiredError(A) {
          const { code: e, reason: t } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_LOCK_NOT_ACQUIRED);
          throw new RtmUnavailableError(A, [t], e);
        }
        _validateSessionExist(A) {
          if (void 0 === this._getRTMSession()) {
            const { code: e, reason: t } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_NOT_CONNECTED);
            throw new RtmInvalidStatusError(A, [t], e);
          }
        }
        _validateEnableStorage(A) {
          const e = getParameter("STORAGE_ENABLED");
          if ("true" !== (void 0 !== e ? String(e) : this._context.consoleConfig["storage.enabled"])) {
            const { code: e2, reason: t } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_NOT_AVAILABLE);
            throw new RtmUnavailableError(A, [t], e2);
          }
        }
        _validateEnableStorageSub(A) {
          const e = getParameter("STORAGE_USER_SUB_ENABLED");
          if ("true" !== (void 0 !== e ? String(e) : this._context.consoleConfig["storage.user_subscribe_enabled"])) {
            const { code: e2, reason: t } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_NOT_AVAILABLE);
            throw new RtmUnavailableError(A, [t], e2);
          }
        }
        _requestUpdateUserMetadata(A) {
          let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { majorRevision: -1, enableRecordTs: false, enableRecordUserId: false }, t = arguments.length > 2 ? arguments[2] : void 0;
          const g = OperationName.updateUserMetadata, o = 1 << 20, I = 1 << 17, i2 = null == e ? void 0 : e.majorRevision, r = this._context.incGetSeq(), n = Date.now();
          return this._sendStoragePacket(g, "StateModify", { sequence: r, target: null != t ? t : this._context.uid, requestUuid: "".concat(r, "_").concat(this._context.instanceId), lock: "", lockRev: Long$1.fromNumber(0), value: A, baseRevision: Long$1.fromNumber(i2 >= 0 ? i2 : 0), author: e.enableRecordUserId ? this._context.uid : "", flags: e.enableRecordTs ? new Long$1(1572864 | (i2 >= 0 ? I : 0), 0, true) : new Long$1(o | (i2 >= 0 ? I : 0), 0, true) }), race(genTimeoutError(RTMErrorCode.RTM_ERROR_STORAGE_OPERATION_TIMEOUT), this._onOperationPacket("StateRequestResult").pipe(first((A2) => {
            let { sequence: e2 } = A2;
            return r.eq(e2);
          }), tap((A2) => {
            let { code: t2 } = A2;
            const { code: C, reason: E } = convertMetadataServerCodeToSdkCode(t2);
            if (this._context.addReportEvents("SyncOperateEvent", { lts: Long$1.fromNumber(Date.now()), ip: "", userid: this._context.uid, vid: Long$1.fromString(this._context.vid || "0"), sid: this._context.sid, usersid: this._context.sid, requestts: Long$1.fromNumber(n), replyts: Long$1.fromNumber(Date.now()), target: this._context.uid, eventtype: "Update", revision: Long$1.fromNumber(e.majorRevision), uuid: "".concat(r, "_").concat(this._context.instanceId), sdktype: 4, flags: e.enableRecordTs ? new Long$1(1572864 | (i2 >= 0 ? I : 0), 0, true) : new Long$1(o | (i2 >= 0 ? I : 0), 0, true), code: C, seq: r, index: { index1: this._context.uid, index2: this._context.appId, index3: "logUpload=".concat(this._context.config.logUpload) }, lock: "", lockrev: Long$1.fromNumber(0), subtarget: this._context.uid, sdkip: "" }), C !== RTMErrorCode.RTM_ERROR_OK)
              throw new RtmUnavailableError(g, [E], C);
          })));
        }
        _requestGetUserMetadata(A) {
          const e = OperationName.getUserMetadata, t = this._context.incGetSeq(), g = 1 << 20, o = Date.now();
          return this._sendStoragePacket(e, "StateGet", { target: A, subTarget: "", lock: "", sequence: t, flags: new Long$1(g, 0, true), lockRev: Long$1.fromNumber(0) }), race(genTimeoutError(RTMErrorCode.RTM_ERROR_STORAGE_OPERATION_TIMEOUT), this._onOperationPacket("StateGetResult").pipe(first((A2) => {
            let { sequence: e2 } = A2;
            return t.eq(e2);
          }), map$1((I) => {
            let { code: i2, allStates: r } = I;
            const { code: n, reason: C } = convertMetadataServerCodeToSdkCode(i2), E = 0 === n ? covertStateStringToMetaData(r).majorRevision : 0;
            if (this._context.addReportEvents("SyncOperateEvent", { lts: Long$1.fromNumber(Date.now()), ip: "", userid: this._context.uid, vid: Long$1.fromString(this._context.vid || "0"), sid: this._context.sid, usersid: this._context.sid, requestts: Long$1.fromNumber(o), replyts: Long$1.fromNumber(Date.now()), target: A, eventtype: "Get", revision: Long$1.fromNumber(E), uuid: "".concat(t, "_").concat(this._context.instanceId), sdktype: 4, flags: new Long$1(g, 0, true), code: n, seq: t, index: { index1: this._context.uid, index2: this._context.appId, index3: "logUpload=".concat(this._context.config.logUpload) }, lock: "", lockrev: Long$1.fromNumber(0), subtarget: this._context.uid, sdkip: "" }), n !== RTMErrorCode.RTM_ERROR_OK)
              throw new RtmUnavailableError(e, [C], n);
            return r;
          }), filter((e2) => {
            var t2;
            return covertStateStringToMetaData(e2).majorRevision >= (null !== (t2 = this._userMetaEventInfos.get(A)) && void 0 !== t2 ? t2 : 0);
          })));
        }
        _requestRemoveUserMetadata(A) {
          let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { majorRevision: -1, enableRecordTs: false, enableRecordUserId: false }, t = arguments.length > 2 ? arguments[2] : void 0;
          const g = OperationName.removeUserMetadata, o = 1 << 20, I = 1 << 17, i2 = null == e ? void 0 : e.majorRevision, r = this._context.incGetSeq(), n = Date.now();
          return this._sendStoragePacket(g, "StateModify", { sequence: r, target: null != t ? t : this._context.uid, requestUuid: "".concat(r, "_").concat(this._context.instanceId), lock: "", lockRev: Long$1.fromNumber(0), value: A, baseRevision: Long$1.fromNumber(i2 >= 0 ? i2 : 0), author: e.enableRecordUserId ? this._context.uid : "", flags: e.enableRecordTs ? new Long$1(1572864 | (i2 >= 0 ? I : 0), 0, true) : new Long$1(o | (i2 >= 0 ? I : 0), 0, true) }), race(genTimeoutError(RTMErrorCode.RTM_ERROR_STORAGE_OPERATION_TIMEOUT), this._onOperationPacket("StateRequestResult").pipe(first((A2) => {
            let { sequence: e2 } = A2;
            return r.eq(e2);
          }), tap((A2) => {
            let { code: t2 } = A2;
            const { code: C, reason: E } = convertMetadataServerCodeToSdkCode(t2);
            if (this._context.addReportEvents("SyncOperateEvent", { lts: Long$1.fromNumber(Date.now()), ip: "", userid: this._context.uid, vid: Long$1.fromString(this._context.vid || "0"), sid: this._context.sid, usersid: this._context.sid, requestts: Long$1.fromNumber(n), replyts: Long$1.fromNumber(Date.now()), target: this._context.uid, eventtype: "Delete", revision: Long$1.fromNumber(e.majorRevision), uuid: "".concat(r, "_").concat(this._context.instanceId), sdktype: 4, flags: e.enableRecordTs ? new Long$1(1572864 | (i2 >= 0 ? I : 0), 0, true) : new Long$1(o | (i2 >= 0 ? I : 0), 0, true), code: C, seq: r, index: { index1: this._context.uid, index2: this._context.appId, index3: "logUpload=".concat(this._context.config.logUpload) }, lock: "", lockrev: Long$1.fromNumber(0), subtarget: this._context.uid, sdkip: "" }), C !== RTMErrorCode.RTM_ERROR_OK)
              throw new RtmUnavailableError(g, [E], C);
          })));
        }
        _requestClearUserMetadata() {
          let A = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { majorRevision: -1, enableRecordTs: false, enableRecordUserId: false }, e = arguments.length > 1 ? arguments[1] : void 0;
          const t = OperationName.removeUserMetadata, g = 1 << 20, o = 1 << 17, I = null == A ? void 0 : A.majorRevision, i2 = this._context.incGetSeq(), r = Date.now();
          return this._sendStoragePacket(t, "StateSet", { sequence: i2, target: null != e ? e : this._context.uid, requestUuid: "".concat(i2, "_").concat(this._context.instanceId), lock: "", lockRev: Long$1.fromNumber(0), value: JSON.stringify({}), baseRevision: Long$1.fromNumber(I >= 0 ? I : 0), author: A.enableRecordUserId ? this._context.uid : "", flags: A.enableRecordTs ? new Long$1(1572864 | (I >= 0 ? o : 0), 0, true) : new Long$1(g | (I >= 0 ? o : 0), 0, true) }), race(genTimeoutError(RTMErrorCode.RTM_ERROR_STORAGE_OPERATION_TIMEOUT), this._onOperationPacket("StateRequestResult").pipe(first((A2) => {
            let { sequence: e2 } = A2;
            return i2.eq(e2);
          }), tap((e2) => {
            let { code: n } = e2;
            const { code: C, reason: E } = convertMetadataServerCodeToSdkCode(n);
            if (this._context.addReportEvents("SyncOperateEvent", { lts: Long$1.fromNumber(Date.now()), ip: "", userid: this._context.uid, vid: Long$1.fromString(this._context.vid || "0"), sid: this._context.sid, usersid: this._context.sid, requestts: Long$1.fromNumber(r), replyts: Long$1.fromNumber(Date.now()), target: this._context.uid, eventtype: "Clear", revision: Long$1.fromNumber(null == A ? void 0 : A.majorRevision), uuid: "".concat(i2, "_").concat(this._context.instanceId), sdktype: 4, flags: A.enableRecordTs ? new Long$1(1572864 | (I >= 0 ? o : 0), 0, true) : new Long$1(g | (I >= 0 ? o : 0), 0, true), code: C, seq: i2, index: { index1: this._context.uid, index2: this._context.appId, index3: "logUpload=".concat(this._context.config.logUpload) }, lock: "", lockrev: Long$1.fromNumber(0), subtarget: this._context.uid, sdkip: "" }), C !== RTMErrorCode.RTM_ERROR_OK)
              throw new RtmUnavailableError(t, [E], C);
          })));
        }
      }
      let RStorage = (_class$2 = class extends EventBase {
        constructor(A, e, t, g, o, I, i2) {
          super(A, "Storage", true, true), _defineProperty$1(this, "storageImpl", void 0), this.storageImpl = new StorageImpl(A, e, t, g, o, I, i2);
        }
        async setChannelMetadata(A, e, t, g) {
          return await this.storageImpl.setChannelMetadata(A, e, t, g);
        }
        async getChannelMetadata(A, e) {
          return await this.storageImpl.getChannelMetadata(A, e);
        }
        async removeChannelMetadata(A, e, t) {
          return await this.storageImpl.removeChannelMetadata(A, e, t);
        }
        async updateChannelMetadata(A, e, t, g) {
          return await this.storageImpl.updateChannelMetadata(A, e, t, g);
        }
        async setUserMetadata(A, e) {
          return await this.storageImpl.setUserMetadata(A, e);
        }
        async getUserMetadata(A) {
          return await this.storageImpl.getUserMetadata(A);
        }
        async removeUserMetadata(A) {
          return await this.storageImpl.removeUserMetadata(A);
        }
        async updateUserMetadata(A, e) {
          return await this.storageImpl.updateUserMetadata(A, e);
        }
        async subscribeUserMetadata(A) {
          return await this.storageImpl.subscribeUserMetadata(A);
        }
        async unsubscribeUserMetadata(A) {
          return await this.storageImpl.unsubscribeUserMetadata(A);
        }
      }, _applyDecoratedDescriptor(_class$2.prototype, "setChannelMetadata", [loggedSensitive], Object.getOwnPropertyDescriptor(_class$2.prototype, "setChannelMetadata"), _class$2.prototype), _applyDecoratedDescriptor(_class$2.prototype, "getChannelMetadata", [loggedSensitive], Object.getOwnPropertyDescriptor(_class$2.prototype, "getChannelMetadata"), _class$2.prototype), _applyDecoratedDescriptor(_class$2.prototype, "removeChannelMetadata", [loggedSensitive], Object.getOwnPropertyDescriptor(_class$2.prototype, "removeChannelMetadata"), _class$2.prototype), _applyDecoratedDescriptor(_class$2.prototype, "updateChannelMetadata", [loggedSensitive], Object.getOwnPropertyDescriptor(_class$2.prototype, "updateChannelMetadata"), _class$2.prototype), _applyDecoratedDescriptor(_class$2.prototype, "setUserMetadata", [loggedSensitive], Object.getOwnPropertyDescriptor(_class$2.prototype, "setUserMetadata"), _class$2.prototype), _applyDecoratedDescriptor(_class$2.prototype, "getUserMetadata", [loggedSensitive], Object.getOwnPropertyDescriptor(_class$2.prototype, "getUserMetadata"), _class$2.prototype), _applyDecoratedDescriptor(_class$2.prototype, "removeUserMetadata", [loggedSensitive], Object.getOwnPropertyDescriptor(_class$2.prototype, "removeUserMetadata"), _class$2.prototype), _applyDecoratedDescriptor(_class$2.prototype, "updateUserMetadata", [loggedSensitive], Object.getOwnPropertyDescriptor(_class$2.prototype, "updateUserMetadata"), _class$2.prototype), _applyDecoratedDescriptor(_class$2.prototype, "subscribeUserMetadata", [loggedSensitive], Object.getOwnPropertyDescriptor(_class$2.prototype, "subscribeUserMetadata"), _class$2.prototype), _applyDecoratedDescriptor(_class$2.prototype, "unsubscribeUserMetadata", [loggedSensitive], Object.getOwnPropertyDescriptor(_class$2.prototype, "unsubscribeUserMetadata"), _class$2.prototype), _class$2);
      const TextMessageDstType = { PeerTextMessage: 0, ChannelTextMessage: 1, VendorTextMessage: 2 }, RawMessageDstType = { PeerRawMessage: 3, ChannelRawMessage: 4, VendorRawMessage: 5 }, MessageDstType = _objectSpread2(_objectSpread2({}, TextMessageDstType), RawMessageDstType), InvitationType = { CallInvite: 101, CallAccept: 102, CallReject: 103, CallCancel: 104 }, MessageType = _objectSpread2(_objectSpread2({}, MessageDstType), InvitationType), CompressionMethod = { Uncompressed: 0, Zlib: 1 };
      class MessageOption extends Struct {
        constructor(A) {
          if (super(), this.define("MessageType", MessageType, 8), this.define("BroadcastJumps", "number", 2), this.define("ToCache", "boolean", 1), this.define("FromCache", "boolean", 1), this.define("CompressionMethod", CompressionMethod, 2), this.define("IterationNumber", "number", 4), this.define("BufferedMessage", "boolean", 1), this.define("ToArchive", "boolean", 1), this.define("FromArchive", "boolean", 1), this.define("kDelegate", "number", 1), this.define("kSecurity", "number", 1), this.define("kBypassGroupMemberCheck", "number", 1), this.define("enableEncryption", "boolean", 1), this.define("encrytionComplement", "number", 5), this.define("kHistory", "number", 1), this.define("undefined", "number", 33), isLongNum(A))
            this.from(A);
          else if (void 0 !== A)
            for (let e = 0, t = getEntries(A); e < t.length; e++) {
              const [A2, g] = t[e];
              this.set(A2, g);
            }
        }
        isTextMessage() {
          return this.assert("MessageType", ["PeerTextMessage", "ChannelTextMessage", "VendorTextMessage"]);
        }
        isRawMessage() {
          return this.assert("MessageType", ["ChannelRawMessage", "PeerRawMessage", "VendorRawMessage"]);
        }
        isRawPeerMessage() {
          return this.assert("MessageType", "PeerRawMessage");
        }
        isRawChannelMessage() {
          return this.assert("MessageType", "ChannelRawMessage");
        }
        isPeerTextMessage() {
          return this.assert("MessageType", "PeerTextMessage");
        }
        isChannelTextMessage() {
          return this.assert("MessageType", "ChannelTextMessage");
        }
        isInvitation(A) {
          return void 0 !== A ? this.assert("MessageType", A) : getKeys(InvitationType).some((A2) => this.assert("MessageType", A2));
        }
        isPeerMessage() {
          return this.assert("MessageType", ["PeerTextMessage", "PeerRawMessage"]);
        }
        isChannelMessage() {
          return this.assert("MessageType", ["ChannelTextMessage", "ChannelRawMessage"]);
        }
        isZlibCompressed() {
          return this.assert("CompressionMethod", "Zlib");
        }
        isFromCache() {
          return this.assert("FromCache", true);
        }
        isBufferedMessage() {
          return this.assert("BufferedMessage", true);
        }
        getInvitationType() {
          if (!this.isInvitation())
            throw new TypeError("cannot get InvitationType of a normal message type");
          return this.typeOf("MessageType");
        }
        isEncryption() {
          return this.assert("enableEncryption", true);
        }
        getEncrytionComplement() {
          var A;
          return null === (A = this.fields.get("encrytionComplement")) || void 0 === A ? void 0 : A.val;
        }
      }
      const { inflate } = UZIP;
      class HistoryImpl extends EventBase {
        constructor(A, e, t, g) {
          super(A, "HistoryImpl", true), _defineProperty$1(this, "_context", void 0), _defineProperty$1(this, "getRTMSession", void 0), _defineProperty$1(this, "_validateRtmConnection", void 0), _defineProperty$1(this, "_apiRateLimit", new ApiRateLimiter()), this._context = e, this.getRTMSession = genGetRTMSession(t), this._validateRtmConnection = g;
        }
        async getMessages(A, e, t) {
          var g, o, I, i2;
          const r = OperationName.getMessages;
          this._apiRateLimit.canMakeOperation("getMessages"), validateHistoryChannelType(r, e), this._validateRtmConnection(r), this._validateEnableHistory(r);
          if (validateKey(A, r, "channel"), "USER" === e && A !== this._context.uid) {
            this.warn("operation not permit");
            const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_HISTORY_OPERATION_NOT_PERMITTED);
            throw new RtmInvalidArgumentError(r, [e2], A2);
          }
          const n = null !== (g = null == t ? void 0 : t.start) && void 0 !== g ? g : 0, C = null !== (o = null == t ? void 0 : t.end) && void 0 !== o ? o : 0;
          if (n > 0 && C > 0 && (n <= C || n - C > GET_MESSAGE_TIME_LIMIT)) {
            this.warn("invalid start or end timestamp}");
            const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_HISTORY_INVALID_TIMESTAMP);
            throw new RtmInvalidArgumentError(r, [e2], A2);
          }
          const E = null !== (I = getParameter("HISTORY_MSG_COUNT_LIMIT")) && void 0 !== I ? I : GET_MESSAGE_MAX_COUNT;
          let s = null !== (i2 = null == t ? void 0 : t.messageCount) && void 0 !== i2 ? i2 : E;
          (0 === s || s > E) && (s = E);
          try {
            var B, a, Q;
            const t2 = this._requestGetMessages({ channelName: A, channelType: e, count: s, startTime: n, endTime: C }), g2 = await t2.toPromise();
            return { messageList: null !== (B = g2.messageList) && void 0 !== B ? B : [], count: null !== (a = null === (Q = g2.messageList) || void 0 === Q ? void 0 : Q.length) && void 0 !== a ? a : 0, newStart: g2.newStart, timestamp: 0 };
          } catch (A2) {
            if (isRtmError(A2)) {
              if (this.logError(A2), isNoLogged(A2))
                throw A2;
              if (isTimeout(A2)) {
                const { code: A3, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_HISTORY_OPERATION_TIMEOUT);
                throw new RtmUnavailableError(r, [e2], A3);
              }
              if (null != A2.code) {
                const { code: e2, reason: t2 } = getErrorInfoByCode(A2.code);
                throw new RtmUnavailableError(r, [t2], e2);
              }
              this.logError("error code is undefined, %o", A2);
            } else
              this.logError("not rtm error, %o", A2);
          }
          return { timestamp: 0, messageList: [], count: 0, newStart: 0 };
        }
        _sendHistoryPacket(A, e, t) {
          this.getRTMSession().sendOperationPacket(A, e, t);
        }
        _onOperationPacket(A) {
          return this.getRTMSession().onOperationPacket(A);
        }
        _requestGetMessages(A) {
          let { channelName: e, channelType: t, startTime: g, endTime: o, count: I } = A;
          const i2 = OperationName.getMessages, r = this._context.incGetSeq() + "_" + this._context.instanceId;
          return this._sendHistoryPacket(i2, "StateHistoryGet2", { dst: e, uuid: r, startTime: Long$1.fromNumber(g), endTime: Long$1.fromNumber(o), count: I, flags: new Long$1("MESSAGE" === t ? 1 : 0, 0, true) }), race(genTimeoutError(RTMErrorCode.RTM_ERROR_HISTORY_OPERATION_TIMEOUT), this._onOperationPacket("StateHistoryGetResult2").pipe(first((A2) => {
            let { uuid: e2 } = A2;
            return r === e2;
          }), map$1((A2) => {
            if (A2.code !== RTMErrorCode.RTM_ERROR_OK) {
              const { code: e2, reason: t2 } = getErrorInfoByCode(A2.code === SyncServerErrorCode.kNoPrivilege ? RTMErrorCode.RTM_ERROR_HISTORY_PERMISSION_DENIED : RTMErrorCode.RTM_ERROR_HISTORY_OPERATION_FAILED);
              throw new RtmUnavailableError(i2, [t2], e2);
            }
            {
              const { messages: e2, oldestTime: t2, more: g2 } = A2;
              let o2 = 0;
              const I2 = e2.filter((A3) => {
                const { options: e3 } = A3, t3 = new MessageOption(e3).isEncryption();
                return !(t3 && !this._context.encryptionInfo.key || !t3 && this._context.encryptionInfo.key) || (o2++, false);
              }).map((A3) => {
                var e3;
                const { options: t3, payload: g3, src: o3, ms: I3, details: i3 } = A3, r2 = new MessageOption(t3), n = r2.isZlibCompressed(), C = r2.isEncryption(), E = null !== (e3 = r2.getEncrytionComplement()) && void 0 !== e3 ? e3 : 0, s = r2.isTextMessage(), { customType: B = new Uint8Array() } = i3, a = new TextDecoder().decode(B);
                if (s) {
                  const A4 = n ? inflate(concatenateUint8Array(g3, Uint8Array.of(0, 0, 0, 0))) : g3, e4 = A4.byteLength - Long$1.fromValue(E).toNumber();
                  return { message: new TextDecoder().decode(C && this._context.encryptionInfo.initEncryption ? decrypt(A4, this._context.encryptionInfo.key, this._context.encryptionInfo.iv, this._context.encryptionInfo.keyLength).slice(0, e4) : A4), customType: a, messageType: MessageType$1.STRING, publisher: o3, timestamp: null == I3 ? void 0 : I3.toNumber() };
                }
                {
                  const A4 = n ? inflate(g3) : g3, e4 = A4.byteLength - Long$1.fromValue(E).toNumber();
                  return { message: C && this._context.encryptionInfo.initEncryption ? decrypt(A4, this._context.key, this._context.encryptionInfo.iv, this._context.encryptionInfo.keyLength).slice(0, e4) : A4, customType: a, messageType: MessageType$1.BINARY, publisher: o3, timestamp: null == I3 ? void 0 : I3.toNumber() };
                }
              });
              return o2 > 0 && this.warn("ignore %d messages because of encryption mismatch", o2), { messageList: I2, newStart: g2 ? t2.toNumber() : 0 };
            }
          })));
        }
        _validateEnableHistory(A) {
          if ("true" !== this._context.consoleConfig["history.enabled"]) {
            const { code: e, reason: t } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_HISTORY_NOT_AVAILABLE);
            throw new RtmUnavailableError(A, [t], e);
          }
        }
      }
      var _class$1;
      let History = (_class$1 = class extends EventBase {
        constructor(A, e, t, g) {
          super(A, "History", true, true), _defineProperty$1(this, "historyImpl", void 0), this.historyImpl = new HistoryImpl(A, e, t, g);
        }
        async getMessages(A, e, t) {
          return await this.historyImpl.getMessages(A, e, t);
        }
      }, _applyDecoratedDescriptor(_class$1.prototype, "getMessages", [loggedSensitive], Object.getOwnPropertyDescriptor(_class$1.prototype, "getMessages"), _class$1.prototype), _class$1);
      var name = "agora-rtm", exports$1 = { ".": { require: "./dist/bundle.umd.js", import: "./dist/bundle.mjs", types: "./dist/types/index.d.ts" } }, version = "2.2.3", description = "JavaScript SDK for Agora RTM", keywords = ["agora", "rtm", "real-time-messaging", "sdk", "javascript", "signaling", "stream", "messaging"], homepage = "https://bitbucket.agoralab.co/projects/WEBRTC/repos/rtm.js", bugs = { url: "https://agora-ticket.agora.io", email: "support@agora.io" }, license = "Apache", author = "Agora Lab.", main = "dist/bundle.umd.js", types = "dist/types/index.d.ts", directories = { lib: "src" }, repository = { type: "git", url: "git+ssh://git@git.agoralab.co/webrtc/rtm.js.git" }, scripts = { "test:coverage": "rm -rf ./coverage && vitest run --config ./vitest.config.ts", "test:coverage:ui": "rm -rf ./coverage && vitest --ui --coverage --config ./vitest.config.ts", postinstall: "touch ./.env && node --experimental-import-meta-resolve ./scripts/patch.mjs", "proto-gen": "npm run proto-gen:js && npm run proto-gen:ts", "proto-gen:js": "pbjs -t static-module --no-create --no-decode --no-verify --no-service --no-convert --force-long --no-delimited -w es6 -o ./src/lib/compiled_proto/report.js ./src/third_party/report.proto && pbjs -t static-module --no-delimited --no-convert --no-verify --no-service --no-create --force-long -w es6 -o ./src/lib/compiled_proto/gateway.js ./src/third_party/gateway.proto && pbjs -t static-module --no-delimited --no-convert --no-verify --no-service --no-create --force-long -w es6 -o ./src/lib/compiled_proto/metadata.js ./src/third_party/metadata.proto", "proto-gen:ts": "pbts --main --out ./src/lib/compiled_proto/report.d.ts ./src/lib/compiled_proto/report.js && pbts --main --out ./src/lib/compiled_proto/gateway.d.ts ./src/lib/compiled_proto/gateway.js && pbts --main --out ./src/lib/compiled_proto/metadata.d.ts ./src/lib/compiled_proto/metadata.js", "build:types": "run-s dts:tsc dts:gen", "dts:tsc": "tsc -p ./tsconfig.json", "dts:gen": "rollup -c ./rollup.types.config.mjs", dev: "FUSION=false NODE_ENV=development BASE_VERSION=100 rollup -c rollup.config.mjs -w", "dev-fusion": "FUSION=true NODE_ENV=development BASE_VERSION=100 rollup -c rollup.config.mjs -w", build: 'NODE_OPTIONS="--max-old-space-size=8192" npm run build:web && NODE_OPTIONS="--max-old-space-size=8192" npm run build:cdn', "build:web": 'cross-env GIT_COMMIT=$(git describe --tags --long --match "v*" --dirty) npx cross-env NODE_ENV=production BASE_VERSION=100 npx rollup -c rollup.config.mjs', "build:cdn": 'cross-env GIT_COMMIT=$(git describe --tags --long --match "v*" --dirty) npx cross-env NODE_ENV=production BASE_VERSION=100 npx rollup -c rollup.config.web.mjs', prepublishOnly: "FUSION=false npm run build && npm run build:types && node ./prepublish.js", prepublishOnlyOversea: "cross-env FUSION=false OVERSEA=true npm run build && npm run build:types && cross-env OVERSEA=true node ./prepublish.js", prepublishOnlyFusion: "cross-env FUSION=true npm run build && npm run build:types && cross-env FUSION=true node ./prepublish.js", beautify: "concurrently -P 'npm:lint:*' -- --fix", lint: "npx eslint src/  --format codeframe", "lint:test": "npx eslint '__test_rtm__/**/*.ts' 'vitest.config.ts' 'vitest.setup.ts' --config .eslintrc.test.js --no-ignore --format codeframe", "beautify:all": "npm run lint -- --fix && npm run lint:test -- --fix", wb: "node white-brand-cli" }, config = { scripts: { commit: "npx git-cz" } }, dependencies = { "@thi.ng/cache": "^1.0.94", "agora-rtc-sdk-ng": "4.23.0", "cross-env": "^7.0.3", debug: "^4.4.0", events: "^3.3.0", "format-util": "^1.0.5", gud: "^1.0.0", "is-mobile": "^3.1.1", "is-what": "^3.14.1", lodash: "^4.17.21", long: "^5.3.1", neverthrow: "^5.1.0", "node-forge": "^1.3.1", protobufjs: "^7.4.0", rxjs: "^6.6.7", "rxjs-etc": "^10.6.2", "rxjs-websockets": "^8.0.1", "safe-json-stringify": "^1.2.0", uuid: "^3.4.0" }, devDependencies = { "@ampproject/rollup-plugin-closure-compiler": "^0.27.0", "@babel/core": "^7.26.0", "@babel/eslint-parser": "^7.25.9", "@babel/plugin-proposal-class-properties": "^7.18.6", "@babel/plugin-proposal-decorators": "^7.25.9", "@babel/plugin-syntax-import-attributes": "^7.26.0", "@babel/plugin-transform-for-of": "^7.25.9", "@babel/preset-env": "^7.26.0", "@babel/preset-typescript": "^7.26.0", "@playwright/test": "^1.41.2", "@rollup/plugin-alias": "^5.1.1", "@rollup/plugin-babel": "^6.0.4", "@rollup/plugin-commonjs": "^25.0.8", "@rollup/plugin-json": "^6.1.0", "@rollup/plugin-node-resolve": "^15.3.1", "@rollup/plugin-replace": "^5.0.7", "@rollup/plugin-terser": "^0.4.4", "@types/node": "^14.18.63", "@typescript-eslint/eslint-plugin": "^6.21.0", "@typescript-eslint/parser": "^6.21.0", "@vitest/browser": "^3.1.1", "@vitest/coverage-istanbul": "^3.1.1", "@vitest/ui": "^3.1.1", "agora-rte-extension": "^1.2.4", "babel-plugin-annotate-pure-calls": "^0.4.0", "babel-plugin-const-enum": "1.0.1", "babel-plugin-istanbul": "^6.1.1", "babel-plugin-polyfill-corejs3": "^0.2.5", "babel-plugin-polyfill-regenerator": "^0.2.3", concurrently: "^7.6.0", "core-js": "^3.39.0", "cross-zip": "^4.0.1", decomment: "^0.9.5", "dotenv-extended": "^2.9.0", eslint: "^8.57.1", "eslint-config-airbnb-typescript": "^17.1.0", "eslint-formatter-codeframe": "^7.32.1", "eslint-plugin-eslint-comments": "^3.2.0", "eslint-plugin-import": "^2.31.0", "eslint-plugin-prettier": "^5.2.1", "eslint-plugin-simple-import-sort": "^10.0.0", "fast-check": "^4.0.0", "fs-extra": "^9.1.0", jsdom: "^20.0.3", msw: "^2.8.2", nodemon: "^2.0.22", "npm-run-all": "^4.1.5", path: "^0.12.7", prettier: "3.2.3", "protobufjs-cli": "~1.1.3", "regenerator-runtime": "^0.14.1", rollup: "^4.28.1", "rollup-plugin-dts": "^6.1.1", "strict-event-emitter-types": "^2.0.0", touch: "^3.1.1", typedoc: "^0.23.28", typescript: "^5.7.2", "utility-types": "^3.11.0", vite: "^5.1.0", "vite-plugin-istanbul": "^7.0.0", vitest: "^3.1.1" }, optionalDependencies = { "@fast-csv/parse": "^4.3.6", "@types/debug": "4.1.5", "@types/format-util": "^1.0.4", "@types/google-closure-compiler": "^0.0.18", "@types/lodash": "^4.17.13", "@types/node-forge": "^1.3.11", "@types/pako": "^1.0.7", "@types/safe-json-stringify": "^1.1.5", "@types/uuid": "^3.4.13", "browserslist-useragent": "^3.1.4", "rollup-plugin-livereload": "^2.0.5", "rollup-plugin-serve": "^1.1.1", "rollup-plugin-visualizer": "^5.12.0", "typedoc-plugin-no-inherit": "^1.4.0" }, pkg = { name, exports: exports$1, version, description, keywords, homepage, bugs, license, author, main, types, directories, repository, scripts, config, dependencies, devDependencies, optionalDependencies }, _getParameter;
      const QUERY_INTERVAL = null !== (_getParameter = getParameter("CONFIG_QUERY_INTERVAL")) && void 0 !== _getParameter ? _getParameter : 3e5, LOCAL_STORAGE_KEY = "_agora_rtm_custom_config";
      function getDeviceInfo(A) {
        let e = "Unknown", t = "Unknown";
        return A.includes("Chrome") ? e = "Chrome" : A.includes("Firefox") ? e = "Firefox" : A.includes("Safari") && !A.includes("Chrome") ? e = "Safari" : A.includes("Edge") ? e = "Edge" : (A.includes("Opera") || A.includes("OPR")) && (e = "Opera"), A.includes("Windows NT") ? t = "Windows" : A.includes("Mac OS X") ? t = "Mac OS" : A.includes("Android") ? t = "Android" : A.includes("iPhone") || A.includes("iPad") ? t = "iOS" : A.includes("Linux") && (t = "Linux"), { deviceName: e, osName: t };
      }
      class CustomConfig {
        get domains() {
          var A, e;
          const t = null !== (A = getParameter("TDS_DOMAINS")) && void 0 !== A ? A : [];
          return t && null !== (e = null == t ? void 0 : t.length) && void 0 !== e && e ? t : this._domains;
        }
        constructor(A, e) {
          var t;
          _defineProperty$1(this, "_appid", ""), _defineProperty$1(this, "_sid", ""), _defineProperty$1(this, "_timer", null), _defineProperty$1(this, "_device", ""), _defineProperty$1(this, "_system", ""), _defineProperty$1(this, "_systemGeneral", ""), _defineProperty$1(this, "_domains", ["ap-web-1.agora.io"]), _defineProperty$1(this, "_useBackup", false), this._appid = A, this._sid = null !== (t = null == e ? void 0 : e.sid) && void 0 !== t ? t : "", this._systemGeneral = navigator.userAgent;
          const { deviceName: g, osName: o } = getDeviceInfo(this._systemGeneral);
          this._device = g, this._system = o;
        }
        init(A) {
          this._sid = A;
          const e = this._getStorageConfig();
          if (e)
            for (const A2 in e)
              this._updateSdkConfig(A2, e[A2]);
          this._start();
        }
        stop() {
          this._timer && (clearInterval(this._timer), this._timer = null);
        }
        async _query() {
          let A = {};
          const e = this.domains, t = null != this && this._useBackup && e.length > 1 ? this.domains[1] : this.domains[0];
          try {
            const e2 = await postWithAbortSignal("https://".concat(t, "/api/v1"), { headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "54", "Content-Type": "application/json" }, body: { flag: 64, cipher_method: 0, features: { device: this._device, system: this._system, system_general: navigator.userAgent, vendor: this._appid, version: pkg.version, install_id: this._sid, session_id: this._sid, detail: "", sdk_type: "web_rtm" } } }), g = JSON.parse(e2.responseText), { code: o, test_tags: I } = g;
            if (0 !== o)
              return;
            A = I;
            const i2 = {};
            for (const e3 in A)
              if (e3.includes("web_rtm")) {
                const [t2, g2] = JSON.parse(A[e3]);
                for (const A2 in g2)
                  Object.hasOwn(MUTABLE_PARAMS, A2) && (i2[A2] = g2[A2]);
              }
            this._setStorageConfig(i2), this._useBackup = false;
          } catch (A2) {
            this._useBackup = true;
          }
        }
        async _start() {
          await this._query(), this._timer = setInterval(async () => {
            await this._query();
          }, QUERY_INTERVAL);
        }
        _getStorageConfig() {
          var A, e;
          const t = atob(null !== (A = localStorage.getItem(LOCAL_STORAGE_KEY)) && void 0 !== A ? A : ""), g = null === (e = JSON.parse(t || JSON.stringify({}))) || void 0 === e ? void 0 : e[this._appid];
          return g || null;
        }
        _setStorageConfig(A) {
          var e;
          const t = JSON.parse(atob(null !== (e = localStorage.getItem(LOCAL_STORAGE_KEY)) && void 0 !== e ? e : "") || "{}");
          t[this._appid] = _objectSpread2({}, A), localStorage.setItem(LOCAL_STORAGE_KEY, btoa(JSON.stringify(t)));
        }
        _isExpectedType(A) {
          return "boolean" == typeof A || "number" == typeof A || "string" == typeof A || Array.isArray(A);
        }
        _updateSdkConfig(A, e) {
          e && this._isExpectedType(e) && setParameter(A, e);
        }
      }
      const implementsFunction = (A, e) => null != A && "function" == typeof A[e], isArrayLike = (A) => null != A && "function" != typeof A && void 0 !== A.length, isIterable = (A) => null != A && "function" == typeof A[Symbol.iterator], compare = (A, e) => A === e ? 0 : null == A ? null == e ? 0 : -1 : null == e ? null == A ? 0 : 1 : "function" == typeof A.compare ? A.compare(e) : "function" == typeof e.compare ? -e.compare(A) : A < e ? -1 : A > e ? 1 : 0, OBJP = Object.getPrototypeOf({}), FN = "function", STR = "string", equiv = (A, e) => {
        let t;
        return A === e || (null == A ? A == e : typeof A.equiv === FN ? A.equiv(e) : null == e ? A == e : typeof e.equiv === FN ? e.equiv(A) : typeof A !== STR && typeof e !== STR && (t = Object.getPrototypeOf(A), null != t && t !== OBJP || (t = Object.getPrototypeOf(e), null != t && t !== OBJP) ? typeof A !== FN && void 0 !== A.length && typeof e !== FN && void 0 !== e.length ? equivArrayLike(A, e) : A instanceof Set && e instanceof Set ? equivSet(A, e) : A instanceof Map && e instanceof Map ? equivMap(A, e) : A instanceof Date && e instanceof Date ? A.getTime() === e.getTime() : A instanceof RegExp && e instanceof RegExp ? A.toString() === e.toString() : A != A && e != e : equivObject(A, e)));
      }, equivArrayLike = function(A, e) {
        let t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : equiv, g = A.length;
        if (g === e.length)
          for (; --g >= 0 && t(A[g], e[g]); )
            ;
        return g < 0;
      }, equivSet = function(A, e) {
        let t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : equiv;
        return A.size === e.size && t([...A.keys()].sort(), [...e.keys()].sort());
      }, equivMap = function(A, e) {
        let t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : equiv;
        return A.size === e.size && t([...A].sort(), [...e].sort());
      }, equivObject = function(A, e) {
        let t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : equiv;
        if (Object.keys(A).length !== Object.keys(e).length)
          return false;
        for (let g in A)
          if (!e.hasOwnProperty(g) || !t(A[g], e[g]))
            return false;
        return true;
      }, defError = function(A) {
        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : (A2) => void 0 !== A2 ? ": " + A2 : "";
        return class extends Error {
          constructor(t) {
            super(A(t) + e(t));
          }
        };
      }, IllegalArgumentError = defError(() => "illegal argument(s)"), illegalArgs = (A) => {
        throw new IllegalArgumentError(A);
      }, OutOfBoundsError = defError(() => "index out of bounds"), outOfBounds = (A) => {
        throw new OutOfBoundsError(A);
      }, ensureIndex = (A, e, t) => (A < e || A >= t) && outOfBounds(A), INV_MAX = 1 / 4294967295;
      class ARandom {
        float() {
          let A = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
          return this.int() * INV_MAX * A;
        }
        norm() {
          let A = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
          return 2 * (this.int() * INV_MAX - 0.5) * A;
        }
        minmax(A, e) {
          return this.float() * (e - A) + A;
        }
      }
      const random = Math.random;
      class SystemRandom extends ARandom {
        int() {
          return 4294967296 * random() >>> 0;
        }
        float() {
          let A = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
          return random() * A;
        }
        norm() {
          let A = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
          return 2 * (random() - 0.5) * A;
        }
      }
      const SYSTEM = new SystemRandom(), SEMAPHORE = Symbol(), NO_OP = () => {
      }, ensureTransducer = (A) => implementsFunction(A, "xform") ? A.xform() : A;
      class Reduced {
        constructor(A) {
          this.value = A;
        }
        deref() {
          return this.value;
        }
      }
      const isReduced = (A) => A instanceof Reduced, unreduced = (A) => A instanceof Reduced ? A.deref() : A;
      function* iterator1(A, e) {
        const t = ensureTransducer(A)([NO_OP, NO_OP, (A2, e2) => e2])[2];
        for (let A2 = 0; A2 < e.length; A2++) {
          let g = e[A2], o = t(SEMAPHORE, g);
          if (isReduced(o))
            return o = unreduced(o.deref()), void (o !== SEMAPHORE && (yield o));
          o !== SEMAPHORE && (yield o);
        }
      }
      const compR = (A, e) => [A[0], A[1], e];
      function map(A, e) {
        return isIterable(e) ? iterator1(map(A), e) : (e2) => {
          const t = e2[2];
          return compR(e2, (e3, g) => t(e3, A(g)));
        };
      }
      class DCons {
        constructor(A) {
          this._length = 0, A && this.into(A);
        }
        get length() {
          return this._length;
        }
        copy() {
          return new DCons(this);
        }
        empty() {
          return new DCons();
        }
        clear() {
          this.release();
        }
        release() {
          let A, e = this.head;
          for (; e; )
            A = e.next, delete e.value, delete e.prev, delete e.next, e = A;
          return delete this.head, delete this.tail, this._length = 0, true;
        }
        compare(A) {
          const e = this._length;
          if (e < A._length)
            return -1;
          if (e > A._length)
            return 1;
          if (0 === e)
            return 0;
          {
            let e2 = this.head, t = A.head, g = 0;
            for (; e2 && 0 == g; )
              g = compare(e2.value, t.value), e2 = e2.next, t = t.next;
            return g;
          }
        }
        equiv(A) {
          if (!(A instanceof DCons || isArrayLike(A)) || this._length !== A.length)
            return false;
          if (!this._length || this === A)
            return true;
          let e = this.head;
          for (let t = 0; t < A.length; t++) {
            let g = A[t];
            if (!equiv(e.value, g))
              return false;
            e = e.next;
          }
          return true;
        }
        *[Symbol.iterator]() {
          let A = this.head;
          for (; A; )
            yield A.value, A = A.next;
        }
        seq() {
          let A = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.length;
          if (A >= e || A < 0)
            return;
          let t = this.nthCell(A);
          const g = this.nthCell(e - 1), o = (A2) => ({ first() {
            return A2.value;
          }, next() {
            return A2 !== g && A2.next ? o(A2.next) : void 0;
          } });
          return t ? o(t) : void 0;
        }
        *cycle() {
          for (; ; )
            yield* this;
        }
        $reduce(A, e) {
          let t = this.head;
          for (; t && !isReduced(e); )
            e = A(e, t.value), t = t.next;
          return e;
        }
        drop() {
          const A = this.head;
          if (A)
            return this.head = A.next, this.head ? delete this.head.prev : delete this.tail, this._length--, A.value;
        }
        cons(A) {
          const e = { value: A, next: this.head };
          return this.head ? this.head.prev = e : this.tail = e, this.head = e, this._length++, this;
        }
        insertBefore(A, e) {
          A || illegalArgs("cell is undefined");
          const t = { value: e, next: A, prev: A.prev };
          return A.prev ? A.prev.next = t : this.head = t, A.prev = t, this._length++, this;
        }
        insertAfter(A, e) {
          A || illegalArgs("cell is undefined");
          const t = { value: e, next: A.next, prev: A };
          return A.next ? A.next.prev = t : this.tail = t, A.next = t, this._length++, this;
        }
        insertBeforeNth(A, e) {
          return A < 0 && (A += this._length), A <= 0 ? this.cons(e) : (ensureIndex(A, 0, this._length), this.insertBefore(this.nthCellUnsafe(A), e));
        }
        insertAfterNth(A, e) {
          return A < 0 && (A += this._length), A >= this._length - 1 ? this.push(e) : (ensureIndex(A, 0, this._length), this.insertAfter(this.nthCellUnsafe(A), e));
        }
        insertSorted(A, e) {
          e = e || compare;
          let t = this.head;
          for (; t; ) {
            if (e(A, t.value) <= 0)
              return this.insertBefore(t, A);
            t = t.next;
          }
          return this.push(A);
        }
        find(A) {
          let e = this.head;
          for (; e; ) {
            if (e.value === A)
              return e;
            e = e.next;
          }
        }
        findWith(A) {
          let e = this.head;
          for (; e; ) {
            if (A(e.value))
              return e;
            e = e.next;
          }
        }
        concat() {
          const A = this.copy();
          for (var e = arguments.length, t = new Array(e), g = 0; g < e; g++)
            t[g] = arguments[g];
          for (let e2 = 0; e2 < t.length; e2++) {
            let g2 = t[e2];
            A.into(g2);
          }
          return A;
        }
        into(A) {
          for (let e = 0; e < A.length; e++) {
            let t = A[e];
            this.push(t);
          }
        }
        slice() {
          let A = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.length, t = A < 0 ? A + this._length : A, g = e < 0 ? e + this._length : e;
          (t < 0 || g < 0) && illegalArgs("invalid indices: ${from} / ${to}");
          const o = new DCons();
          let I = this.nthCell(t);
          for (; I && ++t <= g; )
            o.push(I.value), I = I.next;
          return o;
        }
        splice(A) {
          let e, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, g = arguments.length > 2 ? arguments[2] : void 0;
          "number" == typeof A ? (A < 0 && (A += this._length), ensureIndex(A, 0, this._length), e = this.nthCellUnsafe(A)) : e = A;
          const o = new DCons();
          if (t > 0)
            for (; e && t-- > 0; )
              this.remove(e), o.push(e.value), e = e.next;
          else
            e && (e = e.next);
          if (g)
            if (e)
              for (let A2 = 0; A2 < g.length; A2++) {
                let t2 = g[A2];
                this.insertBefore(e, t2);
              }
            else
              for (let A2 = 0; A2 < g.length; A2++) {
                let e2 = g[A2];
                this.push(e2);
              }
          return o;
        }
        remove(A) {
          return A.prev ? A.prev.next = A.next : this.head = A.next, A.next ? A.next.prev = A.prev : this.tail = A.prev, this._length--, this;
        }
        swap(A, e) {
          if (A !== e) {
            const t = A.value;
            A.value = e.value, e.value = t;
          }
          return this;
        }
        push(A) {
          if (this.tail) {
            const e = { value: A, prev: this.tail };
            return this.tail.next = e, this.tail = e, this._length++, this;
          }
          return this.cons(A);
        }
        pop() {
          const A = this.tail;
          if (A)
            return this.tail = A.prev, this.tail ? delete this.tail.next : delete this.head, this._length--, A.value;
        }
        first() {
          return this.head && this.head.value;
        }
        peek() {
          return this.tail && this.tail.value;
        }
        setHead(A) {
          return this.head ? (this.head.value = A, this) : this.cons(A);
        }
        setTail(A) {
          return this.tail ? (this.tail.value = A, this) : this.push(A);
        }
        setNth(A, e) {
          const t = this.nthCell(A);
          return !t && illegalArgs("index out of bounds: ".concat(A)), t.value = e, this;
        }
        nth(A, e) {
          const t = this.nthCell(A);
          return t ? t.value : e;
        }
        nthCell(A) {
          if (A < 0 && (A += this._length), !(A < 0 || A >= this._length))
            return this.nthCellUnsafe(A);
        }
        rotateLeft() {
          switch (this._length) {
            case 0:
            case 1:
              return this;
            case 2:
              return this.swap(this.head, this.tail);
            default:
              return this.push(this.drop());
          }
        }
        rotateRight() {
          switch (this._length) {
            case 0:
            case 1:
              return this;
            case 2:
              return this.swap(this.head, this.tail);
            default:
              const A = this.peek();
              return this.pop(), this.cons(A);
          }
        }
        map(A) {
          const e = new DCons();
          let t = this.head;
          for (; t; )
            e.push(A(t.value)), t = t.next;
          return e;
        }
        filter(A) {
          const e = new DCons();
          let t = this.head;
          for (; t; )
            A(t.value) && e.push(t.value), t = t.next;
          return e;
        }
        reduce(A, e) {
          let t = e, g = this.head;
          for (; g; )
            t = A(t, g.value), g = g.next;
          return t;
        }
        shuffle(A) {
          let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : SYSTEM;
          if (this._length < 2)
            return this;
          for (A = null != A ? A : Math.ceil(1.5 * Math.log2(this._length)); A > 0; A--) {
            let A2 = this.head;
            for (; A2; ) {
              const t = A2.next;
              e.float() < 0.5 ? this.asHead(A2) : this.asTail(A2), A2 = t;
            }
          }
          return this;
        }
        sort() {
          let A = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : compare;
          if (!this._length)
            return this;
          let e = 1;
          for (; ; ) {
            let t = this.head;
            this.head = void 0, this.tail = void 0;
            let g = 0;
            for (; t; ) {
              g++;
              let o = t, I = 0;
              for (let A2 = 0; A2 < e && (I++, o = o.next, o); A2++)
                ;
              let i2 = e;
              for (; I > 0 || i2 > 0 && o; ) {
                let e2;
                0 === I ? (e2 = o, o = o.next, i2--) : o && 0 !== i2 ? A(t.value, o.value) <= 0 ? (e2 = t, t = t.next, I--) : (e2 = o, o = o.next, i2--) : (e2 = t, t = t.next, I--), this.tail ? this.tail.next = e2 : this.head = e2, e2.prev = this.tail, this.tail = e2;
              }
              t = o;
            }
            if (this.tail.next = void 0, g <= 1)
              return this;
            e *= 2;
          }
        }
        reverse() {
          let A = this.head, e = this.tail, t = (this._length >>> 1) + (1 & this._length);
          for (; A && e && t > 0; ) {
            const g = A.value;
            A.value = e.value, e.value = g, A = A.next, e = e.prev, t--;
          }
          return this;
        }
        asHead(A) {
          return A === this.head || (this.remove(A), this.head.prev = A, A.next = this.head, A.prev = void 0, this.head = A, this._length++), this;
        }
        asTail(A) {
          return A === this.tail || (this.remove(A), this.tail.next = A, A.prev = this.tail, A.next = void 0, this.tail = A, this._length++), this;
        }
        toString() {
          let A = [], e = this.head;
          for (; e; )
            A.push(String(e.value)), e = e.next;
          return A.join(", ");
        }
        toJSON() {
          return [...this];
        }
        nthCellUnsafe(A) {
          let e, t;
          for (A <= this._length >> 1 ? (e = this.head, t = "next") : (e = this.tail, t = "prev", A = this._length - A - 1); A-- > 0 && e; )
            e = e[t];
          return e;
        }
      }
      class LRUCache {
        constructor(A, e) {
          const t = Object.assign({ maxlen: 1 / 0, maxsize: 1 / 0, map: () => /* @__PURE__ */ new Map(), ksize: () => 0, vsize: () => 0 }, e);
          this.map = t.map(), this.items = new DCons(), this._size = 0, this.opts = t, A && this.into(A);
        }
        get length() {
          return this.items.length;
        }
        get size() {
          return this._size;
        }
        [Symbol.iterator]() {
          return this.entries();
        }
        entries() {
          return map((A) => [A.k, A], this.items);
        }
        keys() {
          return map((A) => A.k, this.items);
        }
        values() {
          return map((A) => A.v, this.items);
        }
        copy() {
          const A = this.empty();
          A.items = this.items.copy();
          let e = A.items.head;
          for (; e; )
            A.map.set(e.value.k, e), e = e.next;
          return A;
        }
        empty() {
          return new LRUCache(null, this.opts);
        }
        release() {
          this._size = 0, this.map.clear();
          const A = this.opts.release;
          if (A) {
            let e;
            for (; e = this.items.drop(); )
              A(e.k, e.v);
            return true;
          }
          return this.items.release();
        }
        has(A) {
          return this.map.has(A);
        }
        get(A, e) {
          const t = this.map.get(A);
          return t ? this.resetEntry(t) : e;
        }
        set(A, e) {
          const t = this.opts.ksize(A) + this.opts.vsize(e), g = this.map.get(A);
          return this._size += Math.max(0, t - (g ? g.value.s : 0)), this.ensureSize() && this.doSetEntry(g, A, e, t), e;
        }
        into(A) {
          for (let e = 0; e < A.length; e++) {
            let t = A[e];
            this.set(t[0], t[1]);
          }
          return this;
        }
        getSet(A, e) {
          const t = this.map.get(A);
          return t ? Promise.resolve(this.resetEntry(t)) : e().then((e2) => this.set(A, e2));
        }
        delete(A) {
          const e = this.map.get(A);
          return !!e && (this.removeEntry(e), true);
        }
        resetEntry(A) {
          return this.items.asTail(A), A.value.v;
        }
        ensureSize() {
          const A = this.opts.release, e = this.opts.maxsize, t = this.opts.maxlen;
          for (; this._size > e || this.length >= t; ) {
            const e2 = this.items.drop();
            if (!e2)
              return false;
            this.map.delete(e2.k), A && A(e2.k, e2.v), this._size -= e2.s;
          }
          return true;
        }
        removeEntry(A) {
          const e = A.value;
          this.map.delete(e.k), this.items.remove(A), this.opts.release && this.opts.release(e.k, e.v), this._size -= e.s;
        }
        doSetEntry(A, e, t, g) {
          A ? (A.value.v = t, A.value.s = g, this.items.asTail(A)) : (this.items.push({ k: e, v: t, s: g }), this.map.set(e, this.items.tail));
        }
      }
      class TLRUCache extends LRUCache {
        constructor(A, e) {
          super(A, e = Object.assign({ ttl: 36e5 }, e));
        }
        empty() {
          return new TLRUCache(null, this.opts);
        }
        has(A) {
          return void 0 !== this.get(A);
        }
        get(A, e) {
          const t = this.map.get(A);
          if (t) {
            if (t.value.t >= Date.now())
              return this.resetEntry(t);
            this.removeEntry(t);
          }
          return e;
        }
        set(A, e) {
          let t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.opts.ttl;
          const g = this.opts.ksize(A) + this.opts.vsize(e), o = this.map.get(A);
          if (this._size += Math.max(0, g - (o ? o.value.s : 0)), this.ensureSize()) {
            const I = Date.now() + t;
            o ? (o.value.v = e, o.value.s = g, o.value.t = I, this.items.asTail(o)) : (this.items.push({ k: A, v: e, s: g, t: I }), this.map.set(A, this.items.tail));
          }
          return e;
        }
        getSet(A, e) {
          let t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.opts.ttl;
          const g = this.get(A);
          return g ? Promise.resolve(g) : e().then((e2) => this.set(A, e2, t));
        }
        prune() {
          const A = Date.now();
          let e = this.items.head;
          for (; e; )
            e.value.t < A && this.removeEntry(e), e = e.next;
        }
        ensureSize() {
          const A = this.opts.maxsize, e = this.opts.maxlen, t = Date.now();
          let g = this.items.head;
          for (; g && (this._size > A || this.length >= e); )
            g.value.t < t && this.removeEntry(g), g = g.next;
          return super.ensureSize();
        }
      }
      class ChatManager extends EventBase {
        constructor(A) {
          super(A, "ChatManager"), _defineProperty$1(this, "dialogueLru", new TLRUCache(void 0, { maxlen: LRU_MAX_ITEMS, ttl: DIALOGUE_EXPIRE_TIMEOUT }));
        }
        getChatInfo(A) {
          const e = this.dialogueLru.get(A);
          if (this.dialogueLru.prune(), e) {
            const { dialogue: t2, sequence: g } = e, o = g.add(1), I = { dialogue: t2, sequence: o };
            return this.dialogueLru.set(A, { dialogue: t2, sequence: o }), I;
          }
          const t = { dialogue: getRandomUInt64(), sequence: Long$1.fromNumber(1, true) };
          return this.dialogueLru.set(A, t), t;
        }
      }
      const resetIntervalInfo = () => ({ joined: /* @__PURE__ */ new Set(), left: /* @__PURE__ */ new Set(), timeout: /* @__PURE__ */ new Set(), stateChanged: /* @__PURE__ */ new Set() });
      class ChannelPresence extends EventBase {
        constructor(A, e, t, g) {
          super(e, "ChannelPresence"), _defineProperty$1(this, "_context", void 0), _defineProperty$1(this, "channelsUsersStates", /* @__PURE__ */ new Map()), _defineProperty$1(this, "userJoinEvents", /* @__PURE__ */ new Set()), _defineProperty$1(this, "userLeftEvents", /* @__PURE__ */ new Set()), _defineProperty$1(this, "getRTMSession", void 0), _defineProperty$1(this, "timeoutInSnapshot", /* @__PURE__ */ new Map()), _defineProperty$1(this, "timeoutUsersWithoutInterval", /* @__PURE__ */ new Map()), _defineProperty$1(this, "intervalMode", /* @__PURE__ */ new Map()), _defineProperty$1(this, "intervalTimerId", /* @__PURE__ */ new Map()), _defineProperty$1(this, "intervalSnapshot", /* @__PURE__ */ new Map()), _defineProperty$1(this, "intervalInfos", /* @__PURE__ */ new Map()), _defineProperty$1(this, "backoffEventsTimer", /* @__PURE__ */ new Map()), _defineProperty$1(this, "backoffEventsMap", /* @__PURE__ */ new Map()), _defineProperty$1(this, "pendingPresenceEvent", /* @__PURE__ */ new Map()), _defineProperty$1(this, "_decoupleChannels", /* @__PURE__ */ new Map()), _defineProperty$1(this, "_decoupleChannelPromises", /* @__PURE__ */ new Map()), _defineProperty$1(this, "_intervals4CreateColl", [...CREATE_COLL_INTERVALS]), _defineProperty$1(this, "recoverPresenceTimer", void 0), _defineProperty$1(this, "requestChannelMemberList", void 0), _defineProperty$1(this, "_controlInterval", (A2, e2) => {
            var t2, g2, o, I, i2;
            const r = null !== (t2 = null === (g2 = this.channelsUsersStates.get(A2)) || void 0 === g2 ? void 0 : g2.size) && void 0 !== t2 ? t2 : 0, n = Number(getParameter("PRESENCE_THRESHOLD") || (null === (o = this._context.consoleConfig) || void 0 === o ? void 0 : o["presence.occupancy"])) || 0;
            switch (this.log("occupancy: %d, channelOccupancy: %d", n, r), this.log("(%s) is intervalMode: %s", A2, null !== (I = null === (i2 = this.intervalMode) || void 0 === i2 ? void 0 : i2.get(A2)) && void 0 !== I && I), e2) {
              case "open":
                var C, E;
                if (r >= n && !this.intervalMode.get(A2))
                  this.log("open interval mode in channel: ".concat(replaceRangeWithAsterisk(A2))), this.intervalMode.set(A2, true), this.intervalSnapshot.set(A2, this._getIntervalSnapshot(A2)), this.intervalTimerId.set(A2, setInterval(() => {
                    this.emit("presence-interval", A2);
                  }, 1e3 * (null !== (C = getParameter("PRESENCE_INTERVAL")) && void 0 !== C ? C : Number(null === (E = this._context.consoleConfig) || void 0 === E ? void 0 : E["presence.interval"])))), this.intervalInfos.set(A2, resetIntervalInfo());
                break;
              case "close":
                r < n && this.intervalMode.get(A2) && (this.log("close interval mode in channel: ".concat(replaceRangeWithAsterisk(A2))), this.intervalMode.delete(A2), this.emit("presence-interval", A2, true), this._clearIntervalById(this.intervalTimerId.get(A2)), this.intervalTimerId.delete(A2));
            }
          }), _defineProperty$1(this, "_getLocalStateCache", () => this._context.localStateCache), _defineProperty$1(this, "_handlePresenceEvent", (A2) => (e2) => {
            !getParameter("SENSITIVE_LOG") && console.log({ events: e2 }, "events");
            const t2 = this.backoffEventsMap, g2 = t2.has(A2) || this.backoffEventsTimer.has(A2), o = t2.get(A2), I = !(g2 && o);
            g2 && (clearTimeout(this.recoverPresenceTimer), this.recoverPresenceTimer = setTimeout(() => {
              var e3;
              null !== (e3 = this.getRTMSession()) && void 0 !== e3 && e3.getSynced() && (this.log("synced, recover presence"), this._recoverPresence(A2));
            }, 0));
            const { channelName: i2, channelType: r } = getChannelDetailByName(A2), n = { eventType: "SNAPSHOT", channelType: r, channelName: i2, publisher: "", stateChanged: {}, interval: null, snapshot: [], timestamp: getUTCTimeBaseREG(this._context.offsetTime) }, C = e2.length;
            try {
              for (let t3 = 0; t3 < C; t3++) {
                const { document: g3, type: o2, path: v, value: F } = e2[t3];
                if (n.publisher = g3, "DocSyncEnd" === o2) {
                  const e3 = this.pendingPresenceEvent.get(A2);
                  return void (g3 === this._context.uid ? e3 && ("doc-deleted" !== e3.type && "doc-timeout" !== e3.type || this._rePutSelfDoc(A2), this.pendingPresenceEvent.delete(A2)) : "state-changed" === (null == e3 ? void 0 : e3.type) && (I && this.emit("presence", e3.value), this.pendingPresenceEvent.delete(A2)));
                }
                if ("Put" === o2 && !v && !F) {
                  var E;
                  n.eventType = "REMOTE_JOIN";
                  const e3 = this._requestGetState(A2, g3, true);
                  if (null === (E = this.channelsUsersStates.get(A2)) || void 0 === E || E.set(g3, e3), g3 === this._context.uid)
                    this.log('"'.concat(replaceRangeWithAsterisk(g3), '" receive self presence event in channel("').concat(r, '"-"').concat(replaceRangeWithAsterisk(i2), '"), type is JOIN.'));
                  else {
                    var s, B, a, Q;
                    if (this.log("remote user(".concat(replaceRangeWithAsterisk(g3), ') join channel("').concat(r, '"-"').concat(replaceRangeWithAsterisk(i2), '") in presence subscribe callback')), this.intervalMode.get(A2))
                      if (this.log("interval mode"), null !== (B = this.intervalInfos.get(A2)) && void 0 !== B && B.timeout.has(g3))
                        null === (a = this.intervalInfos.get(A2)) || void 0 === a || a.timeout.delete(g3);
                      else
                        null === (Q = this.intervalInfos.get(A2)) || void 0 === Q || Q.joined.add(g3);
                    else
                      this.log("emit presence,controlInterval open"), I && this.emit("presence", n), this._controlInterval(A2, "open");
                    null === (s = this.timeoutUsersWithoutInterval.get(A2)) || void 0 === s || s.delete(g3);
                  }
                  return;
                }
                if ("Delete" === o2 && !v && !F) {
                  var c;
                  if (null === (c = this.channelsUsersStates.get(A2)) || void 0 === c || c.delete(g3), n.eventType = "REMOTE_LEAVE", g3 === this._context.uid)
                    this.log('"'.concat(replaceRangeWithAsterisk(g3), '" receive self presence event in channel("').concat(r, '"-"').concat(replaceRangeWithAsterisk(i2), '"), type is ').concat(n.eventType, ". will need execute logout.")), this._rePutSelfDoc(A2);
                  else {
                    var l, h;
                    if (null !== (l = this.timeoutUsersWithoutInterval.get(A2)) && void 0 !== l && l.has(g3))
                      return null === (h = this.timeoutUsersWithoutInterval.get(A2)) || void 0 === h || h.delete(g3), void this.log("timeout user(".concat(replaceRangeWithAsterisk(g3), ") left, ignore"));
                    if (this.intervalMode.get(A2)) {
                      var u, d, D;
                      if (null !== (u = this.intervalInfos.get(A2)) && void 0 !== u && u.joined.has(g3))
                        null === (d = this.intervalInfos.get(A2)) || void 0 === d || d.joined.delete(g3);
                      else
                        null === (D = this.intervalInfos.get(A2)) || void 0 === D || D.left.add(g3);
                      this._controlInterval(A2, "close");
                    } else
                      I && this.emit("presence", n);
                  }
                  return;
                }
                if ("Delete" === o2 && v === K_PRESENCE_EXPIRED) {
                  var y;
                  n.eventType = "REMOTE_JOIN";
                  const e3 = this._requestGetState(A2, g3, true);
                  if (null === (y = this.channelsUsersStates.get(A2)) || void 0 === y || y.set(g3, e3), g3 === this._context.uid)
                    this.log('"'.concat(replaceRangeWithAsterisk(g3), '" receive self presence event in channel("').concat(r, '"-"').concat(replaceRangeWithAsterisk(i2), '"), type is REJOIN.'));
                  else {
                    var p2, R2, w, _;
                    if (this.log("remote user(".concat(replaceRangeWithAsterisk(g3), ') rejoin channel("').concat(r, '"-"').concat(replaceRangeWithAsterisk(i2), '") in presence subscribe callback')), this.intervalMode.get(A2))
                      if (null !== (R2 = this.intervalInfos.get(A2)) && void 0 !== R2 && R2.timeout.has(g3))
                        null === (w = this.intervalInfos.get(A2)) || void 0 === w || w.timeout.delete(g3);
                      else
                        null === (_ = this.intervalInfos.get(A2)) || void 0 === _ || _.joined.add(g3);
                    else
                      I && this.emit("presence", n), this._controlInterval(A2, "open");
                    null === (p2 = this.timeoutUsersWithoutInterval.get(A2)) || void 0 === p2 || p2.delete(g3);
                  }
                  return;
                }
                if ("Put" === o2 && v === K_PRESENCE_EXPIRED) {
                  var S, f;
                  if (null === (S = this.channelsUsersStates.get(A2)) || void 0 === S || S.delete(g3), n.eventType = "REMOTE_TIMEOUT", g3 === this._context.uid)
                    this.log('"'.concat(replaceRangeWithAsterisk(g3), '" receive self presence event in channel("').concat(r, '"-"').concat(replaceRangeWithAsterisk(i2), '"), type is TIMEOUT.')), this.pendingPresenceEvent.set(A2, { type: "doc-timeout" });
                  else if (this.log("remote user(".concat(replaceRangeWithAsterisk(g3), ') timeout at channel("').concat(r, '"-"').concat(replaceRangeWithAsterisk(i2), '") in presence subscribe callback')), this.intervalMode.get(A2)) {
                    var N, M, k;
                    if (null !== (N = this.intervalInfos.get(A2)) && void 0 !== N && N.joined.has(g3))
                      null === (M = this.intervalInfos.get(A2)) || void 0 === M || M.joined.delete(g3);
                    else
                      null === (k = this.intervalInfos.get(A2)) || void 0 === k || k.timeout.add(g3);
                    this._controlInterval(A2, "close");
                  } else if (null === (f = this.timeoutUsersWithoutInterval.get(A2)) || void 0 === f || !f.has(g3)) {
                    var L;
                    null === (L = this.timeoutUsersWithoutInterval.get(A2)) || void 0 === L || L.add(g3), I && this.emit("presence", n);
                  }
                  return;
                }
                if (!checkKeyValidity(v[0]))
                  return void this.log("key is invalid in presence subscribe callback, key(".concat(v, ")"));
                if ("Delete" === o2 && v && !F && !e2.some((A3) => "Put" === A3.type && A3.path === K_PRESENCE_EXPIRED)) {
                  var G, b;
                  n.eventType = "REMOTE_STATE_CHANGED";
                  const o3 = null !== (G = null === (b = this.channelsUsersStates.get(A2)) || void 0 === b ? void 0 : b.get(g3)) && void 0 !== G ? G : {};
                  if (delete o3[v], n.stateChanged = _objectSpread2({}, o3), g3 === this._context.uid)
                    this.log('"'.concat(replaceRangeWithAsterisk(g3), '" receive self presence event in channel("').concat(r, '"-"').concat(replaceRangeWithAsterisk(i2), '"), type is ').concat(n.eventType, ", state is ").concat(n.stateChanged));
                  else if (v[0] !== K_SYNC_INTERNAL_KEY_PREFIX) {
                    var U;
                    if (this.intervalMode.get(A2))
                      null === (U = this.intervalInfos.get(A2)) || void 0 === U || U.stateChanged.add(g3);
                    else
                      t3 === findLastIndex$1(e2, (A3) => {
                        let { type: g4 } = A3;
                        return g4 === e2[t3].type;
                      }) && this.pendingPresenceEvent.set(A2, { type: "state-changed", value: n });
                  }
                  if (t3 === C - 1)
                    return;
                }
                if ("Put" === o2 && v && F) {
                  var m, T;
                  const e3 = null !== (m = null === (T = this.channelsUsersStates.get(A2)) || void 0 === T ? void 0 : T.get(g3)) && void 0 !== m ? m : {};
                  if (n.eventType = "REMOTE_STATE_CHANGED", e3[v] = F, n.stateChanged = _objectSpread2({}, e3), g3 === this._context.uid)
                    this.log('"'.concat(replaceRangeWithAsterisk(g3), '" receive self presence event in channel("').concat(r, '"-"').concat(replaceRangeWithAsterisk(i2), '"), type is ').concat(n.eventType, ", state is ").concat(n.stateChanged));
                  else if (v[0] !== K_SYNC_INTERNAL_KEY_PREFIX) {
                    var O;
                    if (this.intervalMode.get(A2))
                      null === (O = this.intervalInfos.get(A2)) || void 0 === O || O.stateChanged.add(g3);
                    else
                      t3 === C - 1 && this.pendingPresenceEvent.set(A2, { type: "state-changed", value: n });
                  }
                  if (t3 === C - 1)
                    return;
                }
              }
            } catch (A3) {
              this.logError("handlePresenceEvent error: %o", A3);
            }
          }), this._context = A, this.getRTMSession = t, this.requestChannelMemberList = g, this.on("presence-interval", (A2, e2) => {
            var t2, g2, o, I, i2, r, n, C;
            const { channelType: E, channelName: s } = getChannelDetailByName(A2), B = { eventType: "INTERVAL", channelType: E, channelName: s, publisher: "", stateChanged: {}, interval: { join: { users: [], userCount: 0 }, leave: { users: [], userCount: 0 }, timeout: { users: [], userCount: 0 }, userStateList: [] }, snapshot: [], timestamp: getUTCTimeBaseREG(this._context.offsetTime) }, { alreadyJoinedUsers: a, alreadyTimeoutUsers: Q } = this.intervalSnapshot.get(A2);
            null === (t2 = this.intervalInfos.get(A2)) || void 0 === t2 || t2.timeout.forEach((A3) => {
              var e3;
              a.includes(A3) && (null === (e3 = B.interval) || void 0 === e3 || e3.timeout.users.push(A3), B.interval.timeout.userCount++);
            }), null === (g2 = this.intervalInfos.get(A2)) || void 0 === g2 || g2.left.forEach((A3) => {
              var e3;
              a.includes(A3) && (null === (e3 = B.interval) || void 0 === e3 || e3.leave.users.push(A3), B.interval.leave.userCount++);
            }), null === (o = this.intervalInfos.get(A2)) || void 0 === o || o.joined.forEach((A3) => {
              B.interval.join.users.push(A3), B.interval.join.userCount++;
            });
            const c = a.filter((e3) => {
              var t3, g3;
              return !(null !== (t3 = this.intervalInfos.get(A2)) && void 0 !== t3 && t3.left.has(e3) || null !== (g3 = this.intervalInfos.get(A2)) && void 0 !== g3 && g3.timeout.has(e3));
            }).concat([...null !== (I = null === (i2 = this.intervalInfos.get(A2)) || void 0 === i2 ? void 0 : i2.joined) && void 0 !== I ? I : /* @__PURE__ */ new Set()]), l = Q.filter((e3) => {
              var t3, g3;
              return !(null !== (t3 = this.intervalInfos.get(A2)) && void 0 !== t3 && t3.joined.has(e3) || null !== (g3 = this.intervalInfos.get(A2)) && void 0 !== g3 && g3.left.has(e3));
            }).concat([...null !== (r = null === (n = this.intervalInfos.get(A2)) || void 0 === n ? void 0 : n.timeout) && void 0 !== r ? r : /* @__PURE__ */ new Set()]);
            if (null === (C = this.intervalInfos.get(A2)) || void 0 === C || C.stateChanged.forEach((e3) => {
              if (c.includes(e3)) {
                var t3, g3, o2;
                null === (t3 = this.intervalInfos.get(A2)) || void 0 === t3 || t3.stateChanged.delete(e3);
                const I2 = null !== (g3 = null === (o2 = this.channelsUsersStates.get(A2)) || void 0 === o2 ? void 0 : o2.get(e3)) && void 0 !== g3 ? g3 : {};
                B.interval.userStateList.push({ userId: e3, states: I2, statesCount: Object.keys(I2).length });
              }
            }), B.interval) {
              const { join: A3, leave: e3, timeout: t3, userStateList: g3 } = B.interval;
              (A3.userCount > 0 || e3.userCount > 0 || t3.userCount > 0 || g3.length > 0) && this.emit("presence", B);
            }
            this.intervalSnapshot.set(A2, { alreadyJoinedUsers: c, alreadyTimeoutUsers: l }), this.intervalInfos.set(A2, resetIntervalInfo()), e2 && this.timeoutUsersWithoutInterval.set(A2, new Set(l));
          }), this._context.internalEmitter.on("presence-backoff", this._startAllBackoffEventsTimer.bind(this)), this._context.internalEmitter.on("GroupEnterNotice", this._onGroupEnter.bind(this)), this._context.internalEmitter.on("GroupLeaveNotice", this._onGroupLeave.bind(this)), this._context.internalEmitter.on("presence-user-joined", (A2) => {
            let { channelName: e2, userId: t2 } = A2;
            this._emitBackoffPresenceEvents("join", e2, t2);
          }), this._context.internalEmitter.on("presence-user-left", (A2) => {
            let { channelName: e2, userId: t2 } = A2;
            this._emitBackoffPresenceEvents("left", e2, t2);
          }), this._context.internalEmitter.on("logout-clear-backoff-events-timer", () => {
            this.backoffEventsTimer.forEach((A2) => {
              clearTimeout(A2);
            }), this.backoffEventsTimer.clear(), this.backoffEventsMap.clear();
          });
        }
        leave(A) {
          const e = this.getRTMSession();
          null == e || e.leaveColl(A), this._cancelBackoffEventsTimer(A);
        }
        delChannelDoc(A) {
          const e = this.getRTMSession();
          null == e || e.delChannelDoc(A), this._context.updateLastSubOrJoinOptionsCache(A, "beQuiet", true);
        }
        cacheAllChannelCrdtState() {
          if (this._context.disablePresence)
            return;
          this._context.getAllChannelNames().forEach((A) => {
            this._context.getChannelOptionsByKey(A, "beQuiet") || this._cacheState(A);
          });
        }
        async exceptionCallback(A, e) {
          if (this._context.disablePresence)
            return;
          const { withPresence: t, beQuiet: g } = e;
          await Promise.all([t ? this.unsubPresence(A, false) : this.unsubscribeSelfPresence(A, false), g ? Promise.resolve() : this._cacheStateAndDelDoc(A)]), this.leave(A), await this._join(A, t, false), g || this._putChannelDocAndSetState(A), t && this._subPresence(A);
        }
        unsubPresence(A) {
          let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          const t = this._decoupleChannels.has(A), g = this.getRTMSession();
          if (!getParameter("DECOUPLE_SYNC") || !t) {
            const e2 = null == g ? void 0 : g.getColl(A, true, "unsubPresence");
            null == e2 || e2.UnSubscribe(), null == g || g.sendTick();
          }
          this._clearIntervalById(this.intervalTimerId.get(A)), this._clearIntervalCacheOfChannel(A), clearTimeout(this.recoverPresenceTimer), e && this._getLocalStateCache().delete(A), this._context.updateLastSubOrJoinOptionsCache(A, "withPresence", false);
        }
        leaveRetryChannels(A) {
          this.info("leaveRetryChannels: %o", A), A.forEach((A2) => {
            this._decoupleChannels.delete(A2), this._decoupleChannelPromises.delete(A2);
          });
        }
        unsubscribeSelfPresence(A) {
          let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          const t = this._decoupleChannels.has(A), g = this.getRTMSession();
          if (!getParameter("DECOUPLE_SYNC") || !t) {
            const e2 = null == g ? void 0 : g.getColl(A, true, "unsubPresence");
            null == e2 || e2.UnSubscribe(), null == g || g.sendTick();
          }
          e && this._getLocalStateCache().delete(A);
        }
        intervalCreateColl() {
          this._context.disablePresence || this._decoupleChannels.forEach((A, e) => {
            const t = Date.now(), { createTs: g = t, retryCnt: o = 0 } = A;
            t - g >= this._getExpectedRetryTs(o) && !A.creating && (this.info("intervalCreateColl, channel: %s, diff: %d, retryCnt: %d", e, t - g, o), this.joinPresenceColl(e, A, false));
          });
        }
        async joinPresenceColl(A, e) {
          var t, g, o;
          let I = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
          if (this.info("joinPresenceColl: %s, customOperation: %s, withPresence: %s", A, I, e.withPresence), null !== (t = this._decoupleChannels.get(A)) && void 0 !== t && t.creating && this.leave(A), this._decoupleChannels.has(A) || this._decoupleChannels.set(A, _objectSpread2(_objectSpread2({}, e), {}, { creating: true })), this._decoupleChannels.has(A) && I) {
            const t2 = this._decoupleChannels.get(A);
            this._decoupleChannels.set(A, _objectSpread2(_objectSpread2(_objectSpread2({}, t2), e), {}, { creating: true }));
          }
          I || this._decoupleChannels.set(A, _objectSpread2(_objectSpread2({}, e), {}, { creating: true }));
          const i2 = null !== (g = null === (o = this._decoupleChannels.get(A)) || void 0 === o ? void 0 : o.createTs) && void 0 !== g ? g : Date.now(), { withPresence: r, reJoinCauseReconnect: n = false, needCreateColl: C } = e;
          try {
            if (C) {
              const e2 = this._join(A, r, n);
              this._decoupleChannelPromises.set(A, e2), await e2, this._cancelBackoffEventsTimer(A);
            }
            this.info("onCreateCollection: %s, needCreateColl: %s", A, C), this._onCreateCollection(A, e), this._decoupleChannels.delete(A);
          } catch (t2) {
            var E, s;
            const g2 = null !== (E = null === (s = this._decoupleChannels.get(A)) || void 0 === s ? void 0 : s.retryCnt) && void 0 !== E ? E : 0;
            if (!getParameter("DECOUPLE_SYNC"))
              throw this._decoupleChannels.delete(A), this.info("(%s) joinPresenceColl error, need to reset withPresence false and beQuiet true", A), this._context.updateLastSubOrJoinOptionsCache(A, "withPresence", false), this._context.updateLastSubOrJoinOptionsCache(A, "beQuiet", true), t2;
            var B;
            if (this.logError("joinPresenceColl error: %s, retryCnt: %d, withPresence: %s, error: %o", A, g2, e.withPresence, t2), this._decoupleChannels.has(A) && null !== (B = this._decoupleChannels.get(A)) && void 0 !== B && B.creating) {
              var a;
              const t3 = null !== (a = this._decoupleChannels.get(A)) && void 0 !== a ? a : e;
              this._decoupleChannels.set(A, _objectSpread2(_objectSpread2({}, t3), {}, { createTs: i2, creating: false, retryCnt: g2 + 1 })), t3.withPresence && this._handleCreateCollError(A);
            }
          } finally {
            this._decoupleChannelPromises.delete(A);
          }
        }
        _cacheState(A) {
          try {
            this._getStateAndSetByLocal(A);
          } catch (A2) {
            this.logError("cacheState error: %o", A2);
          }
        }
        _cacheStateAndDelDoc(A) {
          this._cacheState(A), this.delChannelDoc(A);
        }
        _clearIntervalById(A) {
          clearInterval(A);
        }
        _getIntervalSnapshot(A) {
          var e, t;
          const g = [...null !== (e = this.timeoutUsersWithoutInterval.get(A)) && void 0 !== e ? e : /* @__PURE__ */ new Set()], o = [];
          return null === (t = this.channelsUsersStates.get(A)) || void 0 === t || t.forEach((A2, e2) => {
            g.includes(e2) || o.push(e2);
          }), { alreadyJoinedUsers: o, alreadyTimeoutUsers: g };
        }
        _clearIntervalCacheOfChannel(A) {
          this.timeoutInSnapshot.delete(A), this.intervalMode.delete(A), this.intervalTimerId.delete(A), this.intervalInfos.delete(A), this.timeoutUsersWithoutInterval.delete(A), this.intervalSnapshot.delete(A);
        }
        _emitPresenceSnapshot(A) {
          const e = this._getCollUsers(A, true), t = /* @__PURE__ */ new Map();
          this.timeoutInSnapshot.set(A, /* @__PURE__ */ new Set()), this.log("presence snapshot: %o", e);
          const g = e.filter((e2) => {
            var g2;
            let { userId: o2, states: I2 } = e2;
            return (null === (g2 = this.timeoutInSnapshot.get(A)) || void 0 === g2 || !g2.has(o2)) && (t.set(o2, I2), true);
          });
          this.channelsUsersStates.set(A, t);
          const { channelName: o, channelType: I } = getChannelDetailByName(A), i2 = { eventType: "SNAPSHOT", channelType: I, channelName: o, publisher: "", stateChanged: {}, interval: null, snapshot: g, timestamp: getUTCTimeBaseREG(this._context.offsetTime) };
          this.emit("presence", i2);
        }
        _recoverPresence(A) {
          this.backoffEventsMap.get(A) && this._emitPresenceSnapshot(A), this._cancelBackoffEventsTimer(A);
        }
        async _join(A, e) {
          let t = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          const g = !t, o = Date.now();
          try {
            const g2 = t ? "re-" : "", o2 = A.includes(STREAM_CHANNEL_PREFIX), I = o2 ? OperationName.join : OperationName.subscribe, i2 = this.getRTMSession();
            if (null == i2 || i2.validateSyncConnected(I), null !== (null == i2 ? void 0 : i2.getColl(A)))
              return void this.log("".concat(g2).concat(I, " channel(").concat(replaceRangeWithAsterisk(A), ") already."));
            this.log("".concat(SYNC_RPC_START, ": ").concat(g2).concat(I, " channel(").concat(replaceRangeWithAsterisk(A), ")"));
            const r = Date.now();
            await timeoutPromise(i2.createColl(A, e ? ["*"] : [this._context.uid], e ? ["*"] : [this._context.uid]), COMMON_REQUEST_TIMEOUT, I, o2 ? RTMErrorCode.RTM_ERROR_CHANNEL_JOIN_FAILED : RTMErrorCode.RTM_ERROR_CHANNEL_SUBSCRIBE_TIMEOUT);
            const n = Date.now();
            this.log("".concat(SYNC_RPC_END, ": ").concat(g2).concat(I, " channel(").concat(replaceRangeWithAsterisk(A), ") succeed. cost: ").concat(n - r, "ms.")), e || this._withoutPresenceSubSelf(A);
          } catch (A2) {
            throw A2;
          } finally {
            if (g) {
              const { channelName: e2, channelType: t2 } = getChannelDetailByName(A), g2 = this._context.incGetSeq();
              this._context.addReportEvents("ChannelPresenceSnapshotEvent", { channelName: e2, channelType: ChannelTypeEnum[t2], userId: this._context.uid, sid: this._context.sid, lts: Long$1.fromNumber(Date.now()), elapse: Long$1.fromNumber(Date.now() - o), vid: Long$1.fromString(getParameter("VID").get(this._context.appId) || "0"), reqId: g2 });
            }
          }
        }
        _onCreateCollection(A, e) {
          const { needDelDoc: t, needPutDoc: g = false, needSub: o = false, reJoinCauseReconnect: I = false } = e;
          t && this._cacheStateAndDelDoc(A), g && this._putChannelDocAndSetState(A, I), o && this._subPresence(A);
        }
        _withoutPresenceSubSelf(A) {
          const e = this.getRTMSession(), t = null == e ? void 0 : e.getColl(A, true, "withoutPresenceSubSelf"), g = null == t ? void 0 : t.Subscribe();
          null == g || g.addListener("document-events", (e2) => {
            const t2 = e2.length;
            for (let g2 = 0; g2 < t2; g2++) {
              const { document: t3, type: o, path: I, value: i2 } = e2[g2];
              if (t3 === this._context.uid) {
                if ("DocSyncEnd" === o) {
                  const e3 = this.pendingPresenceEvent.get(A);
                  return void (e3 && ("doc-deleted" !== e3.type && "doc-timeout" !== e3.type || this._rePutSelfDoc(A), this.pendingPresenceEvent.delete(A)));
                }
                "Put" === o && I === K_PRESENCE_EXPIRED && this.pendingPresenceEvent.set(A, { type: "doc-timeout" }), "Delete" !== o || I || i2 || this._rePutSelfDoc(A);
              }
            }
          });
        }
        _subPresence(A) {
          var e;
          this._subAndAddPresenceEventListener(A), this._emitPresenceSnapshot(A), this.timeoutUsersWithoutInterval.set(A, null !== (e = this.timeoutInSnapshot.get(A)) && void 0 !== e ? e : /* @__PURE__ */ new Set()), this._controlInterval(A, "open"), this._context.updateLastSubOrJoinOptionsCache(A, "withPresence", true);
        }
        _getEventIdStr(A, e) {
          const t = A.toString();
          return e.toString() + t;
        }
        _onGroupEnter() {
          return (A) => {
            let { user: e, group: t, seq: g, instance: o } = A;
            if (e === this._context.uid)
              return;
            const I = t + e + this._getEventIdStr(g, o);
            this.userJoinEvents.has(I) ? this.userJoinEvents.delete(I) : (this.userJoinEvents.add(I), this._emitBackoffPresenceEvents("join", t, e));
          };
        }
        _onGroupLeave() {
          return (A) => {
            let { user: e, group: t, seq: g, instance: o } = A;
            if (e === this._context.uid)
              return;
            const I = t + e + this._getEventIdStr(g, o);
            this.userLeftEvents.has(I) ? this.userLeftEvents.delete(I) : (this.userLeftEvents.add(I), this._emitBackoffPresenceEvents("left", t, e));
          };
        }
        _subAndAddPresenceEventListener(A) {
          const e = this.getRTMSession(), t = null == e ? void 0 : e.getColl(A, true, "subAndAddPresenceEventListener"), g = null == t ? void 0 : t.Subscribe();
          null == g || g.addListener("document-events", this._handlePresenceEvent(A));
        }
        _requestGetState(A, e) {
          var t;
          let g = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          const o = this.getRTMSession();
          g || e === this._context.uid || null == o || o.validateSyncConnected(OperationName.presenceGetState);
          const I = OperationName.presenceGetState, i2 = null == o ? void 0 : o.getColl(A, true, "requestGetState"), r = null == i2 ? void 0 : i2.Doc(e);
          if (isNil$1(r)) {
            const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_PRESENCE_USER_NOT_EXIST);
            throw new RtmUnavailableError(I, [e2], A2);
          }
          const n = null !== (t = null == r ? void 0 : r.Get()) && void 0 !== t ? t : {};
          return this._delKeyExpired(n), n;
        }
        _delKeyExpired(A) {
          delete A[K_PRESENCE_EXPIRED];
        }
        _getCollUsers(A, e) {
          var t, g;
          const o = null === (t = this.getRTMSession()) || void 0 === t ? void 0 : t.getColl(A, true, "getCollUsers"), I = null !== (g = null == o ? void 0 : o.Docs()) && void 0 !== g ? g : /* @__PURE__ */ new Map(), i2 = [];
          return I.forEach((t2, g2) => {
            const o2 = t2.Get(), I2 = o2[K_PRESENCE_EXPIRED];
            var r;
            (this._delKeyExpired(o2), I2) && (null === (r = this.timeoutInSnapshot.get(A)) || void 0 === r || r.add(g2));
            I2 || i2.push({ userId: g2, states: e ? o2 : {}, statesCount: e ? Object.keys(o2).length : 0 });
          }), i2;
        }
        async _emitBackoffPresenceEvents(A, e, t) {
          if (this.backoffEventsMap.has(e) && this._context.getChannelOptionsByKey(e, "withPresence")) {
            switch (A) {
              case "join":
                this._emitUserJoinUseReg(e, t);
                break;
              case "left":
                this._emitUserLeftUseReg(e, t);
                break;
              case "snapshot":
                await this._emitSnapshotUseReg(e);
            }
            this.backoffEventsMap.set(e, true);
          }
        }
        _emitUserJoinUseReg(A, e) {
          const { channelName: t, channelType: g } = getChannelDetailByName(A), o = { eventType: "REMOTE_JOIN", channelType: g, channelName: t, publisher: e, stateChanged: {}, interval: null, snapshot: [], timestamp: getUTCTimeBaseREG(this._context.offsetTime) };
          this.emit("presence", o);
        }
        _emitUserLeftUseReg(A, e) {
          const { channelName: t, channelType: g } = getChannelDetailByName(A), o = { eventType: "REMOTE_LEAVE", channelType: g, channelName: t, publisher: e, stateChanged: {}, interval: null, snapshot: [], timestamp: getUTCTimeBaseREG(this._context.offsetTime) };
          this.emit("presence", o);
        }
        async _emitSnapshotUseReg(A) {
          try {
            const e = { eventType: "SNAPSHOT", channelType: "MESSAGE", channelName: A, publisher: "", stateChanged: {}, interval: null, snapshot: (await this.requestChannelMemberList(A)).memberInfos.map((A2) => {
              var e2;
              return { userId: null !== (e2 = A2.account) && void 0 !== e2 ? e2 : "", states: {}, statesCount: 0 };
            }), timestamp: getUTCTimeBaseREG(this._context.offsetTime) };
            this.emit("presence", e);
          } catch (A2) {
          }
        }
        _handleCreateCollError(A) {
          [...this.backoffEventsMap.keys()].filter((e) => e !== A).length > 0 ? this._changeSourceToReg(A) : this._startBackoffEventsTimer(A);
        }
        _changeSourceToReg(A) {
          var e;
          if (this.backoffEventsMap.has(A))
            return;
          this.log("".concat(A, " change source to reg")), this.backoffEventsMap.set(A, false);
          const { channelType: t } = getChannelDetailByName(A);
          "MESSAGE" === t && null === (null === (e = this.getRTMSession()) || void 0 === e ? void 0 : e.getColl(A)) && this._emitBackoffPresenceEvents("snapshot", A);
        }
        _getPresenceBackoffEventInterval() {
          const A = getParameter("PRESENCE_BACKOFF_EVENT_INTERVAL");
          return 1e3 * Number(null != A ? A : 0) || PRESENCE_BACKOFF_EVENT_INTERVAL;
        }
        _startBackoffEventsTimer(A) {
          if (this.backoffEventsTimer.has(A) || this.backoffEventsMap.has(A))
            return;
          if (!this._context.getChannelOptionsByKey(A, "withPresence"))
            return;
          const e = setTimeout(() => {
            this._changeSourceToReg(A);
          }, this._getPresenceBackoffEventInterval());
          this.backoffEventsTimer.set(A, e);
        }
        _startAllBackoffEventsTimer() {
          this.log("start backoff all channels timer");
          this._context.getAllChannelNames().forEach((A) => {
            this._startBackoffEventsTimer(A);
          });
        }
        _cancelBackoffEventsTimer(A) {
          (this.backoffEventsTimer.has(A) || this.backoffEventsMap.has(A)) && this.log("".concat(A, " change source to sync")), this.backoffEventsTimer.has(A) && clearTimeout(this.backoffEventsTimer.get(A)), this.backoffEventsMap.delete(A);
        }
        _getExpectedRetryTs(A) {
          let e = 0;
          const t = this._intervals4CreateColl.length;
          if (A > t)
            return 1e3 * (this._intervals4CreateColl.reduce((A2, e2) => A2 + e2, 0) + (A - t) * this._intervals4CreateColl[t - 1]);
          for (let t2 = 0; t2 < A; t2++)
            e += this._intervals4CreateColl[t2];
          return 1e3 * e;
        }
        _rePutSelfDoc(A) {
          this.log("Try rejoin channel(".concat(A, ") when reconnected."));
          try {
            const { beQuiet: e } = this._context.getChannelLastSubOrJoinOptions(A);
            e || (this.log("presence coll exists, need restore doc and states, channelId is ", A), this._putChannelDocAndSetState(A, true));
          } catch (A2) {
            this.warn("restore presence failed, %o", A2);
          }
        }
        _getStateAndSetByLocal(A) {
          const e = null == this ? void 0 : this._requestGetState(A, this._context.uid, true), t = /* @__PURE__ */ new Map();
          e && Object.keys(e).forEach((A2) => {
            t.set(A2, e[A2]);
          }), null == this || this._getLocalStateCache().set(A, t);
        }
        _putChannelDocAndSetState(A) {
          var e, t;
          let g = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          const o = this.getRTMSession(), I = null == o ? void 0 : o.getColl(A, true, "putChannelDocAndSetState"), i2 = {};
          (null !== (e = this._getLocalStateCache().get(A)) && void 0 !== e ? e : /* @__PURE__ */ new Map()).forEach((A2, e2) => {
            i2[e2] = A2;
          }), this.log("local states: %o, reJoinCauseReconnect: %s", i2, g);
          const r = null == I ? void 0 : I.Doc(this._context.uid), n = !!r, C = null !== (t = null == r ? void 0 : r.Get()) && void 0 !== t ? t : {};
          this.log("remote doc exist: ".concat(n, ", remote state: %o"), C), n && C[K_PRESENCE_EXPIRED] && (null == I || I.DelDoc(this._context.uid)), n && !C[K_PRESENCE_EXPIRED] || (null == I || I.PutDoc(this._context.uid), this.log("Put channel(".concat(replaceRangeWithAsterisk(A), ") document succeed.")));
          const E = null == I ? void 0 : I.Doc(this._context.uid);
          if (null == o || o.setAutoKeepalive(A), null == o || o.sendTick(), g || this._getLocalStateCache().has(A)) {
            if (this.log("update user state in channel(".concat(replaceRangeWithAsterisk(A), ") local cache.")), !n || C[K_PRESENCE_EXPIRED])
              this.log("remote doc not exist or expired, directly set"), null == E || E.Set(i2);
            else {
              const A2 = Object.keys(C).filter((A3) => !i2.hasOwnProperty(A3) && A3 !== K_PRESENCE_EXPIRED);
              A2.length > 0 && (null == E || E.Del(A2));
              const e2 = Object.keys(i2).filter((A3) => !C.hasOwnProperty(A3) || C[A3] !== i2[A3]);
              e2.length > 0 && (null == E || E.Set(i2)), this.log("diff state: %o", { addOrChangedKeys: e2, needDelKeys: A2 });
            }
            null == o || o.sendTick();
          } else
            this.log("first join presence and without local state");
          this._context.updateLastSubOrJoinOptionsCache(A, "beQuiet", false);
        }
      }
      var _exec, _window;
      const chromeVersion = null === (_exec = /Chrome\/([0-9.]+)/.exec(null === (_window = window) || void 0 === _window || null === (_window = _window.navigator) || void 0 === _window ? void 0 : _window.userAgent)) || void 0 === _exec || null === (_exec = _exec[1]) || void 0 === _exec ? void 0 : _exec.split(".")[0];
      if (chromeVersion && parseInt(chromeVersion, 10) >= 88 && !isMobile$1()) {
        var _hiddenCanvas$getCont;
        const A = document.createElement("video"), e = document.createElement("canvas");
        A.setAttribute("style", "display:none"), A.setAttribute("muted", ""), A.muted = true, A.setAttribute("autoplay", ""), A.autoplay = true, A.setAttribute("playsinline", ""), e.setAttribute("style", "display:none"), e.setAttribute("width", "1"), e.setAttribute("height", "1"), null === (_hiddenCanvas$getCont = e.getContext("2d")) || void 0 === _hiddenCanvas$getCont || _hiddenCanvas$getCont.fillRect(0, 0, 1, 1), A.srcObject = null == e ? void 0 : e.captureStream();
      }
      const updateWasmLogLevel = (A) => {
      };
      class RTMImpl extends EventBase {
        constructor(A, e, t) {
          super(A, "RTMImpl", true), _defineProperty$1(this, "presence", void 0), _defineProperty$1(this, "storage", void 0), _defineProperty$1(this, "lock", void 0), _defineProperty$1(this, "history", void 0), _defineProperty$1(this, "_context", void 0), _defineProperty$1(this, "_processId", void 0), _defineProperty$1(this, "_rtmSession", void 0), _defineProperty$1(this, "_channelPresence", void 0), _defineProperty$1(this, "_customConfig", void 0), _defineProperty$1(this, "_suspendedTimer", null), _defineProperty$1(this, "_createCollInterval", null), _defineProperty$1(this, "_streamChannelList", []), _defineProperty$1(this, "_stChannelInstances", /* @__PURE__ */ new Map()), _defineProperty$1(this, "_lastLoginTime", void 0), _defineProperty$1(this, "_connectionState", "DISCONNECTED"), _defineProperty$1(this, "_linkState", "IDLE"), _defineProperty$1(this, "_suspended", false), _defineProperty$1(this, "_reconnId", 0), _defineProperty$1(this, "_channelMetadataSub", /* @__PURE__ */ new Set()), _defineProperty$1(this, "_apiRateLimit", new ApiRateLimiter()), _defineProperty$1(this, "_lockSnapshotLastTime", /* @__PURE__ */ new Map()), _defineProperty$1(this, "_lockEventInfos", /* @__PURE__ */ new Map()), _defineProperty$1(this, "_channelMetaEventInfos", /* @__PURE__ */ new Map()), _defineProperty$1(this, "_userMetaEventInfos", /* @__PURE__ */ new Map()), _defineProperty$1(this, "_notifyLockReSub", new Subject()), _defineProperty$1(this, "_notifyChannelMetaReSub", new Subject()), _defineProperty$1(this, "_notifyChannelReSub", new Subject()), _defineProperty$1(this, "_rtmSubscriptions", { lockSubs: /* @__PURE__ */ new Map(), metadataSubs: /* @__PURE__ */ new Map(), channels: /* @__PURE__ */ new Map() }), _defineProperty$1(this, "_dialPendingMsgSubjectMap", /* @__PURE__ */ new Map()), _defineProperty$1(this, "_dialogueSequenceLru", new LRUCache(void 0, { maxlen: LRU_MAX_ITEMS })), _defineProperty$1(this, "_msgDedupLru", new LRUCache(void 0, { maxlen: MSG_DEDUP_MAX_LEN })), _defineProperty$1(this, "_chatManager", void 0), _defineProperty$1(this, "_tokenPrivilegeWillExpireHandler", (A2) => {
            this.emit("tokenPrivilegeWillExpire", ""), this.emit("token", { eventType: "WILL_EXPIRE", reason: TokenEventReason.WILL_EXPIRE, affectedResources: A2, timestamp: getUTCTimeBaseREG(this._context.offsetTime) });
          }), _defineProperty$1(this, "_userDropHandler", async (A2) => {
            if ("FAILED" === this._connectionState)
              return;
            let e2 = "INTERRUPTED", t2 = LinkStateChangeReasonDescription.UNKNOWN, g = "UNKNOWN";
            switch (A2) {
              case 2:
                this.logError("Server banned because of token is expired, ticket expired."), e2 = "TOKEN_EXPIRED", t2 = LinkStateChangeReasonDescription.TOKEN_EXPIRED, g = "TOKEN_EXPIRED";
                break;
              case RegServerErrorCode.kRejoined:
                this.logError("Kicked off by remote session"), e2 = "SAME_UID_LOGIN", t2 = LinkStateChangeReasonDescription.SAME_UID_LOGIN, g = "SAME_UID_LOGIN";
                break;
              case RegServerErrorCode.kJoinTooFrequently:
                this.logError("login too frequent"), e2 = "REJECTED_BY_SERVER", t2 = LinkStateChangeReasonDescription.LOGIN_TOO_FREQUENT, g = "LOGIN_TOO_FREQUENT";
                break;
              case RegServerErrorCode.kUserBannedByAuth:
                this.logError("Kicked off by authorization"), e2 = "KICKED_OUT_BY_SERVER", t2 = LinkStateChangeReasonDescription.KICKED_OUT_BY_SERVER, g = "KICKED_OUT_BY_SERVER";
                break;
              default:
                this.logError("User kicked off for unknown code: ".concat(A2));
            }
            this._updateLinkState("FAILED", "SERVER_REJECT", this._getUsedMessageChannelIds(), g, t2), this._onConnectionStateChanged("FAILED", e2);
          }), _defineProperty$1(this, "_userMetaDataUpdatedHandler", (A2) => {
            var e2, t2;
            let { uid: g, data: o } = A2;
            if ((null !== (e2 = this._userMetaEventInfos.get(g)) && void 0 !== e2 ? e2 : -1) >= o.majorRevision || !this.storage.storageImpl.isSubedUserMetadata(g))
              return void this.log("user(".concat(replaceRangeWithAsterisk(g), ") meta not changed or not subscribed, ignore."));
            const I = {};
            o.items.map((A3) => {
              var e3;
              I[null == A3 ? void 0 : A3.getKey()] = { value: null !== (e3 = A3.getValue()) && void 0 !== e3 ? e3 : "", revision: A3.getRevision(), updated: A3.getUpdateTs(), authorUid: A3.getAuthorUserId() };
            });
            const i2 = { totalCount: null == o || null === (t2 = o.items) || void 0 === t2 ? void 0 : t2.length, majorRevision: null == o ? void 0 : o.majorRevision, metadata: I };
            let r = "UPDATE";
            this._userMetaEventInfos.has(g) || (r = "SNAPSHOT");
            const n = { channelType: "USER", channelName: "", publisher: g, storageType: "USER", data: i2, eventType: r, timestamp: getUTCTimeBaseREG(this._context.offsetTime) };
            this._userMetaEventInfos.set(g, o.majorRevision), this.emit("storage", n);
          }), _defineProperty$1(this, "_onChannelTextMessage", (A2) => {
            let { memberId: e2, text: t2, channelId: g, customType: o, channelType: I } = A2;
            const i2 = { channelName: g, channelType: I, topicName: "", message: t2, publisher: e2, messageType: "STRING", customType: o, timestamp: getUTCTimeBaseREG(this._context.offsetTime) };
            this.emit("message", i2);
          }), _defineProperty$1(this, "_onChannelRawMessage", (A2) => {
            let { raw: e2, memberId: t2, channelId: g, customType: o, channelType: I } = A2;
            const i2 = { channelName: g, channelType: I, topicName: "", message: e2, publisher: t2, messageType: "BINARY", customType: o, timestamp: getUTCTimeBaseREG(this._context.offsetTime) };
            this.emit("message", i2);
          }), _defineProperty$1(this, "_onChannelMetaDataUpdated", (A2) => {
            var e2, t2;
            let { channelId: g, data: o } = A2;
            if ((null !== (e2 = this._channelMetaEventInfos.get(g)) && void 0 !== e2 ? e2 : -1) >= o.majorRevision || !this._channelMetadataSub.has(g))
              return void this.log("channel(".concat(g, ") meta not changed or not subscribed, ignore."));
            const { channelName: I, channelType: i2 } = getChannelDetailByName(g), r = {};
            o.items.map((A3) => {
              var e3;
              r[null == A3 ? void 0 : A3.getKey()] = { value: null !== (e3 = A3.getValue()) && void 0 !== e3 ? e3 : "", revision: A3.getRevision(), updated: A3.getUpdateTs(), authorUid: A3.getAuthorUserId() };
            });
            const n = { totalCount: null == o || null === (t2 = o.items) || void 0 === t2 ? void 0 : t2.length, majorRevision: null == o ? void 0 : o.majorRevision, metadata: r };
            let C = "UPDATE";
            this._channelMetaEventInfos.has(g) || (C = "SNAPSHOT");
            const E = { channelType: i2, channelName: I, publisher: "", storageType: "CHANNEL", data: n, eventType: C, timestamp: getUTCTimeBaseREG(this._context.offsetTime) };
            this._channelMetaEventInfos.set(g, o.majorRevision), this.emit("storage", E);
          }), _defineProperty$1(this, "_onLogout", () => {
            const A2 = OperationName.logout;
            this._validateRTMSessionExist(A2);
            try {
              this._clearChannel(this._context.getAllChannelNames());
            } catch (A3) {
            }
            this._context.internalEmitter.removeListener("LOGOUT", this._onLogout);
          }), _defineProperty$1(this, "_onChannelLockEvent", (A2) => {
            const { channelName: e2, channelType: t2 } = A2, g = getChannelNameByType(e2, t2);
            this._context.getChannelOptionsByKey(g, "withLock") && this.emit("lock", A2);
          }), this._context = t, this._processId = e, this.setMaxListeners(512), window.addEventListener("offline", () => {
            this.warn("network-state-change: ONLINE -> OFFLINE");
          }), window.addEventListener("online", () => {
            var A2;
            this.log("network-state-change: OFFLINE -> ONLINE"), null === (A2 = this._rtmSession) || void 0 === A2 || A2.notifyNetworkChange(true);
          }), this._addEventsFromContext(), this.lock = new Lock(A, this._context, () => this._rtmSession, this._validateRtmConnection.bind(this)), this.presence = new Presence(A, this._context, () => this._rtmSession, () => this._linkState, () => {
            var A2;
            return null === (A2 = this._channelPresence) || void 0 === A2 ? void 0 : A2.backoffEventsMap;
          }, this._requestChannelMemberList.bind(this)), this.storage = new RStorage(A, this._context, () => this._rtmSession, this._validateRtmConnection.bind(this), this.lock.lockImpl.localAcquiredLocks, this._channelMetaEventInfos, this._userMetaEventInfos), this.history = new History(A, this._context, () => this._rtmSession, this._validateRtmConnection.bind(this)), this._channelPresence = new ChannelPresence(this._context, A, () => this._rtmSession, this._requestChannelMemberList.bind(this)), this._channelPresence.on("presence", (A2) => {
            this.emit("presence", A2);
          }), this.log("rtm use private config: %s, enable cloud proxy: %s", this._context.enablePrivate, this._context.config.cloudProxy), this._context.enablePrivate || (this._customConfig = new CustomConfig(this._context.appId)), this._chatManager = new ChatManager(A);
        }
        async login(A) {
          var e, t, g;
          const o = "FAILED" === this._linkState;
          o && this._channelPresence.cacheAllChannelCrdtState();
          const I = Array.from(null !== (e = this._context.getAllChannelNames()) && void 0 !== e ? e : []), i2 = [], r = OperationName.login;
          let n = null == A ? void 0 : A.token;
          if ("CONNECTING" === this._linkState) {
            const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_DUPLICATE_OPERATION);
            throw new RtmUnavailableError(r, [e2], A2);
          }
          const C = null === this._context.instanceId, E = null !== (t = this._context.instanceId) && void 0 !== t ? t : getRandomUInt64();
          this._context.instanceId = E, this._context.sid = getSid(E), "IDLE" === this._linkState && this._updateLinkState("CONNECTING", "LOGIN", [], "LOGIN", LinkStateChangeReasonDescription.LOGIN);
          const s = { timestamp: 0 };
          if ("CONNECTED" === this._linkState)
            return s;
          if (["SUSPENDED", "DISCONNECTED"].includes(this._linkState))
            return this._updateLinkState("CONNECTING", "LOGIN", [], "RELOGIN", LinkStateChangeReasonDescription.RELOGIN), s;
          "FAILED" === this._linkState && this._updateLinkState("CONNECTING", "LOGIN", [], "RELOGIN", LinkStateChangeReasonDescription.RELOGIN);
          try {
            if (this._context.rtmConfig.privateConfig && !this._context.rtmConfig.privateConfig.serviceType.includes("MESSAGE")) {
              const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_SERVICE_NOT_SUPPORTED);
              throw new RtmUnavailableError(r, [e2], A2);
            }
            if (this._apiRateLimit.canMakeOperation("login"), n && validateToken(n, this._context.appId, r, (A2) => {
              this.warn(A2);
            }), validateKey(this._context.uid, r, "uid"), (null == A ? void 0 : A.token) === this._context.appId && (n = void 0), !isNil$1(n) && "string" != typeof n) {
              const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_INVALID_TOKEN);
              throw new RtmInvalidArgumentError(r, [e2], A2);
            }
            this._context.enablePrivate && areaConfig && throwInvalidPrivateConfig(r, " Use private config, not permit setArea");
          } catch (A2) {
            const { errorCode: e2 } = A2;
            throw this._handleLoginFailedState(e2), A2;
          }
          this._context.internalEmitter.removeListener("LOGOUT", this._onLogout), this._context.internalEmitter.once("LOGOUT", this._onLogout), changeBusyStatus(true), this._context.token = null == A ? void 0 : A.token, this.info("RTM Client logging in as ".concat(replaceRangeWithAsterisk(this._context.uid))), C && this._context.sendReport("Session", { appId: this._context.appId, did: navigator.userAgent, elapse: getElapse(this._context.startTime), index: { index1: this._context.uid, index2: this._context.appId, index3: "logUpload=".concat(this._context.config.logUpload) }, installId: this._processId, lts: Long$1.fromNumber(Date.now()), os: WEB_PLATFORM_TYPE, sid: getSid(E), token: n || "", userId: this._context.uid, ver: VERSION, buildno: 100 * VERSION_NO + SUBVERSION, subVersion: SUBVERSION, version: VERSION_NO }), null === (g = this._customConfig) || void 0 === g || g.init(this._context.sid);
          const B = Date.now();
          try {
            var a;
            await this._loginImpl({ uid: this._context.uid, instanceId: E }), this._onConnectionStateChanged("CONNECTED", "LOGIN_SUCCESS"), this._context.addReportEvents("LoginResult", { lts: Long$1.fromNumber(Date.now()), vid: Long$1.fromString(getParameter("VID").get(this._context.appId) || "0"), sid: this._context.sid, code: null !== (a = this._rtmSession) && void 0 !== a && a.getSyncConnected() ? 0 : RTMErrorCode.RTM_ERROR_PRESENCE_NOT_CONNECTED, elapse: getElapse(this._context.startTime), userId: this._context.uid }), this._updateLinkState("CONNECTED", "LOGIN", [], "LOGIN_SUCCESS", LinkStateChangeReasonDescription.LOGIN_SUCCESS);
            try {
              if (o) {
                const A2 = await Promise.all([...null == I ? void 0 : I.map((A3) => {
                  var e2;
                  const { channelName: t2, channelType: g2 } = getChannelDetailByName(A3), o2 = this._context.getChannelLastSubOrJoinOptions(A3);
                  let I2 = "";
                  const i3 = !(null != o2 && o2.beQuiet), r2 = null == o2 ? void 0 : o2.withPresence;
                  if (o2 && "MESSAGE" === g2)
                    I2 = t2;
                  else {
                    if (!o2 || "STREAM" !== g2)
                      return Promise.resolve();
                    I2 = getChannelNameByType(t2, "STREAM");
                  }
                  return this._context.notInChannel(I2) ? Promise.resolve() : this._attend(I2, { unsubSelfColl: false, unsubColl: false, destroyColl: false }, { withPresence: null !== (e2 = o2.withPresence) && void 0 !== e2 && e2, needCreateColl: !(!o2.withPresence && o2.beQuiet), needPutDoc: i3, needDelDoc: false, needSub: r2, reJoinCauseReconnect: true });
                })]);
                A2.forEach((A3, e2) => {
                  e2 >= I.length || isRtmError(A3) && i2.push(I[e2]);
                });
              }
            } catch (A2) {
              this.logError("restore failed ".concat(JSON.stringify(A2)));
            }
            return s;
          } catch (A2) {
            var Q;
            if (isRtmError(A2) && (null === (Q = this._rtmSession) || void 0 === Q || !Q.isCanceledLogin)) {
              var c;
              const { errorCode: e2 } = A2;
              this._context.addReportEvents("Link", { ackedServerIp: "", destServerIp: "", ec: A2.code || 1, sc: A2.serverCode, elapse: getElapse(this._context.startTime), lts: Long$1.fromNumber(Date.now()), responseTime: Date.now() - B, sid: getSid(E), userId: this._context.uid, version: VERSION_NO, subVersion: SUBVERSION, connectionsequence: Long$1.fromNumber(0), linktype: 4, linkflag: Long$1.fromNumber(0), linkenv: 0 }), (null === (c = this._rtmSession) || void 0 === c || !c.isCanceledLogin) && this._handleLoginFailedState(e2);
            }
            throw A2;
          } finally {
            this._context.socketUseProxy = false, changeBusyStatus(false), this._context.socketUseProxy && this.log("port fallback to 443"), this._clearLinkTimers();
          }
        }
        async logout() {
          var A, e;
          const t = { timestamp: 0 };
          var g;
          ["CONNECTING", "SUSPENDED", "DISCONNECTED"].includes(this._linkState) && (this.warn("logout: cancel login"), null === (g = this._rtmSession) || void 0 === g || g.cancelLogin());
          if ("DISCONNECTED" === this._connectionState && "IDLE" === this._linkState)
            return this.warn("Already in logout state: ".concat(this._connectionState)), t;
          if (this._rtmSession && getParameter("VID").get(this._context.appId) && this._context.addReportEvents("Logout", { elapse: getElapse(this._context.startTime), lts: Long$1.fromNumber(Date.now()), sid: getSid(null !== (A = this._context.instanceId) && void 0 !== A ? A : Long$1.fromNumber(0)), userId: this._context.uid, version: VERSION_NO, subVersion: SUBVERSION, connectionsequence: Long$1.fromNumber(0), linktype: 4, linkflag: Long$1.fromNumber(0), linkenv: 0 }), null === (e = this._customConfig) || void 0 === e || e.stop(), this._clearInternalEvents(), "FAILED" === this._connectionState || "FAILED" === this._linkState) {
            "FAILED" === this._linkState && this._updateLinkState("IDLE", "LOGOUT", [], "LOGOUT", LinkStateChangeReasonDescription.LOGOUT), "FAILED" === this._connectionState && this._onConnectionStateChanged("DISCONNECTED", "LOGOUT");
            try {
              await this._internalLogoutHandler(false, false);
            } catch (A2) {
              this.logError("logout failed when linkState is FAILED: ".concat(A2));
            }
            return t;
          }
          if ("RECONNECTING" === this._connectionState || ["DISCONNECTED", "SUSPENDED", "CONNECTING"].includes(this._linkState)) {
            var o, I;
            this.info('Reset connection state from "RECONNECTING" to "DISCONNECTED"');
            try {
              await this._internalLogoutHandler(true, false);
            } catch (A2) {
              this.logError("logout failed when RECONNECTING: ".concat(A2));
            }
            if (true === (null === (o = this._rtmSession) || void 0 === o ? void 0 : o.isCanceledLogin))
              null === (I = this._rtmSession) || void 0 === I || I.resetCancelLogin();
          } else
            await this._logoutImpl();
          return this._updateLinkState("IDLE", "LOGOUT", this._getUsedMessageChannelIds(), "LOGOUT", LinkStateChangeReasonDescription.LOGOUT), t;
        }
        _handlePermissionRevoked(A) {
          A.forEach((A2) => {
            this._absent(A2), this._channelMetaEventInfos.delete(A2), this._channelMetadataSub.delete(A2), this._lockSnapshotLastTime.delete(A2), this._context.deleteChannel(A2);
          }), this._clearChannel(A);
        }
        async renewToken(A, e) {
          var t;
          const g = OperationName.renewToken;
          this._apiRateLimit.canMakeOperation("renewToken"), this._validateRtmConnection(g, false), validateToken(A, this._context.appId, g, (A2) => {
            this.warn(A2);
          });
          const o = { timestamp: 0 };
          this._context.addReportEvents("RenewToken", { sid: this._context.sid, userId: this._context.uid, lts: Long$1.fromNumber(Date.now()), elapse: getElapse(this._context.startTime), cname: null !== (t = null == e ? void 0 : e.channelName) && void 0 !== t ? t : "", token: A });
          let I = 0;
          try {
            if (null == e || !e.channelName) {
              var i2;
              if ("string" != typeof A || 0 === A.length) {
                const { code: A2, reason: e3 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_INVALID_TOKEN);
                throw new RtmInvalidArgumentError(g, [e3], A2);
              }
              if (!["CONNECTED", "RECONNECTING"].includes(this._connectionState) || "CONNECTED" !== this._linkState) {
                const { code: A2, reason: e3 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_NOT_CONNECTED);
                throw new RtmInvalidStatusError(g, [e3], A2);
              }
              if (this._validateRTMSessionExist(g), A === this._context.token) {
                return { timestamp: 0 };
              }
              try {
                var r = this._context.token;
                this._context.token = A, this._rtmSession.clearEdges4RenewToken();
                var [{ ticket: n }] = await Promise.all([this._rtmSession.genApEdgeInfo$(false, true).pipe(throwIfEmpty(() => new Error("No available edge address to connect")), retryWhen((A2) => A2.pipe(tap((A3) => {
                  if (isRtmError(A3))
                    throw A3;
                }), delay(2500), take(4))), take(1), timeout(COMMON_REQUEST_TIMEOUT), catchError((A2) => (isTimeout(A2) && this.warn("renewToken timed out"), throwError(A2)))).toPromise()]);
              } catch (A2) {
                if (this._rtmSession.recoverEdges4RenewToken(), this._context.token = r, isTimeout(A2)) {
                  const { code: A3, reason: e3 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_RENEW_TOKEN_TIMEOUT);
                  throw new RtmTimeoutError(g, [e3], A3);
                }
                {
                  const { code: e3, reason: t3 } = getErrorInfoByCode(A2.code);
                  throw new RtmUnauthenticatedError(g, [t3], e3);
                }
              }
              const e2 = await this._requestUpdateEdgeTicket2(n).toPromise();
              if (0 !== e2.code) {
                const { code: A2, reason: t3 } = getErrorInfoByCode(e2.code);
                throw new RtmUnavailableError(g, [t3], A2);
              }
              var C;
              null === (C = this._rtmSession) || void 0 === C || C.updateRegTicket(n);
              const t2 = atob(n);
              null === (i2 = this._rtmSession) || void 0 === i2 || i2.updateSyncTicket({ ticket: t2 });
              try {
                const A2 = { messageChannels: JSON.parse(e2.revoked).messageChannels.map((A3) => {
                  var e3;
                  return null !== (e3 = Object.keys(A3)[0]) && void 0 !== e3 ? e3 : "";
                }) };
                Object.values(A2).some((A3) => A3.length > 0) && (this._handlePermissionRevoked(Object.values(A2).flat()), this.emit("token", { eventType: "READ_PERMISSION_REVOKED", reason: TokenEventReason.READ_PERMISSION_REVOKED, affectedResources: A2, timestamp: getUTCTimeBaseREG(this._context.offsetTime) }));
              } catch (A2) {
                this.logError("parse permission revoked resources failed, error: %o", A2);
              }
              var E;
              if (!this._context.disablePresence)
                await (null === (E = this._rtmSession) || void 0 === E ? void 0 : E.renewSyncTicket(t2));
              return o;
            }
            if (validateKey(e.channelName, g, "channel"), this._streamChannelList.some((A2) => A2 === e.channelName) || this.warn("renewToken: channel(".concat(e.channelName, ") not join.")), !this._stChannelInstances.has(e.channelName)) {
              const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_INVALID_CHANNEL_NAME);
              throw new RtmInvalidArgumentError(g, [e2], A2);
            }
            try {
              const t2 = this._stChannelInstances.get(e.channelName);
              return await (null == t2 ? void 0 : t2.renewStreamChannelToken(A)), o;
            } catch (A2) {
              throw A2;
            }
          } catch (A2) {
            const { serverCode: e2, errorCode: t2 } = A2;
            throw I = null != e2 ? e2 : t2, this._context.token = r, A2;
          } finally {
            var s;
            this._context.addReportEvents("RenewTokenRes", { lts: Long$1.fromNumber(Date.now()), vid: Long$1.fromString(getParameter("VID").get(this._context.appId) || "0"), sid: this._context.sid, userId: this._context.uid, elapse: getElapse(this._context.startTime), cname: null !== (s = null == e ? void 0 : e.channelName) && void 0 !== s ? s : "", token: A, apErrCode: I, regErrCode: I });
          }
        }
        async publish(A, e, t) {
          const g = OperationName.publish;
          if (this._apiRateLimit.canMakeOperation("publish"), null != t && t.channelType && "USER" !== (null == t ? void 0 : t.channelType) && "MESSAGE" !== (null == t ? void 0 : t.channelType)) {
            const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_INVALID_CHANNEL_TYPE);
            throw new RtmInvalidArgumentError(g, [e2], A2);
          }
          if (this._validateRtmConnection(g), validateKey(A, g, "channel"), validateMessageSize(e, g), null != t && t.customType && validateCustomType(null == t ? void 0 : t.customType, g), null != t && t.storeInHistory && "true" !== this._context.consoleConfig["history.enabled"]) {
            const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_HISTORY_NOT_AVAILABLE);
            throw new RtmInvalidArgumentError(g, [e2], A2);
          }
          const o = { timestamp: 0, channelName: A }, I = e instanceof Uint8Array ? { rawMessage: e, messageType: "RAW" } : { text: e, messageType: "TEXT" }, i2 = "USER" === (null == t ? void 0 : t.channelType);
          validMessage(I, RTMErrorCode.RTM_ERROR_CHANNEL_INVALID_MESSAGE);
          try {
            await this._commonSendMessage({ message: I, peerId: A, diff: 0, customType: null == t ? void 0 : t.customType, storeInHistory: null == t ? void 0 : t.storeInHistory, toPeer: i2 });
          } catch (A2) {
            if (isTimeout(A2)) {
              const { code: A3, reason: e3 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_PUBLISH_MESSAGE_TIMEOUT);
              throw new RtmTimeoutError(g, [e3], A3);
            }
            if (isRtmError(A2))
              throw A2;
            const { code: e2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_PUBLISH_MESSAGE_FAILED);
            throw new RtmUnknownError(g, [t2], e2);
          }
          return o;
        }
        async subscribe(A, e) {
          var t;
          let g = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          const o = OperationName.subscribe;
          this._apiRateLimit.canMakeOperation("subscribe"), this._validateRtmConnection(o), this._validateRTMSessionExist(o), validateKey(A, o, "channel");
          const I = this._context.notInChannel(A), i2 = this._getUsedMessageChannelIds(), r = null !== (t = getParameter("MESSAGE_CHANNEL_COUNT")) && void 0 !== t ? t : MAX_JOINED_CHANNELS;
          if (I && (this._context.getAllChannelNames().length >= r || i2.length >= r)) {
            const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_INSTANCE_EXCEED_LIMITATION);
            throw new RtmLimitExceededError(o, [e2], A2);
          }
          this._validateJoinOptions(e, o);
          const n = handleSubOptionsAsDefault(e), C = { timestamp: 0, channelName: A }, { currentResolve: E } = await this._context.operationControl.awaitPromise(OperationName.subscribe + A), s = this._rtmSession, B = getRandomInt(0, Number.MAX_SAFE_INTEGER), a = this._context.getChannelLastSubOrJoinOptions(A);
          try {
            const { withMessage: t2 } = a;
            if (this._context.setLastSubOrJoinOptionsCache(A, n), null != n && n.withMessage && !t2)
              try {
                await this._subMessage(A, o);
              } catch (e2) {
                throw this._context.internalEmitter.emit("channelLeft", A), this._context.deleteChannel(A), e2;
              }
            const { code: i3, reason: r2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_SUBSCRIBE_FAILED);
            try {
              await Promise.all([null != n && n.withMessage || !t2 ? Promise.resolve() : this._unsubMessage(A), this._updateOptionsReJoinOrSub(A, I, a, e, g)]);
            } catch (A2) {
              throw isRtmError(A2) ? A2 : new RtmUnknownError(o, [r2 + A2], i3);
            }
          } catch (e2) {
            E(void 0);
            const { errorCode: t2, serverCode: g2 } = e2;
            var Q;
            if (s)
              this._context.addReportEvents("ChnJoinRes", { cname: A, lts: Long$1.fromNumber(Date.now()), elapse: getElapse(this._context.startTime), errCode: t2, sid: getSid(null !== (Q = this._context.instanceId) && void 0 !== Q ? Q : Long$1.fromNumber(0)), serverErrCode: null != g2 ? g2 : t2, userId: this._context.uid, seq: Long$1.fromNumber(B) });
            throw e2;
          } finally {
            this._context.reportChnJoin(A, a, n, B);
          }
          var c;
          s && this._context.addReportEvents("ChnJoinRes", { cname: A, lts: Long$1.fromNumber(Date.now()), elapse: getElapse(this._context.startTime), errCode: 0, sid: getSid(null !== (c = this._context.instanceId) && void 0 !== c ? c : Long$1.fromNumber(0)), serverErrCode: 0, userId: this._context.uid, seq: Long$1.fromNumber(B) });
          return E(void 0), C;
        }
        async unsubscribe(A) {
          const e = OperationName.unsubscribe;
          validateKey(A, e, "channel");
          const t = { timestamp: 0, channelName: A };
          if ("IDLE" === this._linkState)
            return t;
          if (this._validateRtmConnection(e, false), this._validateRTMSessionExist(e), this._context.notInChannel(A))
            return t;
          const { withMessage: g } = this._context.getChannelLastSubOrJoinOptions(A);
          try {
            this._reportChannelLeave(A, 0), await Promise.all([g ? this._unsubMessage(A) : Promise.resolve(), this._unsubLockAMeta(A), this._absent(A)]), this._context.deleteChannel(A);
          } catch (A2) {
            let t2;
            const g2 = RTMErrorCode.RTM_ERROR_CHANNEL_LEAVE_FAILED;
            if (this.logError(A2), isRtmError(A2))
              void 0 === (null == A2 ? void 0 : A2.code) && (A2.code = RTMErrorCode.RTM_ERROR_CHANNEL_LEAVE_FAILED), t2 = A2;
            else {
              const { code: A3, reason: o } = getErrorInfoByCode(g2);
              t2 = new RtmUnknownError(e, [o], A3);
            }
            throw t2;
          }
          return t;
        }
        createStreamChannel(A) {
          const e = OperationName.createStreamChannel;
          if (this._context.rtmConfig.privateConfig && !this._context.rtmConfig.privateConfig.serviceType.includes("STREAM")) {
            const { code: A2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_SERVICE_NOT_SUPPORTED);
            throw new RtmUnavailableError(e, [t2], A2);
          }
          validateKey(A, e, "channel");
          const t = this._stChannelInstances.get(A);
          if (t)
            return this.log("channel already exists ".concat(replaceRangeWithAsterisk(A))), t;
          const g = new StreamChannel(this._context, this.logger, { channelName: A, appId: this._context.appId, userId: false === this._context.rtmConfig.useStringUserId ? parseInt(this._context.uid) : this._context.uid }, this.emit, () => this._streamChannelList, this._validateRtmConnection.bind(this), () => this._rtmSession, this._updateOptionsReJoinOrSub.bind(this), this._unsubLockAMeta.bind(this), this._absent.bind(this));
          return this._stChannelInstances.set(A, g), g;
        }
        async updateConfig(A) {
          for (let e = 0, t = getKeys(A); e < t.length; e++) {
            const g = t[e];
            if ("logLevel" === g) {
              A.logLevel && (updateWasmLogLevel(A.logLevel), updateLogLevel(A.logLevel, this._context.config));
              continue;
            }
            const o = A[g];
            null != o && (A.cloudProxy && this.info("RTM cloud proxy enabled"), A.logUpload && this.info("Log upload enabled"), this._context.config[g] = o);
          }
          return { timestamp: 0 };
        }
        addEventListener(A, e) {
          this.on(A, e);
        }
        removeEventListener(A, e) {
          this.off(A, e);
        }
        async _updateOptionsReJoinOrSub(A) {
          let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], t = arguments.length > 2 ? arguments[2] : void 0, g = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
          const o = handleSubOptionsAsDefault(arguments.length > 3 ? arguments[3] : void 0), { withLock: I, withMetadata: i2, withPresence: r, beQuiet: n } = t, C = getParameter("STORAGE_CHANNEL_SUB_ENABLED"), E = o.withMetadata && !i2 && "true" === (void 0 !== C ? String(C) : this._context.consoleConfig["storage.channel_subscribe_enabled"]), s = o.withLock && !I, B = (null == o ? void 0 : o.beQuiet) && !n && !e, a = !(null != o && o.beQuiet) && (e || n), Q = (null == o ? void 0 : o.withPresence) && !r;
          try {
            await Promise.all([E ? this._subMetadata(A) : void 0, null != o && o.withMetadata || !i2 ? Promise.resolve() : this._unsubMetadata(A), s ? this._subLock(A) : void 0, null != o && o.withLock || !I ? Promise.resolve() : this._unsubLock(A), e ? this._attend(A, { unsubSelfColl: false, unsubColl: false, destroyColl: false }, { withPresence: o.withPresence, needCreateColl: !(!o.withPresence && o.beQuiet), needPutDoc: a, needDelDoc: B, needSub: Q, reJoinCauseReconnect: g }) : Promise.resolve()]);
          } catch (A2) {
            throw A2;
          }
          null != o && o.withPresence && !r && void 0 !== r && await this._attend(A, { unsubSelfColl: true, unsubColl: false, destroyColl: true }, { withPresence: true, needCreateColl: true, needPutDoc: a, needDelDoc: B, needSub: Q, reJoinCauseReconnect: g }), null != o && o.withPresence || !r || await this._attend(A, { unsubSelfColl: false, unsubColl: true, destroyColl: true }, { withPresence: false, needCreateColl: !o.beQuiet, needPutDoc: a, needDelDoc: B, needSub: Q, reJoinCauseReconnect: g }), (a || B) && (null == o ? void 0 : o.withPresence) === r && await this._attend(A, { unsubSelfColl: false, unsubColl: false, destroyColl: false }, { withPresence: o.withPresence, needCreateColl: true === a && false === (null == o ? void 0 : o.withPresence), needPutDoc: a, needDelDoc: B, needSub: Q, reJoinCauseReconnect: g });
        }
        _sendRtmBasePacket(A, e, t, g) {
          var o;
          void 0 !== g ? this._sendRtmBasePacketUseOneEnv(A, g, e, t) : null === (o = this._rtmSession) || void 0 === o || o.sendOperationPacket(A, e, t);
        }
        _sendRtmBasePacketUseOneEnv(A, e, t, g) {
          var o;
          null === (o = this._rtmSession) || void 0 === o || o.sendOperationPacketUseOneEnv(A, e, t, g);
        }
        _onOperationPacket(A) {
          return this._rtmSession.onOperationPacket(A);
        }
        async _internalLogoutHandler() {
          let A = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          try {
            await this._logoutVosWeb();
            try {
              await this._logoutSync(e);
            } catch (A2) {
              throw A2;
            }
          } catch (A2) {
            throw this.logError("internalLogoutHandler error: ".concat(JSON.stringify(A2))), A2;
          } finally {
            A && await this._logoutRegistrar(), this._clearEffectsOfLogout(), this._reportEvents();
          }
        }
        _clearEffectsOfLogout() {
          this.lock.lockImpl.releaseLockModel(), this._lockSnapshotLastTime.clear(), this.storage.storageImpl.releaseStorageModel(), this._userMetaEventInfos.clear(), this._channelMetadataSub.clear(), this._channelMetaEventInfos.clear(), this._clearLinkTimers(), this._context.instanceId = null, this._deleteIntervalCreateColl(), this._context.internalEmitter.emit("LOGOUT"), this._context.localStateCache.clear(), this._context.clearLastSubOrJoinOptions();
        }
        async _logoutVosWeb() {
          await Promise.all([...this._stChannelInstances.values()].map((A) => {
            A._streamChannelImpl.leaveVosWeb();
          }));
        }
        _reportEvents() {
          this._context.forceReportEvents();
        }
        async _logoutImpl() {
          try {
            await this._internalLogoutHandler(true, true), this.log("logout success");
          } catch (A) {
            this.logError("logout failed: ".concat(A));
          } finally {
            this._onConnectionStateChanged("DISCONNECTED", "LOGOUT");
          }
        }
        async _requestSubscribeChannelMetadata(A) {
          const e = OperationName.subscribe, t = fromEvent(this._context.internalEmitter, "unsubChannelMetadata").pipe(filter((e2) => A === e2), take(1)), g = this._context.incGetSeq(), o = Date.now(), I = this._notifyChannelMetaReSub.pipe(filter((e2) => (null == e2 ? void 0 : e2.prefixChannelName) === A || true === (null == e2 ? void 0 : e2.allReSub)), switchMap((t2) => {
            const I2 = g;
            return this._sendRtmBasePacket(e, "StateSubscribe", { sequence: I2, target: A, subTarget: "", flags: new Long$1(1, 0, true) }, t2.env), this._onOperationPacket("StateSubscribeResult").pipe(first((A2) => {
              let { sequence: e2 } = A2;
              return I2.eq(e2);
            }), tap((e2) => {
              let { code: t3 } = e2;
              const { code: I3 } = convertServerCodeToSdkCodeForSub(t3);
              this._context.addReportEvents("SyncSubscribeEvent", { lts: Long$1.fromNumber(Date.now()), userid: this._context.uid, vid: Long$1.fromString(this._context.vid || "0"), sid: this._context.sid, usersid: this._context.sid, target: A, requestts: Long$1.fromNumber(o), replyts: Long$1.fromNumber(Date.now()), eventtype: "Subscribe", sdktype: 4, flags: new Long$1(1, 0, true), code: I3, seq: g, index: { index1: this._context.uid, index2: this._context.appId, index3: "logUpload=".concat(this._context.config.logUpload) }, subtarget: this._context.uid }), I3 !== RTMErrorCode.RTM_ERROR_OK ? I3 === RTMErrorCode.RTM_ERROR_CHANNEL_SUBSCRIBE_PERMISSION_DENIED ? this._handleNoPrivilege(A, "metadata") : (this._context.updateLastSubOrJoinOptionsCache(A, "withMetadata", false), this.warn("Subscribe channel metadata failure. The response code from the RTM service is ".concat(t3))) : this._context.updateLastSubOrJoinOptionsCache(A, "withMetadata", true);
            }));
          }), takeUntil(t), share()), i2 = () => {
            this._rtmSubscriptions.metadataSubs.delete(A);
          };
          this._rtmSubscriptions.metadataSubs.set(A, I.subscribe({ error: i2, complete: i2 })), this._notifyChannelMetaReSub.next({ env: void 0, prefixChannelName: A }), await I.pipe(take(1), timeout(COMMON_REQUEST_TIMEOUT), catchError((e2) => (e2 instanceof TimeoutError && (this.warn("subscribe channel metadata timeout"), this._context.addReportEvents("SyncSubscribeEvent", { lts: Long$1.fromNumber(Date.now()), userid: this._context.uid, vid: Long$1.fromString(this._context.vid || "0"), sid: this._context.sid, usersid: this._context.sid, target: A, requestts: Long$1.fromNumber(o), replyts: Long$1.fromNumber(Date.now()), eventtype: "Subscribe", sdktype: 4, flags: new Long$1(1, 0, true), code: RTMErrorCode.RTM_ERROR_STORAGE_OPERATION_TIMEOUT, seq: g, index: { index1: this._context.uid, index2: this._context.appId, index3: "logUpload=".concat(this._context.config.logUpload) }, subtarget: this._context.uid })), throwError(e2)))).toPromise(), this._channelMetadataSub.add(A);
        }
        async _requestSubscribeLock(A) {
          const e = OperationName.subscribe, t = fromEvent(this._context.internalEmitter, "unsubChannelLock").pipe(filter((e2) => A === e2), take(1), tap((A2) => {
            this._lockSnapshotLastTime.delete(A2);
          })), g = this._context.incGetSeq(), o = this._notifyLockReSub.pipe(filter((e2) => (null == e2 ? void 0 : e2.prefixChannelName) === A || true === (null == e2 ? void 0 : e2.allReSub)), switchMap((t2) => {
            const o2 = g;
            return this._sendRtmBasePacket(e, "StateLockSubscribe", { sequence: o2, target: A, flags: new Long$1(1048577, 0, true) }, t2.env), this._onOperationPacket("StateLockSubscribeResult").pipe(first((A2) => {
              let { sequence: e2 } = A2;
              return o2.eq(e2);
            }), tap((e2) => {
              let { code: t3 } = e2;
              const { code: g2 } = convertServerCodeToSdkCodeForSub(t3);
              g2 !== RTMErrorCode.RTM_ERROR_OK ? g2 === RTMErrorCode.RTM_ERROR_CHANNEL_SUBSCRIBE_PERMISSION_DENIED ? this._handleNoPrivilege(A, "lock") : (this._context.updateLastSubOrJoinOptionsCache(A, "withLock", false), this.warn("Subscribe lock failure. The response code from the RTM service is ".concat(t3))) : this._context.updateLastSubOrJoinOptionsCache(A, "withLock", true);
            }));
          }), takeUntil(t), share()), I = () => {
            this._rtmSubscriptions.lockSubs.delete(A);
          };
          this._rtmSubscriptions.lockSubs.set(A, o.subscribe({ error: I, complete: I })), this._notifyLockReSub.next({ env: void 0, prefixChannelName: A }), await o.pipe(take(1), timeout(COMMON_REQUEST_TIMEOUT), catchError((A2) => (A2 instanceof TimeoutError && this.warn("subscribe channel lock timeout"), throwError(A2)))).toPromise();
        }
        _unsubLockAndMeta4MessageChn() {
          this._context.getAllChannelsOptions().forEach((A, e) => {
            const { channelType: t } = getChannelDetailByName(e);
            "MESSAGE" === t && (A.withLock && this._unsubLock(e), A.withMetadata && this._unsubMetadata(e), A.withMessage && this._unsubMessage(e));
          }), this.storage.storageImpl.unsubAllUserMetadata();
        }
        async _logoutRegistrar() {
          const A = this._hasLock();
          return this._unsubLockAndMeta4MessageChn(), await this._rtmSession.logoutRegistrar(A);
        }
        async _attend(A, e, t) {
          if (this._context.disablePresence)
            return;
          const { unsubSelfColl: g, unsubColl: o, destroyColl: I } = e;
          g && this._channelPresence.unsubscribeSelfPresence(A, false), o && this._channelPresence.unsubPresence(A, false), I && (t.needDelDoc && this._channelPresence.delChannelDoc(A), this._channelPresence.leave(A)), await this._channelPresence.joinPresenceColl(A, t);
        }
        _absent(A) {
          let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          if (this._context.disablePresence)
            return;
          if (this._context.notInChannel(A))
            return;
          const { withPresence: t, beQuiet: g } = this._context.getChannelLastSubOrJoinOptions(A);
          t ? this._channelPresence.unsubPresence(A, e) : this._channelPresence.unsubscribeSelfPresence(A, e), !g && this._channelPresence.delChannelDoc(A), this._context.isInChannel(A) && this._channelPresence.leave(A), this._channelPresence.leaveRetryChannels([A]);
        }
        async _logoutSync() {
          var A;
          let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
          this._context.disablePresence || (await Promise.all(this._context.getAllChannelNames().map((A2) => this._absent(A2))), e && await (null === (A = this._rtmSession) || void 0 === A ? void 0 : A.logoutSyncHandler()));
        }
        _commonSendMessage(A) {
          let { message: e, peerId: t, diff: g, customType: o, storeInHistory: I, toPeer: i2 } = A;
          const r = OperationName.publish;
          switch (e.messageType) {
            case "TEXT":
              return this._sendTextMessage(e.text, t, i2, (i2 ? P2P_MESSAGE_SEND_TIMEOUT : MESSAGE_SEND_TIMEOUT) - g, o, I);
            case "RAW":
              return void 0 === e.description && (e.description = ""), this._sendRawMessage(e.rawMessage, e.description, t, i2, (i2 ? P2P_MESSAGE_SEND_TIMEOUT : MESSAGE_SEND_TIMEOUT) - g, o, I);
            default:
              const { code: A2, reason: n } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_INVALID_MESSAGE);
              throw new RtmInvalidArgumentError(r, [n], A2);
          }
        }
        async _unsubLockAMeta(A) {
          const { withLock: e, withMetadata: t } = this._context.getChannelLastSubOrJoinOptions(A);
          e && this._unsubLock(A), t && this._unsubMetadata(A);
        }
        _handleNoPrivilege(A, e) {
          const t = this._context.operationControl.operationIsRunning(OperationName.subscribe + A);
          if (this.log("".concat(t ? "" : "re-", "subscribe channel ").concat(A, " ").concat(e, " failed, no privilege")), t) {
            this._context.deleteChannel(A);
            const { code: e2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_SUBSCRIBE_PERMISSION_DENIED);
            throw new RtmUnavailableError(OperationName.subscribe, [t2], e2);
          }
          switch (this._absent(A), e) {
            case "message":
              this._context.internalEmitter.emit("channelLeft", A);
              break;
            case "metadata":
              this._channelMetaEventInfos.delete(A), this._channelMetadataSub.delete(A), this._context.internalEmitter.emit("unsubChannelMetadata", A);
              break;
            case "lock":
              this._lockSnapshotLastTime.delete(A), this._context.internalEmitter.emit("unsubChannelLock", A);
          }
          this._context.isInChannel(A) && (this._context.deleteChannel(A), this.emit("token", { eventType: "READ_PERMISSION_REVOKED", reason: TokenEventReason.READ_PERMISSION_REVOKED, affectedResources: { messageChannels: [A] }, timestamp: getUTCTimeBaseREG(this._context.offsetTime) }));
        }
        async _requestChannelJoin(A) {
          const e = OperationName.subscribe, t = fromEvent(this._context.internalEmitter, "channelLeft").pipe(filter((e2) => A === e2), take(1)), g = this._context.incGetSeq(), o = this._notifyChannelReSub.pipe(filter((e2) => (null == e2 ? void 0 : e2.prefixChannelName) === A || true === (null == e2 ? void 0 : e2.allReSub)), switchMap((t2) => {
            const o2 = g;
            return this._sendRtmBasePacket(e, "GroupEnter", { account: A, seq: o2 }, t2.env), this._onOperationPacket("GroupReply").pipe(first((A2) => {
              let { seq: e2 } = A2;
              return o2.eq(e2);
            }), tap((t3) => {
              let { code: g2 } = t3;
              if (0 !== g2) {
                if (g2 !== RegServerErrorCode.kGroupUserNoPrivilege) {
                  const { code: t4, reason: o3 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_JOIN_FAILED);
                  throw this.warn("channel join failed, server code is %d", g2), this._context.updateLastSubOrJoinOptionsCache(A, "withMessage", false), new RtmUnavailableError(e, [o3], { code: t4, serverCode: g2 });
                }
                this._handleNoPrivilege(A, "message");
              } else
                this._context.updateLastSubOrJoinOptionsCache(A, "withMessage", true);
            }));
          }), takeUntil(t), share()), I = () => {
            this._rtmSubscriptions.channels.delete(A);
          };
          this._rtmSubscriptions.channels.set(A, o.subscribe({ error: I, complete: I })), this._notifyChannelReSub.next({ env: void 0, prefixChannelName: A }), await o.pipe(take(1), timeout(COMMON_REQUEST_TIMEOUT), catchError((A2) => {
            if (isRtmError(A2))
              return throwError(A2);
            !(A2 instanceof TimeoutError) && this.logError(A2);
            const { code: t2, reason: g2 } = getErrorInfoByCode(A2 instanceof TimeoutError ? RTMErrorCode.RTM_ERROR_CHANNEL_SUBSCRIBE_TIMEOUT : RTMErrorCode.RTM_ERROR_CHANNEL_SUBSCRIBE_FAILED);
            return throwError(new RtmUnavailableError(e, [g2], t2));
          })).toPromise();
        }
        async _subMessage(A, e) {
          try {
            this.log("Joining the channel %s", replaceRangeWithAsterisk(A)), await this._requestChannelJoin(A), this.info("The channel %s joined successfully", replaceRangeWithAsterisk(A));
          } catch (A2) {
            if (this.logError(A2), isRtmError(A2))
              throw A2;
            const { code: t, reason: g } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_SUBSCRIBE_FAILED);
            throw new RtmUnknownError(e, [g], t);
          }
        }
        async _unsubMessage(A) {
          this._sendRtmBasePacket(OperationName.leave, "GroupLeave2", { account: A, flags: Long$1.fromNumber(0) }), this._context.updateLastSubOrJoinOptionsCache(A, "withMessage", false), this._context.internalEmitter.emit("channelLeft", A);
        }
        async _subMetadata(A) {
          try {
            await this._requestSubscribeChannelMetadata(A);
          } catch (e) {
            if (this.logError("sub channel metadata failure when sub channel(".concat(replaceRangeWithAsterisk(A), "), error is %o."), e), e.errorCode === RTMErrorCode.RTM_ERROR_CHANNEL_SUBSCRIBE_PERMISSION_DENIED)
              throw e;
          }
        }
        _unsubMetadata(A) {
          const e = this._context.incGetSeq();
          this._sendRtmBasePacket(OperationName.unsubscribe, "StateUnsubscribe", { sequence: e, target: A, subTarget: "", flags: new Long$1(1, 0, true) }), this._channelMetaEventInfos.delete(A), this._context.addReportEvents("SyncSubscribeEvent", { lts: Long$1.fromNumber(Date.now()), userid: this._context.uid, vid: Long$1.fromString(this._context.vid || "0"), sid: this._context.sid, usersid: this._context.sid, target: A, requestts: Long$1.fromNumber(Date.now()), replyts: Long$1.fromNumber(Date.now()), eventtype: "UnSubscribe", sdktype: 4, flags: new Long$1(1, 0, true), code: 0, seq: e, index: { index1: this._context.uid, index2: this._context.appId, index3: "logUpload=".concat(this._context.config.logUpload) }, subtarget: this._context.uid }), this._context.updateLastSubOrJoinOptionsCache(A, "withMetadata", false), this._context.internalEmitter.emit("unsubChannelMetadata", A), this._channelMetadataSub.delete(A);
        }
        async _subLock(A) {
          try {
            await this._requestSubscribeLock(A);
          } catch (e) {
            if (this.logError("sub lock info failure when sub channel(".concat(replaceRangeWithAsterisk(A), "), error is %o."), e), e.errorCode === RTMErrorCode.RTM_ERROR_CHANNEL_SUBSCRIBE_PERMISSION_DENIED)
              throw e;
          }
        }
        _unsubLock(A) {
          const e = this._context.incGetSeq();
          this._sendRtmBasePacket(OperationName.unsubscribe, "StateLockUnsubscribe", { sequence: e, target: A, flags: new Long$1(1048577, 0, true) }), this._lockSnapshotLastTime.delete(A), this._context.updateLastSubOrJoinOptionsCache(A, "withLock", false), this._context.internalEmitter.emit("unsubChannelLock", A);
        }
        _clearLinkTimers() {
          this._suspended = false, this._suspendedTimer && clearTimeout(this._suspendedTimer), this._suspendedTimer = null, this._context.linkIntervals = [...LINK_INTERVALS];
        }
        async _loginImpl(A) {
          var e;
          let { uid: t, instanceId: g, forceLoginTime: o = 0 } = A;
          const I = OperationName.login;
          let i2 = g;
          if (void 0 !== this._lastLoginTime && Date.now() - this._lastLoginTime < 1e3 / LOGIN_QPS_LIMIT && o > 0) {
            const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_LOGIN_ABORTED);
            throw new RtmInvokeTooOftenError(I, [e2], A2);
          }
          0 === o && this._onConnectionStateChanged("CONNECTING", "CONNECTING"), null === (e = this._rtmSession) || void 0 === e || e.removeAllListeners();
          const r = new RTMSession(this._context, this.logger, i2, this._channelPresence.cacheAllChannelCrdtState.bind(this._channelPresence), this._channelPresence.exceptionCallback.bind(this._channelPresence));
          return this._rtmSession = r, this._context.internalEmitter.on("connectionLost", () => {
            if ("CONNECTED" === this._connectionState || "CONNECTED" === this._linkState) {
              var A2, e2;
              if (this._updateLinkState("DISCONNECTED", "HEARTBEAT_TIMEOUT", this._getUsedMessageChannelIds(), "KEEP_ALIVE_TIMEOUT", LinkStateChangeReasonDescription.KEEP_ALIVE_TIMEOUT), this._onConnectionStateChanged("RECONNECTING", "INTERRUPTED"), 0 === (null === (A2 = this._rtmSession) || void 0 === A2 ? void 0 : A2.listenerCount("userJoined")))
                null === (e2 = this._rtmSession) || void 0 === e2 || e2.on("userJoined", async () => {
                  this.log("received reconnected userJoined event"), "CONNECTED" !== this._linkState && (await this._updateLinkState("CONNECTED", "AUTO_RECONNECT", this._getUsedMessageChannelIds(), "RECONNECT_SUCCESS", LinkStateChangeReasonDescription.RECONNECT_SUCCESS, !this._suspended), this._onConnectionStateChanged("CONNECTED", "LOGIN_SUCCESS"), this._clearLinkTimers());
                });
              this._lockSnapshotLastTime.clear();
            }
          }), this._context.internalEmitter.on("tokenExpired", async () => {
            var A2;
            this.warn("reg session listen the token expired"), null === (A2 = this._rtmSession) || void 0 === A2 || A2.stopLogin(), this._userDropHandler(2);
          }), this._context.internalEmitter.once("userDrop", this._userDropHandler), this._context.internalEmitter.on("instanceChanged", (A2) => i2 = A2), this._context.internalEmitter.on("login-request", () => {
            "DISCONNECTED" !== this._linkState && "SUSPENDED" !== this._linkState || this._updateLinkState("CONNECTING", "AUTO_RECONNECT", [], "AUTO_RECONNECT", LinkStateChangeReasonDescription.AUTO_RECONNECT);
          }), this._context.internalEmitter.on("login-timeout", (A2) => {
            this.log("login - timeout"), this._suspended ? this._updateLinkState("SUSPENDED", "AUTO_RECONNECT", [], "RECONNECT_TIMEOUT", LinkStateChangeReasonDescription.RECONNECT_TIMEOUT) : this._updateLinkState("DISCONNECTED", "SERVER_TIMEOUT", [], A2 ? "RECONNECT_TIMEOUT" : "LOGIN_TIMEOUT", A2 ? LinkStateChangeReasonDescription.RECONNECT_TIMEOUT : LinkStateChangeReasonDescription.LOGIN_TIMEOUT), isNil$1(this._suspendedTimer) && (this._suspendedTimer = setTimeout(() => {
              this._suspended = true;
            }, 115e3));
          }), this._context.internalEmitter.on("net-change-abort-reconn", () => {
            this._updateLinkState("DISCONNECTED", "NETWORK_CHANGE", [], "NETWORK_CHANGE", LinkStateChangeReasonDescription.NETWORK_CHANGE);
          }), this._lastLoginTime = Date.now(), this._rtmSession.loginHandler().toPromise().catch((A2) => {
            if ("loginRespTimeout" === A2.name && o < 2)
              return this.log("loginRespTimeout: internal re-login..."), this._clearInternalEvents(), this._loginImpl({ uid: t, instanceId: g, forceLoginTime: o + 1 });
            throw this._handleConnectionFailed("registrar", A2);
          });
        }
        _clearInternalEvents() {
          ["connectionLost", "tokenExpired", "userDrop", "instanceChanged", "login-request", "login-timeout", "net-change-abort-reconn"].forEach((A) => {
            this._context.internalEmitter.removeAllListeners(A);
          });
        }
        _handleConnectionFailed(A, e) {
          let t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : OperationName.login;
          if (this.log("Login failed when connecting ".concat(A)), "CONNECTING" !== this._connectionState)
            return e;
          if (isTimeout(e)) {
            this._onConnectionStateChanged("DISCONNECTED", "LOST");
            const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_LOGIN_TIMEOUT);
            throw new RtmTimeoutError(t, [e2], A2);
          }
          if ((null == e ? void 0 : e.code) === RTMErrorCode.RTM_ERROR_TOKEN_EXPIRED)
            throw this._onConnectionStateChanged("DISCONNECTED", "TOKEN_EXPIRED"), e;
          if ((null == e ? void 0 : e.code) === RTMErrorCode.RTM_ERROR_LOGIN_CANCELED)
            throw e;
          if (this._onConnectionStateChanged("DISCONNECTED", "REJECTED_BY_SERVER"), isRtmError(e))
            throw e;
          const { code: g, reason: o } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_LOGIN_ABORTED);
          throw new RtmUnavailableError(t, [o], g);
        }
        _getUsedMessageChannelIds() {
          return this._context.getAllChannelNames().filter((A) => !A.startsWith(K_STREAM_CHANNEL_PREFIX));
        }
        async _requestChannelMemberList(A) {
          var e;
          const t = OperationName.whoNow, g = this._context.incGetSeq();
          return null === (e = this._rtmSession) || void 0 === e || e.sendOperationPacket(t, "GroupAllUsersList", { group: A, pageNumber: 0, pageSize: 200, seq: g }), race(genTimeoutError(RTMErrorCode.RTM_ERROR_PRESENCE_OPERATION_TIMEOUT), this._onOperationPacket("GroupAllUsersResult").pipe(first((e2) => {
            let { group: t2, seq: o } = e2;
            return t2 === A && g.eq(o);
          }))).toPromise();
        }
        _onConnectionStateChanged(A, e) {
          var t;
          ("RECONNECTING" === A && (this._reconnId += 1), this._connectionState = A, "FAILED" === A || "DISCONNECTED" === A) && (this._reconnId = 0, this._clearInternalEvents(), this._rtmSession && (null === (t = this._rtmSession) || void 0 === t || t.removeConnectionControllerAllListeners(), this._msgDedupLru.empty(), this._dialogueSequenceLru.empty(), this._dialPendingMsgSubjectMap.clear()));
          const g = { state: A, reason: e, timestamp: getUTCTimeBaseREG(this._context.offsetTime) };
          this.emit("status", g);
        }
        async _updateLinkState(A, e) {
          let t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [], g = arguments.length > 3 ? arguments[3] : void 0, o = arguments.length > 4 ? arguments[4] : void 0, I = arguments.length > 5 && void 0 !== arguments[5] && arguments[5];
          if ("CONNECTED" === A && this._setIntervalCreateColl(), this._linkState === A)
            return;
          var i2;
          (this._context.sendReport("LinkStateChange", { elapse: getElapse(this._context.startTime), lts: Long$1.fromNumber(Date.now()), reason: LinkStateChangeReason4Report[g], sid: getSid(this._context.instanceId || Long$1.fromNumber(0)), vid: Long$1.fromString(getParameter("VID").get(this._context.appId) || "0"), userid: this._context.uid, currentState: linkStateCodeMap[A], previousState: linkStateCodeMap[this._linkState], operation: linkOperationCodeMap[e], serviceType: 0, streamChannelName: "" }), "CONNECTED" === this._linkState && "DISCONNECTED" === A && this.log("link disconnected"), "CONNECTED" === this._linkState && "FAILED" === A && o && [LinkStateChangeReasonDescription.SAME_UID_LOGIN, LinkStateChangeReasonDescription.LOGIN_TOO_FREQUENT, LinkStateChangeReasonDescription.KICKED_OUT_BY_SERVER].includes(o) && (this._context.instanceId = null), "FAILED" === A) && (this._deleteIntervalCreateColl(), null === (i2 = this._rtmSession) || void 0 === i2 || i2.updateLoggedOut(true));
          const r = { currentState: A, previousState: this._linkState, serviceType: "MESSAGE", operation: e, reason: null != o ? o : e, reasonCode: g, affectedChannels: t, unrestoredChannels: [], timestamp: getUTCTimeBaseREG(this._context.offsetTime), isResumed: I };
          this._linkState = A, this.emit("linkState", r);
        }
        _clearChannel(A) {
          for (let e = 0; e < A.length; e++) {
            const t = A[e];
            this._context.internalEmitter.emit("channelLeft", t), this._context.internalEmitter.emit("unsubChannelLock", t), this._context.internalEmitter.emit("unsubChannelMetadata", t);
          }
        }
        _hasLock() {
          return this.lock.lockImpl.hasLock();
        }
        _validateRtmConnection(A) {
          var e;
          let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          if (this._context.enablePrivate && (null === (e = this._context.rtmConfig.privateConfig) || void 0 === e || !e.serviceType.includes("MESSAGE"))) {
            const { code: e2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_SERVICE_NOT_SUPPORTED);
            throw new RtmUnavailableError(A, t2, e2);
          }
          if ("IDLE" === this._linkState) {
            this.log("The client state is ".concat(this._connectionState, ", cannot do the operation(").concat(A, ")"));
            const { code: e2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_NOT_CONNECTED);
            throw new RtmInvalidStatusError(A, [t2], e2);
          }
          if (t && "CONNECTED" !== this._linkState) {
            const { code: e2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_NOT_CONNECTED);
            throw new RtmInvalidStatusError(A, [t2], e2);
          }
        }
        _validateRTMSessionExist(A) {
          if (void 0 === this._rtmSession) {
            const { code: e, reason: t } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_NOT_CONNECTED);
            throw new RtmUnavailableError(A, [t], e);
          }
        }
        _reportChannelLeave(A, e) {
          this._context.addReportEvents("ChnLeave", { cname: A, lts: Long$1.fromNumber(Date.now()), elapse: getElapse(this._context.startTime), errCode: e, sid: getSid(this._context.instanceId || Long$1.fromNumber(0)), userId: this._context.uid });
        }
        _setIntervalCreateColl() {
          this._createCollInterval && clearInterval(this._createCollInterval), this._createCollInterval = setInterval(() => {
            this._channelPresence.intervalCreateColl();
          }, MONITOR_INTERVAL);
        }
        _deleteIntervalCreateColl() {
          this._createCollInterval && clearInterval(this._createCollInterval);
        }
        _handleLoginFailedState(A) {
          let e = LinkStateChangeReasonDescription.LOGIN_REJECTED, t = "LOGIN_REJECTED";
          switch (A) {
            case RTMErrorCode.RTM_ERROR_INVALID_USER_ID:
              e = LinkStateChangeReasonDescription.INVALID_USER_ID, t = "INVALID_USER_ID";
              break;
            case RTMErrorCode.RTM_ERROR_INVALID_TOKEN:
              e = LinkStateChangeReasonDescription.INVALID_TOKEN, t = "INVALID_TOKEN";
              break;
            case RTMErrorCode.RTM_ERROR_INCONSISTENT_APPID:
              e = LinkStateChangeReasonDescription.INCONSISTENT_APP_ID, t = "INCONSISTENT_APP_ID";
              break;
            case RTMErrorCode.RTM_ERROR_SERVICE_NOT_SUPPORTED:
              e = LinkStateChangeReasonDescription.SERVICE_NOT_SUPPORTED, t = "SERVICE_NOT_SUPPORTED";
              break;
            case RTMErrorCode.RTM_ERROR_OPERATION_RATE_EXCEED_LIMITATION:
              e = LinkStateChangeReasonDescription.OPERATION_RATE_EXCEED_LIMITATION, t = "OPERATION_RATE_EXCEED_LIMITATION";
          }
          this._updateLinkState("FAILED", "LOGIN", [], t, e);
        }
        _validateJoinOptions(A, e) {
          const t = getParameter("STORAGE_CHANNEL_SUB_ENABLED"), g = "true" === (void 0 !== t ? String(t) : this._context.consoleConfig["storage.channel_subscribe_enabled"]);
          if (null != A && A.withMetadata && !g) {
            const { code: A2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_STORAGE_NOT_AVAILABLE);
            throw new RtmUnavailableError(e, [t2], A2);
          }
          const o = getParameter("LOCK_ENABLED"), I = "true" === (void 0 !== o ? String(o) : this._context.consoleConfig["lock.enabled"]);
          if (null != A && A.withLock && !I) {
            const { code: A2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_LOCK_NOT_AVAILABLE);
            throw new RtmUnavailableError(e, [t2], A2);
          }
        }
        _updateLockCache(A) {
          var e;
          const { lockName: t, prefixChannelName: g } = A;
          this._lockEventInfos.get(g) || this._lockEventInfos.set(g, /* @__PURE__ */ new Map());
          const o = null !== (e = this._lockEventInfos.get(g)) && void 0 !== e ? e : /* @__PURE__ */ new Map();
          o.set(t, A), this._lockEventInfos.set(g, o);
        }
        _updateLockSnapshotCache(A) {
          var e;
          const { lockName: t, prefixChannelName: g } = A, o = null !== (e = this._lockEventInfos.get(g)) && void 0 !== e ? e : /* @__PURE__ */ new Map();
          o.set(t, A), this._lockEventInfos.set(g, o);
        }
        _onLockEvent(A) {
          var e;
          const { target: t, lockStates: g, eventType: o } = A;
          if (!this._context.getChannelOptionsByKey(t, "withLock"))
            return;
          const { channelName: I, channelType: i2 } = getChannelDetailByName(t);
          if (o === LockEventType.LockUnknown)
            return void this.log("RTM service Error: lockEvent type is 0 on channel '%s', channelType 's%', member '%s'", replaceRangeWithAsterisk(I), i2, replaceRangeWithAsterisk(this._context.uid || ""));
          const r = getUTCTimeBaseREG(this._context.offsetTime), n = (/* @__PURE__ */ new Date()).getTime();
          if (o === LockEventType.LockSnapshot && 0 === g.length) {
            var C;
            if (this._lockSnapshotLastTime.has(t) && n - (null !== (C = this._lockSnapshotLastTime.get(t)) && void 0 !== C ? C : 0) <= LAST_PONG_RECEIVED_TS_FIELD_NUMBER)
              return;
            const A2 = { channelType: i2, channelName: I, eventType: "SNAPSHOT", lockName: "", ttl: 0, publisher: "", snapshot: [], owner: "", timestamp: r };
            return this.log("received snapshot lockEvent is empty on channel(".concat(t, "), emit channelLockEvent")), this._lockSnapshotLastTime.set(t, n), void this._onChannelLockEvent(A2);
          }
          let E = "SNAPSHOT";
          let s = 0, B = false, a = "", Q = null;
          try {
            var c, l;
            (null === (c = g[0]) || void 0 === c ? void 0 : c.lockState) && (Q = JSON.parse(null === (l = g[0]) || void 0 === l ? void 0 : l.lockState));
          } catch (A2) {
            this.logError("parse lockState error: %o", A2);
          }
          switch (o) {
            case LockEventType.LockAdded:
              var h;
              E = "SET", s = null === (h = Q) || void 0 === h ? void 0 : h.create_ttl;
              break;
            case LockEventType.LockModified:
              var u, d, D, y;
              if (null !== (u = Q) && void 0 !== u && u.user)
                E = "ACQUIRED", s = null === (d = Q) || void 0 === d ? void 0 : d.create_ttl, a = null === (D = Q) || void 0 === D ? void 0 : D.user;
              else
                E = "RELEASED", s = null === (y = Q) || void 0 === y ? void 0 : y.create_ttl;
              break;
            case LockEventType.LockRemoved:
              E = "REMOVED", s = 0;
              break;
            case LockEventType.LockSnapshot:
              E = "SNAPSHOT", B = true;
          }
          const p2 = { channelType: i2, channelName: I, eventType: E, lockName: B ? "" : null !== (e = g[0].lockName) && void 0 !== e ? e : "", ttl: s, publisher: "", snapshot: [], owner: a, timestamp: r };
          if (this.log("received lockEvent: %o", p2, Q), B) {
            var R2;
            (!this._lockSnapshotLastTime.has(t) || n - (null !== (R2 = this._lockSnapshotLastTime.get(t)) && void 0 !== R2 ? R2 : 0) > LAST_PONG_RECEIVED_TS_FIELD_NUMBER) && (this.log("received snapshot lockEvent, emit channelLockEvent"), this._lockSnapshotLastTime.set(t, n), p2.snapshot = g.map((A2) => {
              var e2, g2, o2, I2, i3, r2, n2, C2, E2, s2, B2;
              let a2 = null;
              try {
                A2.lockState && (a2 = JSON.parse(A2.lockState));
              } catch (A3) {
                this.logError("parse lockState error: %o", A3);
              }
              const Q2 = { prefixChannelName: t, lockName: null !== (e2 = A2.lockName) && void 0 !== e2 ? e2 : "", owner: null !== (g2 = null === (o2 = a2) || void 0 === o2 ? void 0 : o2.user) && void 0 !== g2 ? g2 : "", ttl: null !== (I2 = null === (i3 = a2) || void 0 === i3 ? void 0 : i3.create_ttl) && void 0 !== I2 ? I2 : getParameter("LOCK_TTL"), revision: null !== (r2 = null === (n2 = a2) || void 0 === n2 ? void 0 : n2._rev) && void 0 !== r2 ? r2 : 0 };
              return this._updateLockSnapshotCache(Q2), { lockName: A2.lockName, owner: null !== (C2 = null === (E2 = a2) || void 0 === E2 ? void 0 : E2.user) && void 0 !== C2 ? C2 : "", ttl: null !== (s2 = null === (B2 = a2) || void 0 === B2 ? void 0 : B2.create_ttl) && void 0 !== s2 ? s2 : getParameter("LOCK_TTL") };
            }), this._onChannelLockEvent(p2));
          } else {
            var w, _, S, f;
            this.log("received incremental lockEvent, emit channelLockEvent");
            const A2 = Q._rev || 0, e2 = (null === (w = this._lockEventInfos.get(t)) || void 0 === w || null === (w = w.get(null !== (_ = g[0].lockName) && void 0 !== _ ? _ : "")) || void 0 === w ? void 0 : w.revision) || 0;
            let o2 = false;
            if (("RELEASED" !== E && A2 > e2 || "RELEASED" === E && A2 >= e2 && null !== (S = this._lockEventInfos.get(t)) && void 0 !== S && null !== (S = S.get(null !== (f = g[0].lockName) && void 0 !== f ? f : "")) && void 0 !== S && S.owner) && (o2 = true), o2) {
              var N, M, k, L;
              this._onChannelLockEvent(p2);
              const A3 = { prefixChannelName: t, lockName: null !== (N = g[0].lockName) && void 0 !== N ? N : "", owner: null !== (M = Q.user) && void 0 !== M ? M : null, ttl: null !== (k = Q.create_ttl) && void 0 !== k ? k : null, revision: null !== (L = Q._rev) && void 0 !== L ? L : null };
              this._updateLockCache(A3);
            }
          }
        }
        _onStateUpdate(A) {
          let { flags: e, allStates: t, target: g } = A;
          const o = covertStateStringToMetaData(t);
          var I, i2;
          (!e.and(new Long$1(0, 2, true)).isZero() && this.log("metadata is cleared."), e.and(new Long$1(1, 0, true)).isZero()) ? o.majorRevision >= (null !== (I = this._userMetaEventInfos.get(g)) && void 0 !== I ? I : 0) && this._userMetaDataUpdatedHandler({ uid: g, data: o }) : o.majorRevision >= (null !== (i2 = this._channelMetaEventInfos.get(g)) && void 0 !== i2 ? i2 : 0) && this._onChannelMetaDataUpdated({ channelId: g, data: o });
        }
        _sendMessageAck(A) {
          const e = new MessageOption(A.options);
          (e.isInvitation() || e.isPeerMessage()) && this._sendRtmBasePacket("onMessage", "Ack", { code: 0, dialogue: A.dialogue, instance: A.instance, sequence: A.sequence });
        }
        _throwPeerMsgFailed(A, e) {
          const { code: t, reason: g } = getErrorInfoByCode(e === AckCodeType.kAckPeerOffline ? RTMErrorCode.RTM_ERROR_CHANNEL_RECEIVER_OFFLINE : RTMErrorCode.RTM_ERROR_CHANNEL_PUBLISH_MESSAGE_FAILED);
          throw new RtmUnavailableError(A, [g], t);
        }
        async _sendMessageToRetry(A, e, t) {
          let g = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
          this.debug("Attempt to send the message ".concat(e ? " with retrying, %o" : "without retrying"), { retryTimes: g });
          const o = A(g);
          this._sendRtmBasePacket("publish", "Message", o);
          const { dialogue: I, sequence: i2, instance: r } = o, n = this._onOperationPacket("Ack").pipe(filter((A2) => I.eq(A2.dialogue) && i2.eq(A2.sequence) && r.eq(A2.instance) && A2.code !== AckCodeType.kAckMiss), tap((A2) => {
            let { code: e2 } = A2;
            if (e2 === AckCodeType.kAckNoPrivilege) {
              const { code: A3, reason: e3 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_PUBLISH_PERMISSION_DENIED);
              throw new RtmUnavailableError(OperationName.publish, [e3], A3);
            }
          }));
          try {
            const { code: A2 } = await n.pipe(timeout(MESSAGE_RETRY_TIMEOUT + (t ? 500 : 0)), catchError((A3) => (isTimeout(A3) && this.warn("Message send timeout, retry times %d", g), throwError(A3))), take(1)).toPromise();
            return this.debug("The message has been acked, %o", { code: A2 }), { code: A2, retryTimes: g };
          } catch (o2) {
            if (o2 instanceof TimeoutError && e)
              return this._sendMessageToRetry(A, false, t, g + 1);
            throw o2;
          }
        }
        async _sendRawMessage(A, e, t) {
          let g = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], o = arguments.length > 4 ? arguments[4] : void 0, I = arguments.length > 5 ? arguments[5] : void 0, i2 = arguments.length > 6 ? arguments[6] : void 0;
          const r = OperationName.publish;
          if (A.byteLength + new Blob([e]).size + new Blob([null != I ? I : ""]).size > TEXT_MESSAGE_MAX_TEXT_BYTES) {
            const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_MESSAGE_LENGTH_EXCEED_LIMITATION);
            throw new RtmLimitExceededError(r, [e2], A2);
          }
          const n = this._context.encryptionInfo.initEncryption;
          let C = A;
          if (n)
            try {
              const { key: e2, iv: t2, keyLength: g2 } = this._context.encryptionInfo;
              C = encrypt(A, e2, t2, g2);
            } catch (A2) {
              const { code: e2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_ENCRYPT_MESSAGE_FAILED);
              throw new RtmUnavailableError(r, [t2], e2);
            }
          const E = !getParameter("DISABLE_MESSAGE_COMPRESSION") && C.byteLength >= MESSAGE_MIN_COMPRESSION_LEN, { dialogue: s, sequence: B } = this._chatManager.getChatInfo(g ? K_P2P_MESSAGE_PREFIX + t : t), a = this._context.instanceId;
          this.debug('A%s %s raw message is sending to %s: "'.concat(a, "-").concat(s, "#").concat(B, '"'), E ? " compressed" : "", g ? "peer" : "channel", replaceRangeWithAsterisk(t));
          const { code: Q } = await from(this._sendMessageToRetry((o2) => ({ MiscMap: _objectSpread2({ description: new TextEncoder().encode(e) }, I ? { customType: new TextEncoder().encode(I) } : {}), sequence: B, dialogue: s, instance: a, dst: t, ms: Long$1.fromNumber(Date.now(), true), options: new MessageOption({ IterationNumber: o2, CompressionMethod: E ? "Zlib" : "Uncompressed", MessageType: g ? "PeerRawMessage" : "ChannelRawMessage", ToCache: false, ToArchive: false, enableEncryption: n, encrytionComplement: C.byteLength - A.byteLength, kHistory: i2 ? 1 : 0 }).toLong(), payload: E ? deflate(C) : C, src: this._context.uid }), true, g)).pipe(timeout(void 0 === o ? MESSAGE_SEND_TIMEOUT : o), catchError((A2) => (A2 instanceof TimeoutError && this.warn("Send message timeout"), throwError(A2)))).toPromise(), c = 0 === Q;
          return 0 !== Q && this._throwPeerMsgFailed(r, Q), { hasPeerReceived: c };
        }
        async _sendTextMessage(A, e) {
          let t = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], g = arguments.length > 3 ? arguments[3] : void 0, o = arguments.length > 4 ? arguments[4] : void 0, I = arguments.length > 5 ? arguments[5] : void 0;
          const i2 = OperationName.publish;
          if (new Blob([A]).size + new Blob([null != o ? o : ""]).size > TEXT_MESSAGE_MAX_TEXT_BYTES) {
            const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_MESSAGE_LENGTH_EXCEED_LIMITATION);
            throw new RtmLimitExceededError(i2, [e2], A2);
          }
          const r = this._context.encryptionInfo.initEncryption;
          let n = new TextEncoder().encode(A);
          if (r)
            try {
              const { key: e2, iv: t2, keyLength: g2 } = this._context.encryptionInfo;
              n = encrypt(A, e2, t2, g2);
            } catch (A2) {
              const { code: e2, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_CHANNEL_ENCRYPT_MESSAGE_FAILED);
              throw new RtmUnavailableError(i2, [t2], e2);
            }
          const C = !getParameter("DISABLE_MESSAGE_COMPRESSION") && (r ? new Blob([new TextDecoder().decode(n)]).size : new Blob([A]).size) >= MESSAGE_MIN_COMPRESSION_LEN, { dialogue: E, sequence: s } = this._chatManager.getChatInfo(t ? K_P2P_MESSAGE_PREFIX + e : e), B = this._context.instanceId;
          this.debug('A%s %s message is sending to %s: "'.concat(B, "-").concat(E, "#").concat(s, '"'), C ? " compressed" : "", t ? "peer" : "channel", replaceRangeWithAsterisk(e));
          const { code: a } = await from(this._sendMessageToRetry((g2) => ({ MiscMap: _objectSpread2({}, o ? { customType: new TextEncoder().encode(o) } : {}), sequence: s, dialogue: E, instance: B, dst: e, ms: Long$1.fromNumber(Date.now(), true), options: new MessageOption({ IterationNumber: g2, CompressionMethod: C ? "Zlib" : "Uncompressed", MessageType: t ? "PeerTextMessage" : "ChannelTextMessage", ToCache: false, ToArchive: false, enableEncryption: r, encrytionComplement: n.byteLength - new TextEncoder().encode(A).byteLength, kHistory: I ? 1 : 0 }).toLong(), payload: C ? deflate(n) : n, src: this._context.uid }), true, t)).pipe(timeout(void 0 === g ? MESSAGE_SEND_TIMEOUT : g), catchError((A2) => (A2 instanceof TimeoutError && this.warn("Send message timeout"), throwError(A2)))).toPromise(), Q = 0 === a;
          return 0 !== a && this._throwPeerMsgFailed(i2, a), { hasPeerReceived: Q };
        }
        _requestUpdateEdgeTicket2(A) {
          const e = this._context.incGetSeq();
          return this._sendRtmBasePacket(OperationName.renewToken, "UserRenewToken2Req", { instance: this._context.instanceId, seq: e, account: this._context.uid, ticket: A }), race(genTimeoutError(RTMErrorCode.RTM_ERROR_RENEW_TOKEN_TIMEOUT), this._onOperationPacket("UserRenewToken2Resp").pipe(first((A2) => {
            let { seq: t } = A2;
            return e.eq(t);
          }), tap((A2) => {
            let { code: e2 } = A2;
            if (0 !== e2) {
              const { code: A3, reason: t } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_INVALID_TOKEN);
              throw new RtmUnavailableError(OperationName.login, [t], { serverCode: e2, code: A3 });
            }
          })));
        }
        _emitMessage(A, e) {
          var t;
          const { options: g, payload: o, src: I, dst: i2, instance: r, dialogue: n, sequence: C, ms: E, MiscMap: s = {} } = A;
          this._dialogueSequenceLru.set(n.toString(), C);
          const B = "".concat(r, "-").concat(n, "#").concat(C);
          if (this._msgDedupLru.has(B))
            return void this.warn("Env_%d: Messages out-of-order or not start with 1: %s", e, B);
          this._msgDedupLru.set(B, void 0);
          const a = new MessageOption(g);
          this._sendMessageAck(A);
          const Q = a.isZlibCompressed(), c = a.isEncryption(), l = null !== (t = a.getEncrytionComplement()) && void 0 !== t ? t : 0, { customType: h = new Uint8Array() } = s, u = new TextDecoder().decode(h);
          if (!c || this._context.encryptionInfo.key)
            if (c || !this._context.encryptionInfo.key)
              if (a.isPeerMessage() || this._context.getChannelOptionsByKey(i2, "withMessage")) {
                if (a.isTextMessage()) {
                  const A2 = a.isPeerTextMessage(), e2 = Q ? inflate$1(concatenateUint8Array(o, Uint8Array.of(0, 0, 0, 0))) : o, t2 = e2.byteLength - Long$1.fromValue(l).toNumber(), { key: g2, iv: r2, keyLength: n2 } = this._context.encryptionInfo, C2 = new TextDecoder().decode(c ? decrypt(e2, g2, r2, n2).slice(0, t2) : e2);
                  this.debug("Received a %s %s text message from %s to %s, %s", Q ? " compressed" : "", A2 ? "peer" : "channel", replaceRangeWithAsterisk(I), replaceRangeWithAsterisk(i2), B), this._onChannelTextMessage({ channelId: i2, memberId: I, text: C2, properties: { serverReceivedTs: E.toNumber() }, customType: u, channelType: A2 ? "USER" : "MESSAGE" });
                } else if (a.isRawMessage()) {
                  const A2 = a.isRawPeerMessage(), { description: e2 } = s, t2 = void 0 === e2 ? "" : decodeUint8ArrayToString(e2), g2 = Q ? inflate$1(o) : o, r2 = g2.byteLength - Long$1.fromValue(l).toNumber(), { key: n2, iv: C2, keyLength: h2 } = this._context.encryptionInfo, d = c ? decrypt(g2, n2, C2, h2).slice(0, r2) : g2;
                  this.debug("Received a %s %s raw message from %s to %s, %s", Q ? " compressed" : "", A2 ? "peer" : "channel", replaceRangeWithAsterisk(I), replaceRangeWithAsterisk(i2), B), this._onChannelRawMessage({ desc: t2, raw: d, channelId: i2, memberId: I, properties: { serverReceivedTs: E.toNumber() }, customType: u, channelType: A2 ? "USER" : "MESSAGE" });
                }
              } else
                this.warn("Received a message but the channel is not subscribed, %s", B);
            else
              this.warn("Received a message without encryption but the key is ready, %s", B);
          else
            this.warn("Received a message with encryption but the key is not ready yet, %s", B);
        }
        _onMessage(A) {
          var e;
          const { dialogue: t, instance: g, sequence: o, options: I, src: i2, eventReportInfo: r } = A, n = t.toString(), C = this._dialPendingMsgSubjectMap.get(n), E = "".concat(g, "-").concat(t, "#").concat(o), s = this._dialogueSequenceLru.get(n), B = new MessageOption(I);
          if (C)
            return C.next(A), void this.log("Env_%d: The dialogue has pending messages, next: %s", null == r ? void 0 : r.env, E);
          const a = !s && o.eq(1), Q = void 0 !== s && o.sub(s).eq(1);
          if (a || Q)
            return void this._emitMessage(A, null == r ? void 0 : r.env);
          if (s) {
            if (o.lte(s))
              return;
            this.log("Env_%d: The message pended, the sequence is not continuous with the last: %s", null == r ? void 0 : r.env, E);
          } else
            this.log("Env_%d: The message pended, the first sequence is not equal to 1: %s", null == r ? void 0 : r.env, E);
          const c = new Subject();
          this._dialPendingMsgSubjectMap.set(n, c);
          const l = c.pipe(observeOn(asyncScheduler), scan((A2, e2) => [...A2, e2], []), map$1((A2) => [...A2].sort((A3, e2) => {
            let { sequence: t2 } = A3, { sequence: g2 } = e2;
            return t2.eq(g2) ? 0 : t2.gt(g2) ? 1 : -1;
          })), shareReplay(1)), h = !B.isFromCache() && !B.isBufferedMessage();
          l.pipe(takeUntil(timer(null !== (e = B.isChannelMessage() ? getParameter("CHANNEL_MSG_REORDER_TIMEOUT") : getParameter("P2P_MSG_REORDER_TIMEOUT")) && void 0 !== e ? e : h ? ONLINE_MESSAGE_DEDUP_DELAY : OFFLINE_MESSAGE_DEDUP_DELAY)), first((A2) => {
            if (A2.length < 2)
              return false;
            for (let e2 = void 0 === s ? Long$1.fromNumber(1, true) : s.add(1), t2 = 0; t2 < A2.length; e2 = e2.add(1), t2++) {
              if (!A2[t2].sequence.eq(e2))
                return false;
            }
            return true;
          }), finalize(() => {
            this._dialPendingMsgSubjectMap.delete(n);
          })).subscribe((A2) => {
            A2.forEach((A3) => {
              this._emitMessage(A3, null == r ? void 0 : r.env), this.log("Env_%d: The message queue has fully ordered, emitting: %s", null == r ? void 0 : r.env, "".concat(A3.instance, "-").concat(A3.dialogue, "#").concat(A3.sequence));
            });
          }, (A2) => {
            A2 instanceof EmptyError && l.pipe(take(1)).subscribe((A3) => A3.forEach((A4) => {
              this.log("Env_%d: The message pending queue expired, emitting: %s", null == r ? void 0 : r.env, "".concat(A4.instance, "-").concat(A4.dialogue, "#").concat(A4.sequence)), this._emitMessage(A4, null == r ? void 0 : r.env);
            }));
          }), c.next(A);
        }
        _onGroupDrop(A) {
          let { account: e } = A;
          this._context.addReportEvents("ChnLeave", { cname: e, lts: Long$1.fromNumber(Date.now()), elapse: getElapse(this._context.startTime), errCode: RTMErrorCode.RTM_ERROR_CHANNEL_IN_ERROR_STATE, sid: getSid(this._context.instanceId), userId: this._context.uid }), this._rtmSubscriptions.channels.delete(e), this.logError("the user is kicked out of the channel: ".concat(e));
        }
        _addEventsFromContext() {
          this._context.internalEmitter.on("StateLockSubscribeEvent", (A) => {
            this._onLockEvent(A);
          }), this._context.internalEmitter.on("StateUpdate", (A) => {
            this._onStateUpdate(A);
          }), this._context.internalEmitter.on("Message", (A) => {
            this._onMessage(A);
          }), this._context.internalEmitter.on("UserTicketNearlyExpire", (A) => {
            this._tokenPrivilegeWillExpireHandler(A);
          }), this._context.internalEmitter.on("lock", (A) => {
            const e = getChannelNameByType(A.channelName, A.channelType);
            ("EXPIRED" === A.eventType || this._context.getChannelOptionsByKey(e, "withLock")) && this.emit("lock", A);
          }), this._context.internalEmitter.on("GroupDrop", (A) => {
            this._onGroupDrop(A);
          }), this._context.internalEmitter.on("stream-channel-joined", (A) => {
            this._streamChannelList.push(A);
          }), this._context.internalEmitter.on("stream-channel-leaved", (A) => {
            this._streamChannelList = this._streamChannelList.filter((e) => e !== A);
          }), this._context.internalEmitter.on("link-success", (A) => {
            this.lock.lockImpl.notifyLockReAcquire(A), this.storage.storageImpl.notifyUserMetaReSub(A), this._notifyLockReSub.next({ env: A, allReSub: true }), this._notifyChannelMetaReSub.next({ env: A, allReSub: true }), this._notifyChannelReSub.next({ env: A, allReSub: true });
          });
        }
      }
      class OperationControl {
        constructor() {
          _defineProperty$1(this, "promiseMap", /* @__PURE__ */ new Map());
        }
        setPromise(A, e) {
          this.promiseMap.set(A, e);
        }
        getPromise(A) {
          return this.promiseMap.get(A);
        }
        deletePromise(A) {
          this.promiseMap.delete(A);
        }
        async awaitPromise(A) {
          let e, t;
          const g = new Promise((A2, g2) => {
            e = A2, t = g2;
          }), o = this.getPromise(A);
          try {
            o && await o;
          } catch (A2) {
          }
          return g.finally(() => {
            this.deletePromise(A);
          }), this.setPromise(A, g), { currentResolve: e, currentReject: t };
        }
        operationIsRunning(A) {
          return this.promiseMap.has(A);
        }
      }
      const defaultConsoleConfig = { "-": 0, app_key: "", region: "CN", enabled: String(getParameter("RTM2_ENABLED")), "presence.occupancy": String(K_DEFAULT_INTERVAL_THRESHOLD), "presence.interval": String(K_PRESENCE_INTERVAL_DEFAULT), "presence.debounce": String(K_DEBOUNCE_DEFAULT), "storage.enabled": String(true), "storage.channel_subscribe_enabled": String(true), "storage.user_subscribe_enabled": String(true), "lock.enabled": String(true), "history.enabled": String(true) };
      class Context extends EventBase {
        get disablePresence() {
          var A;
          return null !== (A = getParameter("DISABLE_PRESENCE")) && void 0 !== A ? A : this._disablePresence;
        }
        get consoleConfig() {
          return this._consoleConfig;
        }
        set consoleConfig(A) {
          this._consoleConfig = A;
        }
        get seq() {
          return this._seq;
        }
        get userId() {
          return this._uid;
        }
        set pongTime(A) {
          this._pongTime = A;
        }
        get pongTime() {
          return this._pongTime;
        }
        set offsetTime(A) {
          this._offsetTime = A;
        }
        get offsetTime() {
          return this._offsetTime;
        }
        set heartbeatInterval(A) {
          this._heartbeatInterval = "number" == typeof A && A ? A < MIN_HEARTBEAT_INTERVAL ? MIN_HEARTBEAT_INTERVAL : A > MAX_HEARTBEAT_INTERVAL ? MAX_HEARTBEAT_INTERVAL : A : CONFIGURABLE_KEY_RTM_HEARTBEAT_INTERVAL;
        }
        get heartbeatInterval() {
          var A, e;
          return null !== (A = null !== (e = getParameter("HEART_BEAT")) && void 0 !== e ? e : this._heartbeatInterval) && void 0 !== A ? A : CONFIGURABLE_KEY_RTM_HEARTBEAT_INTERVAL;
        }
        set connSyncEnv(A) {
          this._connSyncEnv = A;
        }
        get connSyncEnv() {
          return this._connSyncEnv;
        }
        set socketUseProxy(A) {
          A !== this._socketUseProxy && (this.log("socketUseProxy is set to %s", A), this._socketUseProxy = A);
        }
        get socketUseProxy() {
          return this._socketUseProxy && getParameter("ENABLE_EDGE_AUTO_FALLBACK");
        }
        set token(A) {
          this._token = "string" == typeof A && A ? A : void 0;
        }
        get token() {
          return this._token;
        }
        set uid(A) {
          if (this.log("The user ID is set to %s", replaceRangeWithAsterisk(A)), !isValidId(A))
            throw new RtmInternalError();
          this._uid = A;
        }
        get uid() {
          if ("string" == typeof this._uid && this._uid)
            return this._uid;
          throw new RtmInternalError("Cannot get illegal uid");
        }
        set vid(A) {
          if ("string" != typeof A)
            throw new RtmInternalError();
          this._vid = A;
        }
        get vid() {
          return "string" == typeof this._vid ? this._vid : (this.warn("Cannot get illegal vid"), "");
        }
        get key() {
          if ("string" == typeof this._token && this._token)
            return this._token;
          if ("string" == typeof this.appId && this.appId)
            return this.appId;
          throw new RtmInternalError("Cannot get illegal key");
        }
        get sid() {
          if ("string" == typeof this._sid && this._sid)
            return this._sid;
          throw new RtmInternalError("Cannot get illegal sid");
        }
        set sid(A) {
          if (this.log("sid is set to %s", A), "string" != typeof A || !A)
            throw new RtmInternalError();
          this._sid = A;
        }
        get startTime() {
          return this._startTime;
        }
        set startTime(A) {
          if (this.log("startTime is set to %s", A), "number" != typeof A || !A)
            throw new RtmInternalError();
          this._startTime = A;
        }
        get rtmArea() {
          if ("string" == typeof this._area && this._area)
            return this._area;
          throw new RtmInternalError("Cannot get illegal area");
        }
        set rtmArea(A) {
          this.log("area is set to %s", A), "string" == typeof A && A ? this._area = A : this.warn("set area failed");
        }
        get operationControl() {
          return this._operationControl;
        }
        constructor(A, e, t, g, o, I) {
          var i2, r;
          super(g, "Context"), _defineProperty$1(this, "appId", void 0), _defineProperty$1(this, "cloudProxy", false), _defineProperty$1(this, "config", void 0), _defineProperty$1(this, "localStateCache", /* @__PURE__ */ new Map()), _defineProperty$1(this, "enablePrivate", false), _defineProperty$1(this, "cloudProxyServers", []), _defineProperty$1(this, "encryptionInfo", { key: "", iv: "", keyLength: 0, initEncryption: false }), _defineProperty$1(this, "rtmConfig", void 0), _defineProperty$1(this, "linkIntervals", [...LINK_INTERVALS]), _defineProperty$1(this, "reportIntervalId", void 0), _defineProperty$1(this, "instanceId", null), _defineProperty$1(this, "internalEmitter", void 0), _defineProperty$1(this, "_token", void 0), _defineProperty$1(this, "_uid", void 0), _defineProperty$1(this, "_sid", ""), _defineProperty$1(this, "_vid", void 0), _defineProperty$1(this, "_startTime", void 0), _defineProperty$1(this, "_area", "CN"), _defineProperty$1(this, "_socketUseProxy", false), _defineProperty$1(this, "_seq", Long$1.fromNumber(1, true)), _defineProperty$1(this, "_seqSentStatuses", [false, false]), _defineProperty$1(this, "_pongTime", (/* @__PURE__ */ new Date()).getTime()), _defineProperty$1(this, "_offsetTime", 0), _defineProperty$1(this, "_heartbeatInterval", CONFIGURABLE_KEY_RTM_HEARTBEAT_INTERVAL), _defineProperty$1(this, "_connSyncEnv", void 0), _defineProperty$1(this, "_operationControl", void 0), _defineProperty$1(this, "_couldReportEvent", false), _defineProperty$1(this, "_consoleConfig", defaultConsoleConfig), _defineProperty$1(this, "_lastSubscribeOrJoinOptions", /* @__PURE__ */ new Map()), _defineProperty$1(this, "_disablePresence", false), this.appId = A, this.uid = e, this.config = t, this.rtmConfig = o, I && (this.encryptionInfo = I), this.heartbeatInterval = o.heartbeatInterval ? 1e3 * o.heartbeatInterval : void 0;
          const n = new OperationControl();
          this._operationControl = n, this.rtmConfig.privateConfig && (this.enablePrivate = true), (!this.rtmConfig.privateConfig || (null !== (i2 = null === (r = this.rtmConfig.privateConfig.eventUploadHosts) || void 0 === r ? void 0 : r.length) && void 0 !== i2 ? i2 : 0) > 0) && (this._couldReportEvent = true);
          const C = new eventsExports.EventEmitter();
          C.emit = (A2, e2) => super.emit(A2, e2), C.on = (A2, e2) => super.on(A2, e2), C.once = (A2, e2) => super.once(A2, e2), C.removeListener = (A2, e2) => super.removeListener(A2, e2), C.removeAllListeners = (A2) => super.removeAllListeners(A2), C.setMaxListeners(512), this.internalEmitter = C;
        }
        incSeqIfNeeded(A) {
          if (![0, 1].includes(A))
            throw new CommonError({ INVALID_ENV: "The env argument is not 0 or 1" });
          this._seqSentStatuses[A] && (this._seq = this._seq.add(1), this._seqSentStatuses = [false, false]), this._seqSentStatuses[A] = true;
        }
        incGetSeq() {
          return this._seq = this._seq.add(1), this._seqSentStatuses = [true, true], this._seq;
        }
        addReportEvents(A, e) {
          var t, g;
          this._couldReportEvent && addReportEvents(this.appId, A, e, null !== (t = this.config.cloudProxy || this.socketUseProxy) && void 0 !== t && t, null === (g = this.rtmConfig.privateConfig) || void 0 === g ? void 0 : g.eventUploadHosts, this.vid || "0");
        }
        sendReport(A, e) {
          var t, g;
          this._couldReportEvent && sendReport(this.appId, A, e, null !== (t = this.config.cloudProxy || this.socketUseProxy) && void 0 !== t && t, null === (g = this.rtmConfig.privateConfig) || void 0 === g ? void 0 : g.eventUploadHosts);
        }
        forceReportEvents() {
          var A, e;
          if (!this._couldReportEvent)
            return;
          triggerReport(this.vid || "0", this.appId, null !== (A = this.config.cloudProxy) && void 0 !== A && A, null === (e = this.rtmConfig.privateConfig) || void 0 === e ? void 0 : e.eventUploadHosts, true);
          const t = this.reportIntervalId;
          t && clearEventReportTimer(t), this.reportIntervalId = void 0;
        }
        initReportEvent() {
          if (this._couldReportEvent && !this.reportIntervalId) {
            var A, e;
            const t = initEventReportTimer(this.vid || "0", this.appId, null !== (A = this.config.cloudProxy) && void 0 !== A && A, null === (e = this.rtmConfig.privateConfig) || void 0 === e ? void 0 : e.eventUploadHosts);
            this.reportIntervalId = t;
          }
        }
        getNewJoinFlag(A) {
          let e = 0;
          return null != A && A.withPresence && (e |= JOIN_PRESENCE_FLAG), null != A && A.withLock && (e |= JOIN_LOCK_FLAG), null != A && A.withMetadata && (e |= JOIN_STORAGE_FLAG), null != A && A.withMessage && (e |= JOIN_MESSAGE_FLAG), null != A && A.beQuiet && (e |= JOIN_BE_QUIET_FLAG), e;
        }
        reportChnJoin(A, e, t, g) {
          const o = this.getNewJoinFlag(t), I = (null == e ? void 0 : e.joinFlag) !== o;
          A.startsWith(STREAM_CHANNEL_PREFIX) || I && this.addReportEvents("ChnJoin", { cname: A, lts: Long$1.fromNumber(Date.now()), userId: this.uid, elapse: getElapse(this.startTime), errCode: 0, sid: getSid(this.instanceId || Long$1.fromNumber(0)), joinFlag: new Long$1(o, 0, true), seq: Long$1.fromNumber(g) });
        }
        clearLastSubOrJoinOptions() {
          this._lastSubscribeOrJoinOptions.clear();
        }
        deleteChannel(A) {
          this._lastSubscribeOrJoinOptions.delete(A);
        }
        setLastSubOrJoinOptionsCache(A, e) {
          const t = this.getNewJoinFlag(e);
          this._lastSubscribeOrJoinOptions.set(A, _objectSpread2(_objectSpread2({}, e), {}, { joinFlag: t }));
        }
        updateLastSubOrJoinOptionsCache(A, e, t) {
          console.log({ prefixChannelName: A, optionsKey: e, optionsValue: t }, "updateLastSubOrJoinOptionsCache----");
          const g = _objectSpread2(_objectSpread2({}, this._lastSubscribeOrJoinOptions.get(A)), {}, { [e]: t }), o = this.getNewJoinFlag(g);
          this._lastSubscribeOrJoinOptions.set(A, _objectSpread2(_objectSpread2({}, g), {}, { joinFlag: o }));
        }
        isInChannel(A) {
          return this._lastSubscribeOrJoinOptions.has(A);
        }
        notInChannel(A) {
          return !this._lastSubscribeOrJoinOptions.has(A);
        }
        getChannelLastSubOrJoinOptions(A) {
          var e;
          return _objectSpread2({}, null !== (e = this._lastSubscribeOrJoinOptions.get(A)) && void 0 !== e ? e : {});
        }
        getChannelOptionsByKey(A, e) {
          var t, g, o, I, i2, r, n, C, E, s;
          switch (e) {
            case "withPresence":
              return null !== (t = null === (g = this._lastSubscribeOrJoinOptions.get(A)) || void 0 === g ? void 0 : g.withPresence) && void 0 !== t && t;
            case "withLock":
              return null !== (o = null === (I = this._lastSubscribeOrJoinOptions.get(A)) || void 0 === I ? void 0 : I.withLock) && void 0 !== o && o;
            case "withMetadata":
              return null !== (i2 = null === (r = this._lastSubscribeOrJoinOptions.get(A)) || void 0 === r ? void 0 : r.withMetadata) && void 0 !== i2 && i2;
            case "withMessage":
              return null !== (n = null === (C = this._lastSubscribeOrJoinOptions.get(A)) || void 0 === C ? void 0 : C.withMessage) && void 0 !== n && n;
            case "beQuiet":
              return null !== (E = null === (s = this._lastSubscribeOrJoinOptions.get(A)) || void 0 === s ? void 0 : s.beQuiet) && void 0 !== E && E;
            default:
              return false;
          }
        }
        getAllChannelNames() {
          return [...this._lastSubscribeOrJoinOptions.keys()];
        }
        getAllChannelsOptions() {
          return this._lastSubscribeOrJoinOptions;
        }
      }
      var _class;
      const defaultConfig = { logUpload: false, logFilter: LogFilter.LOG_FILTER_ERROR, cloudProxy: false };
      let RTM = (_class = class extends EventBase {
        constructor(A, e, t) {
          var g, o, I, i2;
          const r = OperationName.initRTM;
          let n = getParameter("PRESENCE_TIMEOUT"), C = true, E = "", s = "", B = 0, a = false, Q = "none";
          if (!isValidAppId(A)) {
            const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_INVALID_APP_ID);
            throw new RtmUnavailableError(r, [e2], A2);
          }
          if (validateKey(e, r, "uid"), false === (null == t ? void 0 : t.useStringUserId)) {
            if (!isUintString(e)) {
              const { code: A2, reason: e2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_INVALID_USER_ID);
              throw new RtmInvalidArgumentError(r, [e2], A2);
            }
            C = false;
          } else
            C = true;
          const c = { logUpload: null !== (g = null == t ? void 0 : t.logUpload) && void 0 !== g ? g : defaultConfig.logUpload, logFilter: defaultConfig.logFilter, cloudProxy: null !== (o = null == t ? void 0 : t.cloudProxy) && void 0 !== o ? o : defaultConfig.cloudProxy }, l = validatePrivateConfig(t);
          var h, u;
          l && (c.cloudProxy && throwInvalidPrivateConfig(r, " Use private config, not permit cloudProxy "), areaConfig && throwInvalidPrivateConfig(r, " Use private config, not permit setArea"), c.logUpload && (null !== (h = null == t || null === (u = t.privateConfig) || void 0 === u || null === (u = u.logUploadHosts) || void 0 === u ? void 0 : u.length) && void 0 !== h ? h : 0) <= 0 && (c.logUpload = false));
          if ("AES_128_GCM" === (null == t ? void 0 : t.encryptionMode) || "AES_256_GCM" === (null == t ? void 0 : t.encryptionMode)) {
            var d, D;
            const A2 = "detail: ";
            let e2 = A2;
            if (void 0 === (null == t ? void 0 : t.cipherKey))
              e2 += "not provide cipherKey but set encryptionMode.";
            else if (t.salt && (null == t || null === (d = t.salt) || void 0 === d ? void 0 : d.byteLength) > 0 && (null == t || null === (D = t.salt) || void 0 === D ? void 0 : D.byteLength) > SALT_LENGTH)
              e2 += "salt should be ".concat(SALT_LENGTH, " bytes");
            else if (e2 === A2) {
              var y;
              B = "AES_128_GCM" === t.encryptionMode ? 16 : 32;
              const A3 = new Uint8Array(SALT_LENGTH);
              A3.set(null !== (y = t.salt) && void 0 !== y ? y : new Uint8Array([]));
              const e3 = null == t ? void 0 : t.cipherKey;
              try {
                const t2 = util$6.createBuffer(A3), g2 = pkcs5$1(e3, t2.getBytes(t2.length()), KEY_ITERATIONS_COUNT, IV_LENGTH + B, "sha256");
                E = g2, s = g2.slice(-IV_LENGTH), g2 ? a = true : console.warn("generate crypto key failure using pbkdf2.");
              } catch (A4) {
                const { code: e4, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_INVALID_ENCRYPTION_PARAMETER);
                throw new RtmUnavailableError(r, [t2 + A4], e4);
              }
            }
            if (e2.length > A2.length) {
              const { code: A3, reason: t2 } = getErrorInfoByCode(RTMErrorCode.RTM_ERROR_INVALID_ENCRYPTION_PARAMETER);
              throw new RtmUnavailableError(r, [t2 + e2], A3);
            }
          }
          if ((null == t ? void 0 : t.logLevel) && updateLogLevel(t.logLevel, c), Q = null !== (I = null == t ? void 0 : t.logLevel) && void 0 !== I ? I : "error", "number" == typeof (null == t ? void 0 : t.presenceTimeout)) {
            let A2 = t.presenceTimeout;
            t.presenceTimeout > K_PRESENCE_TIMEOUT_MAX ? A2 = K_PRESENCE_TIMEOUT_MAX : t.presenceTimeout < K_PRESENCE_TIMEOUT_MIN && (A2 = K_PRESENCE_TIMEOUT_MIN), n = A2;
          }
          const p2 = uuid$1(), R2 = { loggerId: initLoggerId(p2, null == t || null === (i2 = t.privateConfig) || void 0 === i2 ? void 0 : i2.logUploadHosts), config: c, processId: p2, appId: A, userId: e };
          super(R2, "RTM", true, true), _defineProperty$1(this, "presence", void 0), _defineProperty$1(this, "storage", void 0), _defineProperty$1(this, "lock", void 0), _defineProperty$1(this, "history", void 0), _defineProperty$1(this, "_rtmImpl", void 0);
          const w = { useStringUserId: C, presenceTimeout: n, logLevel: Q, heartbeatInterval: null == t ? void 0 : t.heartbeatInterval, privateConfig: l ? null == t ? void 0 : t.privateConfig : void 0 }, _ = new Context(A, e, c, R2, w, a ? { key: E, iv: s, keyLength: B, initEncryption: a } : void 0);
          this._rtmImpl = new RTMImpl(R2, p2, _), this.lock = this._rtmImpl.lock, this.presence = this._rtmImpl.presence, this.storage = this._rtmImpl.storage, this.history = this._rtmImpl.history, this.info("The Agora RTM Web SDK version is %s, fusion is %s", VERSION, FUSION), this.info("The new process ID is %s", p2);
          c.logUpload && this.log("The uploaded logs address is:".concat("http://log-collector-query.dc3.agoralab.co/api/v3/download?namespace=web&process_id=process-").concat(p2)), this.info('The Git commit ID is "'.concat(BUILD, '"')), this.info("The build is %s", BUILD), this.info("NODE_ENV is %s", "production"), this.info("Creating an RTM instance"), this.info("The App ID is %s", replaceRange(A, 4, 10, "*".repeat(6))), this.info("The User ID is %s", e), a && this.info("initialize crypto key success.");
        }
        async renewToken(A, e) {
          return await this._rtmImpl.renewToken(A, e);
        }
        updateConfig(A) {
          return this._rtmImpl.updateConfig(A);
        }
        async login(A) {
          return await this._rtmImpl.login(A);
        }
        async logout() {
          return await this._rtmImpl.logout();
        }
        async publish(A, e, t) {
          return await this._rtmImpl.publish(A, e, t);
        }
        async subscribe(A, e) {
          return await this._rtmImpl.subscribe(A, e);
        }
        async unsubscribe(A) {
          return await this._rtmImpl.unsubscribe(A);
        }
        createStreamChannel(A) {
          return this._rtmImpl.createStreamChannel(A);
        }
        addEventListener(A, e) {
          this._rtmImpl.addEventListener(A, e);
        }
        removeEventListener(A, e) {
          this._rtmImpl.removeEventListener(A, e);
        }
      }, _applyDecoratedDescriptor(_class.prototype, "renewToken", [loggedSensitive], Object.getOwnPropertyDescriptor(_class.prototype, "renewToken"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "updateConfig", [loggedSensitive], Object.getOwnPropertyDescriptor(_class.prototype, "updateConfig"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "login", [loggedSensitive], Object.getOwnPropertyDescriptor(_class.prototype, "login"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "logout", [loggedSensitive], Object.getOwnPropertyDescriptor(_class.prototype, "logout"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "publish", [loggedSensitive], Object.getOwnPropertyDescriptor(_class.prototype, "publish"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "subscribe", [loggedSensitive], Object.getOwnPropertyDescriptor(_class.prototype, "subscribe"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "unsubscribe", [loggedSensitive], Object.getOwnPropertyDescriptor(_class.prototype, "unsubscribe"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "createStreamChannel", [loggedSensitive], Object.getOwnPropertyDescriptor(_class.prototype, "createStreamChannel"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "addEventListener", [loggedSensitive], Object.getOwnPropertyDescriptor(_class.prototype, "addEventListener"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "removeEventListener", [loggedSensitive], Object.getOwnPropertyDescriptor(_class.prototype, "removeEventListener"), _class.prototype), _class);
      var index = { BUILD, VERSION, RTM, getParameter, setArea, setParameter, constantsType: ConstantsType, RTMBaseError };
      return index;
    });
  }
});
export default require_agora_rtm();
/*! Bundled license information:

agora-rtc-sdk-ng/AgoraRTC_N-production.js:
  (*! formdata-polyfill. MIT License. Jimmy W?rting <https://jimmy.warting.se/opensource> *)

agora-rtm-sdk/agora-rtm.js:
  (*! @preserve
   * AgoraRTM Web SDK 2.2.3 - commit: v2.2.3-0-g1291e257-dirty - fusion: false
   * Copyright (C) 2018-2025 Agora Lab.
   * This file is licensed under the AGORA, INC. SDK LICENSE AGREEMENT
   * A copy of this license may be found at https://www.agora.io/en/sdk-license-agreement/
   *)
  (**
  	     * @license
  	     * Copyright 2009 The Closure Library Authors
  	     * Copyright 2020 Daniel Wirtz / The long.js Authors.
  	     *
  	     * Licensed under the Apache License, Version 2.0 (the "License");
  	     * you may not use this file except in compliance with the License.
  	     * You may obtain a copy of the License at
  	     *
  	     *     http://www.apache.org/licenses/LICENSE-2.0
  	     *
  	     * Unless required by applicable law or agreed to in writing, software
  	     * distributed under the License is distributed on an "AS IS" BASIS,
  	     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  	     * See the License for the specific language governing permissions and
  	     * limitations under the License.
  	     *
  	     * SPDX-License-Identifier: Apache-2.0
  	     *)
*/
//# sourceMappingURL=agora-rtm-sdk.js.map
